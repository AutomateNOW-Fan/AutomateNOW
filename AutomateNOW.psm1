Using Module .\Classes.psm1
$InformationPreference = 'Continue'
$ErrorActionPreference = 'Stop'

#Region = Authentication Functions =

Function Connect-AutomateNOW {
    <#
    .SYNOPSIS
    Connects to the API of an AutomateNOW! instance

    .DESCRIPTION
    Connects to the API of an AutomateNOW! instance. The session details are then set to global variable $anow_session.

    .PARAMETER Instance
    Specifies the name of the AutomateNOW! instance. For example: s2.infinitedata.com

    .PARAMETER Domain
    Optional string to set the AutomateNOW domain. Omit this parameter if you do not know what the available domains are and they will be shown to you. You can then run this function again with the -Domain parameter. This function does support recognition of users with a default domain.

    .PARAMETER Proxy
    Optional string to set a proxy. The format should be: 'http://x.x.x.x:8888' where x.x.x.x is the ip or hostname of the proxy server. Proxy credentials are not supported yet. Caution: Using this setting will force all certificate checks to be disabled. It is equivalent to the -NotSecure function.

    .PARAMETER AccessToken
    Optionally specify the access token manually for API users or manual testing. This parameter is required for API users.

    .PARAMETER RefreshToken
    Optionally specify the refresh token manually for API users or manual testing. This parameter is never required but this module will complain about it for non-API users since the token can't be refreshed.

    .PARAMETER ExpirationDate
    Int64 representing the current date in UNIX time milliseconds. You don't need to include this if you use -AccessToken but it's nice to have. This module will complain about it for non-API users since the expiration of the current session token is unknown.

    .PARAMETER ReadJSONFromClipboard
    Switch parameter that will enable reading the JSON payload from the clipboard. You must have a valid authentication JSON payload in your clipboard for this to work (hint: You can copy it from your web browser after you've logged in). This parameter is useful for one-off scenarios where typing a password into the PowerShell prompt is undesireable.

    .PARAMETER User
    Specifies the user connecting to the API only if you want to enter it on the command line manually. If you do not specify this, you will be prompted for it.

    .PARAMETER SecurePass
    Specifies the Secure Password for connecting to the API only if you want to enter it on the command line manually. If you do not specify this, you will be prompted for it. Use ConvertTo-SecureString to create the needed object for this parameter.

    .PARAMETER NotSecure
    Switch parameter to accomodate instances that use the http protocol (typically on port 8080)

    .PARAMETER Quiet
    Switch parameter to silence the output of the session details upon login.

    .PARAMETER SkipMOTD
    Switch parameter to suppress the "message of the day" upon login.

    .PARAMETER SkipPreviousSessionCheck
    Switch parameter to override the requirement to disconnect from a previous session before starting a new session on a different instance.

    .PARAMETER Key
    Optional 16-byte array for when InfiniteDATA has changed their encryption key. Let's hope we don't need to use this :-)

    .INPUTS
    None. You cannot pipe objects to Connect-AutomateNOW (yet).

    .OUTPUTS
    An informational 'MOTD' will be displayed by default with basic information about the logged in users session. The global variable $anow_session will be populated with many details about the current session with the ANOW console.

    .EXAMPLE
    Basic logon without the domain specified. The use case is when you do not know what the available domains are yet. After authenticating, you will see the domains that are available to you.
    Connect-AutomateNOW -Instance 's2.infinitedata.com'

    .EXAMPLE
    Basic login WITH the domain specified. --> This is the recommended standard approach to use when you know the domain that you will want to login to.

    Connect-AutomateNOW -Instance 's2.infinitedata.com' -Domain 'Test'

    .EXAMPLE
    Login by providing the Access Token, Refresh Token and Expiration Date. This is the recommended approach when developing this module. It's better to include the refresh/expiration to prevent warnings.

    Connect-AutomateNOW -Instance 's2.infinitedata.com' -AccessToken 'ey...' -RefreshToken 'ey...' -ExpirationDate 1900000000000

    .EXAMPLE
    Login using the JSON payload from your clipboard. This is the payload from the /authenticate endpoint which can be copied from your browser with Dev Tools. The use case for this approach is one-off connections in front of an audience.

    Connect-AutomateNOW -Instance 's2.infinitedata.com' -ReadJSONFromClipboard

    .EXAMPLE
    Login by providing only the Access Token. This will throw warnings if a non-API user logs in this way --> Not recommended

    Connect-AutomateNOW -Instance 's2.infinitedata.com' -AccessToken 'ey...'

    .EXAMPLE
    Basic login to an ANOW instance running on http without a certificate or on https with a self-signed/expired certificate. Beta Systems training instances tend to require this parameter.

    Connect-AutomateNOW -Instance 's2.infinitedata.com' -NotSecure -Domain 'Test'

    .EXAMPLE
    Quietly logs in to an ANOW instance while supplying the username and password on the command line. Note that you must pass a secure string to -SecurePass. There is not really a use case for this approach but it is here anyway.

    Connect-AutomateNOW -Instance 's2.infinitedata.com' -User 'user.10' -SecurePass (Get-Clipboard | ConvertTo-SecureString -AsPlainText -Force) -Domain 'Test' -Quiet -NotSecure

    .EXAMPLE
    Basic logon to an ANOW instance which has a different encryption key. Note that this parameter is theoretical as it has not been needed yet.

    Connect-AutomateNOW -Instance 's2.infinitedata.com' -Key [byte[]]@(7, 22, 15, 11, 1, 24, 8, 13, 16, 10, 5, 17, 12, 19, 27, 9)

    .NOTES
    1. If you don't know the available domains then you can exclude the -Domain parameter to see them listed (after you authenticate).
    2. The -Domain parameter can be skipped if the user account has a default domain configured (see your administrator).
    3. This module will automatically refresh your token after it is 330 seconds old (see Update-AutomateNOWToken for more info).
    4. After you are finished interacting with the ANOW API, you should use Disconnect-AutomateNOW to disconnect from the instance and cleanse your PowerShell session. This doesn't invalidate your token, though.
    5. You should periodically review and be familiar with the properties available in the global variable $anow_session. There is a wealth of information within.
    6. For a truly silent logon you must include both the -Quiet and -SkipMOTD parameters.
    7. Using the -Proxy parameter will forego certificate checks. This was required to enable connections through a local proxy like Fiddler Classic.

    #>
    [OutputType([string])]
    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $true, ParameterSetName = 'DirectCredential')]
        [Parameter(Mandatory = $true, ParameterSetName = 'AccessToken')]
        [Parameter(Mandatory = $true, ParameterSetName = 'Clipboard')]
        [string]$Instance,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'DirectCredential')]
        [Parameter(Mandatory = $false, ParameterSetName = 'AccessToken')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Clipboard')]
        [string]$Domain,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'DirectCredential')]
        [Parameter(Mandatory = $false, ParameterSetName = 'AccessToken')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Clipboard')]
        [ValidateScript({ $_ -match '^http[s]{0,}://.{1,}:[0-9]{2,5}$' })]
        [string]$Proxy,
        [ValidateScript({ $_ -match '^ey[a-zA-Z0-9_.-]{4,}$' })]
        [Parameter(Mandatory = $true, ParameterSetName = 'AccessToken')]
        [string]$AccessToken,
        [ValidateScript({ $_ -match '^ey[a-zA-Z0-9_.-]{4,}$' })]
        [Parameter(Mandatory = $false, ParameterSetName = 'AccessToken')]
        [string]$RefreshToken,
        [Parameter(Mandatory = $false, ParameterSetName = 'AccessToken')]
        [int64]$ExpirationDate = 0,
        [Parameter(Mandatory = $true, ParameterSetName = 'Clipboard')]
        [switch]$ReadJSONFromClipboard,
        [Parameter(Mandatory = $true, ParameterSetName = 'DirectCredential')]
        [string]$User,
        [Parameter(Mandatory = $true, ParameterSetName = 'DirectCredential')]
        [SecureString]$SecurePass,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'DirectCredential')]
        [Parameter(Mandatory = $false, ParameterSetName = 'AccessToken')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Clipboard')]
        [switch]$NotSecure,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'DirectCredential')]
        [Parameter(Mandatory = $false, ParameterSetName = 'AccessToken')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Clipboard')]
        [switch]$Quiet,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'DirectCredential')]
        [Parameter(Mandatory = $false, ParameterSetName = 'AccessToken')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Clipboard')]
        [switch]$SkipMOTD,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'DirectCredential')]
        [Parameter(Mandatory = $false, ParameterSetName = 'AccessToken')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Clipboard')]
        [switch]$SkipPreviousSessionCheck,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'DirectCredential')]
        [Parameter(Mandatory = $false, ParameterSetName = 'AccessToken')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Clipboard')]
        [byte[]]$Key = @(7, 22, 15, 11, 1, 24, 8, 13, 16, 10, 5, 17, 12, 19, 27, 9)
    )
    Function New-ANOWAuthenticationPayload {
        [OutputType([string])]
        [CmdletBinding()]
        Param(
            [Parameter(Mandatory = $true)]
            [string]$User,
            [Parameter(Mandatory = $true)]
            [SecureString]$SecurePass,
            [Parameter(Mandatory = $false)]
            [boolean]$SuperUser = $false,
            [Parameter(Mandatory = $false)]
            [byte[]]$Key = @(7, 22, 15, 11, 1, 24, 8, 13, 16, 10, 5, 17, 12, 19, 27, 9)
        )
        If ($PSVersionTable.PSVersion.Major -ge 7) {
            [string]$encrypted_string = Protect-AutomateNOWEncryptedString -String ($SecurePass | ConvertFrom-SecureString -AsPlainText) -Key $Key
        }
        Else {
            [string]$encrypted_string = Protect-AutomateNOWEncryptedString -String ([System.Runtime.InteropServices.Marshal]::PtrToStringAuto([System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecurePass))) -Key $Key
        }
        [hashtable]$payload = @{}
        $payload.Add('j_username', $User)
        $payload.Add('j_password', "ENCRYPTED::$encrypted_string")
        $payload.Add('superuser', $SuperUser)
        [string]$payload_json = $payload | ConvertTo-Json -Compress
        Write-Verbose -Message "Sending payload $payload_json"
        Return $payload_json
    }
    Function New-ANOWAuthenticationProperties {
        [OutputType([hashtable])]
        [CmdletBinding()]
        Param(
            [Parameter(Mandatory = $true)]
            [string]$User,
            [Parameter(Mandatory = $true)]
            [SecureString]$SecurePass,
            [Parameter(Mandatory = $false)]
            [string]$Proxy
        )
        [string]$body = New-ANOWAuthenticationPayload -User $User -SecurePass $SecurePass
        [string]$login_url = ($protocol + '://' + $instance + '/automatenow/api/login/authenticate')
        [hashtable]$parameters = @{}
        [int32]$ps_version_major = $PSVersionTable.PSVersion.Major
        If ($ps_version_major -eq 5) {
            # The below C# code provides the equivalent of the -SkipCertificateCheck parameter for Windows PowerShell 5.1 Invoke-WebRequest
            If (($null -eq ("TrustAllCertsPolicy" -as [type])) -and ($protocol -eq 'http')) {
                [string]$certificate_policy = @"
                using System.Net;
                using System.Security.Cryptography.X509Certificates;
                public class TrustAllCertsPolicy : ICertificatePolicy {
                    public bool CheckValidationResult(
                        ServicePoint srvPoint, X509Certificate certificate,
                        WebRequest request, int certificateProblem) {
                        return true;
                    }
                }
"@
                $Error.Clear()
                Try {
                    Add-Type -TypeDefinition $certificate_policy
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Add-Type failed to add the custom certificate policy due to [$Message]"
                    Break
                }
                $Error.Clear()
                Try {
                    [System.Net.ServicePointManager]::CertificatePolicy = New-Object -TypeName TrustAllCertsPolicy
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "New-Object failed to create a new 'TrustAllCertsPolicy' CertificatePolicy object due to [$Message]."
                    Break
                }
            }
            $parameters.Add('UseBasicParsing', $true)
        }
        ElseIf ( $ps_version_major -gt 5) {
            $parameters.Add('SkipCertificateCheck', $true)
        }
        Else {
            Write-Warning -Message "Please use either Windows PowerShell 5.1 or PowerShell Core."
            Break
        }
        $parameters.Add('Uri', $login_url)
        $parameters.Add('Method', 'POST')
        $parameters.Add('Body', $body)
        Remove-Variable -Name body
        If ($Proxy.Length -gt 0) {
            $parameters.Add('Proxy', $Proxy)
        }
        $parameters.Add('ContentType', 'application/json')
        $Error.Clear()
        Try {
            [Microsoft.PowerShell.Commands.BasicHtmlWebResponseObject]$results = Invoke-WebRequest @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            If ($Message -match '(The underlying connection was closed|The SSL connection could not be established)') {
                Write-Warning -Message 'Please try again with the -NotSecure parameter if you are connecting to an insecure instance.'
                Break
            }
            ElseIf ($Message -match 'Response status code does not indicate success:') {
                $Error.Clear()
                Try {
                    [int32]$return_code = $Message -split 'success: ' -split ' ' | Select-Object -Last 1 -Skip 1
                }
                Catch {
                    [string]$Message2 = $_.Exception.Message
                    Write-Warning -Message "Unable to extract the error code from [$Message] due to [$Message2]"
                }
            }
            ElseIf ($Message -match 'The remote server returned an error: ') {
                $Error.Clear()
                Try {
                    [int32]$return_code = $Message -split '\(' -split '\)' | Select-Object -Skip 1 -First 1
                }
                Catch {
                    [string]$Message2 = $_.Exception.Message
                    Write-Warning -Message "Unable to extract the error code from [$Message] due to [$Message2]"
                }
            }
            Else {
                [string]$ReturnCodeWarning = "Invoke-WebRequest failed for an unexpected reason due to [$Message]"
                Write-Warning -Message $ReturnCodeWarning
                Break
            }
            [string]$ReturnCodeWarning = Switch ($return_code) {
                401 { "You received HTTP Code $return_code (Unauthorized). DID YOU MAYBE ENTER THE WRONG PASSWORD? :-)" }
                403 { "You received HTTP Code $return_code (Forbidden). DO YOU MAYBE NOT HAVE PERMISSION TO THIS? [$command]" }
                404 { "You received HTTP Code $return_code (Page Not Found). ARE YOU SURE THIS ENDPOINT REALLY EXISTS? [$command]" }
                Default { "You received HTTP Code $return_code instead of '200 OK'. Apparently, something is wrong..." }
            }
            Write-Warning -Message $ReturnCodeWarning
            Break
        }
        [string]$content = $results.Content
        If ($content -notmatch '^{"token_type":"Bearer","access_token":"[a-zA-Z-_:,."0-9]{1,}"}$') {
            [string]$content = "The returned content does not contain a bearer token. Please check the credential you are using."
            Break
        }
        Write-Verbose -Message "`r`nToken properties: $content`r`n"
        $Error.Clear()
        Try {
            [PSCustomObject]$token_properties = $content | ConvertFrom-Json
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "ConvertFrom-Json failed due to [$Message]."
            Break
        }
        Return $token_properties
    }
    If ($Instance -match '^http[s]{0,}://') {
        Write-Warning -Message "Please do not include https:// in the name of the instance. See Get-Help Connect-AutomateNOW -Examples for examples."
        Break
    }
    If ($NotSecure -eq $true) {
        [string]$protocol = 'http'
    }
    Else {
        [string]$protocol = 'https'
    }
    If (($anow_session.ExpirationDate -is [datetime]) -and ($SkipPreviousSessionCheck -ne $true)) {
        [datetime]$current_date = Get-Date
        [datetime]$expiration_date = $anow_session.ExpirationDate
        [timespan]$TimeRemaining = ($expiration_date - $current_date)
        [int32]$SecondsRemaining = $TimeRemaining.TotalSeconds
        If ($SecondsRemaining -gt 60) {
            [string]$AlreadyConnectedInstance = ($anow_session.Instance)
            If ($Instance -eq $AlreadyConnectedInstance) {
                Write-Warning -Message "Please use Disconnect-AutomateNOW to disconnect from $AlreadyConnectedInstance before connecting to $Instance (Use -SkipPreviousSessionCheck to override this)"
            }
            Else {
                Write-Warning -Message "Please use Disconnect-AutomateNOW to disconnect your active connection to $AlreadyConnectedInstance (It still has [$SecondsRemaining] seconds remaining) (Use -SkipPreviousSessionCheck to override this)"
            }
            Break
        }
        Else {
            If ($SecondsRemaining -lt -172800) {
                [int32]$DaysRemaining = ($SecondsRemaining * -1) / 86400
                Write-Warning -Message "Your previous token expired about $DaysRemaining days ago on $expiration_date. Cleaning up the previous session."
            }
            ElseIf ($SecondsRemaining -lt -7200) {
                [int32]$HoursRemaining = ($SecondsRemaining * -1) / 3600
                Write-Warning -Message "Your previous token expired about $HoursRemaining hours ago on $expiration_date. Cleaning up the previous session."
            }
            ElseIf ($SecondsRemaining -lt -300) {
                [int32]$MinutesRemaining = ($SecondsRemaining * -1) / 60
                Write-Warning -Message "Your previous token expired about $MinutesRemaining minutes ago on $expiration_date. Cleaning up the previous session."
            }
            Else {
                [int32]$SecondsRemaining = $SecondsRemaining * -1
                Write-Warning -Message "Your previous token expired about $SecondsRemaining seconds ago on $expiration_date. Cleaning up the previous session."
            }
            $Error.Clear()
            Try {
                Remove-Variable -Name anow_session -Scope Global -Force
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Remove-Variable failed to remove the expired `$anow_session variable due to [$Message]."
                Break
            }
        }
    }
    If ($ReadJSONFromClipboard -eq $true) {
        $Error.Clear()
        Try {
            If ($null -eq (Get-Clipboard)) {
                Write-Warning -Message "The clipboard cannot be read. Please use a different parameter set or fill up your clipboard with the authentication JSON payload."
                Break
            }
            Else {
                [string]$Clipboard = Get-Clipboard
                If ($Clipboard -notmatch '[0-9a-zA-Z \n{}":,_.-]{1,}(?:"expires_in")[0-9a-zA-Z \n{}":,_.-]{1,}') {
                    Write-Verbose -Message "The contents of the clipboard are: $Clipboard"
                    Write-Warning -Message "The contents of the clipboard do not appear to be a valid JSON authentication payload"
                    Break
                }
            }
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-Clipboard failed to read the clipboard due to [$Message]."
            Break
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$AuthenticationObject = $Clipboard | ConvertFrom-Json
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "ConvertFrom-Json failed to convert the contents of the clipboard due to [$Message]."
            Break
        }
        If ($AuthenticationObject.token_type -ne 'Bearer') {
            Write-Warning -Message "Somehow the authentication object that was extracted from the clipboard does not include the Token Type. This is fatal."
            Break
        }
        ElseIf ($AuthenticationObject.expires_in -isnot [int64]) {
            Write-Warning -Message "Somehow the authentication object that was extracted from the clipboard does not have a valid expires_in property. This is fatal."
            Break
        }
        ElseIf ($AuthenticationObject.expirationDate -isnot [int64]) {
            Write-Warning -Message "Somehow the authentication object that was extracted from the clipboard does not have a valid expirationDate property. This is fatal."
            Break
        }
        [string]$AccessToken = $AuthenticationObject.access_token
        [string]$RefreshToken = $AuthenticationObject.refresh_token
        [int64]$ExpirationDate = $AuthenticationObject.expirationDate
    }
    If ($AccessToken.Length -eq 0) {
        If ($User.Length -eq 0 ) {
            $Error.Clear()
            Try {
                [string]$User = Read-Host -Prompt 'Please enter username (e.g. jsmith)'
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Read-Host failed to receive the current username due to [$Message]."
                Break
            }
            If ($User.Length -eq 0) {
                Write-Warning -Message 'You needed to specify a username. Please try again.'
                Break
            }
        }
        If ($SecurePass.Length -eq 0 ) {
            $Error.Clear()
            Try {
                [SecureString]$SecurePass = Read-Host -Prompt 'Please enter password (e.g. ******)' -AsSecureString
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Read-Host failed due to [$Message]."
                Break
            }
        }
        [hashtable]$parameters = @{}
        $parameters.Add('User', $User)
        $parameters.Add('SecurePass', $SecurePass)
        If ($Proxy.Length -gt 0) {
            $parameters.Add('Proxy', $Proxy)
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$token_properties = New-ANOWAuthenticationProperties @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "New-ANOWAuthenticationProperties failed due to [$Message]."
            Break
        }
        If ( $token_properties.expirationDate -isnot [int64]) {
            Write-Warning -Message "How is it that the expiration date value is not a 64-bit integer? Something must be wrong. Are we in a time machine?"
            Break
        }
        [string]$AccessToken = $token_properties.access_token
        [string]$RefreshToken = $token_properties.refresh_token
    }
    If ($RefreshToken.Length -eq 0) {
        [string]$RefreshToken = 'Not set'
    }
    $Error.Clear()
    Try {
        [System.TimeZoneInfo]$timezone = Get-TimeZone
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-TimeZone failed to get the local time zone due to [$Message]."
        Break
    }
    [boolean]$dst = (Get-Date).IsDaylightSavingTime()
    If ($dst -eq $true) {
        [System.TimeSpan]$utc_offset = ($timezone.BaseUtcOffset + (New-TimeSpan -Minutes 60))
    }
    Else {
        [System.TimeSpan]$utc_offset = $timezone.BaseUtcOffset
    }
    [datetime]$epoch_date = Get-Date -Date '1970-01-01'
    If (($ExpirationDate -gt 0) -or ($token_properties.expirationDate -gt 0)) {
        If ($ExpirationDate -gt 0) {
            $Error.Clear()
            Try {
                [datetime]$expiration_date = $epoch_date.AddMilliseconds($ExpirationDate)
            }
            Catch {
                Write-Warning -Message "Get-Date failed to process the expiration date from the `$ExpirationDate variable in milliseconds due to [$Message]"
                Break
            }
        }
        Else {
            $Error.Clear()
            Try {
                [datetime]$expiration_date = $epoch_date.AddMilliseconds($token_properties.expirationDate)
            }
            Catch {
                Write-Warning -Message "Get-Date failed to process the expiration date from the `$token_properties.expirationDate variable in milliseconds due to [$Message]"
                Break
            }
        }
        [datetime]$Current_Date = Get-Date
        [datetime]$expiration_date = ($expiration_date + $utc_offset) # We're adding 2 values here: the current time in UTC and the current machine's UTC offset
        [timespan]$Remaining_Time = ($Current_Date - $expiration_date)
        If ($Remaining_Time.TotalSeconds -gt 0) {
            [int32]$remaining_minutes = $Remaining_Time.TotalMinutes
            [string]$display_date = $expiration_date.ToString()
            Write-Warning -Message "This token expired about [$remaining_minutes] minute(s) ago at [$display_date]. Please re-authenticate to obtain a new one."
            Break
        }
    }
    Else {
        [datetime]$expiration_date = $epoch_date
    }
    [hashtable]$anow_session = @{}
    $anow_session.Add('User', $User)
    $anow_session.Add('Instance', $Instance)
    If ($NotSecure -eq $true) {
        $anow_session.Add('NotSecure', $True)
    }
    If ($Proxy.Length -gt 0) {
        $anow_session.Add('Proxy', $Proxy)
    }
    $anow_session.Add('ExpirationDate', $expiration_date)
    $anow_session.Add('AccessToken', $AccessToken)
    $anow_session.Add('RefreshToken', $RefreshToken)
    [hashtable]$Header = @{'Authorization' = "Bearer $AccessToken"; 'domain' = ''; }
    $anow_session.Add('header', $Header)
    $Error.Clear()
    Try {
        New-Variable -Name 'anow_session' -Scope Global -Value $anow_session -Force
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "New-Variable failed to create the session properties object due to [$Message]"
        Break
    }
    Write-Verbose -Message 'Global variable $anow_session.header has been set. Refer to this as your authentication header.'
    [string]$home_url = ($protocol + '://' + $instance + '/automatenow')
    [hashtable]$parameters = @{}
    $parameters.Add('UseBasicParsing', $true)
    $parameters.Add('Uri', $home_url)
    If ($Proxy.Length -gt 0) {
        $parameters.Add('Proxy', $Proxy)
        [int32]$ps_version_major = $PSVersionTable.PSVersion.Major
        If ($ps_version_major -eq 5) {
            # The below C# code provides the equivalent of the -SkipCertificateCheck parameter for Windows PowerShell 5.1 Invoke-WebRequest
            If (($null -eq ("TrustAllCertsPolicy" -as [type])) -and ($protocol -eq 'http')) {
                [string]$certificate_policy = @"
                using System.Net;
                using System.Security.Cryptography.X509Certificates;
                public class TrustAllCertsPolicy : ICertificatePolicy {
                    public bool CheckValidationResult(
                        ServicePoint srvPoint, X509Certificate certificate,
                        WebRequest request, int certificateProblem) {
                        return true;
                    }
                }
"@
                $Error.Clear()
                Try {
                    Add-Type -TypeDefinition $certificate_policy
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Add-Type failed to add the custom certificate policy due to [$Message]"
                    Break
                }
                $Error.Clear()
                Try {
                    [System.Net.ServicePointManager]::CertificatePolicy = New-Object -TypeName TrustAllCertsPolicy
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "New-Object failed to create a new 'TrustAllCertsPolicy' CertificatePolicy object due to [$Message]."
                    Break
                }
            }
            $parameters.Add('UseBasicParsing', $true)
        }
        ElseIf ( $ps_version_major -gt 5) {
            $parameters.Add('SkipCertificateCheck', $true)
        }
        Else {
            Write-Warning -Message "Please use either Windows PowerShell 5.1 or PowerShell Core."
            Break
        }
    }
    $Error.Clear()
    Try {
        [Microsoft.PowerShell.Commands.BasicHtmlWebResponseObject]$results = Invoke-WebRequest @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        If ($Message -match '(The underlying connection was closed|The SSL connection could not be established)') {
            Write-Warning -Message 'Please try again with the -NotSecure parameter if you are connecting to an insecure instance.'
            Break
        }
        ElseIf ($Message -match 'Response status code does not indicate success:') {
            $Error.Clear()
            Try {
                [int32]$return_code = $Message -split 'success: ' -split ' ' | Select-Object -Last 1 -Skip 1
            }
            Catch {
                [string]$Message2 = $_.Exception.Message
                Write-Warning -Message "Unable to extract the error code from [$Message] due to [$Message2]"
            }
        }
        ElseIf ($Message -match 'The remote server returned an error: ') {
            $Error.Clear()
            Try {
                [int32]$return_code = $Message -split '\(' -split '\)' | Select-Object -Skip 1 -First 1
            }
            Catch {
                [string]$Message2 = $_.Exception.Message
                Write-Warning -Message "Unable to extract the error code from [$Message] due to [$Message2]"
            }
        }
        Else {
            [string]$ReturnCodeWarning = "Invoke-WebRequest failed trying to access the home page under Connect-AutomateNOW due to [$Message]"
            Write-Warning -Message $ReturnCodeWarning
            Break
        }
        [string]$ReturnCodeWarning = Switch ($return_code) {
            401 { "You received HTTP Code $return_code (Unauthorized). DID YOU MAYBE ENTER THE WRONG PASSWORD? :-)" }
            403 { "You received HTTP Code $return_code (Forbidden). DO YOU MAYBE NOT HAVE PERMISSION TO THIS? [$command]" }
            404 { "You received HTTP Code $return_code (Page Not Found). ARE YOU SURE THIS ENDPOINT REALLY EXISTS? [$command]" }
            Default { "You received HTTP Code $return_code instead of '200 OK'. Apparently, something is wrong." }
        }
        Write-Warning -Message $ReturnCodeWarning
        Break
    }
    If ($results.StatusCode -eq 200) {
        $Error.Clear()
        Try {
            [PSCustomObject]$instance_info = (($results | Select-Object -ExpandProperty content) -split "`n" | Where-Object { $_ -match '^\s{0,8}{"licenseInfo":.{1,}' } | Select-Object -First 1) | ConvertFrom-Json
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the results of the home page details object due to [$Message]"
            Break
        }
        If ($Null -eq $instance_info.licenseInfo) {
            Write-Warning -Message "Somehow the response from the instance info request was empty!"
            Break
        }
        $Error.Clear()
        Try {
            [hashtable]$instance_info_table = @{}
            [string[]]$instance_info_keys = $instance_info | Get-Member -MemberType NoteProperty | Select-Object -ExpandProperty Name
            ForEach ($entry in $instance_info_keys) {
                $instance_info_table.Add(($entry), ($instance_info."$entry"))
            }
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the instance information into a valid object due to [$Message]. We were so close! Did something change in InfiniteDATA's code? :-)"
            Break
        }
        If ($Domain.Length -gt 0) {
            $Header['domain'] = $Domain
            Import-AutomateNOWTimeZone
            $Error.Clear()
            Try {
                [ANOWTimeZone]$server_timezone = Get-AutomateNOWTimeZone -Id ($instance_info.defaultTimeZone)
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the default time zone from [$Instance] into a valid ANOWTimeZone class object due to [$Message]. We were so close! Did something change in the ANOW code? :-)"
                Break
            }
            $Error.Clear()
            Try {
                [ANOWTimeZone[]]$available_timezones = ($instance_info.timeZones) -split ',' | Get-AutomateNOWTimeZone
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the available time zones from [$Instance] into an array of valid ANOWTimeZone class objects due to [$Message]. We were so close! Did something change in the ANOW code? :-)"
                Break
            }
            [int32]$available_timezones_count = $available_timezones.count
            If ($available_timezones_count -gt 0) {
                Write-Verbose -Message "[$Instance] has [$available_timezones_count] available timezones to choose from"
            }
            Else {
                Write-Warning -Message "Somehow there are no timezones available from this instance. Something must be wrong."
                Break
            }
            $anow_session.Add('available_timezones', $available_timezones)
        }
        Else {
            Import-AutomateNOWLocalTimeZone
        }
        $anow_session.Add('server_timezone', $server_timezone)
        $anow_session.Add('instance_info', $instance_info_table)
        [PSCustomObject]$CalendarInfo = [PSCustomObject]@{'firstDayOfWeek' = $instance_info.firstDayOfWeek; 'firstCalendarYear' = $instance_info.firstCalendarYear; 'lastCalendarYear' = $instance_info.lastCalendarYear; }
        $anow_session.Add('calendar_info', $CalendarInfo)
        [string]$applicationVersion = $anow_session.instance_info.licenseInfo.applicationVersion
        [string]$application = $anow_session.instance_info.licenseInfo.application
        If ($Id.length -eq 0) {
            $Error.Clear()
            Try {
                [ANOWSecUserInfo]$userInfo = Get-AutomateNOWSecUser -LoggedOnUser
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWSecUser failed to get the currently logged in user info due to [$Message]."
                Break
            }
            [string]$Id = $userInfo.Id
        }
        # Make sure to check that the domain supplied to the -Domain parameter actually exists within the users available domains
        If ($userInfo.domains -match ',') {
            [string[]]$domains = $userInfo.domains -split ',' | Sort-Object
        }
        Else {
            [string[]]$domains = $userInfo.domains -split ' ' | Sort-Object
        }
        [int32]$domain_count = $domains.Count
        Write-Verbose -Message "Detected $domain_count domains"
        If ($domain_count -gt 0) {
            $anow_session.Add('available_domains', $domains)
        }
        Else {
            Write-Warning -Message "Somehow the count of domains is zero."
            Break
        }
        If ($domain_count -eq 1) {
            If ($Domain.Length -eq 0) {
                [string]$Domain = $domains
                If ($null -ne $anow_session.header.Domain) {
                    $anow_session.header.Remove('domain')
                }
                $anow_session.header.Add('domain', $Domain)
                Write-Verbose -Message "Automatically choosing the [$Domain] domain as it is the only one available."
            }
            ElseIf ($userInfo.domains -ne $Domain) {
                Write-Warning -Message "The domain you chose with -Domain [$Domain] is not the same as the one on [$instance]. Please check the domain name again and note that it is case-sensitive."
                Break
            }
        }
        Else {
            If ($domains -ccontains $Domain) {
                If ($Domain.Length -gt 0) {
                    $anow_session.header['domain'] = $Domain
                }
            }
            ElseIf ($Domain.Length -gt 0 -and $defaultDomain.Length -eq 0) {
                Write-Warning -Message "The domain you chose with -Domain (or your default Domain) [$Domain] is not available on [$instance]. Please check the domain name again and note that it is case-sensitive."
                Break
            }
            Else {
                Write-Verbose -Message "Proceeding without a domain selected and there is no default domain for $Id"
            }
        }
        # Now that we know the name of the user and that the selected domain is available, we can omit the -LoggedOnUser parameter from Get-AutomateNOWSecUser to fetch the *full details*
        $Error.Clear()
        Try {
            [ANOWSecUser]$user = Get-AutomateNOWSecUser -Id $Id
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWSecUser failed to get the currently logged in users full info due to [$Message]."
            Break
        }
        $Error.Clear()
        If ($user.apiUser -eq $true) {
            $anow_session['APIUser'] = $true
        }
        ElseIf ($user.apiUser -eq $false) {
            $anow_session['APIUser'] = $false
        }
        Else {
            Write-Warning -Message "Somehow it was not possible to determine if $Id is an API User. Please look into this."
            Break
        }
        [string]$defaultDomain = $user.defaultDomain
        If ($defaultDomain.Length -gt 0) {
            $anow_session.Add('default_domain', $defaultDomain)
            Write-Verbose -Message "Detected the default domain for $Id is $defaultDomain"
            $userInfo.defaultDomain = $defaultDomain
            If ($Domain.Length -eq 0) {
                Write-Verbose -Message "There was no domain specified with the -Domain parameter, therefore using the users default domain"
                [string]$Domain = $defaultDomain
            }
        }
        Else {
            $anow_session.Add('default_domain', "")
        }
        $anow_session['user_details'] = $userInfo
        [string]$userName = $userInfo.id
        If ($userName.Length -eq 0) {
            Write-Warning -Message "Somehow the username property is not present for this user object. This is fatal!"
            Break
        }
        $anow_session['User'] = $userName
        If ($Domain.Length -eq 0 -and $defaultDomain.Length -eq 0) {
            [string]$domains_display = $domains -join ', '
            Write-Warning -Message "Please try Connect-AutomateNOW again with the -Domain parameter with one of these case-sensitive domains: $domains_display"
            Remove-Variable anow_session -Force
            Break
        }
        $anow_session.Add('current_domain', $Domain)
        $anow_session.Add('protocol', $protocol)
        $Error.Clear()
        Try {
            [ANOWTimeZone]$defaultTimeZone = $userInfo.defaultTimeZone
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to convert the user object's default time zone into an [ANOWTimeZone] object due to [$message]"
            Break
        }
        If ($defaultTimeZone.Length -gt 0) {
            $anow_session.Add('user_timezone', $defaultTimeZone)
        }
        If ($SkipMOTD -ne $true) {
            [string]$motd_message = "`r`nWelcome to $application version $applicationVersion"
            Write-Information -MessageData $motd_message
        }
    }
    Else {
        If ($null -eq $results.StatusCode) {
            Write-Warning -Message "The results were empty. There must be a bigger problem..."
            Break
        }
        Else {
            [int32]$status_code = $results.StatusCode
            Write-Warning -Message "Received HTTP status code [$status_code] instead of 200. Please look into it. You can try suppressing this attempt to retrieve instance info by including the -SkipMOTD parameter."
            Break
        }
    }
    [PSCustomObject]$anow_session_display = [PSCustomObject]@{ protocol = $protocol; instance = $instance; token_expires = $expiration_date; user = $userName; domain = $Domain; access_token = ($AccessToken.SubString(0, 5) + '..' + $AccessToken.SubString(($AccessToken.Length - 5), 5)) }
    If ($Quiet -ne $true) {
        Format-Table -InputObject $anow_session_display -AutoSize -Wrap
    }
}

Function Disconnect-AutomateNOW {
    <#
    .SYNOPSIS
    Disconnects from the API of an AutomateNOW! instance

    .DESCRIPTION
    The `Disconnect-AutomateNOW` function logs out of the API of an AutomateNOW! instance. It then removes the global session variable object.

    .PARAMETER KeepSessionVariable
    An optional switch that is not recommended which will prevent the deletion of the existing session variable. This is intended for testing.

    .INPUTS
    None. You cannot pipe objects to Disconnect-AutomateNOW.

    .OUTPUTS
    A string indicating the results of the disconnection attempt.

    .EXAMPLE
    Disconnect-AutomateNOW

    .NOTES
    Although it is a good practice to disconnect your session, do be aware that the initial auth token is not revoked or terminated on the server side after logging out. This is the nature of JWT tokens.

    #>
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory = $false)]
        [switch]$KeepSessionVariable
    )
    If ($null -eq $anow_session.Instance) {
        Write-Warning -Message "You are not actually connected so you can't disconnect"
        Break
    }
    If ($anow_session.ExpirationDate -gt (Get-Date -Date '1970-01-01 00:00:00')) {
        [datetime]$current_date = Get-Date
        [datetime]$ExpirationDate = $anow_session.ExpirationDate
        [timespan]$TimeRemaining = ($ExpirationDate - $current_date)
        [int32]$SecondsRemaining = $TimeRemaining.TotalSeconds
        If ($SecondsRemaining -lt 2) {
            $Error.Clear()
            Try {
                Remove-Variable -Name anow_session -Scope Global -Force
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Remove-Variable failed to remove the expired anow_session global variable (under Disconnect-AutomateNOW) due to [$Message]."
                Break
            }
            Write-Information -MessageData "Removed the already expired anow_session global variable from this session"
        }
        Else {
            [string]$Instance = $anow_session.Instance
            [string]$command = '/logoutEvent'
            [hashtable]$parameters = @{}
            $parameters.Add('Command', $command)
            $parameters.Add('Method', 'POST')
            If ($anow_session.NotSecure -eq $true) {
                $parameters.Add('NotSecure', $true)
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] while running Disconnect-AutomateNOW due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            [string]$response_text = $results.response.data
            Write-Information -MessageData "[$Instance] reports $response_text"
            If ($KeepSessionVariable -ne $true) {
                $Error.Clear()
                Try {
                    Remove-Variable -Name anow_session -Scope Global -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Remove-Variable failed to remove the `$anow_session variable due to [$Message]."
                    Break
                }
            }
            Write-Information -MessageData "Removed the anow_session global variable from this session (it had $SecondsRemaining seconds remaining)"
        }
    }
}

Function Update-AutomateNOWToken {
    <#
    .SYNOPSIS
    Updates the session token used to connect to an instance of AutomateNOW!

    .DESCRIPTION
    The `Update-AutomateNOWToken` function updates the existing session token that is being used to connect to an instance of AutomateNOW!

    .INPUTS
    None. You cannot pipe objects to Update-AutomateNOWToken (yet).

    .OUTPUTS
    The global session variable $anow_session will be updated.

    .EXAMPLE
    Update-AutomateNOWToken

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This function has no parameters. It assumes you already have a global session variable ($anow_session)

    #>
    If ($anow_session.RefreshToken.Length -eq 0) {
        Write-Warning -Message "Somehow there is no refresh token."
        Break
    }
    ElseIf ( $anow_session.RefreshToken -eq 'Not set' ) {
        Write-Warning -Message "It is not possible to refresh the token if you used -AccessToken without also including -RefreshToken"
        Break
    }
    [string]$command = '/oauth/access_token'
    [string]$ContentType = 'application/x-www-form-urlencoded; charset=UTF-8'
    [string]$RefreshToken = $anow_session.RefreshToken
    [string]$Body = 'grant_type=refresh_token&refresh_token=' + $RefreshToken
    [hashtable]$parameters = @{}
    $parameters.Add('Method', 'POST')
    $parameters.Add('Command', $command)
    $parameters.Add('ContentType', $ContentType)
    $parameters.Add('NotAPICommand', $true)
    $parameters.Add('Body', $Body)
    If (($anow_session.NotSecure) -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    $Error.Clear()
    Try {
        [PSCustomObject]$token_properties = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to access the [$command] endpoint due to [$Message]."
        Break
    }
    [string]$access_token = $token_properties.access_token
    [string]$refresh_token = $token_properties.refresh_token
    $Error.Clear()
    Try {
        [System.TimeZoneInfo]$timezone = Get-TimeZone
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-TimeZone failed to get the time zone due to [$Message]."
        Break
    }
    [boolean]$dst = (Get-Date).IsDaylightSavingTime()
    If ($dst -eq $true) {
        [System.TimeSpan]$utc_offset = ($timezone.BaseUtcOffset + (New-TimeSpan -Minutes 60))
    }
    Else {
        [System.TimeSpan]$utc_offset = $timezone.BaseUtcOffset
    }
    If ($token_properties.expirationDate -ge 10000000000) {
        $Error.Clear()
        Try {
            [datetime]$expiration_date_utc = (Get-Date -Date '1970-01-01').AddMilliseconds(($token_properties.expirationDate))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-Date failed to process the authentication properties due to [$Message]"
            Break
        }
    }
    Else {
        $Error.Clear()
        Try {
            [datetime]$expiration_date_utc = (Get-Date -Date '1970-01-01').AddSeconds(($token_properties.expirationDate))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-Date failed to process the authentication properties due to [$Message]"
            Break
        }

    }
    [datetime]$expiration_date = ($expiration_date_utc + $utc_offset) # We're adding 2 values here: the current time in UTC and the current machine's UTC offset
    $anow_session.'ExpirationDate' = $expiration_date
    $anow_session.'AccessToken' = $access_token
    $anow_session.'RefreshToken' = $refresh_token
    [string]$expiration_date_display = Get-Date -Date $expiration_date -Format 'yyyy-MM-dd HH:mm:ss'
    $anow_session.header.'Authorization' = "Bearer $access_token"
    Write-Verbose -Message 'Global variable $anow_session.header has been set. Use this as your authentication header.'
    Write-Information -MessageData "Your token has been refreshed. The new expiration date is [$expiration_date_display]"
}

Function Confirm-AutomateNOWSession {
    <#
    .SYNOPSIS
    Surmises from the local session variable $anow_session if the current session is authenticated and not expired yet. Returns true or false.

    .DESCRIPTION
    Surmises from the local session variable $anow_session if the current session is authenticated and not expired yet. Returns true or false.

    .PARAMETER Quiet
    Switch parameter to silence the 'MOTD' that is returned by default after successfully authenticating.

    .PARAMETER DoNotRefresh
    Switch parameter to ignore MaximumTokenRefreshAge

    .PARAMETER MaximumTokenRefreshAge
    int32 parameter to specify the minimum age (in seconds) of the refresh token before updating it occurs automatically. Default is 3300 (meaning that the token will not be refreshed if it is less than 330 seconds old)

    .INPUTS
    None. You cannot pipe objects to Confirm-AutomateNOWSession (yet).

    .OUTPUTS
    Returns a boolean $True if the local session variable appears to be valid (not expired yet) otherwise returns $false

    .EXAMPLE
    Confirm-AutomateNOWSession -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token before you can confirm it

    #>
    [OutputType([boolean])]
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$DoNotRefresh,
        [Parameter(Mandatory = $false)]
        [int32]$MaximumTokenRefreshAge = 3300
    )
    If ($anow_session.header.values.count -eq 0) {
        Write-Warning -Message "Please use Connect-AutomateNOW to establish your access token or provide your token through the -AccessToken parameter of Connect-AutomateNOW."
        Break
    }
    ElseIf ($anow_session.header.Authorization -notmatch '^Bearer [a-zA-Z-_/=:,."0-9]{1,}$') {
        [string]$malformed_token = $anow_session.header.values
        Write-Warning -Message "Somehow the access token is not in the expected format. Please contact the author with this apparently malformed token: [$malformed_token]"
        Break
    }
    ElseIf ($anow_session.RefreshToken -eq 'Not set' -and $anow_session.APIUser -eq $false) {
        Write-Warning -Message 'This connection is not an api user but is without a refresh token! Next time you connect, please remember to include -RefreshToken with Connect-AutomateNOW.'
        Return $true
    }
    ElseIf ($anow_session.ExpirationDate -isnot [datetime]) {
        Write-Warning -Message 'Somehow there is no expiration date available. Are you debugging at this moment? Make sure that you allow Confirm-AutomateNOWSession to complete.'
        Break
    }
    ElseIf ($anow_session.RefreshToken -notmatch '^[a-zA-Z-_/=:,."0-9]{1,}$' -and $anow_session.RefreshToken -ne 'Not set' -and $anow_session.RefreshToken.Length -gt 0) {
        [string]$malformed_refresh_token = $anow_session.RefreshToken
        Write-Warning -Message "Somehow the refresh token does not appear to be valid. Please contact the author about this apparently malformed token: [$malformed_refresh_token]"
        Break
    }
    If ($null -eq (Get-Command -Name Invoke-AutomateNOWAPI -EA 0)) {
        Write-Warning -Message 'Somehow the Invoke-AutomateNOWAPI function is not available in this session. Did you install -and- import the module?'
        Break
    }
    If ($anow_session.ExpirationDate -gt (Get-Date -Date '1970-01-01 00:00:00')) {
        [datetime]$current_date = Get-Date
        [datetime]$ExpirationDate = $anow_session.ExpirationDate
        [string]$ExpirationDateDisplay = Get-Date -Date $ExpirationDate -Format 'yyyy-MM-dd HH:mm:ss'
        [timespan]$TimeRemaining = ($ExpirationDate - $current_date)
        [int32]$SecondsRemaining = $TimeRemaining.TotalSeconds
        If ($SecondsRemaining -lt 0) {
            If ($SecondsRemaining -lt -172800) {
                [int32]$DaysRemaining = ($SecondsRemaining * -1) / 86400
                Write-Warning -Message "This token expired about $DaysRemaining days ago at $ExpirationDateDisplay. You can request a new token using Connect-AutomateNOW."
                Break
            }
            ElseIf ($SecondsRemaining -lt -7200) {
                [int32]$HoursRemaining = ($SecondsRemaining * -1) / 3600
                Write-Warning -Message "This token expired about $HoursRemaining hours ago at $ExpirationDateDisplay. You can request a new token using Connect-AutomateNOW."
                Break
            }
            ElseIf ($SecondsRemaining -lt -300) {
                [int32]$MinutesRemaining = ($SecondsRemaining * -1) / 60
                Write-Warning -Message "This token expired about $MinutesRemaining minutes ago at $ExpirationDateDisplay. You can request a new token using Connect-AutomateNOW."
                Break
            }
            Else {
                [int32]$SecondsRemaining = $SecondsRemaining * -1
                Write-Warning -Message "This token expired $SecondsRemaining seconds ago at $ExpirationDateDisplay. You can request a new token using Connect-AutomateNOW."
                Break
            }
        }
        ElseIf (($SecondsRemaining -lt $MaximumTokenRefreshAge) -and ($DoNotRefresh -ne $true)) {
            [int32]$minutes_elapsed = ($TimeRemaining.TotalMinutes)
            Write-Verbose -Message "This token will expire in [$minutes_elapsed] minutes. Refreshing your token automatically. Use -DoNotRefresh with Connect-AutomateNOW to stop this behavior."
            Update-AutomateNOWToken
        }
        Else {
            Write-Verbose -Message "Debug: This token still has [$SecondsRemaining] seconds remaining"
        }
    }
    Else {
        If ( $anow_session.APIUser -eq $false) {
            Write-Warning -Message "This token has an unknown expiration date because you used -AccessToken without including -RefreshToken :|"
        }
    }
    Return $true
}

Function Switch-AutomateNOWDomain {
    <#
    .SYNOPSIS
    Switches the currently selected domain for the logged on user of an AutomateNOW! instance

    .DESCRIPTION
    The `Switch-AutomateNOWDomain` cmdlet does not actually communicate with the AutomateNOW! instance. It modifies the $anow_session global variable.

    .PARAMETER Domain
    Required string representing the name of the domain to switch to.

    .INPUTS
    None. You cannot pipe objects to Switch-AutomateNOWDomain.

    .OUTPUTS
    None except for Write-Information messages.

    .EXAMPLE
    Switch-AutomateNOWDomain -Domain 'Production'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This function is considered part of the Authentication functions. In the future, this function should support receiving a [ANOWDomain] object to switch to.

    #>
    [CmdletBinding()]
    Param(
        [string]$Domain
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    If ($Domain.Length -eq 0) {
        Write-Warning -Message 'Please specify a Domain using the -Domain parameter'
        Break
    }
    [string]$Instance = $anow_session.Instance
    If ($anow_session.available_domains -cnotcontains $Domain) {
        [string]$available_domains = $anow_session.available_domains -join ', '
        If ($anow_session.available_domains -contains $Domain) {
            Write-Warning -Message "The domains are case-sensitive. Please choose from [$available_domains]."
            Break
        }
        Write-Warning -Message "The domain [$Domain] is not on [$Instance]. Please choose from [$available_domains]."
        Break
    }
    $Error.Clear()
    Try {
        $anow_session.header.Remove('domain')
        $anow_session.header.Add('domain', $Domain)
        If ($null -eq $anow_session.current_domain) {
            $anow_session.header.Add('current_domain', $Domain)
        }
        Else {
            $anow_session.current_domain = $Domain
        }

    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "The Add/Remove method failed on `$anow_session.header` due to [$Message]."
        Break
    }
    Write-Information -MessageData "The [$Domain] domain has been selected for [$Instance]."
}

Function New-AutomateNOWServerDayTimestamp {
    <#
    .SYNOPSIS
    Generates a timestamp that can be used for time-based objects where the time-range is a full-day.

    .DESCRIPTION
    Generates a timestamp that can be used for time-based objects where the time-range is a full-day. Example: Enabling a Variable on a particular day.

    #>
    [OutputType([string])]
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory = $true, HelpMessage = "Enter the date in ISO-8601 format: 2029-04-10 or YYYY-MM-DD")]
        [string]$date
    )
    [string]$regex_daytimestamp = '^[2][0-9]{3}-(01|02|03|04|05|06|07|08|09|10|11|12)-(01|02|03|04|05|06|07|08|09|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31)$'
    If ($date -notmatch $regex_daytimestamp) {
        Write-Warning -Message "[$date] does not appear to be valid. Please enter a date string for a single day in ISO-8601 format. Example: 2029-05-31 for May 31st, 2029"
        Break
    }
    [string]$server_java_timezone = $anow_session.instance_info.licenseInfo.javaTimezone
    If ($server_java_timezone.Length -eq 0) {
        Write-Warning -Message "The server java timezone is not available in the global session variable. Please use Connect-AutomateNOW to establish your session."
        Break
    }
    $Error.Clear()
    Try {
        [ANOWTimeZone]$server_java_timezone_object = Get-AutomateNOWTimeZone -Id $server_java_timezone
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWTimeZone failed to create a timezone object under New-AutomateNOWServerDayTimestamp due to [$Message]."
        Break
    }
    [string]$server_java_timezone_object_id = $server_java_timezone_object.id
    If ($server_java_timezone_object_id.Length -eq 0) {
        Write-Warning -Message "Somehow the server java timezone object is invalid. Please look into this."
        Break
    }
    [int32]$server_java_offset = $server_java_timezone_object.rawOffset
    Write-Verbose -Message "The server Java timezone was detected as [$server_java_timezone_object_id] with a raw offset of [$server_java_offset]"
    [string]$utc_date_string = ($date + 'Z')
    $Error.Clear()
    Try {
        [datetime]$server_java_timezone_date = ((Get-Date -Date $utc_date_string).ToUniversalTime()).AddMilliseconds($server_java_offset * -1)
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-Date failed to create the server java timezone date object under New-AutomateNOWServerDayTimestamp due to [$Message]."
        Break
    }
    [string]$server_java_timezone_date_string = Get-Date -Date $server_java_timezone_date -Format "yyyy-MM-ddTHH:mm:ss.fff"
    Write-Verbose -Message "Returning back $server_java_timezone_date_string as the Java Timezone for $instance"
    Return $server_java_timezone_date_string
}

Function Reset-AutomateNOWJWTIssuerToken {
    <#
    .SYNOPSIS
    Resets the JWT issuer token within an instance of AutomateNOW!

    .DESCRIPTION
    Resets the JWT issuer token within an instance of AutomateNOW! Note: This invalidates ALL logged on users including yourself. Use with caution.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the [ANOWApplication] object.

    .INPUTS
    None.

    .OUTPUTS
    An [ANOWApplication] object will be returned

    .EXAMPLE
    Forcefully revokes the JWT issuer token

    Revoke-AutomateNOWJWTIssuerToken -Force

    .EXAMPLE
    Quietly revokes the JWT issuer token

    Revoke-AutomateNOWJWTIssuerToken -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    At the time of this writing in Patch 87, this functionality does not actually work.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    [string]$command = '/applicationConfiguration/resetJwtIssuerToken'
    [hashtable]$parameters = @{}
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$Instance = $anow_session.Instance
    If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("This will revoke ALL user sessions on $Instance. Are you sure you want to do this?")) -eq $true) {
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        $BodyMetaData.Add('_operationType', 'custom')
        $BodyMetaData.Add('_operationId', 'resetJwtIssuerToken')
        $BodyMetaData.Add('_textMatchStyle', 'exact')
        $BodyMetaData.Add('_dataSource', 'ApplicationConfigurationDataSource')
        $BodyMetaData.Add('isc_metaDataPrefix', '_')
        $BodyMetaData.Add('isc_dataFormat', 'json')
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        $parameters.Add('Body', $Body)
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Domain_id] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        Write-Warning -Message "The JWT issuer token has been reset. All user sessions on $Instance have therefore been revoked."
        If ($Quiet -ne $true) {
            $Error.Clear()
            Try {
                [ANOWTimeZone]$defaultTimeZone = Get-AutomateNOWTimeZone -Id $results.response.data[0].defaultTimeZone
                $results.response.data[0].defaultTimeZone = [ANOWTimeZone]$defaultTimeZone
                [ANOWApplicationConfiguration]$applicationConfiguration = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the response into an [ANOWApplication] object (under Reset-AutomateNOWJWTIssuerToken) due to [$Message]."
                Break
            }
            Return $applicationConfiguration
        }
    }
}

#EndRegion

#Region = Object Functions =

#Region - Adhoc Reports

Function Get-AutomateNOWAdhocReport {
    <#
    .SYNOPSIS
    Gets the Adhoc Reports from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Adhoc Reports from an AutomateNOW! instance

    .PARAMETER Id
    The Id of the AdHoc Report. Use this when you only want to retrieve a single report. This parameter cannot be combined with -startRow/-endRow.

    .PARAMETER startRow
    Integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER Folder
    Optional string of the name of the Folder to filter by.

    .PARAMETER Tags
    Optional string array of tags to filter by. Note that for now operator is 'containsAny', not 'containsAll'.

    .INPUTS
    Accepts a string representing the simple id of the Adhoc Report from the pipeline or individually (but not an array) or you can specify by start and end rows.

    .OUTPUTS
    An array of one or more [ANOWAdhocReport] class objects

    .EXAMPLE
    Gets the first page of Adhoc Report objects

    Get-AutomateNOWAdhocReport

    .EXAMPLE
    Gets a specific Adhoc Report object named 'AdhocReport1'

    Get-AutomateNOWAdhocReport -Id 'AdhocReport1'

    .EXAMPLE
    Gets a series of Adhoc Reports using the pipeline

    'AdhocReport1', 'AdhocReport2' | Get-AutomateNOWAdhocReport

    .EXAMPLE
    Gets the first pag of AdHoc Report objects that are tagged with 'Tag1' or 'Tag2'

    Get-AutomateNOWAdhocReport -Tags 'Tag1', 'Tag2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWAdhocReport[]])]
    [Cmdletbinding( DefaultParameterSetName = 'Default' )]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $False, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$Folder,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string[]]$Tags
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 -or $Id.Length -gt 0) {
            If ($_.Length -gt 0 ) {
                $Body.'id' = $_
            }
            Else {
                $Body.'id' = $Id
            }
            [string]$textMatchStyle = 'exactCase'
            $Body.'_operationId' = 'read'
        }
        Else {
            $Body.Add('operator', 'and')
            $Body.Add('_constructor', 'AdvancedCriteria')
            If ($Folder.Length -gt 0) {
                $Body.'criteria1' = ('{"fieldName":"folder","operator":"equals","value":"' + $Folder + '"}')
            }
            If ($Tags.Count -gt 0) {
                If ($Tags.Count -gt 1) {
                    $Error.Clear()
                    Try {
                        [string]$TagString = $Tags | ConvertTo-Json -Compress
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "ConvertTo-Json failed to convert the provided tag names under Get-AutomateNOWAdocReport due to [$Message]."
                        Break
                    }
                }
                Else {
                    [string]$TagString = $Tags
                }
                $Body.'criteria2' = ('{"fieldName":"tags","operator":"containsAny","value":' + $TagString + '}')
            }
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
            [string]$textMatchStyle = 'substring'
            $Body.'_componentId' = 'AdhocReportList'
        }
        $Body.'_textMatchStyle' = $textMatchStyle
        $Body.'_dataSource' = 'AdhocReportDataSource'
        $Body.'_operationType' = 'fetch'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/adhocReport/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] while running Get-AutomateNOWAdhocReport due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWAdhocReport[]]$AdhocReports = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWAdhocReport] objects due to [$Message]."
            Break
        }
        If ($AdhocReports.Count -gt 0) {
            Return $AdhocReports
        }
    }
    End {

    }
}

Function Set-AutomateNOWAdhocReport {
    <#
    .SYNOPSIS
    Changes the settings of an Adhoc Report on an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of an Adhoc Report on an AutomateNOW! instance

    .PARAMETER AdhocReport
    An [ANOWAdhocReport] object representing the Adhoc Report to be modified.

    .PARAMETER reportQuery
    The string representing the query for the Adhoc Report object to execute.

    .PARAMETER UnsetDescription
    Optional switch that will remove the Description from the Adhoc Report object.

    .PARAMETER Description
    Optional string to set the description on the new Adhoc Report object.

    .PARAMETER UnsetFolder
    Optional switch that will remove the Folder assignment from the Adhoc Report object.

    .PARAMETER Folder
    Optional string to set a different folder on the Adhoc Report object.

    .PARAMETER UnsetTags
    Optional switch that will remove the Tags from the Adhoc Report object.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the new Adhoc Report object.

    .PARAMETER CodeRepository
    Optional Code Repository to place the Adhoc Report into. Use Get-AutomateNOWCodeRepository to fetch this object.

    .PARAMETER UnsetCodeRepository
    Switch parameter that will remove the Adhoc Report from its Code Repository.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Switch parameter that silences the output of the updated object.

    .INPUTS
    ONLY [ANOWAdhocReport] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWAdhocReport] object will be returned

    .EXAMPLE
    Changes the description of an Adhoc Report

    $AdhocReport = Get-AutomateNOWAdhocReport -Id 'AdhocReport1'
    Set-AutomateNOWAdhocReport -AdhocReport $AdhocReport -Description 'My Description'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWAdhocReport])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWAdhocReport]$AdhocReport,
        [Parameter(Mandatory = $false)]
        [string]$reportQuery,
        [ValidateScript({ $_.Length -le 255 })]
        [Parameter(Mandatory = $false)]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetCodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot set the Tags and unset them at the same time. Please choose one or the other. Tags from the source object will be carried over to the new object if you do not specify any tag-related parameters."
            Break
        }
        If ($UnsetCodeRepository -eq $true -and $CodeRepository.Id.Length -gt 0) {
            Write-Warning -Message "You cannot unset the Code Repository and set it at the same time. Please choose one or the other."
            Break
        }
        [string]$command = '/adhocReport/update'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWAdhocReport]$AdhocReport = $_
        }
        [string]$AdhocReport_id = $AdhocReport.id
        [string]$AdhocReport_type = $AdhocReport.reportType
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($AdhocReport_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$AdhocReport_exists = ($null -eq (Get-AutomateNOWAdhocReport -Id $AdhocReport_id))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWAdhocReport failed to check if the Adhoc Report [$AdhocReport_id] already existed due to [$Message]."
                Break
            }
            If ($AdhocReport_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not an Adhoc Report named [$AdhocReport_id] in the [$current_domain] domain. Please check into this."
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $AdhocReport_id
            If ($reportQuery.Length -gt 0) {
                $BodyMetaData.'reportQuery' = $reportQuery
            }
            If ($Description.Length -gt 0) {
                $BodyMetaData.'description' = $Description
            }
            ElseIf ($UnsetDescription -eq $true) {
                $BodyMetaData.'description' = $Null
            }
            Else {
                If ($AdhocReport.description.Length -gt 0) {
                    $BodyMetaData.'description' = $AdhocReport.description
                }
            }
            If ($UnsetFolder -eq $True) {
                $BodyMetaData.'folder' = $Null
            }
            ElseIf ($Folder.Length -gt 0) {
                $BodyMetaData.'folder' = $Folder
            }
            Else {
                If ($AdhocReport.folder.Length -gt 0) {
                    $BodyMetaData.'folder' = $AdhocReport.folder
                }
            }
            If ($Tags.Count -gt 0) {
                [int32]$tag_count = 1
                ForEach ($tag in $Tags) {
                    $BodyMetaData.('tags' + $tag_count ) = $tag
                    $tag_count++
                }
            }
            ElseIf ($UnsetTags -eq $true) {
                $BodyMetaData.'tags' = $Null
            }
            Else {
                If ($AdhocReport.Tags -gt 0) {
                    [int32]$tag_count = 1
                    ForEach ($tag in $AdhocReport.tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
            }
            If ($CodeRepository.Id.Length -gt 0) {
                [string]$CodeRepository_Id = $CodeRepository.Id
                $Error.Clear()
                Try {
                    [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository_Id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository_Id] actually existed under Set-AutomateNOWAdhocReport due to [$Message]"
                    Break
                }
                If ($code_repository_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository_Id] under Set-AutomateNOWAdhocReport. Please check again."
                    Break
                }
                $BodyMetaData.'codeRepository' = $CodeRepository_Id
            }
            ElseIf ($UnsetCodeRepository -eq $true) {
                $BodyMetaData.'codeRepository' = $null
            }
            [string]$old_values = $AdhocReport.CreateOldValues()
            $BodyMetaData.'_oldValues' = $old_values
            $BodyMetaData.'_componentId' = 'AdhocReportEditForm'
            $BodyMetaData.'_operationType' = 'update'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_dataSource' = 'AdhocReportDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$AdhocReport_id] of type [$AdhocReport_type] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "AdhocReport object [$AdhocReport_id] of type [$AdhocReport_type] was successfully updated"
            $Error.Clear()
            Try {
                [ANOWAdhocReport]$UpdatedAdhocReport = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the returned updated object to an [ANOWAdhocReport] object due to [$Message]. The object was still updated though."
                Break
            }
            If ($Quiet -ne $true) {
                Return $UpdatedAdhocReport
            }
        }
    }
    End {
    }
}

Function New-AutomateNOWAdhocReport {
    <#
    .SYNOPSIS
    Creates an AdhocReport within an AutomateNOW! instance

    .DESCRIPTION
    Creates an AdhocReport within an AutomateNOW! instance and returns back the newly created [ANOWAdhocReport] object

    .PARAMETER Id
    The intended name of the AdhocReport. For example: 'MyAdhocReport1'. This value may not contain the domain in brackets.

    .PARAMETER reportType
    The type of report. Valid choices are: TABLE and PIVOT

    .PARAMETER Description
    Optional description of the AdhocReport (may not exceed 255 characters).

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new Adhoc Report. Do not pass [ANOWTag] objects here.

    .PARAMETER Folder
    Optional name of the folder to place the Adhoc Report into.

    .PARAMETER CodeRepository
    Optional Code Repository to place the Adhoc Report into. Use Get-AutomateNOWCodeRepository to fetch this object.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWAdhocReport.

    .OUTPUTS
    An [ANOWAdhocReport] object representing the newly created AdhocReport

    .EXAMPLE
    New-AutomateNOWAdhocReport -Id 'AdhocReport1' -reportType 'TABLE' -Description 'my description' -Tags 'Tag1', 'Tag2' -Folder 'Folder1' -CodeRepository 'CodeRepository1'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The name (id) of the AdhocReport must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    You CANNOT include the code when you initially create the report object. This is by design of the API. You will need to use Set-AutomateNOWAdhocReport to add your query. Then use Invoke-AutomateNOWAdhocReport to execute the report.

    #>
    [OutputType([ANOWAdhocReport])]
    [Cmdletbinding()]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $true)]
        [string]$Id,
        [Parameter(Mandatory = $true)]
        [ANOWAdhocReport_reportType]$reportType,
        [Parameter(Mandatory = $false, HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [boolean]$AdhocReport_exists = ($null -ne (Get-AutomateNOWAdhocReport -Id $Id))
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWAdhocReport failed to check if the AdhocReport [$Id] already existed due to [$Message]."
        Break
    }
    If ($AdhocReport_exists -eq $true) {
        [string]$current_domain = $anow_session.header.domain
        Write-Warning -Message "There is already an AdhocReport named [$Id] in [$current_domain]. Please check into this."
        Break
    }
    ## End warning ##
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    $BodyMetaData.'reportType' = $reportType
    $BodyMetaData.'id' = $Id
    If ($Description.Length -gt 0) {
        $BodyMetaData.'description' = $Description
    }
    If ($Tags.Count -gt 0) {
        [int32]$total_tags = $Tags.Count
        [int32]$current_tag = 1
        ForEach ($tag_id in $Tags) {
            $Error.Clear()
            Try {
                [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] running under New-AutomateNOWAdhocReport due to [$message]"
                Break
            }
            If ($tag_object.simpleId.length -eq 0) {
                Throw "New-AutomateNOWAdhocReport has detected that the tag [$tag_id] does not appear to exist. Please check again."
                Break
            }
            ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                [string]$tag_object_simpleId = $tag_object.simpleId
                Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                Break
            }
            [string]$tag_display = $tag_object | ConvertTo-Json -Compress
            Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
            [string]$tag_name_sequence = ('tags' + $current_tag)
            $BodyMetaData."$tag_name_sequence" = $tag_id
            $include_properties += $tag_name_sequence
            $current_tag++
        }
    }
    If ($Folder.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] existed under New-AutomateNOWAdhocReport due to [$Message]"
            Break
        }
        If ($folder_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] under New-AutomateNOWAdhocReport. Please check again."
            Break
        }
        Write-Verbose -Message "Adding Adhoc Report $Id to Folder $Folder"
        $BodyMetaData.'folder' = $Folder
    }
    If ($CodeRepository.id.Length -gt 0) {
        [string]$CodeRepository_Id = $CodeRepository.id
        $Error.Clear()
        Try {
            [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository_Id
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository_Id] existed under New-AutomateNOWAdhocReport due to [$Message]"
            Break
        }
        If ($code_repository_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository_Id] under New-AutomateNOWAdhocReport. Please check again."
            Break
        }
        Write-Verbose -Message "Adding Adhoc Report [$Id] to Code Repository $CodeRepository_Id"
        $BodyMetaData.'codeRepository' = $CodeRepository_Id
    }
    $BodyMetaData.'_operationType' = 'add'
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_oldValues' = ('{"reportType":"' + $reportType + '"}')
    $BodyMetaData.'_componentId' = 'AdhocReportCreateWindow_form'
    $BodyMetaData.'_dataSource' = 'AdhocReportDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$BodyMetaDataString = ConvertTo-QueryString -InputObject $BodyMetaData
    [string]$Body = ($BodyObject + '&' + $BodyMetaDataString)
    [string]$command = '/adhocReport/create'
    [hashtable]$parameters = @{}
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('Body', $Body)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWAdhocReport]$AdhocReport = $results.response.data | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to create [ANOWAdhocReport] object due to [$Message]."
        Break
    }
    If ($AdhocReport.id.Length -eq 0) {
        Write-Warning -Message "Somehow the newly created [ANOWAdhocReport] AdhocReport is empty!"
        Break
    }
    If ($Quiet -ne $true) {
        Return $AdhocReport
    }
}

Function Copy-AutomateNOWAdhocReport {
    <#
    .SYNOPSIS
    Copies an Adhoc Report from an AutomateNOW! instance

    .DESCRIPTION
    Copies an Adhoc Report from an AutomateNOW! instance. AutomateNOW object id can never be changed, but we can copy the object to a new id and it will include all of the items therein.

    .PARAMETER AdhocReport
    Mandatory [ANOWAdhocReport] object to be copied.

    .PARAMETER NewId
    The name (Id) of the new Adhoc Report. The new Id must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    .PARAMETER UnsetDescription
    Optional switch that will ensure that the newly created Adhoc Report will not have a description set.

    .PARAMETER Description
    Optional description to set on the new Adhoc Report object. If you do not set this, the new Adhoc Report object will copy the Description of the source object.

    .PARAMETER UnsetFolder
    Optional switch that will ensure that the newly created Adhoc Report will not have a Folder set.

    .PARAMETER Folder
    Optional description to set a different folder on the new Adhoc Report object. If you do not set this, the new Adhoc Report object will use the same Folder of the source object.

    .PARAMETER UnsetTags
    Optional switch that will ensure that the newly created Adhoc Report will not have any Tags set.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the new AdhocReport object. If you do not set this, the new Adhoc Report object will apply the same Tags of the source object.

    .PARAMETER Force
    Force the copy without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    ONLY [ANOWAdhocReport] object is accepted. Pipeline support is intentionally unavailable.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Creates a copy of an Adhoc Report and changes the description (multi-line format)
    $AdhocReport01 = Get-AutomateNOWAdhocReport -Id 'AdhocReport_01'
    Copy-AutomateNOWAdhocReport -AdhocReport $AdhocReport01 -NewId 'AdhocReport_01_production' -Description 'Adhoc Report 01 Production'

    .EXAMPLE
    Creates a copy of an Adhoc Report that omits the description (one-liner format)
    Copy-AutomateNOWAdhocReport -AdhocReport (Get-AutomateNOWAdhocReport -Id 'AdhocReport_01') -NewId 'AdhocReport_01_production' -UnsetDescription -Tags 'Tag1', 'Tag2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWAdhocReport]$AdhocReport,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot set the Tags and unset them at the same time. Please choose one or the other. Tags from the source object will be carried over to the new object if you do not specify any tag-related parameters."
            Break
        }
        [string]$AdhocReportType = $AdhocReport.AdhocReportType
        Write-Verbose -Message "This is a [$AdhocReportType] type of Data Source"
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$AdhocReport_exists = ($null -ne (Get-AutomateNOWAdhocReport -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWAdhocReport failed to check if the Adhoc Report [$NewId] already existed due to [$Message]."
            Break
        }
        If ($AdhocReport_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already an Adhoc Report named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End warning ##
        [string]$command = '/AdhocReport/copy'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            [string]$AdhocReport_oldId = $AdhocReport.id
            [string]$AdhocReport_simpleId = $AdhocReport.simpleId
            If ($AdhocReport_oldId -eq $NewId) {
                Write-Warning -Message "The new id cannot be the same as the old id."
                Break
            }
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Copy the Adhoc Report $($AdhocReport_simpleId) to $($NewId)?")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                If ($UnsetFolder -eq $True) {
                    $BodyMetaData.'folder' = $Null
                }
                ElseIf ($Folder.Length -gt 0) {
                    $BodyMetaData.'folder' = $Folder
                }
                Else {
                    If ($AdhocReport.folder.Length -gt 0) {
                        $BodyMetaData.'folder' = $AdhocReport.folder
                    }
                }
                If ($Tags.Count -gt 0) {
                    [int32]$tag_count = 1
                    ForEach ($tag in $Tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
                ElseIf ($UnsetTags -eq $true) {
                    $BodyMetaData.'tags' = $Null
                }
                Else {
                    If ($AdhocReport.Tags -gt 0) {
                        [int32]$tag_count = 1
                        ForEach ($tag in $AdhocReport.tags) {
                            $BodyMetaData.('tags' + $tag_count ) = $tag
                            $tag_count++
                        }
                    }
                }
                $BodyMetaData.'oldId' = $AdhocReport_oldId
                $BodyMetaData.'domain' = $AdhocReport.domain
                $BodyMetaData.'id' = $NewId
                If ($UnsetDescription -ne $true) {
                    If ($Description.Length -gt 0) {
                        $BodyMetaData.'description' = $Description
                    }
                    Else {
                        $BodyMetaData.'description' = $AdhocReport.description
                    }
                }
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_operationId' = 'copy'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_dataSource' = 'AdhocReportDataSource'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties oldId, domain, NewId, description, folder, tags
                $parameters.Body = $Body
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$AdhocReport_oldId] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                $Error.Clear()
                Try {
                    [ANOWAdhocReport]$NewAdhocReport = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to create copied [ANOWAdhocReport] object [$NewId] due to [$Message]."
                    Break
                }
                If ($NewAdhocReport.id.Length -eq 0) {
                    Write-Warning -Message "Somehow the newly created (copied) [ANOWAdhocReport] object [$NewId] is empty!"
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $NewAdhocReport
                }
            }
        }
    }
    End {

    }
}

Function Rename-AutomateNOWAdhocReport {
    <#
    .SYNOPSIS
    Renames an Adhoc Report on an AutomateNOW! instance

    .DESCRIPTION
    Performs a psuedo-rename operations of an Adhoc Report from an AutomateNOW! instance by copying it first and then deleting the source. This function merely combines Copy-AutomateNOWAdhocReport and Remove-AutomateNOWAdhocReport therefore it is to be considered destructive.

    .PARAMETER AdhocReport
    An [ANOWAdhocReport] object representing the Adhoc Report to be renamed.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the Adhoc Report. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER Force
    Force the renaming without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly renamed object.

    .INPUTS
    ONLY [ANOWAdhocReport] objects are accepted. There is intentionally no support for the pipeline.

    .OUTPUTS
    The newly renamed [ANOWAdhocReport] object will be returned.

    .EXAMPLE
    $AdhocReport = Get-AutomateNOWAdhocReport -Id 'AdhocReport01'
    Rename-AutomateNOWAdhocReport -AdhocReport $AdhocReport -NewId 'AdhocReport_01'

    .EXAMPLE
    Rename-AutomateNOWAdhocReport -AdhocReport (Get-AutomateNOWAdhocReport -Id 'AdhocReport01') -NewId 'AdhocReport_01'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    When renaming, you may only specify a different Id (name).

    This action will be blocked if any existing referrals are found on the object.
    #>
    [OutputType([ANOWAdhocReport])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWAdhocReport]$AdhocReport,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin standard warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$new_AdhocReport_exists = ($null -ne (Get-AutomateNOWAdhocReport -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWAdhocReport failed to check if the Adhoc Report [$NewId] already existed due to [$Message]."
            Break
        }
        If ($new_AdhocReport_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already an Adhoc Report named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        [string]$AdhocReport_id = $AdhocReport.simpleId
        $Error.Clear()
        Try {
            [boolean]$old_AdhocReport_exists = ($null -ne (Get-AutomateNOWAdhocReport -Id $AdhocReport_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWAdhocReport failed to check if the AdhocReport [$AdhocReport_id] already existed due to [$Message]."
            Break
        }
        If ($old_AdhocReport_exists -eq $false) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not an AdhocReport named [$AdhocReport_id] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End standard warning ##
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($AdhocReport_id)")) -eq $true) {
                $Error.Clear()
                Try {
                    [ANOWAdhocReport]$new_AdhocReport = Copy-AutomateNOWAdhocReport -AdhocReport $AdhocReport -NewId $NewId -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Copy-AutomateNOWAdhocReport failed to create a new AdhocReport [$NewId] as Part 1 of the renaming process due to [$Message]."
                    Break
                }
                If ($new_AdhocReport.simpleId -eq $NewId) {
                    Write-Verbose -Message "Part 1: AdhocReport [$AdhocReport_id] successfully copied to [$NewId]"
                }
                Else {
                    Write-Warning -Message "Somehow the first phase (Copy-AutomateNOWAdhocReport) failed. Please look into this."
                    Break
                }
                $Error.Clear()
                Try {
                    Remove-AutomateNOWAdhocReport -AdhocReport $AdhocReport -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Remove-AutomateNOWAdhocReport failed to remove [$AdhocReport_id] as Part 2 of the renaming process due to [$Message]."
                    Break
                }
                Write-Verbose -Message "Part 2: AdhocReport [$AdhocReport_id] removed"
                Write-Verbose -Message "Task [$AdhocReport_id] successfully renamed to [$NewId]"
                If ($Quiet -ne $true) {
                    Return $new_AdhocReport
                }
            }
        }
        Else {
            Write-Warning -Message "No action was taken because either the source object didn't exist or the new object already existed"
        }
    }
    End {
    }
}

Function Export-AutomateNOWAdhocReport {
    <#
    .SYNOPSIS
    Exports the Adhoc Reports from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Adhoc Reports from an instance of AutomateNOW! to a local .csv file

    .PARAMETER AdhocReport
    Mandatory [ANOWAdhocReport] object (Use Get-AutomateNOWAdhocReport to retrieve them)

    .INPUTS
    ONLY [ANOWAdhocReport] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWAdhocReport] objects are exported to the local disk in CSV format

    .EXAMPLE
    Get-AutomateNOWAdhocReport | Export-AutomateNOWAdhocReport

    .EXAMPLE
    Get-AutomateNOWAdhocReport -Id 'AdhocReport01' | Export-AutomateNOWAdhocReport

    .EXAMPLE
    @( 'AdhocReport01', 'AdhocReport02' ) | Get-AutomateNOWAdhocReport | Export-AutomateNOWAdhocReport

    .NOTES
	You must present [ANOWAdhocReport] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWAdhocReport]$AdhocReport
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-AdhocReports-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWAdhocReport]$AdhocReport = $_
        }
        $Error.Clear()
        Try {
            $AdhocReport | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWAdhocReport] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function Remove-AutomateNOWAdhocReport {
    <#
    .SYNOPSIS
    Removes an Adhoc Report from an AutomateNOW! instance

    .DESCRIPTION
    Removes an Adhoc Report from an AutomateNOW! instance

    .PARAMETER AdhocReport
    An [ANOWAdhocReport] object representing the Adhoc Report to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWAdhocReport] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Removes a single Adhoc Report
    Get-AutomateNOWAdhocReport -Id 'AdhocReport01' | Remove-AutomateNOWAdhocReport

    .EXAMPLE
    Forcefully removes three Adhoc Reports by way of the pipeline
    @( 'AdhocReport1', 'AdhocReport2', 'AdhocReport3') | Get-AutomateNOWAdhocReport | Remove-AutomateNOWAdhocReport -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWAdhocReport]$AdhocReport,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/adhocReport/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWAdhocReport]$AdhocReport = $_
        }
        [string]$AdhocReport_id = $AdhocReport.id
        If ($AdhocReport_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($AdhocReport_id)")) -eq $true) {
            [string]$oldvalues = $AdhocReport.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $AdhocReport.id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'AdhocReportList'
            $BodyMetaData.'_dataSource' = 'AdhocReportDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$AdhocReport_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "AdhocReport [$AdhocReport_id] successfully removed"
        }
    }
    End {

    }
}

Function Invoke-AutomateNOWAdhocReport {
    <#
    .SYNOPSIS
    Starts an Adhoc Report from an AutomateNOW! instance

    .DESCRIPTION
    Starts an Adhoc Report from an AutomateNOW! instance

    .PARAMETER AdhocReport
    An [ANOWAdhocReport] object representing the Adhoc Report to be started. You cannot combine this with -reportQuery.

    .PARAMETER reportQuery
    A string representing the query to run. You cannot combine this with -AdhocReport.

    .INPUTS
    ONLY [ANOWAdhocReport] objects are accepted (including from the pipeline)

    .OUTPUTS
    A [System.Data.Datatable] object representing the results of the invoked Adhoc Report will be returned.

    .EXAMPLE
    Executes a standard Adhoc Report object

    $adhoc_report = Get-AutomateNOWAdhocReport -Id 'adhoc_report1'
    Invoke-AutomateNOWAdhocReport -AdhocReport $adhoc_report

    .EXAMPLE
    Executes a query bypassing the Adhoc Report object altogether

    $reportQuery = 'SELECT id FROM anow.processing LIMIT 1'
    Invoke-AutomateNOWAdhocReport -reportQuery $reportQuery

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    There is no -Quiet parameter here since Adhoc Reports are limited to SELECT statements there would never be a reason to silence the output.

    #>
    [Cmdletbinding(DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True, ParameterSetName = 'Default')]
        [ANOWAdhocReport]$AdhocReport,
        [Parameter(Mandatory = $false, ParameterSetName = 'ManualQuery')]
        [string]$reportQuery,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/adhocReport/runReport'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWAdhocReport]$AdhocReport = $_
        }
        If ($reportQuery.Length -eq 0) {
            [string]$reportQuery = $AdhocReport.reportQuery
        }
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        $BodyMetaData.Add('reportQuery', $reportQuery )
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        If ($null -eq $parameters.Body) {
            $parameters.Add('Body', $Body)
        }
        Else {
            $parameters.Body = $Body
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$AdhocReport_id] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        If ($AdhocReport.simpleId.Length -gt 0) {
            [string]$AdhocId = $AdhocReport.simpleId
            Write-Verbose -Message "The Adhoc Report [$AdhocId] was executed"
        }
        Else {
            Write-Verbose -Message "The manually supplied query was executed"
        }
        $Error.Clear()
        Try {
            [System.Data.Datatable]$Datatable = New-Object -Typename System.Data.Datatable
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "New-Object failed to create a [System.Data.Datatable] due to [$Message]."
            Break
        }
        ForEach ($field in $results.response.data.fields) {
            [string]$column_name = $field.name
            [string]$column_type = $field.type
            [string]$data_type = Switch ($column_type) {
                'text' { 'string'; break }
                'boolean' { 'boolean'; break }
                'datetime' { 'datetime'; break }
                'float' { 'int64'; break }
                'array' { 'string'; break }
                'jsonb' { 'string'; break }
                Default { 'text' }
            }
            $Error.Clear()
            Try {
                [void]$Datatable.Columns.Add($column_name, $data_type)
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "The Add method on the Datatable Columns failed due to [$Message]."
                Break
            }
        }
        $Error.Clear()
        Try {
            [PSCustomObject[]]$ColumnNames = $Datatable.Columns.ColumnName
            [string]$ColumnNames_display = $ColumnNames | ConvertTo-Json -Compress
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to extract the columns names $ColumnNames_display from the response due to [$Message]."
            Break
        }
        [int32]$row_count = $results.response.data.data.count
        [int32]$current_row = 1
        ForEach ($data in $results.response.data.data) {
            [array]$data_set = ( $ColumnNames | ForEach-Object {
                    $data."$_"
                }
            )
            $Error.Clear()
            Try {
                [void]$Datatable.Rows.Add($data_set)
            }
            Catch {
                [string]$Message = $_.Exception.Message
                [string]$data_set_display = $data_set | ConvertTo-Json -Compress
                Write-Warning -Message "Failed to add row number [$current_row] of [$row_count] rows due to [$Message] Columns - $ColumnNames_display - Data $data_set_display"
                Break
            }
            $current_row++
        }
        [int32]$rows_count = $Datatable.Rows.Count
        If ($rows_count -eq 0) {
            Write-Warning -Message "There were no results from the query"
            Break
        }
        Else {
            Return $Datatable
        }
    }
    End {

    }
}

#Endregion

#Region - Agents

Function Get-AutomateNOWAgent {
    <#
    .SYNOPSIS
    Gets the Agents from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Agents from an AutomateNOW! instance

    .PARAMETER Id
    Optional string containing the simple id of the Agents to fetch or you can pipeline a series of simple id strings. You may not enter an array here.

    .PARAMETER startRow
    Integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER Folder
    Optional string to filter by a particular Folder

    .PARAMETER Tags
    Optional string array of Tags to filter by. Note that the 'containsAny' operator will be used.

    .INPUTS
    Accepts a string representing the simple id of the Agents from the pipeline or individually (but not an array).

    .OUTPUTS
    An array of one or more [ANOWAgent] class objects

    .EXAMPLE
    Gets the first page of Agent objects

    Get-AutomateNOWAgent

    .EXAMPLE
    Gets an Agent object named 'Agent1'

    Get-AutomateNOWAgent -Id 'Agent1'

    .EXAMPLE
    Gets a series of Agent objects using the pipeline

    'Agent1', 'Agent2' | Get-AutomateNOWAgent

    .EXAMPLE
    Gets the first page of Agents that are tagged with 'Tag1' or 'Tag2'

    Get-AutomateNOWAgent -Tags 'Tag1', 'Tag2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWAgent[]])]
    [Cmdletbinding(DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $True, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$Folder,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string[]]$Tags
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 -or $Id.Length -gt 0) {
            If ($_.Length -gt 0 ) {
                $Body.'id' = $_
            }
            Else {
                $Body.'id' = $Id
            }
            $Body.'_textMatchStyle' = 'exactCase'
            $Body.'_operationId' = 'Read'
        }
        Else {
            $Body.'operator' = 'and'
            $Body.'_constructor' = 'AdvancedCriteria'
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
            If ($Folder.Length -gt 0) {
                $Body.'criteria1' = ('{"fieldName":"folder","operator":"equals","value":"' + $Folder + '"}')
            }
            If ($Tags.Count -gt 0) {
                If ($Tags.Count -gt 1) {
                    $Error.Clear()
                    Try {
                        [string]$TagString = $Tags | ConvertTo-Json -Compress
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "ConvertTo-Json failed to convert the provided tag names under Get-AutomateNOWAgent due to [$Message]."
                        Break
                    }
                }
                Else {
                    [string]$TagString = $Tags
                }
                $Body.'criteria2' = ('{"fieldName":"tags","operator":"containsAny","value":' + $TagString + '}')
            }
            $Body.'_textMatchStyle' = 'exact'
            $Body.'_componentId' = 'AgentList'
        }
        $Body.'_operationType' = 'fetch'
        $Body.'_dataSource' = 'AgentDataSource'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/agent/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWAgent[]]$Agents = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWAgent] objects due to [$Message]."
            Break
        }
        If ($Agents.Count -gt 0) {
            Return $Agents
        }
    }
    End {

    }
}

Function Set-AutomateNOWAgent {
    <#
    .SYNOPSIS
    Changes the settings of an Agent on an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of an Agent on an AutomateNOW! instance

    .PARAMETER Agent
    An [ANOWAgent] object representing the Agent to be modified.

    .PARAMETER AgentHeartBeat
    An int64 representing the interval between heartbeat messages sent by the Agent to the AutomateNOW! server

    .PARAMETER logMaxFiles
    An int64 representing the number of days an agent log file will be kept at the operating system level.

    .PARAMETER logLevel
    A string representing the level of verbosity for the Agent log. Valid choices are: 'ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE'

    .PARAMETER maxLogSize
    An int32 "MaxLog Size for Preview". This setting is not documented or explained anywhere.

    .PARAMETER UnsetDescription
    Optional switch that will remove the Description from the Agent object.

    .PARAMETER Description
    Optional string to set the description on the new Agent object.

    .PARAMETER UnsetFolder
    Optional switch that will remove the Folder assignment from the Agent object.

    .PARAMETER Folder
    Optional string to set a different folder on the Agent object.

    .PARAMETER UnsetTags
    Optional switch that will remove the Tags from the Agent object.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the new Agent object.

    .PARAMETER CodeRepository
    Optional Code Repository to place the Agent into. Use Get-AutomateNOWCodeRepository to fetch this object.

    .PARAMETER UnsetCodeRepository
    Switch parameter that will remove the the Agent from its Code Repository.

    .PARAMETER Quiet
    Switch parameter that silences the output of the updated object.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWAgent] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWAgent] object will be returned

    .EXAMPLE
    Forcibly sets all of the properties that are available to this function

    $agent = Get-AutomateNOWAgent -Id 'Agent01'
    Set-AutomateNOWAgent -Agent $agent -Description "Description!" -Tags 'TAG1', 'TAG2' -Folder 'Folder1' -logMaxFiles 10 -logLevel ERROR -maxLogSize 100 -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWAgent])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWAgent]$Agent,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetCodeRepository,
        [Parameter(Mandatory = $false)]
        [int64]$AgentHeartbeat,
        [Parameter(Mandatory = $false)]
        [int64]$logMaxFiles,
        [ValidateSet( 'ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE', ignoreCase = $false )]
        [Parameter(Mandatory = $false)]
        [string]$logLevel,
        [Parameter(Mandatory = $false)]
        [int32]$maxLogSize,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot set the Tags and unset them at the same time. Please choose one or the other. Tags from the source object will be carried over to the new object if you do not specify any tag-related parameters."
            Break
        }
        If ($UnsetCodeRepository -eq $true -and $CodeRepository.Id.Length -gt 0) {
            Write-Warning -Message "You cannot unset the Code Repository and set it at the same time. Please choose one or the other."
            Break
        }
        [string]$command = '/agent/update'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWAgent]$Agent = $_
        }
        [string]$Agent_id = $Agent.id
        [string]$Agent_simpleId = $agent.simpleId
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Agent_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$Agent_exists = ($null -eq (Get-AutomateNOWAgent -Id $Agent_id))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWAgent failed to check if the Agent [$Agent_id] already existed due to [$Message]."
                Break
            }
            If ($Agent_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not an Agent named [$Agent_id] in the [$current_domain] domain. Please check into this."
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $Agent_id
            If ($AgentHeartbeat -eq 0) {
                [int64]$AgentHeartbeat = $Agent.configuration.AgentHeartBeat
            }
            If ($logMaxFiles -eq 0) {
                [int64]$logMaxFiles = $Agent.configuration.logMaxFiles
            }
            If ($logLevel.Length -eq 0) {
                [string]$logLevel = $Agent.configuration.logLevel
            }
            If ($maxLogSize -eq 0) {
                [int32]$maxLogSize = $Agent.configuration.maxLogSize
            }
            [string]$configuration = ('{"AgentHeartbeat":' + $AgentHeartbeat + ',"logMaxFiles":' + $logMaxFiles + ',"logLevel":"' + $logLevel + '","maxLogSize":' + $maxLogSize + '}')
            $BodyMetaData.'configuration' = $configuration
            If ($Description.Length -gt 0) {
                $BodyMetaData.'description' = $Description
            }
            ElseIf ($UnsetDescription -eq $true) {
                $BodyMetaData.'description' = $Null
            }
            Else {
                If ($Agent.description.Length -gt 0) {
                    $BodyMetaData.'description' = $Agent.description
                }
            }
            If ($UnsetFolder -eq $True) {
                $BodyMetaData.'folder' = $Null
            }
            ElseIf ($Folder.Length -gt 0) {
                $BodyMetaData.'folder' = $Folder
            }
            Else {
                If ($Agent.folder.Length -gt 0) {
                    $BodyMetaData.'folder' = $Agent.folder
                }
            }
            If ($Tags.Count -gt 0) {
                [int32]$tag_count = 1
                ForEach ($tag in $Tags) {
                    $BodyMetaData.('tags' + $tag_count ) = $tag
                    $tag_count++
                }
            }
            ElseIf ($UnsetTags -eq $true) {
                $BodyMetaData.'tags' = $Null
            }
            Else {
                If ($Agent.Tags -gt 0) {
                    [int32]$tag_count = 1
                    ForEach ($tag in $Agent.tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
            }
            If ($CodeRepository.Id.Length -gt 0) {
                [string]$CodeRepository_Id = $CodeRepository.Id
                $Error.Clear()
                Try {
                    [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository_Id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository_Id] actually existed under Set-AutomateNOWAgent due to [$Message]"
                    Break
                }
                If ($code_repository_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository_Id] under Set-AutomateNOWAgent. Please check again."
                    Break
                }
                $BodyMetaData.'codeRepository' = $CodeRepository_Id
            }
            ElseIf ($UnsetCodeRepository -eq $true) {
                $BodyMetaData.'codeRepository' = $null
            }
            [string]$old_values = $Agent.CreateOldValues()
            $BodyMetaData.'_oldValues' = $old_values
            $BodyMetaData.'_componentId' = 'AgentEditForm'
            $BodyMetaData.'_operationType' = 'update'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_dataSource' = 'AgentDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Agent_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            $Error.Clear()
            Try {
                [ANOWAgent]$UpdatedAgent = Get-AutomateNOWAgent -Id $Agent_simpleId
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to fetch the updated [ANOWAgent] object due to [$Message]."
                Break
            }
            Write-Verbose -Message "Agent object [$Agent_id] was successfully updated"
            If ($Quiet -ne $true) {
                Return $UpdatedAgent
            }
        }
    }
    End {
    }
}

Function Export-AutomateNOWAgent {
    <#
    .SYNOPSIS
    Exports the Agents from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Agents from an instance of AutomateNOW! to a local .csv file

    .PARAMETER Agent
    Mandatory [ANOWAgent] object (Use Get-AutomateNOWAgent to retrieve them)

    .INPUTS
    ONLY [ANOWAgent] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWAgent] objects are exported to the local disk in CSV format

    .EXAMPLE
    Get-AutomateNOWAgent | Export-AutomateNOWAgent

    .EXAMPLE
    Get-AutomateNOWAgent -Id 'Agent01' | Export-AutomateNOWAgent

    .EXAMPLE
    @( 'Agent01', 'Agent02' ) | Get-AutomateNOWAgent | Export-AutomateNOWAgent

    .EXAMPLE
    Get-AutomateNOWAgent | Where-Object { $_.simpleId -eq 'Agent01' } | Export-AutomateNOWAgent

    .NOTES
	You must present [ANOWAgent] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWAgent]$Agent
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-Agents-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWAgent]$Agents = $_
        }
        $Error.Clear()
        Try {
            $Agents | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWAgent] objects on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function New-AutomateNOWAgent {
    <#
    .SYNOPSIS
    Creates a Agent within an AutomateNOW! instance

    .DESCRIPTION
    Creates a Agent within an AutomateNOW! instance and returns back the newly created [ANOWAgent] object

    .PARAMETER Id
    The intended name of the Agent. For example: 'Agent01'. This value may not contain the domain in brackets.

    .PARAMETER Description
    Optional description of the Agent (may not exceed 255 characters).

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new Agent. Do not pass [ANOWTag] objects here.

    .PARAMETER Folder
    Optional name of the folder to place the Agent into.

    .PARAMETER CodeRepository
    Optional name of the code repository to place the Agent into.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWAgent.

    .OUTPUTS
    An [ANOWAgent] object representing the newly created Agent

    .EXAMPLE
    New-AutomateNOWAgent -Id 'Agent01' -Description 'Description1' -Tags 'Tag1', 'Tag2' -Folder 'Folder1' -CodeRepository 'Coderepository01'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The name (id) of the Agent must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    #>
    [OutputType([ANOWAgent])]
    [Cmdletbinding()]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $true)]
        [string]$Id,
        [Parameter(Mandatory = $false, HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [string]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [boolean]$Agent_exists = ($null -ne (Get-AutomateNOWAgent -Id $Id))
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWAgent failed to check if the Agent [$Id] already existed due to [$Message]."
        Break
    }
    If ($Agent_exists -eq $true) {
        [string]$current_domain = $anow_session.header.domain
        Write-Warning -Message "There is already an Agent named [$Id] in [$current_domain]. Please check into this."
        Break
    }
    ## End warning ##
    [System.Collections.Specialized.OrderedDictionary]$ANOWAgent = [System.Collections.Specialized.OrderedDictionary]@{}
    $ANOWAgent.Add('id', $Id)
    If ($Description.Length -gt 0) {
        $ANOWAgent.Add('description', $Description)
    }
    If ($Tags.Count -gt 0) {
        [int32]$total_tags = $Tags.Count
        [int32]$current_tag = 1
        ForEach ($tag_id in $Tags) {
            $Error.Clear()
            Try {
                [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] running under New-AutomateNOWAgent due to [$message]"
                Break
            }
            If ($tag_object.simpleId.length -eq 0) {
                Throw "New-AutomateNOWAgent has detected that the tag [$tag_id] does not appear to exist. Please check again."
                Break
            }
            ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                [string]$tag_object_simpleId = $tag_object.simpleId
                Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                Break
            }
            [string]$tag_display = $tag_object | ConvertTo-Json -Compress
            Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
            [string]$tag_name_sequence = ('tags' + $current_tag)
            $ANOWAgent.Add($tag_name_sequence, $tag_id)
            $include_properties += $tag_name_sequence
            $current_tag++
        }
    }
    If ($Folder.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] existed under New-AutomateNOWAgent due to [$Message]"
            Break
        }
        If ($folder_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] under New-AutomateNOWAgent. Please check again."
            Break
        }
        [string]$folder_display = $folder_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding folder $folder_display to [ANOWAgent] [$Id]"
        $ANOWAgent.Add('folder', $Folder)
        $include_properties += 'folder'
    }
    If ($CodeRepository.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository] existed under New-AutomateNOWAgent due to [$Message]"
            Break
        }
        If ($code_repository_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository] under New-AutomateNOWAgent. Please check again."
            Break
        }
        [string]$code_repository_display = $code_repository_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding code repository $code_repository_display to [ANOWAgent] [$Id]"
        $ANOWAgent.Add('codeRepository', $CodeRepository)
        $include_properties += 'codeRepository'
    }
    [string]$BodyObject = ConvertTo-QueryString -InputObject $ANOWAgent -IncludeProperties id, description, tags, folder, codeRepository
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_operationType' = 'add'
    $BodyMetaData.'_oldValues' = '{}'
    $BodyMetaData.'_componentId' = 'AgentCreateWindow_form'
    $BodyMetaData.'_dataSource' = 'AgentDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$BodyMetaDataString = ConvertTo-QueryString -InputObject $BodyMetaData
    [string]$Body = ($BodyObject + '&' + $BodyMetaDataString)
    [string]$command = '/Agent/create'
    [hashtable]$parameters = @{}
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('Body', $Body)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWAgent]$Agent = $results.response.data | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to create [ANOWAgent] object due to [$Message]."
        Break
    }
    If ($Agent.id.Length -eq 0) {
        Write-Warning -Message "Somehow the newly created [ANOWAgent] Agent is empty!"
        Break
    }
    If ($Quiet -ne $true) {
        Return $Agent
    }
}

Function Remove-AutomateNOWAgent {
    <#
    .SYNOPSIS
    Removes a Agent from an AutomateNOW! instance

    .DESCRIPTION
    Removes a Agent from an AutomateNOW! instance

    .PARAMETER Agent
    An [ANOWAgent] object representing the Agent to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWAgent] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Removes a single Agent
    Get-AutomateNOWAgent -Id 'Agent01' | Remove-AutomateNOWAgent

    .EXAMPLE
    Forcefully removes three Agents by way of the pipeline
    @( 'Agent1', 'Agent2', 'Agent3') | Get-AutomateNOWAgent | Remove-AutomateNOWAgent -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWAgent]$Agent,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/agent/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWAgent]$Agent = $_
        }
        [string]$Agent_id = $Agent.id
        If ($Agent_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Agent_id)")) -eq $true) {
            [string]$oldvalues = $Agent.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $Agent.id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'AgentList'
            $BodyMetaData.'_dataSource' = 'AgentDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Agent_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Agent [$Agent_id] successfully removed"
        }
    }
    End {

    }
}

Function Copy-AutomateNOWAgent {
    <#
    .SYNOPSIS
    Copies an Agent from an AutomateNOW! instance

    .DESCRIPTION
    Copies an Agent from an AutomateNOW! instance.

    .PARAMETER Agent
    Mandatory [ANOWAgent] object to be copied.

    .PARAMETER NewId
    The name (Id) of the new Agent. The new Id must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    .PARAMETER UnsetDescription
    Optional switch that will ensure that the newly created Agent will not have a description set.

    .PARAMETER Description
    Optional description to set on the new Agent object. If you do not set this, the new Agent object will copy the Description of the source object.

    .PARAMETER UnsetFolder
    Optional switch that will ensure that the newly created Agent will not have a Folder set.

    .PARAMETER Folder
    Optional description to set a different folder on the new Agent object. If you do not set this, the new Agent object will use the same Folder of the source object.

    .PARAMETER UnsetTags
    Optional switch that will ensure that the newly created Agent will not have any Tags set.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the new Agent object. If you do not set this, the new Agent object will apply the same Tags of the source object.

    .PARAMETER Force
    Force the copy without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    ONLY the [ANOWAgent] object type is accepted. Pipeline support is intentionally unavailable.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Creates a copy of an Agent and changes the description (multi-line format)
    $Agent01 = Get-AutomateNOWAgent -Id 'Agent_01'
    Copy-AutomateNOWAgent -Agent $Agent01 -NewId 'Agent_01_production' -Description 'Agent 01 Production'

    .EXAMPLE
    Creates a copy of an Agent that omits the description (one-liner format)
    Copy-AutomateNOWAgent -Agent (Get-AutomateNOWAgent -Id 'Agent_01') -NewId 'Agent_01_production' -UnsetDescription -Tags 'Tag1', 'Tag2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWAgent]$Agent,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot set the Tags and unset them at the same time. Please choose one or the other. Tags from the source object will be carried over to the new object if you do not specify any tag-related parameters."
            Break
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$Agent_exists = ($null -ne (Get-AutomateNOWAgent -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWAgent failed to check if the Agent [$NewId] already existed due to [$Message]."
            Break
        }
        If ($Agent_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already an Agent named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End warning ##
        [string]$command = '/agent/copy'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            [string]$Agent_oldId = $Agent.id
            [string]$Agent_simpleId = $Agent.simpleId
            If ($Agent_oldId -eq $NewId) {
                Write-Warning -Message "The new id cannot be the same as the old id."
                Break
            }
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Copy the Agent $($Agent_simpleId) to $($NewId)?")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                If ($UnsetFolder -eq $True) {
                    $BodyMetaData.'folder' = $Null
                }
                ElseIf ($Folder.Length -gt 0) {
                    $BodyMetaData.'folder' = $Folder
                }
                Else {
                    If ($Agent.folder.Length -gt 0) {
                        $BodyMetaData.'folder' = $Agent.folder
                    }
                }
                If ($Tags.Count -gt 0) {
                    [int32]$tag_count = 1
                    ForEach ($tag in $Tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
                ElseIf ($UnsetTags -eq $true) {
                    $BodyMetaData.'tags' = $Null
                }
                Else {
                    If ($Agent.Tags -gt 0) {
                        [int32]$tag_count = 1
                        ForEach ($tag in $Agent.tags) {
                            $BodyMetaData.('tags' + $tag_count ) = $tag
                            $tag_count++
                        }
                    }
                }
                $BodyMetaData.'oldId' = $Agent_oldId
                $BodyMetaData.'domain' = $Agent.domain
                $BodyMetaData.'id' = $NewId
                If ($UnsetDescription -ne $true) {
                    If ($Description.Length -gt 0) {
                        $BodyMetaData.'description' = $Description
                    }
                    Else {
                        $BodyMetaData.'description' = $Agent.description
                    }
                }
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_operationId' = 'copy'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_Agent' = 'AgentAgent'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties oldId, domain, NewId, description, folder, tags
                $parameters.Body = $Body
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Agent_oldId] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                $Error.Clear()
                Try {
                    [ANOWAgent]$NewAgent = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to create copied [ANOWAgent] object [$NewId] due to [$Message]."
                    Break
                }
                If ($NewAgent.id.Length -eq 0) {
                    Write-Warning -Message "Somehow the newly created (copied) [ANOWAgent] object [$NewId] is empty!"
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $NewAgent
                }
            }
        }
    }
    End {

    }
}

Function Rename-AutomateNOWAgent {
    <#
    .SYNOPSIS
    Renames an Agent on an AutomateNOW! instance

    .DESCRIPTION
    Performs a psuedo-rename operations of an Agent from an AutomateNOW! instance by copying it first and then deleting the source. This function merely combines Copy-AutomateNOWAgent and Remove-AutomateNOWAgent therefore it is to be considered destructive.

    .PARAMETER Agent
    An [ANOWAgent] object representing the Agent to be renamed.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the Agent. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER Force
    Force the renaming without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly renamed object.

    .INPUTS
    ONLY [ANOWAgent] objects are accepted. There is intentionally no support for the pipeline.

    .OUTPUTS
    The newly renamed [ANOWAgent] object will be returned.

    .EXAMPLE
    $Agent = Get-AutomateNOWAgent -Id 'Agent01'
    Rename-AutomateNOWAgent -Agent $Agent -NewId 'Agent_02'

    .EXAMPLE
    Rename-AutomateNOWAgent -Agent (Get-AutomateNOWAgent -Id 'Agent01') -NewId 'Agent_02'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    When renaming, you may only specify a different Id (name).

    This action will be denied if any existing referrals are found on the object.
    #>
    [OutputType([ANOWAgent])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWAgent]$Agent,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin standard warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$new_Agent_exists = ($null -ne (Get-AutomateNOWAgent -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWAgent failed to check if the Agent [$NewId] already existed due to [$Message]."
            Break
        }
        If ($new_Agent_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Agent named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        [string]$Agent_id = $Agent.simpleId
        $Error.Clear()
        Try {
            [boolean]$old_Agent_exists = ($null -ne (Get-AutomateNOWAgent -Id $Agent_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWAgent failed to check if the Agent [$Agent_id] already existed due to [$Message]."
            Break
        }
        If ($old_Agent_exists -eq $false) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not a Agent named [$Agent_id] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End standard warning ##
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Agent_id)")) -eq $true) {
                $Error.Clear()
                Try {
                    [ANOWAgent]$new_Agent = Copy-AutomateNOWAgent -Agent $Agent -NewId $NewId -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Copy-AutomateNOWAgent failed to create a new Agent [$NewId] as Part 1 of the renaming process due to [$Message]."
                    Break
                }
                If ($new_Agent.simpleId -eq $NewId) {
                    Write-Verbose -Message "Part 1: Agent [$Agent_id] successfully copied to [$NewId]"
                }
                Else {
                    Write-Warning -Message "Somehow the first phase (Copy-AutomateNOWAgent) failed. Please look into this."
                    Break
                }
                $Error.Clear()
                Try {
                    Remove-AutomateNOWAgent -Agent $Agent -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Remove-AutomateNOWAgent failed to remove [$Agent_id] as Part 2 of the renaming process due to [$Message]."
                    Break
                }
                Write-Verbose -Message "Part 2: Agent [$Agent_id] removed"
                Write-Verbose -Message "Task [$Agent_id] successfully renamed to [$NewId]"
                If ($Quiet -ne $true) {
                    Return $new_Agent
                }
            }
        }
        Else {
            Write-Warning -Message "No action was taken because either the source object didn't exist or the new object already existed"
        }
    }
    End {
    }
}

#endregion

#Region - Agent Server Nodes

Function Read-AutomateNOWAgentServerNode {
    <#
    .SYNOPSIS
    Reads the Agent Server Node objects from a Server Node within an AutomateNOW! instance

    .DESCRIPTION
    Reads the Agent Server Node objects from a Server Node within an AutomateNOW! instance

    .PARAMETER Agent
    Mandatory [ANOWAgent] object. Use Get-AutomateNOWAgent to get this object.

    .PARAMETER ServerNode
    Optional [ANOWServerNode] object to filter by. Use Get-AutomateNOWServerNode to retrieve 1. You still need to present an [ANOWAgent] object, too.

    .PARAMETER Id
    36-character GUID of the Agent Server Node object to read. This is normally intended for verifying that the Agent Server Node object exists before deleting it. This parameter can only be used exclusively from the others.

    .PARAMETER startRow
    Integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER sortBy
    Optional string parameter to sort the results by (may not be used with the Id parameter). Valid choices are: 'serverNodeType'*, 'dateCreated', 'lastUpdated', 'id'

    .PARAMETER Ascending
    Optional switch parameter which changes the sort order to ascending

    .INPUTS
    You can send either [ANOWServerAgent] objects or 36-character GUID Id's from [ANOWAgentServerNode] objects (individually or to the pipeline).

    .OUTPUTS
    An array of one or more [ANOWAgentServerNode] class objects that are linked to the provided [ANOWServerNode] object

    .EXAMPLE
    Reads the Agent Server Node objects from an Agent named 'Agent1' and returns the results descendingly sorted by dateCreated (one-liner format)

    Get-AutomateNOWAgent -Id 'Agent1' | Read-AutomateNOWAgentServerNode -sortBy dateCreated -Descending

    .EXAMPLE
    Reads an Agent Server Node object by specific Id using the -Id parameter

    Read-AutomateNOWAgentServerNode -Id 'bdd0ec83-b2bb-484c-968f-dfce73600729'

    .EXAMPLE
    Reads an Agent Server Node object by specific Id across the pipeline

    'bdd0ec83-b2bb-484c-968f-dfce73600729' | Read-AutomateNOWAgentServerNode

    .EXAMPLE
    Reads the Agent Server Node object associated with a Server Node named 'ServerNode1' that is attached to an agent named 'Agent1'

    Read-AutomateNOWAgentServerNode -Agent (Get-AutomateNOWAgent -Id 'Agent1') -ServerNode (Get-AutomateNOWServerNode -Id 'ServerNode1')

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWAgentServerNode[]])]
    [Cmdletbinding(DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $True, ParameterSetName = 'Default', ValueFromPipeline = $True)]
        [Parameter(Mandatory = $True, ParameterSetName = 'ServerNode', ValueFromPipeline = $True)]
        [ANOWAgent]$Agent,
        [Parameter(Mandatory = $True, ParameterSetName = 'ServerNode')]
        [ANOWServerNode]$ServerNode,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100,
        [ValidateScript({ $_ -match '^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$' })]
        [Parameter(Mandatory = $True, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [string]$Id,
        [ValidateSet('serverNodeType', 'dateCreated', 'lastUpdated', 'id', ignoreCase = $false)]
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$sortBy = 'serverNodeType',
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$Descending
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.agentStatus.Length -gt 0 -or $Agent.id.Length -gt 0) {
            If ($_.agentStatus.Length -gt 0) {
                [ANOWAgent]$Agent = $_
            }
            [string]$Agent_id = $Agent.id
        }
        If ($_ -match '^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$') {
            [string]$Id = $_
        }
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        $Body.Add('_operationType', 'fetch')
        If ($Id.Length -gt 0) {
            $Body.Add('id', $Id)
        }
        ElseIf ( $Agent_id.Length -gt 0) {
            $Body.Add('agent', $Agent_id)
            If ($ServerNode.id.Length -gt 0) {
                [string]$ServerNode_simpleid = $ServerNode.simpleId
                $Body.Add('operator', 'and')
                $Body.Add('_constructor', 'AdvancedCriteria')
                $Body.'criteria1' = ('{"fieldName":"serverNode","operator":"equals","value":"' + $ServerNode_simpleid + '"}')
            }
            Else {
                $Body.Add('_startRow', $startRow)
                $Body.Add('_endRow', $endRow)
                If ($Descending -eq $true) {
                    $Body.'_sortBy' = '-' + $sortBy
                }
                Else {
                    $Body.'_sortBy' = $sortBy
                }
            }
        }
        Else {
            Write-Warning -Message "Somehow was not able to parse the parameters for Read-AutomateNOWAgentServerNode"
            Break
        }
        $Body.Add('_textMatchStyle', 'exact')
        [string]$command = '/agentServerNode/read?'
        $Body.Add('_dataSource', 'AgentServerNodeDataSource')
        $Body.Add('isc_metaDataPrefix', '_')
        $Body.Add('isc_dataFormat', 'json')
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ($command + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        [int32]$ResultsCount = $results.response.data.count
        If ($ResultsCount -gt 50000) {
            Write-Warning -Message "This ServerNode object has over 50,000 endpoints added! This module does not support that yet."
            Break
        }
        If ($ResultsCount -gt 0) {
            If ($ResultsCount -gt 1 -and $Id.Length -gt 0) {
                Write-Warning -Message "Wait! There cannot be more then 1 result if the -Id parameter was specified. Something is wrong. Please look into this."
                Break
            }
            $Error.Clear()
            Try {
                [ANOWAgentServerNode[]]$AgentServerNodes = ForEach ($result in $results.response.data) {
                    $result
                }
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the response into a series of [ANOWAgentServerNode] objects due to [$Message]."
                Break
            }
            If ($AgentServerNodes.Count -gt 0) {
                Return $AgentServerNodes
            }
            Else {
                Write-Verbose -Message "There are no Agent Server Node objects added to Agent $Agent_id"
            }
        }
    }
    End {

    }
}

Function Export-AutomateNOWAgentServerNode {
    <#
    .SYNOPSIS
    Exports the Agent Server Node objects from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Agent Server Node objects from an instance of AutomateNOW! to a local .csv file

    .PARAMETER Agent
    Mandatory [ANOWAgentServerNode] object (Use Read-AutomateNOWAgentServerNode to retrieve them)

    .INPUTS
    ONLY [ANOWAgentServerNode] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWAgentServerNode] objects are exported to the local disk in CSV format

    .EXAMPLE
    Exports the first page of Agent Server Node objects that are associated with an Agent named 'Agent1'

    Get-AutomateNOWAgent -Id 'Agent1' | Read-AutomateNOWAgentServerNode | Export-AutomateNOWAgentServerNode

    .EXAMPLE
    Exports a specific Agent Server Node object by its Id

    'bdd0ec83-b2bb-484c-968f-dfce73600729' | Read-AutomateNOWAgentServerNode | Export-AutomateNOWAgentServerNode

    .NOTES
	You must present [ANOWAgentServerNode] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWAgentServerNode]$AgentServerNode
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-AgentServerNodes-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWAgentServerNode]$AgentServerNode = $_
        }
        $Error.Clear()
        Try {
            $AgentServerNode | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWAgentServerNode] objects on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function Dismount-AutomateNOWAgentServerNode {
    <#
    .SYNOPSIS
    Dismounts (detaches) a Node from an Agent on an AutomateNOW! instance

    .DESCRIPTION
    Dismounts (detaches) a Node from an Agent on an AutomateNOW! instance

    .PARAMETER Agent
    An [ANOWAgent] object representing the Agent from which the Node will be dismounted (detached).

    .PARAMETER ServerNode
    An [ANOWServerNode] object representing the Node to be detached from an Agent.

    .PARAMETER Quiet
    Switch parameter to silence the returned [ANOWServerNode] object

    .PARAMETER Force
    Force the dismounting without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    One [ANOWAgent] object must be presented along with at least one [ANOWServerNode] object. Nodes can be sent along the pipeline.

    .OUTPUTS
    Informational message that the Node was detached from the Agent.

    .EXAMPLE

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWAgent]$Agent,
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWServerNode]$ServerNode,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = ('/serverNode/deleteAgentNode')
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWServerNode]$ServerNode = $_
        }
        [string]$ServerNode_id = $ServerNode.id
        [string]$Agent_Id = $Agent.Id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ServerNode_id) from $Agent_Id")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('agent', $Agent_Id )
            $BodyMetaData.Add('id', $ServerNode_id )
            $BodyMetaData.Add('_operationType', 'remove')
            $BodyMetaData.Add('_operationId', 'deleteAgentNode')
            $BodyMetaData.Add('_componentId', 'AgentServerNodeList')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ServerNodeDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ServerNode_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            If ($Quiet -ne $true) {
                Write-Information -MessageData "Node $ServerNode_id was dismounted (detached) from $Agent_Id"
            }
        }
    }
    End {

    }
}

Function Mount-AutomateNOWAgentServerNode {
    <#
    .SYNOPSIS
    Mounts (attaches) a Node from an Agent on an AutomateNOW! instance

    .DESCRIPTION
    Mounts (attaches) a Node from an Agent on an AutomateNOW! instance

    .PARAMETER Agent
    An [ANOWAgent] object representing the Agent to which the Node will be mounted (attached).

    .PARAMETER ServerNode
    An [ANOWServerNode] object representing the Node to be attached to an Agent.

    .PARAMETER Quiet
    Switch parameter to silence the returned [ANOWAgentServerNode] object

    .PARAMETER Force
    Force the mounting without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    One [ANOWAgent] object must be presented along with at least one [ANOWServerNode] object. Nodes can be sent along the pipeline.

    .OUTPUTS
    An [ANOWAgentServerNode] object showing the successful attachment will be returned.

    .EXAMPLE
    Mounts (attached) a Server Node named 'ServerNode1' to an Agent named 'Agent1' (one-liner format)

    Mount-AutomateNOWAgentServerNode -Agent (Get-AutomateNOWAgent -Id 'Agent1') -ServerNode (Get-AutomateNOWServerNode -Id 'ServerNode1')

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWAgentServerNode])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWAgent]$Agent,
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWServerNode]$ServerNode,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = ('/agentServerNode/create')
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWServerNode]$ServerNode = $_
        }
        [string]$ServerNode_id = $ServerNode.id
        [string]$Agent_Id = $Agent.Id
        [string]$ServerNode_Type = $ServerNode.serverNodeType
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ServerNode_id) onto $Agent_Id")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('agent', $Agent_Id )
            $BodyMetaData.Add('serverNode', $ServerNode_id )
            $BodyMetaData.Add('serverNodeType', $ServerNode_Type )
            $BodyMetaData.Add('_operationType', 'add')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'AgentServerNodeDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ServerNode_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            If ($Quiet -ne $true) {
                Write-Information -MessageData "Node $ServerNode_id ($ServerNode_Type) was mounted (attached) to $Agent_Id"
                $Error.Clear()
                Try {
                    [ANOWAgentServerNode]$AgentServerNode = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to parse the result into an [ANOWAgentServerNode] object due to [$Message]."
                    Break
                }
                Return $AgentServerNode
            }
        }
    }
    End {

    }
}

#endregion

#Region - Anomalies

Function Get-AutomateNOWAnomaly {
    <#
    .SYNOPSIS
    Gets the Anomaly objects from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Anomaly objects from an AutomateNOW! instance

    .PARAMETER Id
    The Id of the Anomaly. Use this when you only want to retrieve a single Anomaly. This parameter cannot be combined with -startRow/-endRow.

    .PARAMETER startRow
    Integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER Folder
    Optional string to filter by a particular Folder

    .PARAMETER Tags
    Optional string array of Tags to filter by. Note that the 'containsAny' operator will be used.

    .INPUTS
    Accepts a string representing the simple id of the Anomaly object from the pipeline or individually (but not an array) or you can specify by start and end rows.

    .OUTPUTS
    An array of one or more [ANOWSecRole] class objects

    .EXAMPLE
    Gets the first page of Anomalies
    Get-AutomateNOWAnomaly

    .EXAMPLE
    Gets the first 500 Anomaly objects
    Get-AutomateNOWAnomaly -Id 'Anomaly1' -startRow 0 -endRow 500

    .EXAMPLE
    Gets a specific Anomaly named 'Anomaly1'
    Get-AutomateNOWAnomaly -Id 'Anomaly1'

    .EXAMPLE
    Gets a series of Anomalies using the pipeline
    'Anomaly1', 'Anomaly2' | Get-AutomateNOWAnomaly

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWSecRole[]])]
    [Cmdletbinding( DefaultParameterSetName = 'Default' )]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $True, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False)]
        [string]$Folder,
        [Parameter(Mandatory = $False)]
        [string[]]$Tags
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 -or $Id.Length -gt 0) {
            If ($_.Length -gt 0 ) {
                $Body.'id' = $_
            }
            Else {
                $Body.'id' = $Id
            }
            [string]$textMatchStyle = 'exactCase'
            $Body.'_operationId' = 'read'
        }
        Else {
            $Body.Add('operator', 'and')
            $Body.Add('_constructor', 'AdvancedCriteria')
            If ($Folder.Length -gt 0) {
                $Body.'criteria1' = ('{"fieldName":"folder","operator":"equals","value":"' + $Folder + '"}')
            }
            If ($Tags.Count -gt 0) {
                If ($Tags.Count -gt 1) {
                    $Error.Clear()
                    Try {
                        [string]$TagString = $Tags | ConvertTo-Json -Compress
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "ConvertTo-Json failed to convert the provided tag names under Get-AutomateNOWAnomaly due to [$Message]."
                        Break
                    }
                }
                Else {
                    [string]$TagString = $Tags
                }
                $Body.'criteria2' = ('{"fieldName":"tags","operator":"containsAny","value":' + $TagString + '}')
            }
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
            [string]$textMatchStyle = 'exact'
            $Body.'_componentId' = 'AnomalyList'
        }
        $Body.'_textMatchStyle' = $textMatchStyle
        $Body.'_dataSource' = 'AnomalyDataSource'
        $Body.'_operationType' = 'fetch'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/anomaly/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] while running Get-AutomateNOWAnomaly due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWAnomaly[]]$Anomalies = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWAnomaly] objects due to [$Message]."
            Break
        }
        If ($Anomalies.Count -gt 0) {
            Return $Anomalies
        }
    }
    End {

    }
}

Function Set-AutomateNOWAnomaly {
    <#
    .SYNOPSIS
    Changes the settings of an Anomaly on an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of an Anomaly on an AutomateNOW! instance

    .PARAMETER Anomaly
    An [ANOWAnomaly] object representing the Anomaly to be changed.

    .PARAMETER Description
    A text description of at least 1 character.

    .PARAMETER UnsetDescription
    Switch parameter that will remove the description.

    .PARAMETER CodeRepository
    Optional Code Repository to place the Anomaly into. Use Get-AutomateNOWCodeRepository to fetch this object.

    .PARAMETER UnsetCodeRepository
    Switch parameter that will remove the the Anomaly from its Code Repository.

    .PARAMETER iconSet
    The name of the icon library (if you choose to use one). Possible choices are: FAT_COW, FUGUE (note that FONT_AWESOME is not an actual icon library)

    .PARAMETER iconCode
    The name of the icon which matches the chosen library (must be lowercase). To see the list of available iconCodes, use Import-AutomateNOWIcon (or Import-AutomateNOWLocalIcon) then try $anow_assets.icon_library."FUGUE"[0..10] to see the names of the first 10 icons from the Fugue library.

    .PARAMETER RemoveIcon
    Switch parameter that will remove the icon configured for this Anomaly.

    .PARAMETER Folder
    (This parameter does not presently work!) String that specifies the name of the folder to place the Anomaly into.

    .PARAMETER UnsetFolder
    (This parameter does not presently work!) Switch parameter that will remove the Anomaly from its current folder.

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new Anomaly.

    .PARAMETER UnsetTags
    Switch parameter that will remove the tags from the Anomaly.

    .PARAMETER minMagnitude
    Optional int64 to specify the minimum Magnitude. This value (in PowerShell can be as low as -9223372036854775808). Oddly, the ANOW UI allows a minimum value as low as -999999999991000000000.

    .PARAMETER UnsetMinMagnitude
    Switch parameter that will remove the minMagnitude value from the Anomaly

    .PARAMETER maxMagnitude
    Optional int64 to specify the maximum Magnitude. This value (in PowerShell can be as high as 9223372036854775807). Oddly, the ANOW UI allows a minimum value as low as 999999999991000000000.

    .PARAMETER UnsetMaxMagnitude
    Switch parameter that will remove the maxMagnitude value from the Anomaly

    .PARAMETER Quiet
    Switch parameter that silences the output of the updated object.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWAnomaly] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWAnomaly] object will be returned

    .EXAMPLE
    Sets the description on an Anomaly
    Set-AutomateNOWAnomaly -Anomaly $Anomaly -Description 'My Description' -Force

    .EXAMPLE
    Unsets the description on an Anomaly
    Set-AutomateNOWAnomaly -Anomaly $Anomaly -UnsetDescription -Force

    .EXAMPLE
    Sets the icon on an Anomaly
    Import-AutomateNOWLocalIcon
    Set-AutomateNOWAnomaly -Anomaly $Anomaly -iconSet FUGUE -iconCode address-book -Force

    .EXAMPLE
    Unsets the icon on an Anomaly
    Set-AutomateNOWAnomaly -Anomaly $Anomaly -RemoveIcon -Force

    .EXAMPLE
    Places an Anomaly into a Folder
    Set-AutomateNOWAnomaly -Anomaly $Anomaly -Folder 'MyFolder'

    .EXAMPLE
    Removes an Anomaly from its current Folder
    Set-AutomateNOWAnomaly -Anomaly $Anomaly -UnsetFolder -Force

    .EXAMPLE
    Adds tags to an Anomaly
    Set-AutomateNOWAnomaly -Anomaly $Anomaly -Tags 'Tag1', 'Tag2'

    .EXAMPLE
    Forcibly removes (unsets) the tags from an Anomaly
    Set-AutomateNOWAnomaly -Anomaly $Anomaly -UnsetTags -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The -iconSet and -iconCode parameter set requires that you import the local icon names with Import-AutomateNOWIcon or Import-AutomateNOWLocalIcon. This is only to check that the name of the icon being sent to the API is valid.

    If you have three tags on an Anomaly and wanted to remove one then use the -SetTags parameter to apply the 2 that you want to keep. If you want to remove all tags then use -UnsetTags.

    #>
    [OutputType([ANOWAnomaly])]
    [Cmdletbinding(SupportsShouldProcess, DefaultParameterSetName = 'Default', ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'Default', ValueFromPipeline = $true)]
        [Parameter(Mandatory = $true, ParameterSetName = 'Icon', ValueFromPipeline = $true)]
        [ANOWAnomaly]$Anomaly,
        [ValidateScript({ $_.Length -le 255 })]
        [Parameter(Mandatory = $false, ParameterSetName = 'Default', HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [Parameter(Mandatory = $false, ParameterSetName = 'Icon', HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [string]$Description,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Icon')]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetCodeRepository,
        [Parameter(Mandatory = $True, ParameterSetName = 'Icon')]
        [ANOWIcon_IconsOnly]$iconSet,
        [ValidateScript({ $_ -match '^[a-z0-9-_]{1,}$' })]
        [Parameter(Mandatory = $True, ParameterSetName = 'Icon')]
        [string]$iconCode,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$RemoveIcon,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Icon')]
        [string]$Folder,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Icon')]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Icon')]
        [string[]]$Tags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Icon')]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Icon')]
        [Nullable[int64]]$minMagnitude,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Icon')]
        [switch]$UnsetMinMagnitude,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Icon')]
        [Nullable[int64]]$maxMagnitude,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Icon')]
        [switch]$UnsetMaxMagnitude,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Icon')]
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Icon')]
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($iconSet.length -gt 0 ) {
            If ($anow_assets.icon_library.length -eq 0) {
                Write-Warning -Message "Please import the ANOW icons into your session with Import-AutomateNOWIcon or Import-AutomateNOWLocalIcon"
                Break
            }
            If ($iconCode -notin ($anow_assets.icon_library."$iconSet")) {
                Write-Warning -Message "The icon [$iconCode] does not appear to exist within the [$iconSet] icon set. Please check again."
                Break
            }
        }
        If (($RemoveIcon -eq $true) -and ($iconCode.Length -gt 0 -or $iconSet.Length -gt 0)) {
            Write-Warning -Message "You cannot unset the Icon and set it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot unset the Description and set it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot unset the Folder and set it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot unset the Tags and set them at the same time. Please choose one or the other."
            Break
        }
        If ($minMagnitude -gt $maxMagnitude) {
            Write-Warning -Message "The minMagnitude ($minMagnitude) cannot be greater than the maxMagnitude ($maxMagnitude)"
            Break
        }
        ElseIf ($maxMagnitude -lt $minMagnitude) {
            Write-Warning -Message "The maxMagnitude ($maxMagnitude) cannot be less than the minMagnitude ($minMagnitude)"
            Break
        }
        If (($UnsetMinMagnitude -eq $true) -and ($null -ne $minMagnitude)) {
            Write-Warning -Message "You cannot unset the minimum magnitude and set it at the same time. Please choose one or the other."
            Break
        }
        If (($UnsetMaxMagnitude -eq $true) -and ($null -ne $maxMagnitude)) {
            Write-Warning -Message "You cannot unset the maximum magnitude and set it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetCodeRepository -eq $true -and $CodeRepository.Id.Length -gt 0) {
            Write-Warning -Message "You cannot unset the Code Repository and set it at the same time. Please choose one or the other."
            Break
        }
        [string]$command = '/anomaly/update'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWAnomaly]$Anomaly = $_
        }
        [string]$Anomaly_id = $Anomaly.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$Anomaly_id")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$Anomaly_exists = ($null -eq (Get-AutomateNOWAnomaly -Id $Anomaly_id))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWAnomaly failed to check if the Anomaly [$Anomaly_id] already existed due to [$Message]."
                Break
            }
            If ($Anomaly_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not an Anomaly named [$Anomaly_id] in the current domain [$current_domain]. Please check into this."
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $Anomaly_id
            If ($Description.Length -gt 0) {
                $BodyMetaData.'description' = $Description
            }
            ElseIf ($UnsetDescription -eq $true) {
                $BodyMetaData.'description' = $null
            }
            If ($iconCode.Length -gt 0) {
                $BodyMetaData.'iconCode' = $iconCode
                $BodyMetaData.'iconSet' = $iconSet
            }
            ElseIf ($RemoveIcon -eq $true) {
                $BodyMetaData.'iconSet' = $null
            }
            If ($Tags.Count -gt 0) {
                [int32]$total_tags = $Tags.Count
                [int32]$current_tag = 1
                ForEach ($tag_id in $Tags) {
                    $Error.Clear()
                    Try {
                        [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] under Set-AutomateNOWAnomaly due to [$message]"
                        Break
                    }
                    If ($tag_object.simpleId.length -eq 0) {
                        Throw "Set-AutomateNOWAnomaly has detected that the tag [$tag_id] does not appear to exist. Please check again."
                        Break
                    }
                    ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                        [string]$tag_object_simpleId = $tag_object.simpleId
                        Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                        Break
                    }
                    [string]$tag_display = $tag_object | ConvertTo-Json -Compress
                    Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
                    [string]$tag_name_sequence = ('tags' + $current_tag)
                    $BodyMetaData.$tag_name_sequence = $tag_id
                    $current_tag++
                }
            }
            ElseIf ($UnsetTags -eq $true) {
                $BodyMetaData.'tags' = $null
            }
            If ($Folder.Length -gt 0) {
                $Error.Clear()
                Try {
                    [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] actually existed under Set-AutomateNOWAnomaly due to [$Message]"
                    Break
                }
                If ($folder_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] under Set-AutomateNOWAnomaly. Please check again."
                    Break
                }
                [string]$folder_display = $folder_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Adding folder $folder_display to [ANOWAnomaly] $Anomaly_id"
                $BodyMetaData.'folder' = $Folder
            }
            ElseIf ($UnsetFolder -eq $true) {
                $BodyMetaData.'folder' = $null
            }
            If ($CodeRepository.Id.Length -gt 0) {
                [string]$CodeRepository_Id = $CodeRepository.Id
                $Error.Clear()
                Try {
                    [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository_Id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository_Id] actually existed under Set-AutomateNOWAnomaly due to [$Message]"
                    Break
                }
                If ($code_repository_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository_Id] under Set-AutomateNOWAnomaly. Please check again."
                    Break
                }
                $BodyMetaData.'codeRepository' = $CodeRepository_Id
            }
            ElseIf ($UnsetCodeRepository -eq $true) {
                $BodyMetaData.'codeRepository' = $null
            }
            If ($null -ne $maxMagnitude) {
                $BodyMetaData.'maxMagnitude' = $maxMagnitude
            }
            ElseIf ($UnsetMaxMagnitude -eq $true) {
                $BodyMetaData.'maxMagnitude' = $null
            }
            If ($null -ne $minMagnitude) {
                $BodyMetaData.'minMagnitude' = $minMagnitude
            }
            ElseIf ($UnsetMinMagnitude -eq $true) {
                $BodyMetaData.'minMagnitude' = $null
            }
            $BodyMetaData.'_operationType' = 'update'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_componentId' = 'AnomalyEditForm'
            $BodyMetaData.'_dataSource' = 'AnomalyDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on $Anomaly_id due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Anomaly $Anomaly_id was successfully updated"
            $Error.Clear()
            Try {
                [ANOWAnomaly]$UpdatedAnomaly = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the returned updated object to an [ANOWAnomaly] object due to [$Message]. The object was still updated though."
                Break
            }
            If ($Quiet -ne $true) {
                Return $UpdatedAnomaly
            }
        }
    }
    End {
    }
}

Function New-AutomateNOWAnomaly {
    <#
    .SYNOPSIS
    Creates an Anomaly within an AutomateNOW! instance

    .DESCRIPTION
    Creates an Anomaly within an AutomateNOW! instance and returns back the newly created [ANOWAnomaly] object

    .PARAMETER Id
    The intended name of the Anomaly. For example: 'Anomaly1'. This value may not contain the domain in brackets.

    .PARAMETER Description
    Optional description of the Anomaly (may not exceed 255 characters).

    .PARAMETER maxMagnitude
    Optional int64 to specify the maximum Magnitude. This value (in PowerShell can be as high as 9223372036854775807). Oddly, the ANOW UI allows a minimum value as low as 999999999991000000000.

    .PARAMETER minMagnitude
    Optional int64 to specify the minimum Magnitude. This value (in PowerShell can be as low as -9223372036854775808). Oddly, the ANOW UI allows a minimum value as low as -999999999991000000000.

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new Anomaly.

    .PARAMETER Folder
    Optional name of the folder to place the Anomaly into.

    .PARAMETER iconSet
    Mandatory string representing a choice between three icon sets. Valid choices are: FAT_COW, FUGUE, FONT_AWESOME

    .PARAMETER iconCode
    The name of the icon which matches the chosen library. Must be lower-case.

    .PARAMETER CodeRepository
    Optional name of the code repository to place the Anomaly into.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWAnomaly.

    .OUTPUTS
    An [ANOWAnomaly] object representing the newly created Anomaly

    .EXAMPLE
    New-AutomateNOWAnomaly -Id 'Anomaly1' -Description 'Anomaly1 description' -Tags 'Tag1', 'Tag2' -Folder 'Folder1' -iconSet 'FAT_COW' -iconCode 'paper_airplane' -codeRepository 'Repository1'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The name (id) of the Anomaly must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    The names of the icon is not enforced here! If you want to know the names of the available icons try running Import-AutomateNOWLocalIcon then review the $anow_assets.icon_library global variable.

    #>
    [OutputType([ANOWAnomaly])]
    [Cmdletbinding(DefaultParameterSetName = 'Default')]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $true, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $true, ParameterSetName = 'iconSet')]
        [string]$Id,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'iconSet', HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'iconSet')]
        [int64]$minMagnitude,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'iconSet')]
        [int64]$maxMagnitude,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'iconSet')]
        [string[]]$Tags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'iconSet')]
        [string]$Folder,
        [Parameter(Mandatory = $true, ParameterSetName = 'iconSet')]
        [ANOWIcon_IconsOnly]$iconSet,
        [ValidateScript({ $_ -match '^[a-z0-9-_]{1,}$' })]
        [Parameter(Mandatory = $true, ParameterSetName = 'iconSet')]
        [string]$iconCode,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'iconSet')]
        [string]$CodeRepository,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'iconSet')]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    If ($minMagnitude -gt $maxMagnitude) {
        Write-Warning -Message "The minMagnitude ($minMagnitude) cannot be greater than the maxMagnitude ($maxMagnitude)"
        Break
    }
    ElseIf ($maxMagnitude -lt $minMagnitude) {
        Write-Warning -Message "The maxMagnitude ($maxMagnitude) cannot be less than the minMagnitude ($minMagnitude)"
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [boolean]$Anomaly_exists = ($null -ne (Get-AutomateNOWAnomaly -Id $Id))
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWAnomaly failed to check if the Anomaly [$Id] already existed due to [$Message]."
        Break
    }
    If ($Anomaly_exists -eq $true) {
        [string]$current_domain = $anow_session.header.domain
        Write-Warning -Message "There is already an Anomaly named [$Id] in [$current_domain]. Please check into this."
        Break
    }
    ## End warning ##
    [System.Collections.Specialized.OrderedDictionary]$ANOWAnomaly = [System.Collections.Specialized.OrderedDictionary]@{}
    $ANOWAnomaly.Add('id', $Id)
    If ($Description.Length -gt 0) {
        $ANOWAnomaly.Add('description', $Description)
    }
    If ($Tags.Count -gt 0) {
        [int32]$total_tags = $Tags.Count
        [int32]$current_tag = 1
        ForEach ($tag_id in $Tags) {
            $Error.Clear()
            Try {
                [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] under New-AutomateNOWAnomaly due to [$message]"
                Break
            }
            If ($tag_object.simpleId.length -eq 0) {
                Throw "New-AutomateNOWAnomaly has detected that the tag [$tag_id] does not appear to exist. Please check again."
                Break
            }
            ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                [string]$tag_object_simpleId = $tag_object.simpleId
                Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                Break
            }
            [string]$tag_display = $tag_object | ConvertTo-Json -Compress
            Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
            [string]$tag_name_sequence = ('tags' + $current_tag)
            $ANOWAnomaly.Add($tag_name_sequence, $tag_id)
            $include_properties += $tag_name_sequence
            $current_tag++
        }
    }
    If ($Folder.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] actually existed under New-AutomateNOWAnomaly due to [$Message]"
            Break
        }
        If ($folder_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] under New-AutomateNOWAnomaly. Please check again."
            Break
        }
        [string]$folder_display = $folder_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding folder $folder_display to [ANOWAnomaly] [$Id]"
        $ANOWAnomaly.Add('folder', $Folder)
        $include_properties += 'folder'
    }
    If ($CodeRepository.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository] actually existed under New-AutomateNOWAnomaly due to [$Message]"
            Break
        }
        If ($code_repository_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository] under New-AutomateNOWAnomaly. Please check again."
            Break
        }
        [string]$code_repository_display = $code_repository_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding code repository $code_repository_display to [ANOWAnomaly] [$Id]"
        $ANOWAnomaly.Add('codeRepository', $CodeRepository)
        $include_properties += 'codeRepository'
    }
    If ($iconSet.Length -gt 0) {
        $ANOWAnomaly.'iconSet' = $iconSet
    }
    If ($iconCode.Length -gt 0) {
        $ANOWAnomaly.'iconCode' = $iconCode
    }
    If ($null -ne $maxMagnitude) {
        $ANOWAnomaly.'maxMagnitude' = $maxMagnitude
    }
    If ($null -ne $minMagnitude) {
        $ANOWAnomaly.'minMagnitude' = $minMagnitude
    }
    [string]$BodyObject = ConvertTo-QueryString -InputObject $ANOWAnomaly -IncludeProperties id, description, tags, folder, codeRepository, iconSet, iconCode
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    $BodyMetaData.'_operationType' = 'add'
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_oldValues' = '{}'
    $BodyMetaData.'_componentId' = 'AnomalyCreateWindow_form'
    $BodyMetaData.'_dataSource' = 'AnomalyDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$BodyMetaDataString = ConvertTo-QueryString -InputObject $BodyMetaData
    [string]$Body = ($BodyObject + '&' + $BodyMetaDataString)
    [string]$command = '/anomaly/create'
    [hashtable]$parameters = @{}
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('Body', $Body)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWAnomaly]$Anomaly = $results.response.data | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to create a new [ANOWAnomaly] object due to [$Message]."
        Break
    }
    If ($Anomaly.id.Length -eq 0) {
        Write-Warning -Message "Somehow the newly created [ANOWAnomaly] object is empty!"
        Break
    }
    If ($Quiet -ne $true) {
        Return $Anomaly
    }
}

Function Export-AutomateNOWAnomaly {
    <#
    .SYNOPSIS
    Exports the Anomalies from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Anomalies from an instance of AutomateNOW! to a local .csv file

    .PARAMETER Anomaly
    Mandatory [ANOWAnomaly] object (Use Get-AutomateNOWAnomaly to retrieve them)

    .INPUTS
    ONLY [ANOWAnomaly] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWAnomaly] objects are exported to the local disk in CSV format

    .EXAMPLE
    Get-AutomateNOWAnomaly | Export-AutomateNOWAnomaly

    .EXAMPLE
    Get-AutomateNOWAnomaly -Id 'Anomaly1' | Export-AutomateNOWAnomaly

    .EXAMPLE
    'Anomaly1', 'Anomaly2' | Get-AutomateNOWAnomaly | Export-AutomateNOWAnomaly

    .NOTES
	You must present [ANOWAnomaly] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWAnomaly]$Anomaly
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-Anomalies-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWAnomaly]$Anomaly = $_
        }
        $Error.Clear()
        Try {
            $Anomaly | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWAnomaly] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function Remove-AutomateNOWAnomaly {
    <#
    .SYNOPSIS
    Removes an Anomaly from an AutomateNOW! instance

    .DESCRIPTION
    Removes an Anomaly from an AutomateNOW! instance

    .PARAMETER Anomaly
    An [ANOWAnomaly] object representing the Anomaly to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWAnomaly] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Get-AutomateNOWAnomaly -Id 'Anomaly1' | Remove-AutomateNOWAnomaly

    .EXAMPLE
    'Anomaly1', 'Anomaly2', 'Anomaly3' | Remove-AutomateNOWAnomaly

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWAnomaly]$Anomaly,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/anomaly/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWAnomaly]$Anomaly = $_
        }
        [string]$Anomaly_id = $Anomaly.id
        If ($Anomaly_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Anomaly_id)")) -eq $true) {
            [string]$oldvalues = $Anomaly.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $Anomaly_id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'AnomalyList'
            $BodyMetaData.'_dataSource' = 'AnomalyDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Anomaly_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Anomaly $Anomaly_id successfully removed"
        }
    }
    End {

    }
}

Function Copy-AutomateNOWAnomaly {
    <#
    .SYNOPSIS
    Copies an Anomaly from an AutomateNOW! instance

    .DESCRIPTION
    Copies an Anomaly from an AutomateNOW! instance. AutomateNOW object id can never be changed, but we can copy the object to a new id and it will include all of the items therein.

    .PARAMETER Anomaly
    Mandatory [ANOWAnomaly] object to be copied.

    .PARAMETER NewId
    The name (Id) of the new Anomaly. The new Id must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    .PARAMETER UnsetDescription
    Optional switch that will ensure that the newly created Anomaly will not have a description set.

    .PARAMETER Description
    Optional description to set on the new Anomaly object. If you do not set this, the new Anomaly object will use the description of the source object.

    .PARAMETER Force
    Force the copy without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    ONLY [ANOWAnomaly] objects are accepted. Pipeline support is intentionally unavailable.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Creates a copy of an Anomaly and changes the description (multi-line format)
    $Anomaly1 = Get-AutomateNOWAnomaly -Id 'Anomaly1'
    Copy-AutomateNOWAnomaly -Anomaly $Anomaly1 -NewId 'Anomaly1_production' -Description 'Anomaly 1 Production'

    .EXAMPLE
    Creates a copy of an Anomaly that omits the description (one-liner format)
    Copy-AutomateNOWAnomaly -Anomaly (Get-AutomateNOWAnomaly -Id 'Anomaly1') -NewId 'Anomaly2_production' -UnsetDescription

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWAnomaly]$Anomaly,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$Anomaly_exists = ($null -ne (Get-AutomateNOWAnomaly -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWAnomaly failed to check if the Anomaly [$NewId] already existed due to [$Message]."
            Break
        }
        If ($Anomaly_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already an Anomaly named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End warning ##
        [string]$command = '/anomaly/copy'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            [string]$Anomaly_oldId = $Anomaly.id
            [string]$Anomaly_simpleId = $Anomaly.simpleId
            If ($Anomaly_oldId -eq $NewId) {
                Write-Warning -Message "The new id cannot be the same as the old id."
                Break
            }
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Copy the Anomaly $($Anomaly_simpleId) to $($NewId)?")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                $BodyMetaData.'oldId' = $Anomaly_oldId
                $BodyMetaData.'domain' = $Anomaly.domain
                $BodyMetaData.'id' = $NewId
                If ($UnsetDescription -ne $true) {
                    If ($Description.Length -gt 0) {
                        $BodyMetaData.'description' = $Description
                    }
                    Else {
                        $BodyMetaData.'description' = $Anomaly.description
                    }
                }
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_operationId' = 'copy'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_dataSource' = 'AnomalyDataSource'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties oldId, domain, NewId, description
                $parameters.Body = $Body
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Anomaly_id] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                $Error.Clear()
                Try {
                    [ANOWAnomaly]$Anomaly = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to create copied [ANOWAnomaly] object $NewId due to [$Message]."
                    Break
                }
                If ($Anomaly.id.Length -eq 0) {
                    Write-Warning -Message "Somehow the newly created (copied) [ANOWAnomaly] object is empty!"
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $Anomaly
                }
            }
        }
    }
    End {

    }
}

Function Rename-AutomateNOWAnomaly {
    <#
    .SYNOPSIS
    Renames an Anomaly on an AutomateNOW! instance

    .DESCRIPTION
    Performs a psuedo-rename operations of an Anomaly from an AutomateNOW! instance by copying it first and then deleting the source. This function merely combines Copy-AutomateNOWAnomaly and Remove-AutomateNOWAnomaly therefore it is to be considered destructive.

    .PARAMETER Anomaly
    An [ANOWAnomaly] object representing the Anomaly to be renamed.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the Anomaly. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER Force
    Force the renaming without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly renamed object.

    .INPUTS
    ONLY [ANOWAnomaly] objects are accepted. There is intentionally no support for the pipeline.

    .OUTPUTS
    The newly renamed [ANOWAnomaly] object will be returned.

    .EXAMPLE
    Renames an Anomaly named 'Anomaly1' to 'Anomaly2' (multi-line format)

    $Anomaly = Get-AutomateNOWAnomaly -Id 'Anomaly1'
    Rename-AutomateNOWAnomaly -Anomaly $Anomaly -NewId 'Anomaly2'

    .EXAMPLE
    Renames an Anomaly named 'Anomaly1' to 'Anomaly2' (one-liner format)

    Rename-AutomateNOWAnomaly -Anomaly (Get-AutomateNOWAnomaly -Id 'Anomaly1') -NewId 'Anomaly2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    When renaming, you may only specify a different Id (name).

    This action will be blocked if any existing referrals are found on the object.
    #>
    [OutputType([ANOWAnomaly])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWAnomaly]$Anomaly,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin standard warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$new_Anomaly_exists = ($null -ne (Get-AutomateNOWAnomaly -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWAnomaly failed to check if the Anomaly [$NewId] already existed due to [$Message]."
            Break
        }
        If ($new_Anomaly_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already an Anomaly named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        #[string]$Anomaly_id = $Anomaly.id
        [string]$Anomaly_id = $Anomaly.simpleId
        $Error.Clear()
        Try {
            [boolean]$old_Anomaly_exists = ($null -ne (Get-AutomateNOWAnomaly -Id $Anomaly_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWAnomaly failed to check if the Anomaly [$Anomaly_id] already existed due to [$Message]."
            Break
        }
        If ($old_Anomaly_exists -eq $false) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not an Anomaly named [$Anomaly_id] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End standard warning ##
        ## Begin referrals warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [int32]$referrals_count = Find-AutomateNOWObjectReferral -Anomaly $Anomaly -Count | Select-Object -Expandproperty referrals
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Find-AutomateNOWObjectReferral failed to extract the referrals on Anomaly [$Anomaly_id] due to [$Message]."
            Break
        }
        If ($referrals_count -gt 0) {
            Write-Warning -Message "Unfortunately, you cannot rename an Anomaly that has referrals. This is because the rename is not actually renaming but copying anew and deleting the old. Please, use the Find-AutomateNOWObjectReferral function to identify referrals and remove them."
            Break
        }
        Else {
            Write-Verbose -Message "The Anomaly [$Anomaly_id] does not have any referrals. It is safe to proceed."
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Anomaly_id)")) -eq $true) {
                $Error.Clear()
                Try {
                    [ANOWAnomaly]$new_Anomaly = Copy-AutomateNOWAnomaly -Anomaly $Anomaly -NewId $NewId -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Copy-AutomateNOWAnomaly failed to create a new Anomaly [$NewId] as Part 1 of the renaming process due to [$Message]."
                    Break
                }
                If ($new_Anomaly.simpleId -eq $NewId) {
                    Write-Verbose -Message "Part 1: Anomaly [$Anomaly_id] successfully copied to [$NewId]"
                }
                Else {
                    Write-Warning -Message "Somehow the first phase (Copy-AutomateNOWAnomaly) failed. Please look into this."
                    Break
                }
                $Error.Clear()
                Try {
                    Remove-AutomateNOWAnomaly -Anomaly $Anomaly -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Remove-AutomateNOWAnomaly failed to remove [$Anomaly_id] as Part 2 of the renaming process due to [$Message]."
                    Break
                }
                Write-Verbose -Message "Part 2: Anomaly [$Anomaly_id] removed"
                Write-Verbose -Message "Task [$Anomaly_id] successfully renamed to [$NewId]"
                If ($Quiet -ne $true) {
                    Return $Anomaly
                }
            }
        }
        Else {
            Write-Warning -Message "No action was taken because either the source object didn't exist or the new object already existed"
        }
    }
    End {
    }
}

#endregion

#Region - Approvals

Function Get-AutomateNOWApproval {
    <#
    .SYNOPSIS
    Gets the Approvals from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Approvals from an AutomateNOW! instance

    .PARAMETER startRow
    Integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .INPUTS
    Accepts a string representing the simple id of the Approval from the pipeline or individually (but not an array) or you can specify by start and end rows.

    .OUTPUTS
    An array of one or more [ANOWApproval] class objects

    .EXAMPLE
    Gets all of the Approval objects
    Get-AutomateNOWApproval

    .EXAMPLE
    Gets a specific Approval object
    Get-AutomateNOWApproval -Id 'my_Approval_01'

    .EXAMPLE
    Gets a series of Approvals using the pipeline
    @( 'my_Approval_01', 'my_Approval_02' ) | Get-AutomateNOWApproval

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Run this function without parameters to retrieve all of the Approvals.

    #>
    [OutputType([ANOWApproval[]])]
    [Cmdletbinding( DefaultParameterSetName = 'Default' )]
    Param(
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100,
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $False, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [string]$Id
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 -or $Id.Length -gt 0) {
            If ($_.Length -gt 0 ) {
                $Body.'id' = $_
            }
            Else {
                $Body.'id' = $Id
            }
            [string]$textMatchStyle = 'exactCase'
            $Body.'_operationId' = 'read'
        }
        Else {
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
            [string]$textMatchStyle = 'exact'
            $Body.'_componentId' = 'ApprovalConfigurationList'
        }
        $Body.'_textMatchStyle' = $textMatchStyle
        $Body.'_dataSource' = 'ApprovalConfigurationDataSource'
        $Body.'_operationType' = 'fetch'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/approvalConfiguration/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] while running Get-AutomateNOWApproval due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWApproval[]]$approvals = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWApproval] objects due to [$Message]."
            Break
        }
        If ($Approvals.Count -gt 0) {
            Return $Approvals
        }
    }
    End {

    }
}

Function Set-AutomateNOWApproval {
    <#
    .SYNOPSIS
    Changes the settings of an Approval on an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of an Approval on an AutomateNOW! instance

    .PARAMETER Approval
    An [ANOWApproval] object representing the Approval to be changed.

    .PARAMETER Description
    Optional description of the Approval (may not exceed 255 characters).

    .PARAMETER UnsetDescription
    Switch parameter to remove the Description (i.e. set it to null)

    .PARAMETER CodeRepository
    Optional Code Repository to place the Approval into. Use Get-AutomateNOWCodeRepository to fetch this object.

    .PARAMETER UnsetCodeRepository
    Switch parameter that will remove the the Approval from its Code Repository.

    .PARAMETER Quiet
    Switch parameter that silences the output of the updated object.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWApproval] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWApproval] object will be returned

    .EXAMPLE
    Changes the description of an Approval

    $approval = Get-AutomateNOWApproval -Id 'Approval1'
    Set-AutomateNOWApproval -Approval $approval -Description 'My Description'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The console does not include the "oldValues" property  when updating the description therefore it is not included here either.

    #>
    [OutputType([ANOWApproval])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWApproval]$Approval,
        [ValidateScript({ $_.Length -le 255 })]
        [Parameter(Mandatory = $false)]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetCodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message 'You cannot set the description and remove it at the same time. Please choose one or the other.'
            Break
        }
        If ($UnsetCodeRepository -eq $true -and $CodeRepository.Id.Length -gt 0) {
            Write-Warning -Message "You cannot unset the Code Repository and set it at the same time. Please choose one or the other."
            Break
        }
        [string]$command = '/approvalConfiguration/update'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWApproval]$Approval = $_
        }
        [string]$Approval_id = $Approval.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Approval_id)?")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$Approval_exists = ($null -eq (Get-AutomateNOWApproval -Id $Approval_id))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWApproval failed to check if the Approval [$Approval_id] already existed due to [$Message]."
                Break
            }
            If ($Approval_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not an Approval named [$Approval_id] in the [$current_domain] domain. Please check into this."
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $Approval_id
            If ($Description.Length -gt 0) {
                $BodyMetaData.'description' = $Description
            }
            ElseIf ($UnsetDescription -eq $true) {
                $BodyMetaData.'description' = $null
            }
            If ($CodeRepository.Id.Length -gt 0) {
                [string]$CodeRepository_Id = $CodeRepository.Id
                $Error.Clear()
                Try {
                    [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository_Id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository_Id] actually existed under Set-AutomateNOWApproval due to [$Message]"
                    Break
                }
                If ($code_repository_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository_Id] under Set-AutomateNOWApproval. Please check again."
                    Break
                }
                $BodyMetaData.'codeRepository' = $CodeRepository_Id
            }
            ElseIf ($UnsetCodeRepository -eq $true) {
                $BodyMetaData.'codeRepository' = $null
            }
            $BodyMetaData.'_operationType' = 'update'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_dataSource' = 'ApprovalConfigurationDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Approval_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Workspace $Workspace_id was successfully updated"
            $Error.Clear()
            Try {
                [ANOWApproval]$UpdatedApproval = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the returned updated object to an [ANOWApproval] object due to [$Message]. The object was still updated though."
                Break
            }
            If ($Quiet -ne $true) {
                Return $UpdatedApproval
            }
        }
    }
    End {

    }
}

Function New-AutomateNOWApproval {
    <#
    .SYNOPSIS
    Creates an Approval within an AutomateNOW! instance

    .DESCRIPTION
    Creates an Approval within an AutomateNOW! instance and returns back the newly created [ANOWApproval] object

    .PARAMETER Id
    The intended name of the Approval. For example: 'MyApproval1'. This value may not contain the domain in brackets.

    .PARAMETER Description
    Optional description of the Approval (may not exceed 255 characters).

    .PARAMETER CodeRepository
    Optional name of the code repository to place the Approval into.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWApproval.

    .OUTPUTS
    An [ANOWApproval] object representing the newly created Approval

    .EXAMPLE
    New-AutomateNOWApproval -Id 'Approval01' -Description 'the description' -CodeRepository 'Repo1'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The name (id) of the Approval must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    #>
    [OutputType([ANOWApproval])]
    [Cmdletbinding()]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $true)]
        [string]$Id,
        [Parameter(Mandatory = $false, HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [string]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [boolean]$approval_exists = ($null -ne (Get-AutomateNOWApproval -Id $Id))
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWApproval failed to check if the Approval [$Id] already existed due to [$Message]."
        Break
    }
    If ($approval_exists -eq $true) {
        [string]$current_domain = $anow_session.header.domain
        Write-Warning -Message "There is already an Approval named [$Id] in [$current_domain]. Please check into this."
        Break
    }
    ## End warning ##
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    $BodyMetaData.'id' = $Id
    If ($Description.Length -gt 0) {
        $BodyMetaData.'description' = $Description
    }
    If ($CodeRepository.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository] existed under New-AutomateNOWApproval due to [$Message]"
            Break
        }
        If ($code_repository_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository] under New-AutomateNOWApproval. Please check again."
            Break
        }
        [string]$code_repository_display = $code_repository_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding code repository $code_repository_display to [ANOWApproval] [$Id]"
        $BodyMetaData.'codeRepository' = $codeRepository
        $include_properties += 'codeRepository'
    }
    $BodyMetaData.'_operationType' = 'add'
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_oldValues' = '{}'
    $BodyMetaData.'_componentId' = 'ApprovalConfigurationCreateWindow_form'
    $BodyMetaData.'_dataSource' = 'ApprovalConfigurationDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$BodyMetaDataString = ConvertTo-QueryString -InputObject $BodyMetaData
    [string]$Body = ($BodyObject + '&' + $BodyMetaDataString)
    [string]$command = '/approvalConfiguration/create'
    [hashtable]$parameters = @{}
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('Body', $Body)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWApproval]$approval = $results.response.data | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to create [ANOWApproval] object due to [$Message]."
        Break
    }
    If ($Approval.id.Length -eq 0) {
        Write-Warning -Message "Somehow the newly created [ANOWApproval] Approval is empty!"
        Break
    }
    If ($Quiet -ne $true) {
        Return $approval
    }
}

Function Remove-AutomateNOWApproval {
    <#
    .SYNOPSIS
    Removes an Approval from an AutomateNOW! instance

    .DESCRIPTION
    Removes an Approval from an AutomateNOW! instance

    .PARAMETER Approval
    An [ANOWApproval] object representing the Approval to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWApproval] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Removes a single Approval
    Get-AutomateNOWApproval -Id 'Approval01' | Remove-AutomateNOWApproval

    .EXAMPLE
    Forcefully removes three Approvals by way of the pipeline
    @( 'Approval1', 'Approval2', 'Approval3') | Remove-AutomateNOWApproval -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWApproval]$Approval,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/approvalConfiguration/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWApproval]$Approval = $_
        }
        [string]$Approval_id = $Approval.id
        If ($Approval_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Approval_id)")) -eq $true) {
            [string]$oldvalues = $Approval.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $Approval.id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'ApprovalConfigurationList'
            $BodyMetaData.'_dataSource' = 'ApprovalConfigurationDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Approval_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Approval $Approval_id successfully removed"
        }
    }
    End {

    }
}

Function Export-AutomateNOWApproval {
    <#
    .SYNOPSIS
    Exports the Approvals from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Approvals from an instance of AutomateNOW! to a local .csv file

    .PARAMETER Approval
    Mandatory [ANOWApproval] object (Use Get-AutomateNOWApproval to retrieve them)

    .INPUTS
    ONLY [ANOWApproval] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWApproval] objects are exported to the local disk in CSV format

    .EXAMPLE
    Get-AutomateNOWApproval | Export-AutomateNOWApproval

    .EXAMPLE
    Get-AutomateNOWApproval -Id 'Approval01' | Export-AutomateNOWApproval

    .EXAMPLE
    @( 'Approval01', 'Approval02' ) | Get-AutomateNOWApproval | Export-AutomateNOWApproval

    .NOTES
	You must present [ANOWApproval] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWApproval]$Approval
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-Approvals-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWApproval]$Approval = $_
        }
        $Error.Clear()
        Try {
            $Approval | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWApproval] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function Copy-AutomateNOWApproval {
    <#
    .SYNOPSIS
    Copies an Approval from an AutomateNOW! instance

    .DESCRIPTION
    Copies an Approval from an AutomateNOW! instance. AutomateNOW object id can never be changed, but we can copy the object to a new id and it will include all of the items therein.

    .PARAMETER Approval
    Mandatory [ANOWApproval] object to be copied.

    .PARAMETER NewId
    The name (Id) of the new Approval. The new Id must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    .PARAMETER UnsetDescription
    Optional switch that will ensure that the newly created Approval will not have a description set.

    .PARAMETER Description
    Optional description to set on the new Approval object. If you do not set this, the new Approval object will use the description of the source object.

    .PARAMETER Force
    Force the copy without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    ONLY [ANOWApproval] objects are accepted. Pipeline support is intentionally unavailable.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Creates a copy of an Approval and changes the description (multi-line format)
    $Approval01 = Get-AutomateNOWApproval -Id 'approval_01'
    Copy-AutomateNOWApproval -Approval $Approval01 -NewId 'approval_01_production' -Description 'Approval 01 Production'

    .EXAMPLE
    Creates a copy of an Approval that omits the description (one-liner format)
    Copy-AutomateNOWApproval -Approval (Get-AutomateNOWApproval -Id 'approval_01') -NewId 'approval_01_production' -UnsetDescription

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWApproval]$Approval,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$approval_exists = ($null -ne (Get-AutomateNOWApproval -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWApproval failed to check if the Approval [$NewId] already existed due to [$Message]."
            Break
        }
        If ($approval_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already an Approval named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End warning ##
        [string]$command = '/approvalConfiguration/copy'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            [string]$Approval_oldId = $Approval.id
            [string]$Approval_simpleId = $Approval.simpleId
            If ($Approval_oldId -eq $NewId) {
                Write-Warning -Message "The new id cannot be the same as the old id."
                Break
            }
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Copy the Approval $($Approval_simpleId) to $($NewId)?")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                $BodyMetaData.'oldId' = $Approval_oldId
                $BodyMetaData.'domain' = $Approval.domain
                $BodyMetaData.'id' = $NewId
                If ($UnsetDescription -ne $true) {
                    If ($Description.Length -gt 0) {
                        $BodyMetaData.'description' = $Description
                    }
                    Else {
                        $BodyMetaData.'description' = $Approval.description
                    }
                }
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_operationId' = 'copy'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_dataSource' = 'ApprovalConfigurationDataSource'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties oldId, domain, NewId, description
                $parameters.Body = $Body
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Approval_id] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                $Error.Clear()
                Try {
                    [ANOWApproval]$Approval = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to create copied [ANOWApproval] object $NewId due to [$Message]."
                    Break
                }
                If ($Approval.id.Length -eq 0) {
                    Write-Warning -Message "Somehow the newly created (copied) [ANOWApproval] object is empty!"
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $Approval
                }
            }
        }
    }
    End {

    }
}

Function Rename-AutomateNOWApproval {
    <#
    .SYNOPSIS
    Renames an Approval on an AutomateNOW! instance

    .DESCRIPTION
    Performs a psuedo-rename operations of an Approval from an AutomateNOW! instance by copying it first and then deleting the source. This function merely combines Copy-AutomateNOWApproval and Remove-AutomateNOWApproval therefore it is to be considered destructive.

    .PARAMETER Approval
    An [ANOWApproval] object representing the Approval to be renamed.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the Approval. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER Force
    Force the renaming without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly renamed object.

    .INPUTS
    ONLY [ANOWApproval] objects are accepted. There is intentionally no support for the pipeline.

    .OUTPUTS
    The newly renamed [ANOWApproval] object will be returned.

    .EXAMPLE
    Renames an approval in 2 lines of code

    $Approval = Get-AutomateNOWApproval -Id 'Approval01'
    Rename-AutomateNOWApproval -Approval $Approval -NewId 'Approval_02'

    .EXAMPLE
    Renames an approval in 1 line of code

    Rename-AutomateNOWApproval -Approval (Get-AutomateNOWApproval -Id 'Approval01') -NewId 'Approval_02'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    When renaming, you may only specify a different Id (name).

    This action will be blocked if any existing referrals are found on the object.
    #>
    [OutputType([ANOWApproval])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWApproval]$Approval,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin standard warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$new_Approval_exists = ($null -ne (Get-AutomateNOWApproval -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWApproval failed to check if the Approval [$NewId] already existed due to [$Message]."
            Break
        }
        If ($new_Approval_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already an Approval named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        #[string]$Approval_id = $Approval.id
        [string]$Approval_id = $Approval.simpleId
        $Error.Clear()
        Try {
            [boolean]$old_Approval_exists = ($null -ne (Get-AutomateNOWApproval -Id $Approval_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWApproval failed to check if the Approval [$Approval_id] already existed due to [$Message]."
            Break
        }
        If ($old_Approval_exists -eq $false) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not an Approval named [$Approval_id] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End standard warning ##
        ## Begin referrals warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [int32]$referrals_count = Find-AutomateNOWObjectReferral -Approval $Approval -Count | Select-Object -Expandproperty referrals
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Find-AutomateNOWObjectReferral failed to extract the referrals on Approval [$Approval_id] due to [$Message]."
            Break
        }
        If ($referrals_count -gt 0) {
            Write-Warning -Message "Unfortunately, you cannot rename an Approval that has referrals. This is because the rename is not actually renaming but copying anew and deleting the old. Please, use the Find-AutomateNOWObjectReferral function to identify referrals and remove them."
            Break
        }
        Else {
            Write-Verbose -Message "The Approval [$Approval_id] does not have any referrals. It is safe to proceed."
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Approval_id)")) -eq $true) {
                $Error.Clear()
                Try {
                    [ANOWApproval]$new_Approval = Copy-AutomateNOWApproval -Approval $Approval -NewId $NewId -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Copy-AutomateNOWApproval failed to create a new Approval [$NewId] as Part 1 of the renaming process due to [$Message]."
                    Break
                }
                If ($new_Approval.simpleId -eq $NewId) {
                    Write-Verbose -Message "Part 1: Approval [$Approval_id] successfully copied to [$NewId]"
                }
                Else {
                    Write-Warning -Message "Somehow the first phase (Copy-AutomateNOWApproval) failed. Please look into this."
                    Break
                }
                $Error.Clear()
                Try {
                    Remove-AutomateNOWApproval -Approval $Approval -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Remove-AutomateNOWApproval failed to remove [$Approval_id] as Part 2 of the renaming process due to [$Message]."
                    Break
                }
                Write-Verbose -Message "Part 2: Approval [$Approval_id] removed"
                Write-Verbose -Message "Task [$Approval_id] successfully renamed to [$NewId]"
                If ($Quiet -ne $true) {
                    Return $Approval
                }
            }
        }
        Else {
            Write-Warning -Message "No action was taken because either the source object didn't exist or the new object already existed"
        }
    }
    End {
    }
}

#endregion

#Region - Approval Rules

Function New-AutomateNOWApprovalRule {
    <#
    .SYNOPSIS
    Creates an Approval Rule object for use with an Approval object within an AutomateNOW! instance

    .DESCRIPTION
    Creates an Approval Rule object for use with an Approval object within an AutomateNOW! instance

    .PARAMETER approvalLevel
    Mandatory string that sets the approval level. Valid choices are: LOW, MEDIUM, HIGH

    .PARAMETER approvalActionType
    Mandatory string that sets the approval level. Valid choices are: READY_TO_START, PROCESSING_RESTART, PROCESSING_FORCE_READY, PROCESSING_FORCE_COMPLETED, PROCESSING_FORCE_FAILED, PROCESSING_SKIP_ON, PROCESSING_SKIP_OFF, PROCESSING_HOLD, PROCESSING_RESUME, PROCESSING_INTERNAL_ACTION, PROCESSING_ABORT, PROCESSING_KILL, PROCESSING_ARCHIVED, PROCESSING_ARCHIVED_CLEANUP

    .PARAMETER noSelfApproval
    Optional switch that requires a different user account to approve the approval

    .PARAMETER passwordConfirmation
    Optional switch that will ask the approver for a password.

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWApprovalRule.

    .OUTPUTS
    An [ANOWApprovalRule] object representing the newly created Approval Rule

    .EXAMPLE
    New-AutomateNOWApprovalRule ?

    .NOTES

    This function does not require connectivity to the AutomateNOW! instance

    #>
    [OutputType([ANOWApprovalRule])]
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $True)]
        [ANOWApprovalRule_approvalLevel]$approvalLevel,
        [Parameter(Mandatory = $True)]
        [ANOWApprovalRule_approvalActionType]$approvalActionType,
        [Parameter(Mandatory = $False)]
        [switch]$noSelfApproval,
        [Parameter(Mandatory = $False)]
        [switch]$passwordConfirmation
    )
    $Error.Clear()
    Try {
        [ANOWApprovalRule]$ApprovalRule = [ANOWApprovalRule]::new()
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "The [ANOWApprovalRule] failed to instantiate due to [$Message]."
        Break
    }
    $Error.Clear()
    Try {
        $ApprovalRule.approvalLevel = [string]$approvalLevel
        $ApprovalRule.approvalActionType = [string]$approvalActionType
        If ($noSelfApproval -eq $true) {
            $ApprovalRule.noSelfApproval = [boolean]$noSelfApproval
        }
        If ($passwordConfirmation -eq $true) {
            $ApprovalRule.passwordConfirmation = [boolean]$passwordConfirmation
        }
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "The [ANOWApprovalRule] object failed to populate one of the properties due to [$Message]."
        Break
    }
    Return $ApprovalRule
}

Function Add-AutomateNOWApprovalRule {
    <#
    .SYNOPSIS
    Adds a Rule (a.k.a. "Action") to an Approval on an AutomateNOW! instance

    .DESCRIPTION
    Adds a Rule (a.k.a. "Action") to an Approval on an AutomateNOW! instance

    .PARAMETER Approval
    Mandatory [ANOWApproval] object (Use Get-AutomateNOWApproval).

    .PARAMETER ApprovalRule
    Mandatory [ANOWApprovalRule] object (Use New-AutomateNOWApprovalRule)

    .PARAMETER Quiet
    Switch parameter to silence the output from a successful update

    .PARAMETER Force
    Force the addition of the object without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    One [ANOWApproval] object along with one or more [ANOWApprovalRule] objects must be supplied

    .OUTPUTS
    The updated [ANOWApproval] object will be returned.

    .EXAMPLE
    Creates a rule with action type READY_TO_START, no self-approval, password confirmation and a high approval level to an Approval named 'Approval1' (multi-line format)
    $approval = Get-AutomateNOWApproval -Id 'Approval1'
    $approval_rule = New-AutomateNOWApprovalRule -approvalLevel HIGH -approvalActionType READY_TO_START -noSelfApproval -passwordConfirmation
    Add-AutomateNOWApprovalRule -Approval $approval -ApprovalRule $approval_rule

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWApproval]$Approval,
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWApprovalRule]$ApprovalRule,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
        [PSCustomObject]$ApprovalRuleArray = @()
        [string]$command = '/approvalConfiguration/update'
    }
    Process {
        If ($_.approvalLevel.Length -gt 0) {
            [ANOWApprovalRule[]]$ApprovalRuleArray += $_
        }
        Else {
            [ANOWApprovalRule[]]$ApprovalRuleArray += $ApprovalRule
        }
    }
    End {
        [string]$Approval_id = $Approval.simpleId
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Add the Approval Rule(s) to the Approval $($Approval_id)?")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [ANOWApproval]$current_result = Get-AutomateNOWApproval -Id $Approval_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWApproval failed to check if the Approval [$Approval_id] existed under Add-AutomateNOWApprovalRule due to [$Message]."
                Break
            }
            If ($current_result.id.length -eq 0) {
                Write-Warning -Message "The Approval object that you specified [$Approval_id] does not seem to exist under Add-AutomateNOWApprovalRule"
                Break
            }
            ## End warning ##
            $Error.Clear()
            Try {
                $ApprovalRuleArray += [ANOWApprovalRule[]]$Approval.rules
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to merge the Approval Rule Array under Add-AutomateNOWApprovalRule due to [$Message]."
                Break
            }
            $Error.Clear()
            Try {
                [string]$ConvertedApprovalRuleArray = $ApprovalRuleArray | ForEach-Object { [PSCustomObject]@{ approvalLevel = [string]$_.approvalLevel; approvalActionType = [string]$_.approvalActionType; noSelfApproval = $_.noSelfApproval; passwordConfirmation = $_.passwordConfirmation; } } | ConvertTo-Json -Compress
                If ($ConvertedApprovalRuleArray[0] -ne '[') {
                    [string]$ConvertedApprovalRuleArray = ('[' + $ConvertedApprovalRuleArray + ']')
                }
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "ConvertTo-Json failed to convert the array of Approval rules due to [$Message]."
                Break
            }
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $Approval_id )
            If ($Approval.description.Length -gt 0) {
                $BodyMetaData.Add('description', $Approval.description)
            }
            Else {
                $BodyMetaData.Add('description', $null)
            }
            If ($Approval.codeRepository.Length -gt 0) {
                $BodyMetaData.Add('codeRepository', $Approval.codeRepository)
            }
            Else {
                $BodyMetaData.Add('codeRepository', $null)
            }
            $BodyMetaData.Add('rules', $ConvertedApprovalRuleArray )
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_oldValues', $Approval.CreateOldValues())
            $BodyMetaData.Add('_componentId', 'ApprovalEditForm')
            $BodyMetaData.Add('_dataSource', 'ApprovalDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $parameters.Add('command', $command)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Task_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            $Error.Clear()
            [ANOWApprovalRule[]]$rules = Try {
                ForEach ($rule in $results.response.data.rules) {
                    [ANOWApprovalRule]$rule
                }
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the response [ANOWApproval] object rules objects under Add-AutomateNOWApprovalRule due to [$Message]."
                Break
            }
            [PSCustomObject]$temp_results = $results.response.data | Select-Object -ExcludeProperty rules
            $temp_results | Add-Member -MemberType NoteProperty -Name rules -Value $rules -TypeName ANOWApprovalRule
            [ANOWApproval]$UpdatedApproval = $temp_results
            If ($Quiet -ne $true) {
                Return $UpdatedApproval
            }
        }
    }
}

Function Remove-AutomateNOWApprovalRule {
    <#
    .SYNOPSIS
    Removes a Rule (a.k.a. "Action") to an Approval on an AutomateNOW! instance

    .DESCRIPTION
    Removes a Rule (a.k.a. "Action") to an Approval on an AutomateNOW! instance

    .PARAMETER Approval
    Mandatory [ANOWApproval] object (Use Get-AutomateNOWApproval).

    .PARAMETER ApprovalRule
    Mandatory [ANOWApprovalRule] object (Use Get-AutomateNOWApprovalRule | Select-Object -ExpandProperty rules)

    .PARAMETER Quiet
    Switch parameter to silence the output from a successful update

    .PARAMETER Force
    Force the removal of the object(s) without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    One [ANOWApproval] object along with one or more [ANOWApprovalRule] objects must be supplied

    .OUTPUTS
    The updated [ANOWApproval] object will be returned.

    .EXAMPLE
    Forcibly and quietly removes first two Approval Rules of type 'PROCESSING_SKIP_OFF' from an Approval named 'Approval1' (multi-line format)

    $approval = Get-AutomateNOWApproval -Id 'Approval1'
    $approval_rules = $approval.rules
    $approval_rules_to_remove = $approval_rules | Where-Object { $_.approvalActionType -eq 'PROCESSING_SKIP_OFF' } | Select-Object -First 2
    $approval_rules_to_remove | Remove-AutomateNOWApprovalRule -Approval $approval -Quiet -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Approval Rules do not have an Id or even a Name, thus you need to exercise caution here and use some extra coding to ensure you do not remove more than you planned to.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWApproval]$Approval,
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWApprovalRule]$ApprovalRule,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
        [string]$Approval_id = $Approval.id
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [ANOWApproval]$current_result = Get-AutomateNOWApproval -Id $Approval_id
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWApproval failed to check if the Approval [$Approval_id] existed under Remove-AutomateNOWApprovalRule due to [$Message]."
            Break
        }
        If ($current_result.id.length -eq 0) {
            Write-Warning -Message "The Approval object that you specified [$Approval_id] does not seem to exist under Remove-AutomateNOWApprovalRule"
            Break
        }
        ## End warning ##
        [int32]$OriginalApprovalRulesCount = $Approval.rules.Count
        If ($OriginalApprovalRulesCount -eq 0) {
            Write-Warning -Message "There are no rules inside of this Approval. Please check again."
            Break
        }
        Else {
            Write-Verbose -Message "[$Approval_id] originally contained [$OriginalApprovalRulesCount] rules"
        }
        $Error.Clear()
        Try {
            [System.Collections.ArrayList]$UpdatedApprovalRules = $Approval.rules.Clone()
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to make a clone of the Approval Rules (under Remove-AutomateNOWApprovalRule) due to [$Message]."
            Break
        }
        [string]$command = '/approvalConfiguration/update'
    }
    Process {
        If ($_.approvalLevel.Length -gt 0) {
            [ANOWApprovalRule]$ApprovalRule = $_
        }
        $Error.Clear()
        Try {
            [int32]$RuleLocation = $UpdatedApprovalRules.IndexOf($ApprovalRule)
            $UpdatedApprovalRules.RemoveAt($RuleLocation)
        }
        Catch {
            [string]$Message = $_.Exception.Message
            [string]$ApprovalRuleJson = $ApprovalRule | ConvertTo-Json -Compress
            Write-Warning -Message "Failed to locate (or remove) the submitted ApprovalRule ($ApprovalRuleJson) within the Approvals rule set (under Remove-AutomateNOWApprovalRule) due to [$Message]."
            Break
        }
    }
    End {
        [string]$Approval_id = $Approval.simpleId
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Remove the Approval Rule(s) from the Approval [$($Approval_id)]?")) -eq $true) {
            $Error.Clear()
            Try {
                [string]$ConvertedApprovalRuleArray = $UpdatedApprovalRules | ForEach-Object { [PSCustomObject]@{ approvalLevel = [string]$_.approvalLevel; approvalActionType = [string]$_.approvalActionType; noSelfApproval = $_.noSelfApproval; passwordConfirmation = $_.passwordConfirmation; } } | ConvertTo-Json -Compress
                If ($ConvertedApprovalRuleArray[0] -ne '[') {
                    [string]$ConvertedApprovalRuleArray = ('[' + $ConvertedApprovalRuleArray + ']')
                }
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "ConvertTo-Json failed to convert the array of Approval rules due to [$Message]."
                Break
            }
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $Approval_id )
            $BodyMetaData.Add('rules', $ConvertedApprovalRuleArray )
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_oldValues', $Approval.CreateOldValues())
            $BodyMetaData.Add('_componentId', 'ApprovalEditForm')
            $BodyMetaData.Add('_dataSource', 'ApprovalDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $parameters.Add('command', $command)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Task_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            $Error.Clear()
            [ANOWApprovalRule[]]$rules = Try {
                ForEach ($rule in $results.response.data.rules) {
                    [ANOWApprovalRule]$rule
                }
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the response [ANOWApproval] object rules objects under Add-AutomateNOWApprovalRule due to [$Message]."
                Break
            }
            [PSCustomObject]$temp_results = $results.response.data | Select-Object -ExcludeProperty rules
            $temp_results | Add-Member -MemberType NoteProperty -Name rules -Value $rules -TypeName ANOWApprovalRule
            [ANOWApproval]$UpdatedApproval = $temp_results
            If ($Quiet -ne $true) {
                Return $UpdatedApproval
            }
        }
    }
}

Function Pop-AutomateNOWApprovalRule {
    <#
    .SYNOPSIS
    Moves (pops) an Approval Rule to the bottom of the list within an Approval on an AutomateNOW! instance

    .DESCRIPTION
    Moves (pops) an Approval Rule to the bottom of the list within an Approval on an AutomateNOW! instance

    .PARAMETER Approval
    Mandatory [ANOWApproval] object (Use Get-AutomateNOWApproval).

    .PARAMETER ApprovalRule
    Mandatory [ANOWApprovalRule] object (Use Get-AutomateNOWApprovalRule | Select-Object -ExpandProperty rules) that will be popped to the bottom of the stack.

    .PARAMETER Quiet
    Switch parameter to silence the output from a successful update

    .PARAMETER Force
    Force the change of the object order without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    One [ANOWApproval] object along with only one [ANOWApprovalRule] object. Pipeline is not supported.

    .OUTPUTS
    The updated [ANOWApproval] object will be returned.

    .EXAMPLE

    Forcibly and quietly pops the first Approval Rule of type 'Skip Off' to the bottom of the stack within an Approval named 'Approval1'

    $approval = Get-AutomateNOWApproval -Id 'Approval1'
    $approval_rules = $approval.rules
    $approval_rule_to_move = $approval_rules | Where-Object { $_.approvalActionType -eq 'PROCESSING_SKIP_OFF' } | Select-Object -First 1
    $approval_rule_to_move | Pop-AutomateNOWApprovalRule -Approval $approval -Quiet -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Approval Rules do not have an Id or even a Name, thus you need to exercise caution here.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWApproval]$Approval,
        [Parameter(Mandatory = $true)]
        [ANOWApprovalRule]$ApprovalRule,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    [hashtable]$parameters = @{}
    $parameters.Add('Method', 'POST')
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$Approval_id = $Approval.id
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [ANOWApproval]$current_result = Get-AutomateNOWApproval -Id $Approval_id
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWApproval failed to check if the Approval [$Approval_id] existed under Pop-AutomateNOWApprovalRule due to [$Message]."
        Break
    }
    If ($current_result.id.length -eq 0) {
        Write-Warning -Message "The Approval object that you specified [$Approval_id] does not seem to exist under Pop-AutomateNOWApprovalRule"
        Break
    }
    ## End warning ##
    [int32]$OriginalApprovalRulesCount = $Approval.rules.Count
    If ($OriginalApprovalRulesCount -eq 0) {
        Write-Warning -Message "There are no rules inside of this Approval. Please check again."
        Break
    }
    Else {
        [string]$OriginalApprovalRulesOrder = $Approval.rules | ConvertTo-Json -Compress
        Write-Verbose -Message "[$Approval_id] originally contained [$OriginalApprovalRulesCount] rules in the following order: $OriginalApprovalRulesOrder"
    }
    $Error.Clear()
    Try {
        [System.Collections.ArrayList]$UpdatedApprovalRules = $Approval.rules.Clone()
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to make a clone of the Approval Rules (under Remove-AutomateNOWApprovalRule) due to [$Message]."
        Break
    }
    [string]$command = '/approvalConfiguration/update'
    If ($_.approvalLevel.Length -gt 0) {
        [ANOWApprovalRule]$ApprovalRule = $_
    }
    $Error.Clear()
    Try {
        [int32]$RuleLocation = $UpdatedApprovalRules.IndexOf($ApprovalRule)
        $UpdatedApprovalRules.RemoveAt($RuleLocation)
        $UpdatedApprovalRules.Add($ApprovalRule)
    }
    Catch {
        [string]$Message = $_.Exception.Message
        [string]$ApprovalRuleJson = $ApprovalRule | ConvertTo-Json -Compress
        Write-Warning -Message "Failed to pop the submitted ApprovalRule ($ApprovalRuleJson) within the Approvals rule set (under Pop-AutomateNOWApprovalRule) to the bottom of the stack due to [$Message]."
        Break
    }
    [string]$Approval_id = $Approval.simpleId
    If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Pop the Approval Rule to the bottom of Approval [$($Approval_id)]?")) -eq $true) {
        $Error.Clear()
        Try {
            [string]$ConvertedApprovalRuleArray = $UpdatedApprovalRules | ForEach-Object { [PSCustomObject]@{ approvalLevel = [string]$_.approvalLevel; approvalActionType = [string]$_.approvalActionType; noSelfApproval = $_.noSelfApproval; passwordConfirmation = $_.passwordConfirmation; } } | ConvertTo-Json -Compress
            If ($ConvertedApprovalRuleArray[0] -ne '[') {
                [string]$ConvertedApprovalRuleArray = ('[' + $ConvertedApprovalRuleArray + ']')
            }
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "ConvertTo-Json failed to convert the array of Approval rules due to [$Message]."
            Break
        }
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        $BodyMetaData.Add('id', $Approval_id )
        $BodyMetaData.Add('rules', $ConvertedApprovalRuleArray )
        $BodyMetaData.Add('_operationType', 'update')
        $BodyMetaData.Add('_textMatchStyle', 'exact')
        $BodyMetaData.Add('_oldValues', $Approval.CreateOldValues())
        $BodyMetaData.Add('_componentId', 'ApprovalEditForm')
        $BodyMetaData.Add('_dataSource', 'ApprovalDataSource')
        $BodyMetaData.Add('isc_metaDataPrefix', '_')
        $BodyMetaData.Add('isc_dataFormat', 'json')
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        If ($null -eq $parameters.Body) {
            $parameters.Add('Body', $Body)
        }
        Else {
            $parameters.Body = $Body
        }
        $parameters.Add('command', $command)
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Task_id] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        [ANOWApprovalRule[]]$rules = Try {
            ForEach ($rule in $results.response.data.rules) {
                [ANOWApprovalRule]$rule
            }
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response [ANOWApproval] object rules objects under Add-AutomateNOWApprovalRule due to [$Message]."
            Break
        }
        [PSCustomObject]$temp_results = $results.response.data | Select-Object -ExcludeProperty rules
        $temp_results | Add-Member -MemberType NoteProperty -Name rules -Value $rules -TypeName ANOWApprovalRule
        [ANOWApproval]$UpdatedApproval = $temp_results
        If ($Quiet -ne $true) {
            Return $UpdatedApproval
        }
    }
}

Function Push-AutomateNOWApprovalRule {
    <#
    .SYNOPSIS
    Moves (pushes) an Approval Rule to the top of the list within an Approval on an AutomateNOW! instance

    .DESCRIPTION
    Moves (pushes) an Approval Rule to the top of the list within an Approval on an AutomateNOW! instance

    .PARAMETER Approval
    Mandatory [ANOWApproval] object (Use Get-AutomateNOWApproval).

    .PARAMETER ApprovalRule
    Mandatory [ANOWApprovalRule] object (Use Get-AutomateNOWApprovalRule | Select-Object -ExpandProperty rules) that will be pushed to the top of the stack.

    .PARAMETER Quiet
    Switch parameter to silence the output from a successful update

    .PARAMETER Force
    Force the change of the object order without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    One [ANOWApproval] object along with only one [ANOWApprovalRule] object. Pipeline is not supported.

    .OUTPUTS
    The updated [ANOWApproval] object will be returned.

    .EXAMPLE
    Forcibly and quietly pushes the first Approval Rule of type 'Skip Off' to the top of the stack within an Approval named 'Approval1'

    $approval = Get-AutomateNOWApproval -Id 'Approval1'
    $approval_rules = $approval.rules
    $approval_rule_to_move = $approval_rules | Where-Object { $_.approvalActionType -eq 'PROCESSING_SKIP_OFF' } | Select-Object -First 1
    $approval_rule_to_move | Push-AutomateNOWApprovalRule -Approval $approval -Quiet -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Approval Rules do not have an Id or even a Name, thus you need to exercise caution here.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWApproval]$Approval,
        [Parameter(Mandatory = $true)]
        [ANOWApprovalRule]$ApprovalRule,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    [hashtable]$parameters = @{}
    $parameters.Add('Method', 'POST')
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$Approval_id = $Approval.id
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [ANOWApproval]$current_result = Get-AutomateNOWApproval -Id $Approval_id
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWApproval failed to check if the Approval [$Approval_id] existed under Push-AutomateNOWApprovalRule due to [$Message]."
        Break
    }
    If ($current_result.id.length -eq 0) {
        Write-Warning -Message "The Approval object that you specified [$Approval_id] does not seem to exist under Push-AutomateNOWApprovalRule"
        Break
    }
    ## End warning ##
    [int32]$OriginalApprovalRulesCount = $Approval.rules.Count
    If ($OriginalApprovalRulesCount -eq 0) {
        Write-Warning -Message "There are no rules inside of this Approval. Please check again."
        Break
    }
    Else {
        [string]$OriginalApprovalRulesOrder = $Approval.rules | ConvertTo-Json -Compress
        Write-Verbose -Message "[$Approval_id] originally contained [$OriginalApprovalRulesCount] rules in the following order: $OriginalApprovalRulesOrder"
    }
    $Error.Clear()
    Try {
        [System.Collections.ArrayList]$UpdatedApprovalRules = $Approval.rules.Clone()
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to make a clone of the Approval Rules (under Push-AutomateNOWApprovalRule) due to [$Message]."
        Break
    }
    [string]$command = '/approvalConfiguration/update'
    If ($_.approvalLevel.Length -gt 0) {
        [ANOWApprovalRule]$ApprovalRule = $_
    }
    $Error.Clear()
    Try {
        [int32]$RuleLocation = $UpdatedApprovalRules.IndexOf($ApprovalRule)
        $UpdatedApprovalRules.RemoveAt($RuleLocation)
        $UpdatedApprovalRules.Insert(0, $ApprovalRule)
    }
    Catch {
        [string]$Message = $_.Exception.Message
        [string]$ApprovalRuleJson = $ApprovalRule | ConvertTo-Json -Compress
        Write-Warning -Message "Failed to push the submitted ApprovalRule ($ApprovalRuleJson) within the Approvals rule set (under Pop-AutomateNOWApprovalRule) to the top of the stack due to [$Message]."
        Break
    }
    [string]$Approval_id = $Approval.simpleId
    If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Push the Approval Rule to the top of Approval [$($Approval_id)]?")) -eq $true) {
        $Error.Clear()
        Try {
            [string]$ConvertedApprovalRuleArray = $UpdatedApprovalRules | ForEach-Object { [PSCustomObject]@{ approvalLevel = [string]$_.approvalLevel; approvalActionType = [string]$_.approvalActionType; noSelfApproval = $_.noSelfApproval; passwordConfirmation = $_.passwordConfirmation; } } | ConvertTo-Json -Compress
            If ($ConvertedApprovalRuleArray[0] -ne '[') {
                [string]$ConvertedApprovalRuleArray = ('[' + $ConvertedApprovalRuleArray + ']')
            }
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "ConvertTo-Json failed to convert the array of Approval rules due to [$Message]."
            Break
        }
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        $BodyMetaData.Add('id', $Approval_id )
        $BodyMetaData.Add('rules', $ConvertedApprovalRuleArray )
        $BodyMetaData.Add('_operationType', 'update')
        $BodyMetaData.Add('_textMatchStyle', 'exact')
        $BodyMetaData.Add('_oldValues', $Approval.CreateOldValues())
        $BodyMetaData.Add('_componentId', 'ApprovalEditForm')
        $BodyMetaData.Add('_dataSource', 'ApprovalDataSource')
        $BodyMetaData.Add('isc_metaDataPrefix', '_')
        $BodyMetaData.Add('isc_dataFormat', 'json')
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        If ($null -eq $parameters.Body) {
            $parameters.Add('Body', $Body)
        }
        Else {
            $parameters.Body = $Body
        }
        $parameters.Add('command', $command)
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Task_id] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        [ANOWApprovalRule[]]$rules = Try {
            ForEach ($rule in $results.response.data.rules) {
                [ANOWApprovalRule]$rule
            }
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response [ANOWApproval] object rules objects under Add-AutomateNOWApprovalRule due to [$Message]."
            Break
        }
        [PSCustomObject]$temp_results = $results.response.data | Select-Object -ExcludeProperty rules
        $temp_results | Add-Member -MemberType NoteProperty -Name rules -Value $rules -TypeName ANOWApprovalRule
        [ANOWApproval]$UpdatedApproval = $temp_results
        If ($Quiet -ne $true) {
            Return $UpdatedApproval
        }
    }
}

#endregion

#Region - Audit Logs

Function Get-AutomateNOWAuditLog {
    <#
    .SYNOPSIS
    Gets the Audit log from an instance of AutomateNOW!

    .DESCRIPTION
    The `Get-AutomateNOWAuditLog` cmdlet gets the Audit log from an instance of AutomateNOW!

    .PARAMETER Type
    An optional string to filter the results based on type. Valid choices are: UPDATE, INSERT and DELETE

    .PARAMETER TableName
    An optional string to filter the results based on the name of the table. The list of tables is not defined. Some examples are: server_node, processing_template.

    .PARAMETER ObjectId
    An optional string to filter the results based on the name of the object. This is the Id of the object which means the domain is prefixed in brackets (see examples).

    .PARAMETER startRow
    An optional int32 representing what row to start the download from. This is intended for multi-page transfers.

    .PARAMETER endRow
    An optional int32 representing how many rows of data to receive. The default is 100. This is ideal for testing when you only want a few items.

    .PARAMETER Ascending
    Optional switch parameter which changes the sort order (of the actionTimestamp property) from the default descending to ascending

    .INPUTS
    None. You cannot pipe objects to Get-AutomateNOWAuditLog.

    .OUTPUTS
    An array of PSCustomObjects

    .EXAMPLE
    Gets the most recent 100 audit log entries

    Get-AutomateNOWAuditLog

    .EXAMPLE
    Gets the most recent 1000 audit log entries

    Get-AutomateNOWAuditLog -startRow 0 -endRow 1000

    .EXAMPLE
    Gets the most recent 1000 audit log entries of type UPDATE (which means INSERT and DELETE are not included)

    Get-AutomateNOWAuditLog -startRow 0 -endRow 1000 -Type UPDATE

    .EXAMPLE
    Gets the oldest 1000 audit log entries

    Get-AutomateNOWAuditLog -startRow 0 -endRow 1000 -Ascending

    .EXAMPLE
    Gets the first 100 audit log entries pertaining to server nodes.

    Get-AutomateNOWAuditLog -TableName 'server_node'

    .EXAMPLE
    Gets the first 100 audit log entries pertaining to a server node named 'ServerNode1' on a domain called 'Domain1'.

    Get-AutomateNOWAuditLog -ObjectId '[Domain1]ServerNode1'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The sort order from the console is by timestamp which is NOT ACCURATE! This function will sort by Id instead which is guaranteed to be unique.

    Sorting does not seem to work when using -ObjectId and possibly other parameters. You may need to sort the results again in that case.

    #>
    [OutputType([ANOWAuditLog[]])]
    [Cmdletbinding()]
    Param(
        [ValidateSet('UPDATE', 'INSERT', 'DELETE', ignoreCase = $false)]
        [Parameter(Mandatory = $False)]
        [string]$Type,
        [Parameter(Mandatory = $False)]
        [string]$TableName,
        [ValidateScript({ $_ -match '^\[[0-9a-zA-z_.-]{1,255}][0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $False)]
        [string]$ObjectId,
        [Parameter(Mandatory = $False)]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False)]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False)]
        [switch]$Ascending
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    If ($endRow -lt $startRow) {
        Write-Warning -Message "The end row must be higher then the start row"
        Break
    }
    [System.Collections.Specialized.OrderedDictionary]$BodyObject = [System.Collections.Specialized.OrderedDictionary]@{}
    If (($Type.Length -gt 0) -or ($TableName.Length -gt 0) -or ($ObjectId.Length -gt 0)) {
        $BodyObject.Add('operator', 'and')
        $BodyObject.Add('_constructor', 'AdvancedCriteria')
        If ($Type.Length -gt 0) {
            $BodyObject.Add('criteria1', '{"fieldName":"actionType","operator":"equals","value":"' + $Type + '"}')
        }
        If ($TableName.Length -gt 0) {
            $BodyObject.Add('criteria2', '{"fieldName":"tableName","operator":"equals","value":"' + $TableName + '"}')
        }
        If ($ObjectId.Length -gt 0) {
            $BodyObject.Add('criteria3', '{"fieldName":"objectId","operator":"equals","value":"' + $ObjectId + '"}')
        }
    }
    $BodyObject.Add('_operationType', 'fetch')
    $BodyObject.Add('_startRow', $startRow)
    $BodyObject.Add('_endRow', $endRow)
    If ($Ascending -ne $true) {
        $BodyObject.Add('_sortBy', '-id')
    }
    Else {
        $BodyObject.Add('_sortBy', 'id')
    }
    $BodyObject.Add('_textMatchStyle', 'substring')
    $BodyObject.Add('_componentId', 'AuditLogEventList')
    $BodyObject.Add('_dataSource', 'AuditLogDataSource')
    $BodyObject.Add('isc_metaDataPrefix', '_')
    $BodyObject.Add('isc_dataFormat', 'json')
    [string]$Body = ConvertTo-QueryString -InputObject $BodyObject
    [string]$command = ('/auditLog/read?' + $Body)
    [string]$Instance = $anow_session.Instance
    [hashtable]$parameters = @{}
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'GET')
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Instance', $Instance)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed due to execute [$command] due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    [int32]$AuditLogs_count = $results.response.data.Count
    If ($AuditLogs_count -eq 0 -and $startRow -gt 0) {
        Write-Warning -Message "There are not any more rows of data past this point. Please try different -startRow value."
        Break
    }
    $Error.Clear()
    Try {
        [ANOWAuditLog[]]$AuditLogs = ForEach ($entry in $results.response.data) {
            Try {
                $entry | Add-Member -MemberType NoteProperty -Name changedValuesText -TypeName String -Value ''
                $entry | Add-Member -MemberType NoteProperty -Name changedValues -TypeName PSCustomObject -Value ''
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Add-Member failed to add the NoteProperty changedValues to an audit log UPDATE entry due to [$Message]."
                Break
            }
            If ($entry.actionType -eq 'UPDATE') {
                $Error.Clear()
                Try {
                    [PSCustomObject]$ChangedValues = Compare-ObjectProperty -ReferenceObject $entry.oldValues -DifferenceObject $entry.newValues
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Compare-ObjectProperty failed to compare an audit log UPDATE entry due to [$Message]."
                    Break
                }
                $Error.Clear()
                Try {
                    [PSCustomObject[]]$ObjectValues = $ChangedValues | ForEach-Object { [PSCustomObject]@{ name = $_.PropertyName; oldValue = $_.RefValue; newValue = $_.DiffValue; } }
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "ForEach-Object failed to format an audit log UPDATE entry due to [$Message]."
                    Break
                }
                $Error.Clear()
                Try {
                    [string]$JSONValues = $ObjectValues | Sort-Object -Property name | ConvertTo-Json -Compress -Depth 10
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "ConvertTo-Json failed to convert an audit log UPDATE entry due to [$Message]."
                    Break
                }
                $entry.changedValues = $ObjectValues
                $entry.changedValuesText = $JSONValues
            }
            $entry
        }
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to parse the returned AuditLog entries under Get-AutomateNOWAuditLog due to [$Message]."
        Break
    }
    Return $AuditLogs
}

Function Export-AutomateNOWAuditLog {
    <#
    .SYNOPSIS
    Exports the AuditLog entries from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the AuditLog entries from an instance of AutomateNOW! to a local .csv file

    .PARAMETER AuditLog
    Mandatory [ANOWAuditLog] object (Use Get-AutomateNOWAuditLog to retrieve them)

    .INPUTS
    ONLY [ANOWAuditLog] objects are accepted (including from the pipeline)

    .OUTPUTS
    The [ANOWAuditLog] objects are exported to the local disk in CSV format

    .EXAMPLE
    Get-AutomateNOWAuditLog | Export-AutomateNOWAuditLog

    .NOTES
	You must present [ANOWAuditLog] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWAuditLog]$AuditLog
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-AuditLogs-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        $parameters.Add('Delimiter', "`t")
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWAuditLog]$AuditLog = $_
        }
        $Error.Clear()
        Try {
            $AuditLog | Select-Object -ExcludeProperty oldValues, newValues, changedValues | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWAuditLog] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function Restore-AutomateNOWObjectVersion {
    <#
    .SYNOPSIS
    Restores (reconstitutes) previous versions of an object based on its exported migration .json file.

    .DESCRIPTION
    Restores (reconstitutes) previous versions of an object based on its exported migration .json file.

    .PARAMETER JsonFile
    Mandatory [System.IO.FileSystemInfo] object of the JSON file to restore from. Use Get-Item to fetch this object. See examples.

    .PARAMETER DestinationFilepath
    Optional path for the outgoing exported objects to be written to. Use this if you want the exported JSON file to be written somewhere other than the current path.

    .PARAMETER Quiet
    Switch parameter that suppresses the informational message when each previous version of the object is written to disk.

    .INPUTS
    An exported ANOW Migration object in a .json file is required. Use Get-Item to create the required [System.IO.FileSystemInfo] object. Pipeline capable.

    .OUTPUTS
    Up to 10,000 versions of the provided .json file will be generated to disk. Example: '[Test]MyPowerShellScript.ps1_version-20350719074533-UPDATE.json'

    .EXAMPLE
    Restores previous versions of an object that was exported to the filename: AutomateNOW!_Test_Test_2035_07_19_10_25_53.json in the 'c:\temp' directory.

    Restore-AutomateNOWObjectVersion -JsonFile (Get-Item 'c:\temp\AutomateNOW!_Test_Test_2035_07_19_10_25_53.json') -DestinationPath 'c:\temp'

    .NOTES
	You must use Connect-AutomateNOW to establish the token by way of global variable.

    This function will always overwrite the output file.

    You can use New-AutomateNOWMigrationImport to import the resulting files back into the console.

    This is an experimental function that may still have issues.
    
    Known Issues: Some .json files may not restore correctly due to duplicate keys within the json. PowerShell Core can directly handle this but Windows PowerShell needs a workaround.

    #>
    Param(
        [ValidateScript({ ((Test-Path -Path $_ ) -eq $true) })]
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [System.IO.FileSystemInfo]$JsonFile,
        [ValidateScript({ (Test-Path -Path "$_") -eq $true })]
        [Parameter(Mandatory = $false)]
        [string]$DestinationPath = ".",
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
    }
    Process {
        If ($_.Name.Length -gt 0) {
            [System.IO.FileSystemInfo]$JsonFile = $_
        }
        [string]$file_name = $JsonFile.name
        $Error.Clear()
        Try {
            [string]$json_content_string = ($JsonFile | Get-Content) -join "`n"
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-Content failed to read the contents of $file_name under New-AutomateNOWMigrationImport due to [$Message]"
            Break
        }
        If ($json_content_string.Length -eq 0) {
            Write-Warning -Message "Somehow the file $file_name appears to be empty. Please check into this."
            Break
        }
        $Error.Clear()
        Try {
            [PSCustomObject[]]$json_content = $json_content_string | ConvertFrom-Json | Where-Object { $null -ne $_ }
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "ConvertFrom-Json failed to import the JSON content within $file_name under Restore-AutomateNOWObjectVersion due to [$Message]"
            Break
        }
        If ($json_content.count -eq 0) {
            Write-Warning -Message "Somehow the formatted JSON content was empty!"
            Break
        }
        ElseIf ($json_content.count -gt 1) {
            Write-Warning -Message "Please only have 1 object in the JSON file."
            Break
        }
        [PSCustomObject]$json_content = $json_content
        [string]$ObjectId = $json_content.Id
        If ($ObjectId.Length -eq 0) {
            Write-Warning -Message "Somehow the Id of the object within the JSON file was empty or not present. Please check the file you are trying to import."
            Break
        }
        ElseIf ($ObjectId -notmatch '^\[[0-9a-zA-z_.-]{1,255}][0-9a-zA-z_.-]{1,}$') {
            Write-Warning -Message "The format of the ObjectId found within the imported JSON file was not in the expected format. The expected format is [Domain]ObjectName"
            Break
        }
        Else {
            Write-Verbose -Message "Located $ObjectId within $file_name"
        }
        [ANOWAuditLog[]]$log_entries = Get-AutomateNOWAuditLog -ObjectId $ObjectId -startRow 0 -endRow 10000 | Sort-Object -Property id -Descending
        If ($log_entries.count -eq 0) {
            Write-Verbose -Message "There were no audit log entries for $ObjectId in the current domain."
            Return
        }
        Else {
            $log_entries_count = $log_entries.count
            If ($log_entries_count -eq 10000) {
                Write-Warning -Message "Unfortunately, $ObjectId has more Audit Log entries than is allowed."
                Break
            }
            Else {
                Write-Verbose -Message "Extracted $log_entries_count log entries for $ObjectId"
            }
        }
        If (($log_entries | Select-Object -Last 1 | Select-Object -ExpandProperty actionType) -eq 'INSERT') {
            Write-Verbose -Message "The oldest entry in the Audit Log for $ObjectID is an INSERT statement. This means we should be able to restore every version from the beginning."
        }
        ElseIf (($log_entries | Select-Object -Last 1 | Select-Object -ExpandProperty actionType) -eq 'UPDATE') {
            Write-Verbose -Message "The oldest entry in the Audit Log for $ObjectID is an UPDATE statement, not an INSERT. This means we don't have the complete history of this object from beginning to end."
        }
        ElseIf (($log_entries | Select-Object -Last 1 | Select-Object -ExpandProperty actionType) -eq 'DELETE') {
            Write-Warning -Message "The oldest entry in the Audit Log for $ObjectID is a DELETE statement, not an INSERT. This means we do not have the complete history of this object from beginning to end."
        }
        Else {
            Write-Warning -Message "Somehow it was not possible to process the extracted Audit Log entries for $ObjectId"
            Break
        }
        [ANOWAuditLog[]]$update_log_entries = $log_entries | Where-Object { ((-not ($_.changedvalues.count -eq 1 -and $_.changedvalues.name -eq 'last_updated')) -and ($_.actionType -eq 'UPDATE')) -or ($_.actionType -eq 'INSERT') }
        [int32]$update_log_entries_count = $update_log_entries.count
        If ($update_log_entries_count -eq 0) {
            Write-Warning -Message "Somehow there are 0 UPDATE log entries for $ObjectId. How did this happen?"
            Break
        }
        ForEach ($log_entry in $update_log_entries) {
            [string]$actionType = $log_entry.actionType
            If ($actionType.Length -eq 0) {
                Write-Warning -Message 'Somehow the actionType of an Audit Log entry (under Restore-AutomateNOWObjectVersion) could not be read. Please look into this.'
                Break
            }
            [PSCustomObject]$new_values = $log_entry.newValues
            If ($null -eq $new_values) {
                Write-Warning -Message "Somehow the newValues value of an Audit Log entry (under Restore-AutomateNOWObjectVersion) could not be read. Please look into this."
            }
            $Error.Clear()
            Try {
                [string]$new_values_json = @(, @($new_values)) | ConvertTo-Json -Depth 100 # Note this forces the json into a json array which is required for importing.
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "ConvertTo-Json failed to parse the newValues within an audit log entry (under Restore-AutomateNOWObjectVersion) due to [$Message]."
                Break
            }
            [string]$actionTimestamp = $log_entry.actionTimestamp | Get-Date -Format 'yyyyMMddHHmmss'
            [string]$outgoing_file_name = ($ObjectId + "_version-$actionTimestamp-$actionType.json")
            [string]$outgoing_file_path = Join-Path -Path $DestinationPath -ChildPath $outgoing_file_name
            $Error.Clear()
            Try {
                ("`n" + $new_values_json ) | Out-File -LiteralPath $outgoing_file_path -Force #Note the newline character (byte 0A) being prepended to the payload. This is to mimic the behavior of the ANOW console.
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Out-File failed to write $outgoing_file_path (under Restore-AutomateNOWObjectVersion) due to [$Message]."
                Break
            }
            If ($Quiet -ne $true) {
                If ((Test-Path -LiteralPath $outgoing_file_path) -eq $true) {
                    $Error.Clear()
                    Try {
                        [System.IO.FileSystemInfo]$outgoing_file_info = Get-Item -LiteralPath "$outgoing_file_path"
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Get-Item failed to read the current exported file $outgoing_file_path (under Restore-AutomateNOWObjectVersion) due to [$Message]."
                        Break
                    }
                    [int32]$filelength = $outgoing_file_info.Length
                    [string]$filelength_display = [math]::Round(($filelength / 1024), 2, 'ToZero')
                    Write-Information -MessageData "Saved '$outgoing_file_name' to disk ($filelength_display kb)"
                }
            }
        }
    }
    End {

    }
}

#endregion

#Region - Business Views

Function Get-AutomateNOWBusinessView {
    <#
    .SYNOPSIS
    Gets the Business Views from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Business Views from an AutomateNOW! instance

    .PARAMETER Id
    Optional string containing the simple id of the Business View to fetch or you can pipeline a series of simple id strings. You may not enter an array here.

    .PARAMETER sortBy
    Optional string parameter to sort the results by. Valid choices are: id {To be continued...}

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER Folder
    Optional string to filter by a particular Folder

    .PARAMETER Tags
    Optional string array of Tags to filter by. Note that the 'containsAny' operator will be used.

    .INPUTS
    Accepts a string representing the simple id of the Business View from the pipeline or individually (but not an array).

    .OUTPUTS
    An array of one or more [ANOWBusinessView] class objects

    .EXAMPLE
    Gets the the first page of Business View objects

    Get-AutomateNOWBusinessView

    .EXAMPLE
    Gets a single Business View named 'BusinessView1'

    Get-AutomateNOWBusinessView -Id 'BusinessView1'

    .EXAMPLE
    Gets a series of Business Views from a list of strings sent across the pipeline

    'BusinessView1', 'BusinessView2' | Get-AutomateNOWBusinessView

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWBusinessView[]])]
    [Cmdletbinding(DefaultParameterSetName = 'Default')]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $True, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default' )]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$sortBy = 'id',
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$Descending,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$Folder,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string[]]$Tags
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 -or $Id.Length -gt 0) {
            If ($_.Length -gt 0 ) {
                [string]$BusinessViewName = $_
            }
            Else {
                [string]$BusinessViewName = $Id
            }
            [string]$textMatchStyle = 'exact'
            $Body.'id' = $BusinessViewName
        }
        Else {
            [string]$textMatchStyle = 'substring'
            $Body.'_constructor' = 'AdvancedCriteria'
            $Body.'operator' = 'and'
            If ($Folder.Length -gt 0) {
                $Body.'criteria1' = ('{"fieldName":"folder","operator":"equals","value":"' + $Folder + '"}')
            }
            If ($Tags.Count -gt 0) {
                If ($Tags.Count -gt 1) {
                    $Error.Clear()
                    Try {
                        [string]$TagString = $Tags | ConvertTo-Json -Compress
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "ConvertTo-Json failed to convert the provided tag names under Get-AutomateNOWBusinessView due to [$Message]."
                        Break
                    }
                }
                Else {
                    [string]$TagString = $Tags
                }
                $Body.'criteria2' = ('{"fieldName":"tags","operator":"containsAny","value":' + $TagString + '}')
            }
        }
        $Body.'_operationType' = 'fetch'
        $Body.'_startRow' = $startRow
        $Body.'_endRow' = $endRow
        $Body.'_textMatchStyle' = $textMatchStyle
        $Body.'_componentId' = 'BusinessViewList'
        $Body.'_dataSource' = 'BusinessViewDataSource'
        If ($Descending -eq $true) {
            $Body.'_sortBy' = '-' + $sortBy
        }
        Else {
            $Body.'_sortBy' = $sortBy
        }
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/businessView/read?' + $Body)
        If ($null -ne $parameters.command) {
            $parameters.command = $command
        }
        Else {
            $parameters.Add('command', $command)
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWBusinessView[]]$BusinessViews = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWBusinessView] objects due to [$Message]."
            Break
        }
        If ($BusinessViews.Count -gt 0) {
            Return $BusinessViews
        }
    }
    End {

    }
}

Function Set-AutomateNOWBusinessView {
    <#
    .SYNOPSIS
    Changes the settings of a Business View on an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of a Business View on an AutomateNOW! instance

    .PARAMETER BusinessView
    An [ANOWBusinessView] object representing the Business View to be changed.

    .PARAMETER Description
    A text description of at least 1 character.

    .PARAMETER UnsetDescription
    Switch parameter that will remove the description.

    .PARAMETER iconSet
    The name of the icon library (if you choose to use one). Possible choices are: FAT_COW, FUGUE (note that FONT_AWESOME is not an actual icon library)

    .PARAMETER iconCode
    The name of the icon which matches the chosen library. Must be lower-case. To see the list of available iconCodes, use Import-AutomateNOWIcon (or Import-AutomateNOWLocalIcon) then try $anow_assets.icon_library."FUGUE"[0..10] to see the names of the first 10 icons from the Fugue library.

    .PARAMETER RemoveIcon
    Switch parameter that will remove the icon configured for this Business View.

    .PARAMETER Folder
    (This parameter does not presently work!) String that specifies the name of the folder to place the Business View into.

    .PARAMETER UnsetFolder
    (This parameter does not presently work!) Switch parameter that will remove the Business View from its current folder.

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new Business View.

    .PARAMETER UnsetTags
    Switch parameter that will remove the tags from the Business View.

    .PARAMETER CodeRepository
    Optional Code Repository to place the Business View into. Use Get-AutomateNOWCodeRepository to fetch this object.

    .PARAMETER UnsetCodeRepository
    Switch parameter that will remove the the Business View from its Code Repository.

    .PARAMETER Quiet
    Switch parameter to suppress the return of the updated object

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWBusinessView] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWBusinessView] object will be returned

    .EXAMPLE
    Quietly sets the Description, Icon, Folder, Tag and Code Repository on a Business View named 'BusinessView1' (one-liner format)

    Get-AutomateNOWBusinessView -Id 'BusinessView1' | Set-AutomateNOWBusinessView -Description 'my description' -Folder 'Folder1' -Tags 'Tag1', 'Tag2' -CodeRepository (Get-AutomateNOWCodeRepository -Id 'CodeRepository1') -Force

    .EXAMPLE
    Forcibly removes the Description, Icons, Folder, Tags and Code Repository from a Business View named 'BusinessView1'. Note that the UI will display an icon anyway by default (see Notes) (one-liner format)

    Get-AutomateNOWBusinessView -Id 'BusinessView1' | Set-AutomateNOWBusinessView -UnsetDescription -RemoveIcon -UnsetFolder -UnsetTags -UnsetCodeRepository -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The -iconSet and -iconCode parameter set requires that you import the icon names with Import-AutomateNOWIcon or Import-AutomateNOWLocalIcon.

    All Business Views must have an icon even if it is not required to specify one when creating or modifying a Business View. Therefore, if no icon is selected, the UI will display a default icon anyway (fat_cow\reseller_programm). The iconSet property can never be null.

    #>
    [OutputType([ANOWBusinessView])]
    [Cmdletbinding(SupportsShouldProcess, DefaultParameterSetName = 'Default', ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'Default', ValueFromPipeline = $true)]
        [Parameter(Mandatory = $true, ParameterSetName = 'WithIcon', ValueFromPipeline = $true)]
        [ANOWBusinessView]$BusinessView,
        [ValidateScript({ $_.Length -le 255 })]
        [Parameter(Mandatory = $false, ParameterSetName = 'Default', HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon', HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [string]$Description,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $true, ParameterSetName = 'WithIcon')]
        [ANOWIcon_IconsOnly]$iconSet,
        [ValidateScript({ $_ -match '^[a-z0-9-_]{1,}$' })]
        [Parameter(Mandatory = $true, ParameterSetName = 'WithIcon')]
        [string]$iconCode,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [switch]$RemoveIcon,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [string]$Folder,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [string[]]$Tags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [switch]$UnsetCodeRepository,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [switch]$Quiet,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($iconSet.length -gt 0 ) {
            If ($anow_assets.icon_library.length -eq 0) {
                Write-Warning -Message "Please import the ANOW icons into your session with Import-AutomateNOWIcon or Import-AutomateNOWLocalIcon"
                Break
            }
            If ($iconCode -notin ($anow_assets.icon_library."$iconSet")) {
                Write-Warning -Message "The icon [$iconCode] does not appear to exist within the [$iconSet] icon set. Please check again."
                Break
            }
        }
        If (($RemoveIcon -eq $true) -and ($iconCode.Length -gt 0 -or $iconSet.Length -gt 0)) {
            Write-Warning -Message "You cannot unset the Icon and set it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot unset the Description and set it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot unset the Folder and set it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot unset the Tags and set them at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetCodeRepository -eq $true -and $CodeRepository.Id.Length -gt 0) {
            Write-Warning -Message "You cannot unset the Code Repository and set it at the same time. Please choose one or the other."
            Break
        }
        [string]$command = '/businessView/update'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWBusinessView]$BusinessView = $_
        }
        [string]$BusinessView_id = $BusinessView.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$BusinessView_id")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$BusinessView_exists = ($null -eq (Get-AutomateNOWBusinessView -Id $BusinessView_id))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWBusinessView failed to check if the Business View [$BusinessView_id] already existed due to [$Message]."
                Break
            }
            If ($BusinessView_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not a Business View named [$BusinessView_id] in the current domain [$current_domain]. Please check into this."
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $BusinessView_id
            [string]$old_values = $BusinessView.CreateOldValues()
            If ($Description.Length -gt 0) {
                $BodyMetaData.'description' = $Description
            }
            ElseIf ($UnsetDescription -eq $true) {
                $BodyMetaData.'description' = $null
            }
            If ($iconCode.Length -gt 0) {
                $BodyMetaData.'iconSet' = $iconSet
                $BodyMetaData.'iconCode' = $iconCode
            }
            ElseIf ($RemoveIcon -eq $true) {
                $BodyMetaData.'iconCode' = $null
                $BodyMetaData.'iconSet' = $null # Note: The application will revert to a default value of FAT_COW when you try to set this to null (as of Patch 89)
            }
            If ($Tags.Count -gt 0) {
                [int32]$total_tags = $Tags.Count
                [int32]$current_tag = 1
                ForEach ($tag_id in $Tags) {
                    $Error.Clear()
                    Try {
                        [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] under Set-AutomateNOWBusinessView due to [$message]"
                        Break
                    }
                    If ($tag_object.simpleId.length -eq 0) {
                        Throw "Set-AutomateNOWBusinessView has detected that the tag [$tag_id] does not appear to exist. Please check again."
                        Break
                    }
                    ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                        [string]$tag_object_simpleId = $tag_object.simpleId
                        Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                        Break
                    }
                    [string]$tag_display = $tag_object | ConvertTo-Json -Compress
                    Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
                    [string]$tag_name_sequence = ('tags' + $current_tag)
                    $BodyMetaData.$tag_name_sequence = $tag_id
                    $current_tag++
                }
            }
            ElseIf ($UnsetTags -eq $true) {
                $BodyMetaData.'tags' = $null
            }
            If ($Folder.Length -gt 0) {
                $Error.Clear()
                Try {
                    [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] actually existed under Set-AutomateNOWBusinessView due to [$Message]"
                    Break
                }
                If ($folder_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] under Set-AutomateNOWBusinessView. Please check again."
                    Break
                }
                [string]$folder_display = $folder_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Adding folder $folder_display to Business View [$Id]"
                $BodyMetaData.'folder' = $Folder
            }
            ElseIf ($UnsetFolder -eq $true) {
                $BodyMetaData.'folder' = $null
            }
            If ($CodeRepository.Id.Length -gt 0) {
                [string]$CodeRepository_Id = $CodeRepository.Id
                $Error.Clear()
                Try {
                    [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository_Id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository_Id] actually existed under Set-AutomateNOWBusinessView due to [$Message]"
                    Break
                }
                If ($code_repository_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository_Id] under Set-AutomateNOWBusinessView. Please check again."
                    Break
                }
                $BodyMetaData.'codeRepository' = $CodeRepository_Id
            }
            ElseIf ($UnsetCodeRepository -eq $true) {
                $BodyMetaData.'codeRepository' = $null
            }
            $BodyMetaData.'_oldValues' = $old_values
            $BodyMetaData.'_operationType' = 'update'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_dataSource' = 'BusinessViewDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$BusinessView_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Business View $BusinessView_id was successfully updated"
            $Error.Clear()
            Try {
                [ANOWBusinessView]$UpdatedBusinessView = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the returned updated object to an [ANOWBusinessView] object due to [$Message]. The object was still updated though."
                Break
            }
            If ($Quiet -ne $true) {
                Return $UpdatedBusinessView
            }
        }
    }
    End {
    }
}

Function Export-AutomateNOWBusinessView {
    <#
    .SYNOPSIS
    Exports the Business Views from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Business Views from an instance of AutomateNOW! to a local .csv file

    .PARAMETER BusinessView
    Mandatory [ANOWBusinessView] object (Use Get-AutomateNOWBusinessView to retrieve them)

    .INPUTS
    ONLY [ANOWBusinessView] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWBusinessView] objects are exported to the local disk in CSV format

    .EXAMPLE
    Get-AutomateNOWBusinessView | Export-AutomateNOWBusinessView

    .EXAMPLE
    Get-AutomateNOWBusinessView -Id 'BusinessView01' | Export-AutomateNOWBusinessView

    .EXAMPLE
    @( 'BusinessView01', 'BusinessView02' ) | Get-AutomateNOWBusinessView | Export-AutomateNOWBusinessView

    .EXAMPLE
    Get-AutomateNOWBusinessView | Where-Object { $_.simpleId -eq 'BusinessView01' } | Export-AutomateNOWBusinessView

    .NOTES
	You must present [ANOWBusinessView] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWBusinessView]$BusinessView
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-BusinessViews-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWBusinessView]$BusinessView = $_
        }
        $Error.Clear()
        Try {
            $BusinessView | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWBusinessView] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function New-AutomateNOWBusinessView {
    <#
    .SYNOPSIS
    Creates a Business View within an AutomateNOW! instance

    .DESCRIPTION
    Creates a Business View within an AutomateNOW! instance and returns back the newly created [ANOWBusinessView] object

    .PARAMETER Id
    The intended name of the Business View. For example: 'BusinessView1'. This value may not contain the domain in brackets.

    .PARAMETER Description
    Optional description of the Business View (may not exceed 255 characters).

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new Business View.

    .PARAMETER Folder
    Optional name of the folder to place the Business View into.

    .PARAMETER iconSet
    Mandatory string representing a choice between three icon sets. Valid choices are: FAT_COW, FUGUE, FONT_AWESOME

    .PARAMETER iconCode
    The name of the icon which matches the chosen library. Must be lower-case.

    .PARAMETER CodeRepository
    Optional name of the code repository to place the Business View into.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWBusinessView.

    .OUTPUTS
    An [ANOWBusinessView] object representing the newly created Business View

    .EXAMPLE
    New-AutomateNOWBusinessView -Id 'BusinessView1' -Description 'BusinessView1 description' -Tags 'Tag1', 'Tag2' -Folder 'Folder1' -iconSet 'FAT_COW' -iconCode 'paper_airplane' -codeRepository 'Repository1'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The name (id) of the Business View must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    The names of the icon is not enforced here! If you want to know the names of the available icons try running Import-AutomateNOWLocalIcon then review the $anow_assets.icon_library global variable.

    #>
    [OutputType([ANOWBusinessView])]
    [Cmdletbinding(DefaultParameterSetName = 'Default')]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $true, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $true, ParameterSetName = 'iconSet')]
        [string]$Id,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'iconSet', HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'iconSet')]
        [string[]]$Tags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'iconSet')]
        [string]$Folder,
        [Parameter(Mandatory = $true, ParameterSetName = 'iconSet')]
        [ANOWIcon_IconsOnly]$iconSet,
        [ValidateScript({ $_ -match '^[a-z0-9-_]{1,}$' })]
        [Parameter(Mandatory = $true, ParameterSetName = 'iconSet')]
        [string]$iconCode,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'iconSet')]
        [string]$CodeRepository,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'iconSet')]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [boolean]$BusinessView_exists = ($null -ne (Get-AutomateNOWBusinessView -Id $Id))
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWBusinessView failed to check if the Business View [$Id] already existed due to [$Message]."
        Break
    }
    If ($BusinessView_exists -eq $true) {
        [string]$current_domain = $anow_session.header.domain
        Write-Warning -Message "There is already a Business View named [$Id] in [$current_domain]. Please check into this."
        Break
    }
    ## End warning ##
    [System.Collections.Specialized.OrderedDictionary]$ANOWBusinessView = [System.Collections.Specialized.OrderedDictionary]@{}
    $ANOWBusinessView.Add('id', $Id)
    If ($Description.Length -gt 0) {
        $ANOWBusinessView.Add('description', $Description)
    }
    If ($Tags.Count -gt 0) {
        [int32]$total_tags = $Tags.Count
        [int32]$current_tag = 1
        ForEach ($tag_id in $Tags) {
            $Error.Clear()
            Try {
                [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] under New-AutomateNOWBusinessView due to [$message]"
                Break
            }
            If ($tag_object.simpleId.length -eq 0) {
                Throw "New-AutomateNOWBusinessView has detected that the tag [$tag_id] does not appear to exist. Please check again."
                Break
            }
            ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                [string]$tag_object_simpleId = $tag_object.simpleId
                Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                Break
            }
            [string]$tag_display = $tag_object | ConvertTo-Json -Compress
            Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
            [string]$tag_name_sequence = ('tags' + $current_tag)
            $ANOWBusinessView.Add($tag_name_sequence, $tag_id)
            $include_properties += $tag_name_sequence
            $current_tag++
        }
    }
    If ($Folder.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] actually existed under New-AutomateNOWBusinessView due to [$Message]"
            Break
        }
        If ($folder_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] under New-AutomateNOWBusinessView. Please check again."
            Break
        }
        [string]$folder_display = $folder_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding folder $folder_display to [ANOWBusinessView] [$Id]"
        $ANOWBusinessView.Add('folder', $Folder)
        $include_properties += 'folder'
    }
    If ($CodeRepository.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository] actually existed under New-AutomateNOWBusinessView due to [$Message]"
            Break
        }
        If ($code_repository_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository] under New-AutomateNOWBusinessView. Please check again."
            Break
        }
        [string]$code_repository_display = $code_repository_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding code repository $code_repository_display to [ANOWBusinessView] [$Id]"
        $ANOWBusinessView.Add('codeRepository', $CodeRepository)
        $include_properties += 'codeRepository'
    }
    If ($iconSet.Length -gt 0) {
        $ANOWBusinessView.'iconSet' = $iconSet
    }
    If ($iconCode.Length -gt 0) {
        $ANOWBusinessView.'iconCode' = $iconCode
    }
    [string]$BodyObject = ConvertTo-QueryString -InputObject $ANOWBusinessView -IncludeProperties id, description, tags, folder, codeRepository, iconSet, iconCode
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    $BodyMetaData.'_operationType' = 'add'
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_oldValues' = '{}'
    $BodyMetaData.'_componentId' = 'BusinessViewCreateWindow_form'
    $BodyMetaData.'_dataSource' = 'BusinessViewDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$BodyMetaDataString = ConvertTo-QueryString -InputObject $BodyMetaData
    [string]$Body = ($BodyObject + '&' + $BodyMetaDataString)
    [string]$command = '/BusinessView/create'
    [hashtable]$parameters = @{}
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('Body', $Body)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWBusinessView]$BusinessView = $results.response.data | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to create a new [ANOWBusinessView] object due to [$Message]."
        Break
    }
    If ($BusinessView.id.Length -eq 0) {
        Write-Warning -Message "Somehow the newly created [ANOWBusinessView] object is empty!"
        Break
    }
    Return $BusinessView

}

Function Remove-AutomateNOWBusinessView {
    <#
    .SYNOPSIS
    Removes a Business View from an AutomateNOW! instance

    .DESCRIPTION
    Removes a Business View from an AutomateNOW! instance

    .PARAMETER BusinessView
    An [ANOWBusinessView] object representing the Business View to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWBusinessView] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Get-AutomateNOWBusinessView -Id 'BusinessView01' | Remove-AutomateNOWBusinessView

    .EXAMPLE
    @( 'BusinessView1', 'BusinessView2', 'BusinessView3') | Remove-AutomateNOWBusinessView

    .EXAMPLE
    Get-AutomateNOWBusinessView | Where-Object { $_.simpleId -match 'MyBusinessView' } | Remove-AutomateNOWBusinessView

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWBusinessView]$BusinessView,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/BusinessView/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWBusinessView]$BusinessView = $_
        }
        [string]$BusinessView_id = $BusinessView.id
        If ($BusinessView_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($BusinessView_id)")) -eq $true) {
            [string]$oldvalues = $BusinessView.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $BusinessView_id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'BusinessViewList'
            $BodyMetaData.'_dataSource' = 'BusinessViewDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$BusinessView_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Business View $BusinessView_id successfully removed"
        }
    }
    End {

    }
}

Function Copy-AutomateNOWBusinessView {
    <#
    .SYNOPSIS
    Copies a Business View from an AutomateNOW! instance

    .DESCRIPTION
    Copies a Business View from an AutomateNOW! instance. AutomateNOW object id can never be changed, but we can copy the Business View to a new object with a new Id and it will include all of the settings but not the items.

    .PARAMETER BusinessView
    Mandatory [ANOWBusinessView] object to be copied.

    .PARAMETER NewId
    The name (Id) of the new Business View. The new Id must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    .PARAMETER UnsetDescription
    Optional switch that will ensure that the newly created Business View will not have a description set.

    .PARAMETER Description
    Optional description to set on the new Business View object. If you do not set this, the new Business View object will copy the Description of the source object.

    .PARAMETER UnsetFolder
    Optional switch that will ensure that the newly created Business View will not have a Folder set.

    .PARAMETER Folder
    Optional description to set a different folder on the new Business View object. If you do not set this, the new Business View object will use the same Folder of the source object.

    .PARAMETER UnsetTags
    Optional switch that will ensure that the newly created Business View will not have any Tags set.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the new Business View object. If you do not set this, the new Business View object will apply the same Tags of the source object.

    .PARAMETER Force
    Force the copy without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    ONLY [ANOWBusinessView] object is accepted. Pipeline support is intentionally unavailable.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Creates a copy of an Business View and changes the description (multi-line format)
    $BusinessView01 = Get-AutomateNOWBusinessView -Id 'BusinessView_01'
    Copy-AutomateNOWBusinessView -BusinessView $BusinessView01 -NewId 'BusinessView_01_production' -Description 'BusinessView 01 Production'

    .EXAMPLE
    Creates a copy of an Business View that omits the description (one-liner format)
    Copy-AutomateNOWBusinessView -BusinessView (Get-AutomateNOWBusinessView -Id 'BusinessView_01') -NewId 'BusinessView_01_production' -UnsetDescription -Tags 'Tag1', 'Tag2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWBusinessView]$BusinessView,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot set the Tags and unset them at the same time. Please choose one or the other. Tags from the source object will be carried over to the new object if you do not specify any tag-related parameters."
            Break
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$BusinessView_exists = ($null -ne (Get-AutomateNOWBusinessView -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWBusinessView failed to check if the Business View [$NewId] already existed due to [$Message]."
            Break
        }
        If ($BusinessView_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Business View named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End warning ##
        [string]$command = '/BusinessView/copy'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            [string]$BusinessView_oldId = $BusinessView.id
            [string]$BusinessView_simpleId = $BusinessView.simpleId
            If ($BusinessView_oldId -eq $NewId) {
                Write-Warning -Message "The new id cannot be the same as the old id."
                Break
            }
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Copy the BusinessView $($BusinessView_simpleId) to $($NewId)?")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                If ($UnsetFolder -eq $True) {
                    $BodyMetaData.'folder' = $Null
                }
                ElseIf ($Folder.Length -gt 0) {
                    $BodyMetaData.'folder' = $Folder
                }
                Else {
                    If ($BusinessView.folder.Length -gt 0) {
                        $BodyMetaData.'folder' = $BusinessView.folder
                    }
                }
                If ($Tags.Count -gt 0) {
                    [int32]$tag_count = 1
                    ForEach ($tag in $Tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
                ElseIf ($UnsetTags -eq $true) {
                    $BodyMetaData.'tags' = $Null
                }
                Else {
                    If ($BusinessView.Tags -gt 0) {
                        [int32]$tag_count = 1
                        ForEach ($tag in $BusinessView.tags) {
                            $BodyMetaData.('tags' + $tag_count ) = $tag
                            $tag_count++
                        }
                    }
                }
                $BodyMetaData.'oldId' = $BusinessView_oldId
                $BodyMetaData.'domain' = $BusinessView.domain
                $BodyMetaData.'id' = $NewId
                If ($UnsetDescription -ne $true) {
                    If ($Description.Length -gt 0) {
                        $BodyMetaData.'description' = $Description
                    }
                    Else {
                        $BodyMetaData.'description' = $BusinessView.description
                    }
                }
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_operationId' = 'copy'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_dataSource' = 'BusinessViewDataSource'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties oldId, domain, NewId, description, folder, tags
                $parameters.Body = $Body
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$BusinessView_oldId] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                $Error.Clear()
                Try {
                    [ANOWBusinessView]$NewBusinessView = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to create copied [ANOWBusinessView] object [$NewId] due to [$Message]."
                    Break
                }
                If ($NewBusinessView.id.Length -eq 0) {
                    Write-Warning -Message "Somehow the newly created (copied) [ANOWBusinessView] object [$NewId] is empty!"
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $NewBusinessView
                }
            }
        }
    }
    End {

    }
}

Function Rename-AutomateNOWBusinessView {
    <#
    .SYNOPSIS
    Renames a Business View on an AutomateNOW! instance

    .DESCRIPTION
    Performs a psuedo-rename operations of a Business View from an AutomateNOW! instance by copying it first and then deleting the source. This function merely combines Copy-AutomateNOWBusiness View and Remove-AutomateNOWBusinessView therefore it is to be considered destructive.

    .PARAMETER BusinessView
    An [ANOWBusinessView] object representing the Business View to be renamed.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the Business View. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER Force
    Force the renaming without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly renamed object.

    .INPUTS
    ONLY [ANOWBusinessView] objects are accepted. There is intentionally no support for the pipeline.

    .OUTPUTS
    The newly renamed [ANOWBusinessView] object will be returned.

    .EXAMPLE
    $BusinessView = Get-AutomateNOWBusinessView -Id 'BusinessView01'
    Rename-AutomateNOWBusinessView -BusinessView $BusinessView -NewId 'BusinessView_01'

    .EXAMPLE
    Rename-AutomateNOWBusinessView -BusinessView (Get-AutomateNOWBusinessView -Id 'BusinessView01') -NewId 'BusinessView_01'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    When renaming, you may only specify a different Id (name).

    This action will be blocked if any existing referrals are found on the object.
    #>
    [OutputType([ANOWBusinessView])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWBusinessView]$BusinessView,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin standard warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$new_BusinessView_exists = ($null -ne (Get-AutomateNOWBusinessView -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWBusinessView failed to check if the Business View [$NewId] already existed due to [$Message]."
            Break
        }
        If ($new_BusinessView_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Business View named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        #[string]$BusinessView_id = $BusinessView.id
        [string]$BusinessView_id = $BusinessView.simpleId
        $Error.Clear()
        Try {
            [boolean]$old_BusinessView_exists = ($null -ne (Get-AutomateNOWBusinessView -Id $BusinessView_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWBusinessView failed to check if the Business View [$BusinessView_id] already existed due to [$Message]."
            Break
        }
        If ($old_BusinessView_exists -eq $false) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not a Business View named [$BusinessView_id] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End standard warning ##
        ## Begin referrals warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [int32]$referrals_count = Find-AutomateNOWObjectReferral -BusinessView $BusinessView -Count | Select-Object -Expandproperty referrals
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Find-AutomateNOWObjectReferral failed to extract the referrals on Business View [$BusinessView_id] due to [$Message]."
            Break
        }
        If ($referrals_count -gt 0) {
            Write-Warning -Message "Unfortunately, you cannot rename a Business View that has referrals. This is because the rename is not actually renaming but copying anew and deleting the old. Please, use the Find-AutomateNOWObjectReferral function to identify referrals and remove them."
            Break
        }
        Else {
            Write-Verbose -Message "The Business View [$BusinessView_id] does not have any referrals. It is safe to proceed."
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($BusinessView_id)")) -eq $true) {
                $Error.Clear()
                Try {
                    [ANOWBusinessView]$new_BusinessView = Copy-AutomateNOWBusinessView -BusinessView $BusinessView -NewId $NewId -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Copy-AutomateNOWBusinessView failed to create a new Business View [$NewId] as Part 1 of the renaming process due to [$Message]."
                    Break
                }
                If ($new_BusinessView.simpleId -eq $NewId) {
                    Write-Verbose -Message "Part 1: Business View [$BusinessView_id] successfully copied to [$NewId]"
                }
                Else {
                    Write-Warning -Message "Somehow the first phase (Copy-AutomateNOWBusinessView) failed. Please look into this."
                    Break
                }
                $Error.Clear()
                Try {
                    Remove-AutomateNOWBusinessView -BusinessView $BusinessView -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Remove-AutomateNOWBusinessView failed to remove [$BusinessView_id] as Part 2 of the renaming process due to [$Message]."
                    Break
                }
                Write-Verbose -Message "Part 2: Business View [$BusinessView_id] removed"
                Write-Verbose -Message "Task [$BusinessView_id] successfully renamed to [$NewId]"
                If ($Quiet -ne $true) {
                    Return $new_BusinessView
                }
            }
        }
        Else {
            Write-Warning -Message "No action was taken because either the source object didn't exist or the new object already existed"
        }
    }
    End {
    }
}

#endregion

#Region - BusinessView Items

Function Read-AutomateNOWBusinessViewItem {
    <#
    .SYNOPSIS
    Reads the items in a Business View on an AutomateNOW! instance

    .DESCRIPTION
    Reads the items in a Business View on an AutomateNOW! instance

    .PARAMETER BusinessView
    The [ANOWBusinessView] object representing the Business View to be read.

    .PARAMETER sortBy
    Optional string parameter to sort the results by. Valid choices are: item, id, businessView, createdBy, dateCreated, description, lastUpdatedBy, lastUpdated

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .INPUTS
    ONLY [ANOWBusinessView] objects are accepted (including from the pipeline)

    .OUTPUTS
    [BusinessViewItem] objects will be returned.

    .EXAMPLE
    Gets the first 100 Business View Items from a Business View named 'BusinessView1' via the pipeline

    Get-AutomateNOWBusinessView -Id 'BusinessView1' | Read-AutomateNOWBusinessViewItem

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWBusinessViewItem[]])]
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWBusinessView]$BusinessView,
        [Parameter(Mandatory = $False)]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False)]
        [int32]$endRow = 100,
        [ValidateSet( 'id', 'item', 'businessView', 'createdBy', 'dateCreated', 'description', 'lastUpdatedBy', 'lastUpdated', ignoreCase = $false)]
        [Parameter(Mandatory = $False)]
        [string]$sortBy = 'id',
        [Parameter(Mandatory = $False)]
        [switch]$Descending,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWBusinessView]$BusinessView = $_
        }
        [string]$BusinessView_id = $BusinessView.Id
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        $BodyMetaData.Add('businessView', $BusinessView_id)
        $BodyMetaData.Add('_operationType', 'fetch')
        $BodyMetaData.Add('_startRow', $startRow)
        $BodyMetaData.Add('_endRow', $endRow)
        If ($Descending -eq $true) {
            $BodyMetaData.'_sortBy' = '-' + $sortBy
        }
        Else {
            $BodyMetaData.'_sortBy' = $sortBy
        }
        $BodyMetaData.Add('_textMatchStyle', 'substring')
        $BodyMetaData.Add('_componentId', 'BusinessViewItemList')
        $BodyMetaData.Add('_dataSource', 'BusinessViewItemDataSource')
        $BodyMetaData.Add('isc_metaDataPrefix', '_')
        $BodyMetaData.Add('isc_dataFormat', 'json')
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        [string]$command = ('/businessViewItem/read' + '?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.'Command' = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ScheduleTemplate_id] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        If ($results.response.data.count -gt 0) {
            Try {
                [ANOWBusinessViewItem[]]$BusinessViewItems = $results.response.data
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the Business View Items from $BusinessView_id due to [$Message]"
                Break
            }
            Write-Verbose -Message "Business View Items successfully read from $BusinessView_id"
            If ($BusinessViewItems.Count -gt 0) {
                Return $BusinessViewItems
            }
        }
        Else {
            Write-Verbose -Message "There were no Business View Items within $BusinessView_id"
        }
    }
    End {

    }
}

Function Add-AutomateNOWBusinessViewItem {
    <#
    .SYNOPSIS
    Adds a Business View Item to a Business View within an AutomateNOW! instance

    .DESCRIPTION
    Adds a Business View Item to a Business View within an AutomateNOW! instance

    .PARAMETER BusinessView
    Mandatory [ANOWBusinessView] object. Use Get-AutomateNOWBusinessView to get this object.

    .PARAMETER itemType
    Required type of the Business View Item. Valid options are: PROCESSING, RESOURCE, SERVER_NODE & BUSINESS_VIEW

    .PARAMETER ProcessingTemplate
    Mandatory [ANOWProcessingTemplate] object (if itemType is PROCESSING). This includes the following object types: Task Templates, Workflow Templates, Schedule Templates and ServiceManager Templates. Integration Template objects are not supported yet.

    .PARAMETER Resource
    Mandatory [ANOWResource] object (if itemType is RESOURCE). This includes the following object types: Calendars, Events, Locks, Metrics, PhysicalResources, Semaphores, Stocks, TimeWindows, Variables

    .PARAMETER ServerNode
    Mandatory [ANOWServerNode] object (if itemType is SERVER_NODE). This includes the following object types: Server Nodes

    .PARAMETER BusinessViewChild
    Mandatory [ANOWBusinessView] object (if itemType is BUSINESS_VIEW). This includes the following object types: Business Views

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object

    .PARAMETER Force
    Force the addition of the object without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    An [ANOWBusinessView] object, the type of Item being added and other objects depending on the parameters.

    .OUTPUTS
    An [ANOWBusinessViewItem] object representing the newly created BusinessViewItem

    .EXAMPLE
    Forcefully adds the first five server nodes to a Business View named 'BusinessView1'

    $business_view = Get-AutomateNOWBusinessView -Id 'BusinessView1'
    Get-AutomateNOWServerNode -startRow 0 -endRow 5 | Add-AutomateNOWBusinessViewItem -BusinessView $business_view -Force

    .EXAMPLE
    Adds a Task Template named 'TaskTemplate1' to a Business View using the pipeline

    Get-AutomateNOWWorkflowTemplate -Id 'TaskTemplate1' | Add-AutomateNOWBusinessViewItem -BusinessView (Get-AutomateNOWBusinessView -Id 'BusinessView1')

    .EXAMPLE
    Adds a Task Template named 'TaskTemplate1' to a Business View without using the pipeline

    Add-AutomateNOWBusinessViewItem -BusinessView (Get-AutomateNOWBusinessView -Id 'BusinessView1') -ProcessingTemplate (Get-AutomateNOWWorkflowTemplate -Id 'TaskTemplate1')

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The parameter BusinessViewChild is used because the BusinessView parameter was already occupied.

    #>
    [OutputType([ANOWDataSourceItem])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'PROCESSING')]
        [Parameter(Mandatory = $true, ParameterSetName = 'RESOURCE')]
        [Parameter(Mandatory = $true, ParameterSetName = 'SERVER_NODE')]
        [Parameter(Mandatory = $true, ParameterSetName = 'BUSINESS_VIEW')]
        [ANOWBusinessview]$BusinessView,
        [Parameter(Mandatory = $true, ParameterSetName = 'PROCESSING', ValueFromPipeline = $true)]
        [ANOWProcessingTemplate]$ProcessingTemplate,
        [Parameter(Mandatory = $true, ParameterSetName = 'RESOURCE', ValueFromPipeline = $true)]
        [ANOWResource]$Resource,
        [Parameter(Mandatory = $true, ParameterSetName = 'SERVER_NODE', ValueFromPipeline = $true)]
        [ANOWServerNode]$ServerNode,
        [Parameter(Mandatory = $true, ParameterSetName = 'BUSINESS_VIEW', ValueFromPipeline = $true)]
        [ANOWBusinessView]$BusinessViewChild,
        [Parameter(Mandatory = $false, ParameterSetName = 'PROCESSING')]
        [Parameter(Mandatory = $false, ParameterSetName = 'RESOURCE')]
        [Parameter(Mandatory = $false, ParameterSetName = 'SERVER_NODE')]
        [Parameter(Mandatory = $false, ParameterSetName = 'BUSINESS_VIEW')]
        [switch]$Quiet,
        [Parameter(Mandatory = $false, ParameterSetName = 'PROCESSING')]
        [Parameter(Mandatory = $false, ParameterSetName = 'RESOURCE')]
        [Parameter(Mandatory = $false, ParameterSetName = 'SERVER_NODE')]
        [Parameter(Mandatory = $false, ParameterSetName = 'BUSINESS_VIEW')]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        [string]$BusinessView_Id = $BusinessView.Id
        $Error.Clear()
        Try {
            [ANOWBusinessViewItem[]]$BusinessView_Items = $BusinessView | Read-AutomateNOWBusinessViewItem
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Read-AutomateNOWBusinessViewItem failed to read the Business View Items within $BusinessView_Id under Add-AutomateNOWBusinessViewItem due to [$Message]."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Command', '/businessViewItem/create')
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_ -is [ANOWProcessingTemplate] -or $ProcessingTemplate.id.Length -gt 0) {
            [string]$Type = 'PROCESSING'
            If ($_ -is [ANOWProcessingTemplate]) {
                [ANOWProcessingTemplate]$ProcessingTemplate = $_
            }
            [string]$item_id = $ProcessingTemplate.Id
            [ANOWProcessingEvent_processingType]$processingType = $ProcessingTemplate.processingType
            $BodyMetaData.'processingType' = $processingType
            If ($processingType -eq 'TASK') {
                $BodyMetaData.'taskType' = $ProcessingTemplate.taskType
            }
            ElseIf ($processingType -eq 'WORKFLOW') {
                $BodyMetaData.'workflowType' = $ProcessingTemplate.workflowType
            }
            ElseIf ($processingType -eq 'SERVICE') {
                $BodyMetaData.'serviceType' = $ProcessingTemplate.serviceType
                If ($ProcessingTemplate.serviceType -eq 'SENSOR') {
                    $BodyMetaData.'sensorType' = $ProcessingTemplate.sensorType
                }
                ElseIf ($ProcessingTemplate.serviceType -eq 'MONITOR') {
                    $BodyMetaData.'monitorType' = $ProcessingTemplate.monitorType
                }
                ElseIf ($ProcessingTemplate.serviceType -eq 'SERVICE_MANAGER') {
                    $BodyMetaData.'serviceManagerType' = $ProcessingTemplate.serviceManagerType
                    $BodyMetaData.'serverNodeType' = 'INTERNAL'
                }
                Else {
                    Write-Host "Somehow was not able to determine the serviceType of the processing template under Add-AutomateNOWBusinessViewItem"
                    Break
                }
            }
            ElseIf ($processingType -eq 'TRIGGER') {
                # There are no additional properties to add for the TRIGGER processingType
            }
            Else {
                Write-Host "Somehow was not able to determine the processingType of the supplied object under Add-AutomateNOWBusinessViewItem"
                Break
            }
            If ($ProcessingTemplate.Description.Length -gt 0) {
                $BodyMetaData.'description' = $ProcessingTemplate.description
            }
        }
        ElseIf ($_ -is [ANOWResource] -or $Resource.id.Length -gt 0) {
            [string]$Type = 'RESOURCE'
            If ($_ -is [ANOWResource]) {
                [ANOWResource]$Resource = $_
            }
            [string]$item_id = $Resource.Id
            [ANOWResource_resourceType]$resourceType = $Resource.resourceType
            $BodyMetaData.'resourceType' = $resourceType
            If ($Resource.Description.Length -gt 0) {
                $BodyMetaData.'description' = $Resource.description
            }
        }
        ElseIf ($_ -is [ANOWServerNode] -or $ServerNode.id.Length -gt 0) {
            [string]$Type = 'SERVER_NODE'
            If ($_ -is [ANOWServerNode]) {
                [ANOWServerNode]$ServerNode = $_
            }
            [string]$item_id = $ServerNode.Id
            [ANOWServerNode_serverNodeType]$serverNodeType = $ServerNode.serverNodeType
            $BodyMetaData.'serverNodeType' = $serverNodeType
            If ($ServerNode.Description.Length -gt 0) {
                $BodyMetaData.'description' = $ServerNode.description
            }
        }
        ElseIf ($_ -is [ANOWBusinessView] -or $BusinessViewChild.id.Length -gt 0) {
            [string]$Type = 'BUSINESS_VIEW'
            If ($_ -is [ANOWBusinessView]) {
                [ANOWBusinessView]$BusinessViewChild = $_
            }
            [string]$item_id = $BusinessViewChild.Id
            If ($item_id -eq $BusinessView_Id) {
                Write-Warning -Message "You cannot add a Business View to itself but you may add a Business View to a different Business View"
                Break
            }
            If ($BusinessViewChild.Description.Length -gt 0) {
                $BodyMetaData.'description' = $BusinessViewChild.description
            }
        }
        Else {
            Write-Host "Somehow was not able to determine the type of object that was supplied to Add-AutomateNOWBusinessViewItem"
            Break
        }
        [string]$item_simple_id = $item_id -split ']' | Select-Object -Last 1
        If ( ($BusinessView_Items | Select-Object -ExpandProperty item) -contains $item_simple_id) {
            Write-Warning -Message "$item_simple_id is already added to $BusinessView_Id"
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Add $item_id to $BusinessView_Id?")) -eq $true) {
            $BodyMetaData.'businessView' = $BusinessView_Id
            $BodyMetaData.'businessViewItemType' = $Type
            $BodyMetaData.'item' = $item_id
            $BodyMetaData.'_operationType' = 'add'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_dataSource' = 'BusinessViewItemDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            [string]$parameters_display = $parameters | ConvertTo-Json -Compress
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Business View Item item added to Business View $BusinessView_Id"
            If ($Quiet -ne $true) {
                Return $results.response.data
            }
        }
    }
    End {

    }
}

Function Remove-AutomateNOWBusinessViewItem {
    <#
    .SYNOPSIS
    Removes (deletes) an item from a Business View in an AutomateNOW! instance

    .DESCRIPTION
    Removes (deletes) an item from a Business View in an AutomateNOW! instance

    .PARAMETER BusinessViewItem
    Mandatory BusinessViewItem object to be removed from a Business View. Use Read-AutomateNOWBusinessViewItem to retrieve them.

    .PARAMETER Force
    Force the removal of the object without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the display of the results

    .INPUTS
    You must pass [ANOWBusinessViewItems] objects. The pipeline may be used.

    .OUTPUTS
    The object that was removed from the Business View will be returned

    .EXAMPLE
    Forcibly removes the first 100 (or less) Business View Items from a Business View named 'BusinessView1' via the pipeline
    Get-AutomateNOWBusinessView -Id 'BusinessView1' | Read-AutomateNOWBusinessViewItem | Remove-AutomateNOWBusinessViewItem -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([PSCustomObject])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWBusinessViewItem]$BusinessViewItem,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('Command', '/businessViewItem/delete')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Id.Length -gt 0 ) {
            [ANOWBusinessViewItem]$BusinessViewItem = $_
        }
        [string]$Item_id = $BusinessViewItem.id
        If ($Item_id.Length -eq 0) {
            Write-Warning -Message "Somehow a Business View Item with an empty Id was passed to Remove-AutomateNOWBusinessViewItem. Please look into this."
            Break
        }
        [string]$Item_Domain = $BusinessViewItem.domain
        If ($Item_Domain.Length -eq 0) {
            Write-Warning -Message "Somehow a Business View Item with an empty domain was passed to Remove-AutomateNOWBusinessViewItem. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$Item_id")) -eq $true) {
            [string]$old_values = $BusinessViewItem.CreateOldValues()
            $Body.'id' = $Item_id
            $Body.'_oldValues' = $old_values
            $Body.'_textMatchStyle' = 'exact'
            $Body.'_componentId' = 'BusinessViewItemList'
            $Body.'_dataSource' = 'BusinessViewItemDataSource'
            $Body.'isc_metaDataPrefix' = '_'
            $Body.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $Body
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "$Item_id was removed from its Business View"
        }
    }
    End {

    }
}

#endregion

#Region - Calendars (RESOURCE)

Function Get-AutomateNOWCalendar {
    <#
    .SYNOPSIS
    Gets the Calendar objects from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Calendar objects from an AutomateNOW! instance

    .PARAMETER Id
    Optional string containing the simple id of the Calendar to fetch or you can pipeline a series of simple id strings. You may not enter an array here.

    .PARAMETER Detailed
    Switch parameter to provide the detailed properties of the [ANOWCalendar] object. This may only be used in conjunction with -Id. Use this option to see the fully populated object.

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100. The console default hard limit is 10,000.

    .PARAMETER sortBy
    Optional string parameter to sort the results by (may not be used with the Id parameter). Valid choices are: {To be continued...}

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .PARAMETER Folder
    Optional string to filter by a particular Folder

    .PARAMETER Tags
    Optional string array of Tags to filter by. Note that the 'containsAny' operator will be used.

    .INPUTS
    Accepts a string representing the simple id of the Calendar from the pipeline or individually (but not an array).

    .OUTPUTS
    Either one or more [ANOWCalendar] objects

    .EXAMPLE
    Gets the first page of Calendar objects

    Get-AutomateNOWCalendar

    .EXAMPLE
    Gets the first 500 Calendar objects

    Get-AutomateNOWCalendar -startRow 0 -endRow 500

    .EXAMPLE
    Gets a single non-detailed Calendar named 'Calendar1'

    Get-AutomateNOWCalendar -Id 'Calendar1'

    .EXAMPLE
    Gets the detailed version of a Calendar object named 'Calendar1'

    Get-AutomateNOWCalendar -Id 'Calendar1' -Detailed

    .EXAMPLE
    Gets a series of Calendar objects through the pipeline

    'Calendar1', 'Calendar2' | Get-AutomateNOWCalendar

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(DefaultParameterSetName = 'All')]
    Param(
        [Parameter(Mandatory = $True, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [Parameter(Mandatory = $True, ParameterSetName = 'Detailed', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $True, ParameterSetName = 'Detailed')]
        [switch]$Detailed,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [string]$sortBy = 'id',
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [switch]$Descending,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [string]$Folder,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [string[]]$Tags
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 ) {
            [string]$Calendar_Id = $_
        }
        Else {
            [string]$Calendar_Id = $Id
        }
        If ($Detailed -eq $true) {
            $Body.'id' = $Calendar_Id
            [string]$textMatchStyle = 'exactCase'
            $Body.'_operationId' = 'readDetailed'
            [string]$Method = 'POST'
        }
        Else {
            $Body.'_constructor' = 'AdvancedCriteria'
            $Body.'operator' = 'and'
            $Body.'criteria1' = '{"fieldName":"resourceType","operator":"equals","value":"CALENDAR"}'
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
            If ($Calendar_Id.Length -gt 0) {
                $Body.'criteria2' = ('{"fieldName":"simpleId","operator":"equals","value":"' + $Calendar_Id + '"}')
                [string]$textMatchStyle = 'exact'
            }
            Else {
                [string]$textMatchStyle = 'substring'
            }
            If ($Folder.Length -gt 0) {
                $Body.'criteria3' = ('{"fieldName":"folder","operator":"equals","value":"' + $Folder + '"}')
            }
            If ($Tags.Count -gt 0) {
                If ($Tags.Count -gt 1) {
                    $Error.Clear()
                    Try {
                        [string]$TagString = $Tags | ConvertTo-Json -Compress
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "ConvertTo-Json failed to convert the provided tag names under Get-AutomateNOWCalendar due to [$Message]."
                        Break
                    }
                }
                Else {
                    [string]$TagString = $Tags
                }
                $Body.'criteria4' = ('{"fieldName":"tags","operator":"containsAny","value":' + $TagString + '}')
            }
            $Body.'_componentId' = 'ResourceList'
            If ($Descending -eq $true) {
                $Body.'_sortBy' = '-' + $sortBy
            }
            Else {
                $Body.'_sortBy' = $sortBy
            }
            [string]$Method = 'GET'
        }
        $Body.'_operationType' = 'fetch'
        $Body.'_textMatchStyle' = $textMatchStyle
        $Body.'_dataSource' = 'ResourceDataSource'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        If ($Detailed -eq $true) {
            [string]$command = ('/resource/readDetailed')
            If ($Null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            If ($null -eq $parameters["Command"]) {
                $parameters.Add('Command', $command)
            }
            Else {
                $parameters.Command = $command
            }
        }
        Else {
            [string]$command = ('/resource/read?' + $Body)
            $parameters.Command = $command
        }
        If ($null -eq $parameters.Method) {
            $parameters.Add('Method', $Method)
        }
        Else {
            $parameters.Method = $Method
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWCalendar[]]$Calendars = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCalendar failed to parse the results into [ANOWCalendar] objects due to [$Message]."
            Break
        }
        If ($Calendars.Count -gt 0) {
            Return $Calendars
        }
    }
    End {

    }
}

Function Export-AutomateNOWCalendar {
    <#
    .SYNOPSIS
    Exports the Calendar objects from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Calendar objects from an instance of AutomateNOW! to a local .csv file

    .PARAMETER Calendar
    Mandatory [ANOWCalendar] object (Use Get-AutomateNOWCalendar to retrieve them)

    .INPUTS
    ONLY [ANOWCalendar] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWCalendar] objects are exported to the local disk in CSV format

    .EXAMPLE
    Exports all of the Calendar objects (up to 100 by default)

    Get-AutomateNOWCalendar | Export-AutomateNOWCalendar

    .EXAMPLE
    Exports 1 Calendar by name

    Get-AutomateNOWCalendar -Id 'Calendar01' | Export-AutomateNOWCalendar

    .EXAMPLE
    Exports a series of Calendar objects by the pipeline

    @( 'Calendar01', 'Calendar02' ) | Get-AutomateNOWCalendar | Export-AutomateNOWCalendar

    .NOTES
	You must present [ANOWCalendar] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWCalendar]$Calendar
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-Calendars-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWCalendar]$Calendar = $_
        }
        $Error.Clear()
        Try {
            $Calendar | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWCalendar] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function New-AutomateNOWCalendar {
    <#
    .SYNOPSIS
    Creates a Calendar within an AutomateNOW! instance

    .DESCRIPTION
    Creates a Calendar within an AutomateNOW! instance and returns back the newly created [ANOWCalendar] object

    .PARAMETER Id
    The intended name of the Calendar. For example: 'calendar1'. This value may not contain the domain in brackets.

    .PARAMETER Description
    Optional description of the Calendar (may not exceed 255 characters).

    .PARAMETER Timezone
    Optional timezone for the calendar. If not specified, the default server timezone will be used. Valid choices are: 'Africa/Abidjan', 'Africa/Accra', 'Africa/Addis_Ababa', 'Africa/Algiers', 'Africa/Asmara', 'Africa/Asmera', 'Africa/Bamako', 'Africa/Bangui', 'Africa/Banjul', 'Africa/Bissau', 'Africa/Blantyre', 'Africa/Brazzaville', 'Africa/Bujumbura', 'Africa/Cairo', 'Africa/Casablanca', 'Africa/Ceuta', 'Africa/Conakry', 'Africa/Dakar', 'Africa/Dar_es_Salaam', 'Africa/Djibouti', 'Africa/Douala', 'Africa/El_Aaiun', 'Africa/Freetown', 'Africa/Gaborone', 'Africa/Harare', 'Africa/Johannesburg', 'Africa/Juba', 'Africa/Kampala', 'Africa/Khartoum', 'Africa/Kigali', 'Africa/Kinshasa', 'Africa/Lagos', 'Africa/Libreville', 'Africa/Lome', 'Africa/Luanda', 'Africa/Lubumbashi', 'Africa/Lusaka', 'Africa/Malabo', 'Africa/Maputo', 'Africa/Maseru', 'Africa/Mbabane', 'Africa/Mogadishu', 'Africa/Monrovia', 'Africa/Nairobi', 'Africa/Ndjamena', 'Africa/Niamey', 'Africa/Nouakchott', 'Africa/Ouagadougou', 'Africa/Porto-Novo', 'Africa/Sao_Tome', 'Africa/Timbuktu', 'Africa/Tripoli', 'Africa/Tunis', 'Africa/Windhoek', 'America/Adak', 'America/Anchorage', 'America/Anguilla', 'America/Antigua', 'America/Araguaina', 'America/Argentina/Buenos_Aires', 'America/Argentina/Catamarca', 'America/Argentina/ComodRivadavia', 'America/Argentina/Cordoba', 'America/Argentina/Jujuy', 'America/Argentina/La_Rioja', 'America/Argentina/Mendoza', 'America/Argentina/Rio_Gallegos', 'America/Argentina/Salta', 'America/Argentina/San_Juan', 'America/Argentina/San_Luis', 'America/Argentina/Tucuman', 'America/Argentina/Ushuaia', 'America/Aruba', 'America/Asuncion', 'America/Atikokan', 'America/Atka', 'America/Bahia', 'America/Bahia_Banderas', 'America/Barbados', 'America/Belem', 'America/Belize', 'America/Blanc-Sablon', 'America/Boa_Vista', 'America/Bogota', 'America/Boise', 'America/Buenos_Aires', 'America/Cambridge_Bay', 'America/Campo_Grande', 'America/Cancun', 'America/Caracas', 'America/Catamarca', 'America/Cayenne', 'America/Cayman', 'America/Chicago', 'America/Chihuahua', 'America/Coral_Harbour', 'America/Cordoba', 'America/Costa_Rica', 'America/Creston', 'America/Cuiaba', 'America/Curacao', 'America/Danmarkshavn', 'America/Dawson', 'America/Dawson_Creek', 'America/Denver', 'America/Detroit', 'America/Dominica', 'America/Edmonton', 'America/Eirunepe', 'America/El_Salvador', 'America/Ensenada', 'America/Fort_Nelson', 'America/Fort_Wayne', 'America/Fortaleza', 'America/Glace_Bay', 'America/Godthab', 'America/Goose_Bay', 'America/Grand_Turk', 'America/Grenada', 'America/Guadeloupe', 'America/Guatemala', 'America/Guayaquil', 'America/Guyana', 'America/Halifax', 'America/Havana', 'America/Hermosillo', 'America/Indiana/Indianapolis', 'America/Indiana/Knox', 'America/Indiana/Marengo', 'America/Indiana/Petersburg', 'America/Indiana/Tell_City', 'America/Indiana/Vevay', 'America/Indiana/Vincennes', 'America/Indiana/Winamac', 'America/Indianapolis', 'America/Inuvik', 'America/Iqaluit', 'America/Jamaica', 'America/Jujuy', 'America/Juneau', 'America/Kentucky/Louisville', 'America/Kentucky/Monticello', 'America/Knox_IN', 'America/Kralendijk', 'America/La_Paz', 'America/Lima', 'America/Los_Angeles', 'America/Louisville', 'America/Lower_Princes', 'America/Maceio', 'America/Managua', 'America/Manaus', 'America/Marigot', 'America/Martinique', 'America/Matamoros', 'America/Mazatlan', 'America/Mendoza', 'America/Menominee', 'America/Merida', 'America/Metlakatla', 'America/Mexico_City', 'America/Miquelon', 'America/Moncton', 'America/Monterrey', 'America/Montevideo', 'America/Montreal', 'America/Montserrat', 'America/Nassau', 'America/New_York', 'America/Nipigon', 'America/Nome', 'America/Noronha', 'America/North_Dakota/Beulah', 'America/North_Dakota/Center', 'America/North_Dakota/New_Salem', 'America/Nuuk', 'America/Ojinaga', 'America/Panama', 'America/Pangnirtung', 'America/Paramaribo', 'America/Phoenix', 'America/Port-au-Prince', 'America/Port_of_Spain', 'America/Porto_Acre', 'America/Porto_Velho', 'America/Puerto_Rico', 'America/Punta_Arenas', 'America/Rainy_River', 'America/Rankin_Inlet', 'America/Recife', 'America/Regina', 'America/Resolute', 'America/Rio_Branco', 'America/Rosario', 'America/Santa_Isabel', 'America/Santarem', 'America/Santiago', 'America/Santo_Domingo', 'America/Sao_Paulo', 'America/Scoresbysund', 'America/Shiprock', 'America/Sitka', 'America/St_Barthelemy', 'America/St_Johns', 'America/St_Kitts', 'America/St_Lucia', 'America/St_Thomas', 'America/St_Vincent', 'America/Swift_Current', 'America/Tegucigalpa', 'America/Thule', 'America/Thunder_Bay', 'America/Tijuana', 'America/Toronto', 'America/Tortola', 'America/Vancouver', 'America/Virgin', 'America/Whitehorse', 'America/Winnipeg', 'America/Yakutat', 'America/Yellowknife', 'Antarctica/Casey', 'Antarctica/Davis', 'Antarctica/DumontDUrville', 'Antarctica/Macquarie', 'Antarctica/Mawson', 'Antarctica/McMurdo', 'Antarctica/Palmer', 'Antarctica/Rothera', 'Antarctica/South_Pole', 'Antarctica/Syowa', 'Antarctica/Troll', 'Antarctica/Vostok', 'Arctic/Longyearbyen', 'Asia/Aden', 'Asia/Almaty', 'Asia/Amman', 'Asia/Anadyr', 'Asia/Aqtau', 'Asia/Aqto be', 'Asia/Ashgabat', 'Asia/Ashkhabad', 'Asia/Atyrau', 'Asia/Baghdad', 'Asia/Bahrain', 'Asia/Baku', 'Asia/Bangkok', 'Asia/Barnaul', 'Asia/Beirut', 'Asia/Bishkek', 'Asia/Brunei', 'Asia/Calcutta', 'Asia/Chita', 'Asia/Choibalsan', 'Asia/Chongqing', 'Asia/Chungking', 'Asia/Colombo', 'Asia/Dacca', 'Asia/Damascus', 'Asia/Dhaka', 'Asia/Dili', 'Asia/Dubai', 'Asia/Dushanbe', 'Asia/Famagusta', 'Asia/Gaza', 'Asia/Harbin', 'Asia/Hebron', 'Asia/Ho_Chi_Minh', 'Asia/Hong_Kong', 'Asia/Hovd', 'Asia/Irkutsk', 'Asia/Istanbul', 'Asia/Jakarta', 'Asia/Jayapura', 'Asia/Jerusalem', 'Asia/Kabul', 'Asia/Kamchatka', 'Asia/Karachi', 'Asia/Kashgar', 'Asia/Kathmandu', 'Asia/Katmandu', 'Asia/Khandyga', 'Asia/Kolkata', 'Asia/Krasnoyarsk', 'Asia/Kuala_Lumpur', 'Asia/Kuching', 'Asia/Kuwait', 'Asia/Macao', 'Asia/Macau', 'Asia/Magadan', 'Asia/Makassar', 'Asia/Manila', 'Asia/Muscat', 'Asia/Nicosia', 'Asia/Novokuznetsk', 'Asia/Novosibirsk', 'Asia/Omsk', 'Asia/Oral', 'Asia/Phnom_Penh', 'Asia/Pontianak', 'Asia/Pyongyang', 'Asia/Qatar', 'Asia/Qostanay', 'Asia/Qyzylorda', 'Asia/Rangoon', 'Asia/Riyadh', 'Asia/Saigon', 'Asia/Sakhalin', 'Asia/Samarkand', 'Asia/Seoul', 'Asia/Shanghai', 'Asia/Singapore', 'Asia/Srednekolymsk', 'Asia/Taipei', 'Asia/Tashkent', 'Asia/Tbilisi', 'Asia/Tehran', 'Asia/Tel_Aviv', 'Asia/Thimbu', 'Asia/Thimphu', 'Asia/Tokyo', 'Asia/Tomsk', 'Asia/Ujung_Pandang', 'Asia/Ulaanbaatar', 'Asia/Ulan_Bator', 'Asia/Urumqi', 'Asia/Ust-Nera', 'Asia/Vientiane', 'Asia/Vladivostok', 'Asia/Yakutsk', 'Asia/Yangon', 'Asia/Yekaterinburg', 'Asia/Yerevan', 'Atlantic/Azores', 'Atlantic/Bermuda', 'Atlantic/Canary', 'Atlantic/Cape_Verde', 'Atlantic/Faeroe', 'Atlantic/Faroe', 'Atlantic/Jan_Mayen', 'Atlantic/Madeira', 'Atlantic/Reykjavik', 'Atlantic/South_Georgia', 'Atlantic/St_Helena', 'Atlantic/Stanley', 'Australia/ACT', 'Australia/Adelaide', 'Australia/Brisbane', 'Australia/Broken_Hill', 'Australia/Canberra', 'Australia/Currie', 'Australia/Darwin', 'Australia/Eucla', 'Australia/Hobart', 'Australia/LHI', 'Australia/Lindeman', 'Australia/Lord_Howe', 'Australia/Melbourne', 'Australia/NSW', 'Australia/North', 'Australia/Perth', 'Australia/Queensland', 'Australia/South', 'Australia/Sydney', 'Australia/Tasmania', 'Australia/Victoria', 'Australia/West', 'Australia/Yancowinna', 'Brazil/Acre', 'Brazil/DeNoronha', 'Brazil/East', 'Brazil/West', 'CET', 'CST6CDT', 'Canada/Atlantic', 'Canada/Central', 'Canada/Eastern', 'Canada/Mountain', 'Canada/Newfoundland', 'Canada/Pacific', 'Canada/Saskatchewan', 'Canada/Yukon', 'Chile/Continental', 'Chile/EasterIsland', 'Cuba', 'EET', 'EST5EDT', 'Egypt', 'Eire', 'Etc/GMT', 'Etc/GMT+0', 'Etc/GMT+1', 'Etc/GMT+10', 'Etc/GMT+11', 'Etc/GMT+12', 'Etc/GMT+2', 'Etc/GMT+3', 'Etc/GMT+4', 'Etc/GMT+5', 'Etc/GMT+6', 'Etc/GMT+7', 'Etc/GMT+8', 'Etc/GMT+9', 'Etc/GMT-0', 'Etc/GMT-1', 'Etc/GMT-10', 'Etc/GMT-11', 'Etc/GMT-12', 'Etc/GMT-13', 'Etc/GMT-14', 'Etc/GMT-2', 'Etc/GMT-3', 'Etc/GMT-4', 'Etc/GMT-5', 'Etc/GMT-6', 'Etc/GMT-7', 'Etc/GMT-8', 'Etc/GMT-9', 'Etc/GMT0', 'Etc/Greenwich', 'Etc/UCT', 'Etc/UTC', 'Etc/Universal', 'Etc/Zulu', 'Europe/Amsterdam', 'Europe/Andorra', 'Europe/Astrakhan', 'Europe/Athens', 'Europe/Belfast', 'Europe/Belgrade', 'Europe/Berlin', 'Europe/Bratislava', 'Europe/Brussels', 'Europe/Bucharest', 'Europe/Budapest', 'Europe/Busingen', 'Europe/Chisinau', 'Europe/Copenhagen', 'Europe/Dublin', 'Europe/Gibraltar', 'Europe/Guernsey', 'Europe/Helsinki', 'Europe/Isle_of_Man', 'Europe/Istanbul', 'Europe/Jersey', 'Europe/Kaliningrad', 'Europe/Kiev', 'Europe/Kirov', 'Europe/Lisbon', 'Europe/Ljubljana', 'Europe/London', 'Europe/Luxembourg', 'Europe/Madrid', 'Europe/Malta', 'Europe/Mariehamn', 'Europe/Minsk', 'Europe/Monaco', 'Europe/Moscow', 'Europe/Nicosia', 'Europe/Oslo', 'Europe/Paris', 'Europe/Podgorica', 'Europe/Prague', 'Europe/Riga', 'Europe/Rome', 'Europe/Samara', 'Europe/San_Marino', 'Europe/Sarajevo', 'Europe/Saratov', 'Europe/Simferopol', 'Europe/Skopje', 'Europe/Sofia', 'Europe/Stockholm', 'Europe/Tallinn', 'Europe/Tirane', 'Europe/Tiraspol', 'Europe/Ulyanovsk', 'Europe/Uzhgorod', 'Europe/Vaduz', 'Europe/Vatican', 'Europe/Vienna', 'Europe/Vilnius', 'Europe/Volgograd', 'Europe/Warsaw', 'Europe/Zagreb', 'Europe/Zaporozhye', 'Europe/Zurich', 'GB', 'GB-Eire', 'GMT', 'GMT0', 'Greenwich', 'Hongkong', 'Iceland', 'Indian/Antananarivo', 'Indian/Chagos', 'Indian/Christmas', 'Indian/Cocos', 'Indian/Comoro', 'Indian/Kerguelen', 'Indian/Mahe', 'Indian/Maldives', 'Indian/Mauritius', 'Indian/Mayotte', 'Indian/Reunion', 'Iran', 'Israel', 'Jamaica', 'Japan', 'Kwajalein', 'Libya', 'MET', 'MST7MDT', 'Mexico/BajaNorte', 'Mexico/BajaSur', 'Mexico/General', 'NZ', 'NZ-CHAT', 'Navajo', 'PRC', 'PST8PDT', 'Pacific/Apia', 'Pacific/Auckland', 'Pacific/Bougainville', 'Pacific/Chatham', 'Pacific/Chuuk', 'Pacific/Easter', 'Pacific/Efate', 'Pacific/Enderbury', 'Pacific/Fakaofo', 'Pacific/Fiji', 'Pacific/Funafuti', 'Pacific/Galapagos', 'Pacific/Gambier', 'Pacific/Guadalcanal', 'Pacific/Guam', 'Pacific/Honolulu', 'Pacific/Johnston', 'Pacific/Kiritimati', 'Pacific/Kosrae', 'Pacific/Kwajalein', 'Pacific/Majuro', 'Pacific/Marquesas', 'Pacific/Midway', 'Pacific/Nauru', 'Pacific/Niue', 'Pacific/Norfolk', 'Pacific/Noumea', 'Pacific/Pago_Pago', 'Pacific/Palau', 'Pacific/Pitcairn', 'Pacific/Pohnpei', 'Pacific/Ponape', 'Pacific/Port_Moresby', 'Pacific/Rarotonga', 'Pacific/Saipan', 'Pacific/Samoa', 'Pacific/Tahiti', 'Pacific/Tarawa', 'Pacific/Tongatapu', 'Pacific/Truk', 'Pacific/Wake', 'Pacific/Wallis', 'Pacific/Yap', 'Poland', 'Portugal', 'ROK', 'Singapore', 'Turkey', 'UCT', 'US/Alaska', 'US/Aleutian', 'US/Arizona', 'US/Central', 'US/East-Indiana', 'US/Eastern', 'US/Hawaii', 'US/Indiana-Starke', 'US/Michigan', 'US/Mountain', 'US/Pacific', 'US/Samoa', 'UTC', 'Universal', 'W-SU', 'WET', 'Zulu', 'EST', 'HST', 'MST'

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new Calendar. Do not pass [ANOWTag] objects here.

    .PARAMETER Folder
    Optional name of the folder to place the Calendar into.

    .PARAMETER CodeRepository
    Optional name of the code repository to place the Calendar into.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWCalendar.

    .OUTPUTS
    An [ANOWCalendar] object representing the newly created Calendar

    .EXAMPLE
    New-AutomateNOWCalendar -Id 'Calendar01' -Type 'CAL_SELECT' -Description 'Description01' -Tags 'Tag01' -Folder 'Folder01'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The name (id) of the Calendar must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    #>
    [OutputType([ANOWCalendar])]
    [Cmdletbinding()]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $true)]
        [string]$Id,
        [Parameter(Mandatory = $true)]
        [ANOWResource_calendarType]$Type,
        [ValidateScript({ $_.Length -le 255 })]
        [Parameter(Mandatory = $false, HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [string]$Description,
        [ValidateSet('Africa/Abidjan', 'Africa/Accra', 'Africa/Addis_Ababa', 'Africa/Algiers', 'Africa/Asmara', 'Africa/Asmera', 'Africa/Bamako', 'Africa/Bangui', 'Africa/Banjul', 'Africa/Bissau', 'Africa/Blantyre', 'Africa/Brazzaville', 'Africa/Bujumbura', 'Africa/Cairo', 'Africa/Casablanca', 'Africa/Ceuta', 'Africa/Conakry', 'Africa/Dakar', 'Africa/Dar_es_Salaam', 'Africa/Djibouti', 'Africa/Douala', 'Africa/El_Aaiun', 'Africa/Freetown', 'Africa/Gaborone', 'Africa/Harare', 'Africa/Johannesburg', 'Africa/Juba', 'Africa/Kampala', 'Africa/Khartoum', 'Africa/Kigali', 'Africa/Kinshasa', 'Africa/Lagos', 'Africa/Libreville', 'Africa/Lome', 'Africa/Luanda', 'Africa/Lubumbashi', 'Africa/Lusaka', 'Africa/Malabo', 'Africa/Maputo', 'Africa/Maseru', 'Africa/Mbabane', 'Africa/Mogadishu', 'Africa/Monrovia', 'Africa/Nairobi', 'Africa/Ndjamena', 'Africa/Niamey', 'Africa/Nouakchott', 'Africa/Ouagadougou', 'Africa/Porto-Novo', 'Africa/Sao_Tome', 'Africa/Timbuktu', 'Africa/Tripoli', 'Africa/Tunis', 'Africa/Windhoek', 'America/Adak', 'America/Anchorage', 'America/Anguilla', 'America/Antigua', 'America/Araguaina', 'America/Argentina/Buenos_Aires', 'America/Argentina/Catamarca', 'America/Argentina/ComodRivadavia', 'America/Argentina/Cordoba', 'America/Argentina/Jujuy', 'America/Argentina/La_Rioja', 'America/Argentina/Mendoza', 'America/Argentina/Rio_Gallegos', 'America/Argentina/Salta', 'America/Argentina/San_Juan', 'America/Argentina/San_Luis', 'America/Argentina/Tucuman', 'America/Argentina/Ushuaia', 'America/Aruba', 'America/Asuncion', 'America/Atikokan', 'America/Atka', 'America/Bahia', 'America/Bahia_Banderas', 'America/Barbados', 'America/Belem', 'America/Belize', 'America/Blanc-Sablon', 'America/Boa_Vista', 'America/Bogota', 'America/Boise', 'America/Buenos_Aires', 'America/Cambridge_Bay', 'America/Campo_Grande', 'America/Cancun', 'America/Caracas', 'America/Catamarca', 'America/Cayenne', 'America/Cayman', 'America/Chicago', 'America/Chihuahua', 'America/Coral_Harbour', 'America/Cordoba', 'America/Costa_Rica', 'America/Creston', 'America/Cuiaba', 'America/Curacao', 'America/Danmarkshavn', 'America/Dawson', 'America/Dawson_Creek', 'America/Denver', 'America/Detroit', 'America/Dominica', 'America/Edmonton', 'America/Eirunepe', 'America/El_Salvador', 'America/Ensenada', 'America/Fort_Nelson', 'America/Fort_Wayne', 'America/Fortaleza', 'America/Glace_Bay', 'America/Godthab', 'America/Goose_Bay', 'America/Grand_Turk', 'America/Grenada', 'America/Guadeloupe', 'America/Guatemala', 'America/Guayaquil', 'America/Guyana', 'America/Halifax', 'America/Havana', 'America/Hermosillo', 'America/Indiana/Indianapolis', 'America/Indiana/Knox', 'America/Indiana/Marengo', 'America/Indiana/Petersburg', 'America/Indiana/Tell_City', 'America/Indiana/Vevay', 'America/Indiana/Vincennes', 'America/Indiana/Winamac', 'America/Indianapolis', 'America/Inuvik', 'America/Iqaluit', 'America/Jamaica', 'America/Jujuy', 'America/Juneau', 'America/Kentucky/Louisville', 'America/Kentucky/Monticello', 'America/Knox_IN', 'America/Kralendijk', 'America/La_Paz', 'America/Lima', 'America/Los_Angeles', 'America/Louisville', 'America/Lower_Princes', 'America/Maceio', 'America/Managua', 'America/Manaus', 'America/Marigot', 'America/Martinique', 'America/Matamoros', 'America/Mazatlan', 'America/Mendoza', 'America/Menominee', 'America/Merida', 'America/Metlakatla', 'America/Mexico_City', 'America/Miquelon', 'America/Moncton', 'America/Monterrey', 'America/Montevideo', 'America/Montreal', 'America/Montserrat', 'America/Nassau', 'America/New_York', 'America/Nipigon', 'America/Nome', 'America/Noronha', 'America/North_Dakota/Beulah', 'America/North_Dakota/Center', 'America/North_Dakota/New_Salem', 'America/Nuuk', 'America/Ojinaga', 'America/Panama', 'America/Pangnirtung', 'America/Paramaribo', 'America/Phoenix', 'America/Port-au-Prince', 'America/Port_of_Spain', 'America/Porto_Acre', 'America/Porto_Velho', 'America/Puerto_Rico', 'America/Punta_Arenas', 'America/Rainy_River', 'America/Rankin_Inlet', 'America/Recife', 'America/Regina', 'America/Resolute', 'America/Rio_Branco', 'America/Rosario', 'America/Santa_Isabel', 'America/Santarem', 'America/Santiago', 'America/Santo_Domingo', 'America/Sao_Paulo', 'America/Scoresbysund', 'America/Shiprock', 'America/Sitka', 'America/St_Barthelemy', 'America/St_Johns', 'America/St_Kitts', 'America/St_Lucia', 'America/St_Thomas', 'America/St_Vincent', 'America/Swift_Current', 'America/Tegucigalpa', 'America/Thule', 'America/Thunder_Bay', 'America/Tijuana', 'America/Toronto', 'America/Tortola', 'America/Vancouver', 'America/Virgin', 'America/Whitehorse', 'America/Winnipeg', 'America/Yakutat', 'America/Yellowknife', 'Antarctica/Casey', 'Antarctica/Davis', 'Antarctica/DumontDUrville', 'Antarctica/Macquarie', 'Antarctica/Mawson', 'Antarctica/McMurdo', 'Antarctica/Palmer', 'Antarctica/Rothera', 'Antarctica/South_Pole', 'Antarctica/Syowa', 'Antarctica/Troll', 'Antarctica/Vostok', 'Arctic/Longyearbyen', 'Asia/Aden', 'Asia/Almaty', 'Asia/Amman', 'Asia/Anadyr', 'Asia/Aqtau', 'Asia/Aqto be', 'Asia/Ashgabat', 'Asia/Ashkhabad', 'Asia/Atyrau', 'Asia/Baghdad', 'Asia/Bahrain', 'Asia/Baku', 'Asia/Bangkok', 'Asia/Barnaul', 'Asia/Beirut', 'Asia/Bishkek', 'Asia/Brunei', 'Asia/Calcutta', 'Asia/Chita', 'Asia/Choibalsan', 'Asia/Chongqing', 'Asia/Chungking', 'Asia/Colombo', 'Asia/Dacca', 'Asia/Damascus', 'Asia/Dhaka', 'Asia/Dili', 'Asia/Dubai', 'Asia/Dushanbe', 'Asia/Famagusta', 'Asia/Gaza', 'Asia/Harbin', 'Asia/Hebron', 'Asia/Ho_Chi_Minh', 'Asia/Hong_Kong', 'Asia/Hovd', 'Asia/Irkutsk', 'Asia/Istanbul', 'Asia/Jakarta', 'Asia/Jayapura', 'Asia/Jerusalem', 'Asia/Kabul', 'Asia/Kamchatka', 'Asia/Karachi', 'Asia/Kashgar', 'Asia/Kathmandu', 'Asia/Katmandu', 'Asia/Khandyga', 'Asia/Kolkata', 'Asia/Krasnoyarsk', 'Asia/Kuala_Lumpur', 'Asia/Kuching', 'Asia/Kuwait', 'Asia/Macao', 'Asia/Macau', 'Asia/Magadan', 'Asia/Makassar', 'Asia/Manila', 'Asia/Muscat', 'Asia/Nicosia', 'Asia/Novokuznetsk', 'Asia/Novosibirsk', 'Asia/Omsk', 'Asia/Oral', 'Asia/Phnom_Penh', 'Asia/Pontianak', 'Asia/Pyongyang', 'Asia/Qatar', 'Asia/Qostanay', 'Asia/Qyzylorda', 'Asia/Rangoon', 'Asia/Riyadh', 'Asia/Saigon', 'Asia/Sakhalin', 'Asia/Samarkand', 'Asia/Seoul', 'Asia/Shanghai', 'Asia/Singapore', 'Asia/Srednekolymsk', 'Asia/Taipei', 'Asia/Tashkent', 'Asia/Tbilisi', 'Asia/Tehran', 'Asia/Tel_Aviv', 'Asia/Thimbu', 'Asia/Thimphu', 'Asia/Tokyo', 'Asia/Tomsk', 'Asia/Ujung_Pandang', 'Asia/Ulaanbaatar', 'Asia/Ulan_Bator', 'Asia/Urumqi', 'Asia/Ust-Nera', 'Asia/Vientiane', 'Asia/Vladivostok', 'Asia/Yakutsk', 'Asia/Yangon', 'Asia/Yekaterinburg', 'Asia/Yerevan', 'Atlantic/Azores', 'Atlantic/Bermuda', 'Atlantic/Canary', 'Atlantic/Cape_Verde', 'Atlantic/Faeroe', 'Atlantic/Faroe', 'Atlantic/Jan_Mayen', 'Atlantic/Madeira', 'Atlantic/Reykjavik', 'Atlantic/South_Georgia', 'Atlantic/St_Helena', 'Atlantic/Stanley', 'Australia/ACT', 'Australia/Adelaide', 'Australia/Brisbane', 'Australia/Broken_Hill', 'Australia/Canberra', 'Australia/Currie', 'Australia/Darwin', 'Australia/Eucla', 'Australia/Hobart', 'Australia/LHI', 'Australia/Lindeman', 'Australia/Lord_Howe', 'Australia/Melbourne', 'Australia/NSW', 'Australia/North', 'Australia/Perth', 'Australia/Queensland', 'Australia/South', 'Australia/Sydney', 'Australia/Tasmania', 'Australia/Victoria', 'Australia/West', 'Australia/Yancowinna', 'Brazil/Acre', 'Brazil/DeNoronha', 'Brazil/East', 'Brazil/West', 'CET', 'CST6CDT', 'Canada/Atlantic', 'Canada/Central', 'Canada/Eastern', 'Canada/Mountain', 'Canada/Newfoundland', 'Canada/Pacific', 'Canada/Saskatchewan', 'Canada/Yukon', 'Chile/Continental', 'Chile/EasterIsland', 'Cuba', 'EET', 'EST5EDT', 'Egypt', 'Eire', 'Etc/GMT', 'Etc/GMT+0', 'Etc/GMT+1', 'Etc/GMT+10', 'Etc/GMT+11', 'Etc/GMT+12', 'Etc/GMT+2', 'Etc/GMT+3', 'Etc/GMT+4', 'Etc/GMT+5', 'Etc/GMT+6', 'Etc/GMT+7', 'Etc/GMT+8', 'Etc/GMT+9', 'Etc/GMT-0', 'Etc/GMT-1', 'Etc/GMT-10', 'Etc/GMT-11', 'Etc/GMT-12', 'Etc/GMT-13', 'Etc/GMT-14', 'Etc/GMT-2', 'Etc/GMT-3', 'Etc/GMT-4', 'Etc/GMT-5', 'Etc/GMT-6', 'Etc/GMT-7', 'Etc/GMT-8', 'Etc/GMT-9', 'Etc/GMT0', 'Etc/Greenwich', 'Etc/UCT', 'Etc/UTC', 'Etc/Universal', 'Etc/Zulu', 'Europe/Amsterdam', 'Europe/Andorra', 'Europe/Astrakhan', 'Europe/Athens', 'Europe/Belfast', 'Europe/Belgrade', 'Europe/Berlin', 'Europe/Bratislava', 'Europe/Brussels', 'Europe/Bucharest', 'Europe/Budapest', 'Europe/Busingen', 'Europe/Chisinau', 'Europe/Copenhagen', 'Europe/Dublin', 'Europe/Gibraltar', 'Europe/Guernsey', 'Europe/Helsinki', 'Europe/Isle_of_Man', 'Europe/Istanbul', 'Europe/Jersey', 'Europe/Kaliningrad', 'Europe/Kiev', 'Europe/Kirov', 'Europe/Lisbon', 'Europe/Ljubljana', 'Europe/London', 'Europe/Luxembourg', 'Europe/Madrid', 'Europe/Malta', 'Europe/Mariehamn', 'Europe/Minsk', 'Europe/Monaco', 'Europe/Moscow', 'Europe/Nicosia', 'Europe/Oslo', 'Europe/Paris', 'Europe/Podgorica', 'Europe/Prague', 'Europe/Riga', 'Europe/Rome', 'Europe/Samara', 'Europe/San_Marino', 'Europe/Sarajevo', 'Europe/Saratov', 'Europe/Simferopol', 'Europe/Skopje', 'Europe/Sofia', 'Europe/Stockholm', 'Europe/Tallinn', 'Europe/Tirane', 'Europe/Tiraspol', 'Europe/Ulyanovsk', 'Europe/Uzhgorod', 'Europe/Vaduz', 'Europe/Vatican', 'Europe/Vienna', 'Europe/Vilnius', 'Europe/Volgograd', 'Europe/Warsaw', 'Europe/Zagreb', 'Europe/Zaporozhye', 'Europe/Zurich', 'GB', 'GB-Eire', 'GMT', 'GMT0', 'Greenwich', 'Hongkong', 'Iceland', 'Indian/Antananarivo', 'Indian/Chagos', 'Indian/Christmas', 'Indian/Cocos', 'Indian/Comoro', 'Indian/Kerguelen', 'Indian/Mahe', 'Indian/Maldives', 'Indian/Mauritius', 'Indian/Mayotte', 'Indian/Reunion', 'Iran', 'Israel', 'Jamaica', 'Japan', 'Kwajalein', 'Libya', 'MET', 'MST7MDT', 'Mexico/BajaNorte', 'Mexico/BajaSur', 'Mexico/General', 'NZ', 'NZ-CHAT', 'Navajo', 'PRC', 'PST8PDT', 'Pacific/Apia', 'Pacific/Auckland', 'Pacific/Bougainville', 'Pacific/Chatham', 'Pacific/Chuuk', 'Pacific/Easter', 'Pacific/Efate', 'Pacific/Enderbury', 'Pacific/Fakaofo', 'Pacific/Fiji', 'Pacific/Funafuti', 'Pacific/Galapagos', 'Pacific/Gambier', 'Pacific/Guadalcanal', 'Pacific/Guam', 'Pacific/Honolulu', 'Pacific/Johnston', 'Pacific/Kiritimati', 'Pacific/Kosrae', 'Pacific/Kwajalein', 'Pacific/Majuro', 'Pacific/Marquesas', 'Pacific/Midway', 'Pacific/Nauru', 'Pacific/Niue', 'Pacific/Norfolk', 'Pacific/Noumea', 'Pacific/Pago_Pago', 'Pacific/Palau', 'Pacific/Pitcairn', 'Pacific/Pohnpei', 'Pacific/Ponape', 'Pacific/Port_Moresby', 'Pacific/Rarotonga', 'Pacific/Saipan', 'Pacific/Samoa', 'Pacific/Tahiti', 'Pacific/Tarawa', 'Pacific/Tongatapu', 'Pacific/Truk', 'Pacific/Wake', 'Pacific/Wallis', 'Pacific/Yap', 'Poland', 'Portugal', 'ROK', 'Singapore', 'Turkey', 'UCT', 'US/Alaska', 'US/Aleutian', 'US/Arizona', 'US/Central', 'US/East-Indiana', 'US/Eastern', 'US/Hawaii', 'US/Indiana-Starke', 'US/Michigan', 'US/Mountain', 'US/Pacific', 'US/Samoa', 'UTC', 'Universal', 'W-SU', 'WET', 'Zulu', 'EST', 'HST', 'MST', ignoreCase = $false)]
        [Parameter(Mandatory = $false)]
        [string]$Timezone,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [string]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [boolean]$Calendar_exists = ($null -ne (Get-AutomateNOWCalendar -Id $Id))
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWCalendar failed to check if the Calendar [$Id] already existed due to [$Message]."
        Break
    }
    If ($Calendar_exists -eq $true) {
        [string]$current_domain = $anow_session.header.domain
        Write-Warning -Message "There is already a Calendar named [$Id] in [$current_domain]. Please check into this."
        Break
    }
    ## End warning ##
    [System.Collections.Specialized.OrderedDictionary]$ANOWCalendar = [System.Collections.Specialized.OrderedDictionary]@{}
    $ANOWCalendar.Add('id', $Id)
    If ($Description.Length -gt 0) {
        $ANOWCalendar.Add('description', $Description)
    }
    If ($Timezone.Length -gt 0) {
        $Error.Clear()
        Try {
            If ($null -eq (Get-AutomateNOWTimeZone -Id $Timezone)) {
                Write-Warning -Message "Somehow the provided Timezone $Timezone is not actually valid. Please look into this."
                Break
            }
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWTimeZone had an error while retrieving the timezone Id [$Timezone] running under New-AutomateNOWCalendar due to [$message]"
            Break
        }
        $ANOWCalendar.Add('timeZone', $Timezone)
    }
    If ($Tags.Count -gt 0) {
        [int32]$total_tags = $Tags.Count
        [int32]$current_tag = 1
        ForEach ($tag_id in $Tags) {
            $Error.Clear()
            Try {
                [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] running under New-AutomateNOWCalendar due to [$message]"
                Break
            }
            If ($tag_object.simpleId.length -eq 0) {
                Throw "New-AutomateNOWCalendar has detected that the tag [$tag_id] does not appear to exist. Please check again."
                Break
            }
            ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                [string]$tag_object_simpleId = $tag_object.simpleId
                Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                Break
            }
            [string]$tag_display = $tag_object | ConvertTo-Json -Compress
            Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
            [string]$tag_name_sequence = ('tags' + $current_tag)
            $ANOWCalendar.Add($tag_name_sequence, $tag_id)
            $include_properties += $tag_name_sequence
            $current_tag++
        }
    }
    If ($Folder.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] existed under New-AutomateNOWCalendar due to [$Message]"
            Break
        }
        If ($folder_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] under New-AutomateNOWCalendar. Please check again."
            Break
        }
        [string]$folder_display = $folder_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding folder $folder_display to [ANOWCalendar] [$Id]"
        $ANOWCalendar.Add('folder', $Folder)
        $include_properties += 'folder'
    }
    If ($CodeRepository.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository] existed under New-AutomateNOWCalendar due to [$Message]"
            Break
        }
        If ($code_repository_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository] under New-AutomateNOWCalendar. Please check again."
            Break
        }
        [string]$code_repository_display = $code_repository_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding code repository $code_repository_display to [ANOWCalendar] [$Id]"
        $ANOWCalendar.Add('codeRepository', $CodeRepository)
        $include_properties += 'codeRepository'
    }
    $ANOWCalendar.Add('calendarType', $Type)
    [string]$title = Switch ($Type) {
        'BASE' { 'Base' }
        'OR' { 'Sum' }
        'AND' { 'Conjunction' }
        'NOT' { 'Inversion' }
        'CAL_SELECT' { 'Select' }
        Default { 'Unknown' }
    }
    $ANOWCalendar.Add('title', $title)
    $ANOWCalendar.Add('icon', '[SKINIMG]/skin/date_control.png')
    $oldvalues = ('{"title":"' + $title + '","resourceType":"CALENDAR","calendarType":"' + $Type + '","icon":"[SKINIMG]/skin/date_control.png"}')
    [string]$BodyObject = ConvertTo-QueryString -InputObject $ANOWCalendar -IncludeProperties id, description, calendarType, title, icon, tags, folder, codeRepository
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    $BodyMetaData.'resourceType' = 'CALENDAR'
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_operationType' = 'add'
    $BodyMetaData.'_oldValues' = $oldvalues
    $BodyMetaData.'_componentId' = 'CalendarCreateWindow_form'
    $BodyMetaData.'_dataSource' = 'CalendarDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$BodyMetaDataString = ConvertTo-QueryString -InputObject $BodyMetaData
    [string]$Body = ($BodyObject + '&' + $BodyMetaDataString)
    [string]$command = '/resource/create'
    [hashtable]$parameters = @{}
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('Body', $Body)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWCalendar]$Calendar = $results.response.data | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to create the [ANOWCalendar] object due to [$Message]."
        Break
    }
    If ($Calendar.id.Length -eq 0) {
        Write-Warning -Message "Somehow the newly created [ANOWCalendar] Calendar is empty!"
        Break
    }
    If ($Quiet -ne $true) {
        Return $Calendar
    }
}

Function Remove-AutomateNOWCalendar {
    <#
    .SYNOPSIS
    Removes a Calendar from an AutomateNOW! instance

    .DESCRIPTION
    Removes a Calendar from an AutomateNOW! instance

    .PARAMETER Calendar
    An [ANOWCalendar] object representing the Calendar to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWCalendar] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Remove a single Calendar by name

    Get-AutomateNOWCalendar -Id 'calendar01' | Remove-AutomateNOWCalendar

    .EXAMPLE
    Removes a series of Calendar objects via input from the pipeline

    @( 'calendar01', 'calendar02', 'calendar03') | Get-AutomateNOWCalendar | Remove-AutomateNOWCalendar

    .EXAMPLE
    Forcefully removes all Calendar objects that have a timezone configured as UTC

    Get-AutomateNOWCalendar | Where-Object { $_.timeZone -eq 'UTC'} | Remove-AutomateNOWCalendar -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWCalendar]$Calendar,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/resource/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWCalendar]$Calendar = $_
        }
        [string]$Calendar_id = $Calendar.id
        If ($Calendar_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Calendar_id)")) -eq $true) {
            [string]$oldvalues = $Calendar.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $Calendar.id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'ResourceList'
            $BodyMetaData.'_dataSource' = 'ResourceDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Calendar_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Calendar [$Calendar_id] successfully removed"
        }
    }
    End {

    }
}

Function Copy-AutomateNOWCalendar {
    <#
    .SYNOPSIS
    Copies an Calendar from an AutomateNOW! instance

    .DESCRIPTION
    Copies an Calendar from an AutomateNOW! instance. AutomateNOW object id can never be changed, but we can copy the object to a new id and it will include all of the items therein.

    .PARAMETER Calendar
    Mandatory [ANOWCalendar] object to be copied.

    .PARAMETER NewId
    The name (Id) of the new Calendar. The new Id must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    .PARAMETER UnsetDescription
    Optional switch that will ensure that the newly created Calendar will not have a description set.

    .PARAMETER Description
    Optional description to set on the new Calendar object. If you do not set this, the new Calendar object will copy the Description of the source object.

    .PARAMETER UnsetFolder
    Optional switch that will ensure that the newly created Calendar will not have a Folder set.

    .PARAMETER Folder
    Optional description to set a different folder on the new Calendar object. If you do not set this, the new Calendar object will use the same Folder of the source object.

    .PARAMETER UnsetTags
    Optional switch that will ensure that the newly created Calendar will not have any Tags set.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the new Calendar object. If you do not set this, the new Calendar object will apply the same Tags of the source object.

    .PARAMETER Force
    Force the copy without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    ONLY [ANOWCalendar] object is accepted. Pipeline support is intentionally unavailable.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Creates a copy of an Calendar and changes the description (multi-line format)
    $Calendar01 = Get-AutomateNOWCalendar -Id 'Calendar_01'
    Copy-AutomateNOWCalendar -Calendar $Calendar01 -NewId 'Calendar_01_production' -Description 'Calendar 01 Production'

    .EXAMPLE
    Creates a copy of an Calendar that omits the description (one-liner format)
    Copy-AutomateNOWCalendar -Calendar (Get-AutomateNOWCalendar -Id 'Calendar_01') -NewId 'Calendar_01_production' -UnsetDescription -Tags 'Tag1', 'Tag2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWCalendar]$Calendar,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot set the Tags and unset them at the same time. Please choose one or the other. Tags from the source object will be carried over to the new object if you do not specify any tag-related parameters."
            Break
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$Calendar_exists = ($null -ne (Get-AutomateNOWCalendar -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCalendar failed to check if the Calendar [$NewId] already existed due to [$Message]."
            Break
        }
        If ($Calendar_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Calendar named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End warning ##
        [string]$command = '/resource/copy'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            [string]$Calendar_oldId = $Calendar.id
            [string]$Calendar_simpleId = $Calendar.simpleId
            If ($Calendar_oldId -eq $NewId) {
                Write-Warning -Message "The new id cannot be the same as the old id."
                Break
            }
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Copy the Calendar $($Calendar_simpleId) to $($NewId)?")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                If ($UnsetFolder -eq $True) {
                    $BodyMetaData.'folder' = $Null
                }
                ElseIf ($Folder.Length -gt 0) {
                    $BodyMetaData.'folder' = $Folder
                }
                Else {
                    If ($Calendar.folder.Length -gt 0) {
                        $BodyMetaData.'folder' = $Calendar.folder
                    }
                }
                If ($Tags.Count -gt 0) {
                    [int32]$tag_count = 1
                    ForEach ($tag in $Tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
                ElseIf ($UnsetTags -eq $true) {
                    $BodyMetaData.'tags' = $Null
                }
                Else {
                    If ($Calendar.Tags -gt 0) {
                        [int32]$tag_count = 1
                        ForEach ($tag in $Calendar.tags) {
                            $BodyMetaData.('tags' + $tag_count ) = $tag
                            $tag_count++
                        }
                    }
                }
                $BodyMetaData.'oldId' = $Calendar_oldId
                $BodyMetaData.'domain' = $Calendar.domain
                $BodyMetaData.'id' = $NewId
                If ($UnsetDescription -ne $true) {
                    If ($Description.Length -gt 0) {
                        $BodyMetaData.'description' = $Description
                    }
                    Else {
                        $BodyMetaData.'description' = $Calendar.description
                    }
                }
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_operationId' = 'copy'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_dataSource' = 'ResourceDataSource'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties oldId, domain, NewId, description, folder, tags
                $parameters.Body = $Body
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Calendar_oldId] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                $Error.Clear()
                Try {
                    [ANOWCalendar]$NewCalendar = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to create copied [ANOWCalendar] object [$NewId] due to [$Message]."
                    Break
                }
                If ($NewCalendar.id.Length -eq 0) {
                    Write-Warning -Message "Somehow the newly created (copied) [ANOWCalendar] object [$NewId] is empty!"
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $NewCalendar
                }
            }
        }
    }
    End {

    }
}

Function Rename-AutomateNOWCalendar {
    <#
    .SYNOPSIS
    Renames a Calendar on an AutomateNOW! instance

    .DESCRIPTION
    Performs a psuedo-rename operations of a Calendar from an AutomateNOW! instance by copying it first and then deleting the source. This function merely combines Copy-AutomateNOWCalendar and Remove-AutomateNOWCalendar therefore it is to be considered destructive.

    .PARAMETER Calendar
    An [ANOWCalendar] object representing the Calendar to be renamed.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the Calendar. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER Force
    Force the renaming without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly renamed object.

    .INPUTS
    ONLY [ANOWCalendar] objects are accepted. There is intentionally no support for the pipeline.

    .OUTPUTS
    The newly renamed [ANOWCalendar] object will be returned.

    .EXAMPLE
    $Calendar = Get-AutomateNOWCalendar -Id 'Calendar01'
    Rename-AutomateNOWCalendar -Calendar $Calendar -NewId 'Calendar_01'

    .EXAMPLE
    Rename-AutomateNOWCalendar -Calendar (Get-AutomateNOWCalendar -Id 'Calendar01') -NewId 'Calendar_01'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    When renaming, you may only specify a different Id (name).

    This action will be blocked if any existing referrals are found on the object.
    #>
    [OutputType([ANOWCalendar])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWCalendar]$Calendar,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin standard warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$new_Calendar_exists = ($null -ne (Get-AutomateNOWCalendar -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCalendar failed to check if the Calendar [$NewId] already existed due to [$Message]."
            Break
        }
        If ($new_Calendar_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Calendar named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        #[string]$Calendar_id = $Calendar.id
        [string]$Calendar_id = $Calendar.simpleId
        $Error.Clear()
        Try {
            [boolean]$old_Calendar_exists = ($null -ne (Get-AutomateNOWCalendar -Id $Calendar_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCalendar failed to check if the Calendar [$Calendar_id] already existed due to [$Message]."
            Break
        }
        If ($old_Calendar_exists -eq $false) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not a Calendar named [$Calendar_id] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End standard warning ##
        ## Begin referrals warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [int32]$referrals_count = Find-AutomateNOWObjectReferral -Calendar $Calendar -Count | Select-Object -Expandproperty referrals
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Find-AutomateNOWObjectReferral failed to extract the referrals on Calendar [$Calendar_id] due to [$Message]."
            Break
        }
        If ($referrals_count -gt 0) {
            Write-Warning -Message "Unfortunately, you cannot rename a Calendar that has referrals. This is because the rename is not actually renaming but copying anew and deleting the old. Please, use the Find-AutomateNOWObjectReferral function to identify referrals and remove them."
            Break
        }
        Else {
            Write-Verbose -Message "The Calendar [$Calendar_id] does not have any referrals. It is safe to proceed."
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Calendar_id)")) -eq $true) {
                $Error.Clear()
                Try {
                    [ANOWCalendar]$new_Calendar = Copy-AutomateNOWCalendar -Calendar $Calendar -NewId $NewId -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Copy-AutomateNOWCalendar failed to create a new Calendar [$NewId] as Part 1 of the renaming process due to [$Message]."
                    Break
                }
                If ($new_Calendar.simpleId -eq $NewId) {
                    Write-Verbose -Message "Part 1: Calendar [$Calendar_id] successfully copied to [$NewId]"
                }
                Else {
                    Write-Warning -Message "Somehow the first phase (Copy-AutomateNOWCalendar) failed. Please look into this."
                    Break
                }
                $Error.Clear()
                Try {
                    Remove-AutomateNOWCalendar -Calendar $Calendar -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Remove-AutomateNOWCalendar failed to remove [$Calendar_id] as Part 2 of the renaming process due to [$Message]."
                    Break
                }
                Write-Verbose -Message "Part 2: Calendar [$Calendar_id] removed"
                Write-Verbose -Message "Task [$Calendar_id] successfully renamed to [$NewId]"
                If ($Quiet -ne $true) {
                    Return $new_Calendar
                }
            }
        }
        Else {
            Write-Warning -Message "No action was taken because either the source object didn't exist or the new object already existed"
        }
    }
    End {
    }
}

#endregion

#Region - Code Repositories

Function Get-AutomateNOWCodeRepository {
    <#
    .SYNOPSIS
    Gets the Code Repositories from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Code Repositories from an AutomateNOW! instance

    .PARAMETER Id
    Optional string containing the simple id of the Code Repository to fetch or you can pipeline a series of simple id strings. You may not enter an array here.

    .PARAMETER startRow
    Integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER Folder
    Optional string to filter by a particular Folder

    .PARAMETER Tags
    Optional string array of Tags to filter by. Note that the 'containsAny' operator will be used.

    .INPUTS
    Accepts a string representing the simple id of the Code Repository from the pipeline or individually (but not an array).

    .OUTPUTS
    An array of one or more [ANOWCodeRepository] class objects

    .EXAMPLE
    Gets the first page of Code Repository objects

    Get-AutomateNOWCodeRepository

    .EXAMPLE
    Gets a Code Repository object named 'CodeRepository1'

    Get-AutomateNOWCodeRepository -Id 'CodeRepository1'

    .EXAMPLE
    'CodeRepository1', 'CodeRepository2' | Get-AutomateNOWCodeRepository

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWCodeRepository[]])]
    [Cmdletbinding(DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $True, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False)]
        [string]$Folder,
        [Parameter(Mandatory = $False)]
        [string[]]$Tags
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 -or $Id.Length -gt 0) {
            If ($_.Length -gt 0 ) {
                $Body.'id' = $_
            }
            Else {
                $Body.'id' = $Id
            }
            $Body.'_textMatchStyle' = 'exact'
        }
        Else {
            $Body.'_constructor' = 'AdvancedCriteria'
            $Body.'operator' = 'and'
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
            $Body.'_textMatchStyle' = 'substring'
            If ($Folder.Length -gt 0) {
                $Body.'criteria1' = ('{"fieldName":"folder","operator":"equals","value":"' + $Folder + '"}')
            }
            If ($Tags.Count -gt 0) {
                If ($Tags.Count -gt 1) {
                    $Error.Clear()
                    Try {
                        [string]$TagString = $Tags | ConvertTo-Json -Compress
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "ConvertTo-Json failed to convert the provided tag names under Get-AutomateNOWCodeRepository due to [$Message]."
                        Break
                    }
                }
                Else {
                    [string]$TagString = $Tags
                }
                $Body.'criteria2' = ('{"fieldName":"tags","operator":"containsAny","value":' + $TagString + '}')
            }
        }
        $Body.'_operationType' = 'fetch'
        $Body.'_componentId' = 'CodeRepositoryList'
        $Body.'_dataSource' = 'CodeRepositoryDataSource'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/codeRepository/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWCodeRepository[]]$CodeRepositories = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWCodeRepository] objects due to [$Message]."
            Break
        }
        If ($CodeRepositories.Count -gt 0) {
            Return $CodeRepositories
        }
    }
    End {

    }
}

Function Set-AutomateNOWCodeRepository {
    <#
    .SYNOPSIS
    Modifies a local Code Repository in an AutomateNOW! instance

    .DESCRIPTION
    Modifies a local Code Repository in an AutomateNOW! instance

    .PARAMETER CodeRepository
    Mandatory [ANOWCodeRepository] object (Use Get-AutomateNOWCodeRepository to retrieve them)

    .PARAMETER sshKeyLocationType
    Mandatory string representing the type of SSH Key Location of the remote Git repository. Possible choices are: SSH_KEY_FILE_PATH, INLINE

    .PARAMETER authenticationMethod
    Mandatory string representing the authentication method of the remote Git repository. Possible choices are: SSH, PASSWORD

    .PARAMETER repositoryURL
    Mandatory string representing the URL of the remote Git repository

    .PARAMETER sshKey
    Mandatory (if authenticationMethod is SSH) string representing the path to an authorized SSH Key stored in the ANOW host server

    .PARAMETER sshKeyPassPhrase
    Optional (if authenticationMethod is SSH) securestring representing the pass phrase of the provided SSH key

    .PARAMETER User
    Mandatory (if authenticationMethod is Username/Password) string representing the name of the git user account with access to the remote code repository (the maximum length of this string is unknown)

    .PARAMETER Password
    Mandatory (if authenticationMethod is Username/Password) securestring representing the password of the git user account with access to the remote code repository

    .PARAMETER localFolder
    Mandatory string representing where ANOW will store its local copy of the Git repository in the host server

    .PARAMETER codeRepositoryRoot
    Optional string representing the sub-folder of the Git repository to which the ANOW JSON files will be stored

    .PARAMETER UnsetDescription
    Optional switch that will remove the Description from the Code Repository object.

    .PARAMETER Description
    Optional string to set on the Code Repository object.

    .PARAMETER UnsetFolder
    Optional switch that will remove the current Folder assignment from the Code Repository object.

    .PARAMETER Folder
    Optional string to set a different folder on the Code Repository object.

    .PARAMETER UnsetTags
    Optional switch that will remove the Tags from the Code Repository object.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the Code Repository object.

    .PARAMETER Quiet
    Optional switch to suppress the display of the results

    .PARAMETER Force
    Force the modification of the object without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWCodeRepository] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWCodeRepository] object will be returned

    .EXAMPLE
    Sets multiple tags on a local Code Repository named 'CodeRepository1'

    $repository = Get-AutomateNOWCodeRepository -Id 'CodeRepository1'
    Set-AutomateNOWCodeRepository -CodeRepository $repository -Tags 'Tag1', 'Tag2'

    .EXAMPLE
    Forcibly sets the local folder on a local Code Repository named 'CodeRepository1'

    $repository = Get-AutomateNOWCodeRepository -Id 'CodeRepository1'
    Set-AutomateNOWCodeRepository -CodeRepository $repository -localfolder '/appl/archive/Anow/Prod/Git-repos/Prod/CodeRepository1' -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This function is not fully tested.

    #>
    [OutputType([ANOWCodeRepository])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'Default', ValueFromPipeline = $true)]
        [Parameter(Mandatory = $true, ParameterSetName = 'SSH', ValueFromPipeline = $true)]
        [Parameter(Mandatory = $true, ParameterSetName = 'Password', ValueFromPipeline = $true)]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'SSH')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Password')]
        [string]$repositoryURL,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'SSH')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Password')]
        [ANOWCodeRepository_authenticationMethod]$authenticationMethod,
        [Parameter(Mandatory = $true, ParameterSetName = 'SSH')]
        [ANOWCodeRepository_sshKeyLocationType]$sshKeyLocationType,
        [Parameter(Mandatory = $true, ParameterSetName = 'SSH')]
        [string]$sshKeyPath,
        [Parameter(Mandatory = $false, ParameterSetName = 'SSH')]
        [SecureString]$sshKeyPassPhrase,
        [Parameter(Mandatory = $true, ParameterSetName = 'Password')]
        [string]$User,
        [Parameter(Mandatory = $true, ParameterSetName = 'Password')]
        [SecureString]$Password,
        [Parameter(Mandatory = $false, ParameterSetName = 'Password')]
        [switch]$skipSslVerification,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'SSH')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Password')]
        [string]$localFolder,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'SSH')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Password')]
        [string]$codeRepositoryRoot,
        [ValidateScript({ $_.Length -le 255 })]
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'SSH')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Password')]
        [string]$Description,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'SSH')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Password')]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'SSH')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Password')]
        [string]$Folder,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'SSH')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Password')]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'SSH')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Password')]
        [string[]]$Tags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'SSH')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Password')]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'SSH')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Password')]
        [switch]$Quiet,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'SSH')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Password')]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($Description.Length -gt 0 -and $UnsetDescription -eq $true) {
            Write-Warning -Message 'You cannot set the Description and unset it at the same time. Please choose one or the other.'
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($Tags.count -gt 0 -and $UnsetTags -eq $true) {
            Write-Warning -Message "You cannot set the tags and unset them at the same time. Please choose one or the other."
            Break
        }
        If ($User.Length -gt 0 -and $Password.Length -eq 0) {
            Write-Warning -Message "You must include a password if you are specifying a git user account"
            Break
        }
        If ($User.Length -eq 0 -and $Password.Length -gt 0) {
            Write-Warning -Message "You must include a git user account if you are specifying a git user password"
            Break
        }
        If ( $sshKeyLocationType.Length -gt 0 -and $sshKeyPath.Length -eq 0) {
            Write-Warning -Message "You must include the path the SSH Key if you are specifying the SSH Key Location Type"
            Break
        }
        If ( $sshKeyLocationType.Length -eq 0 -and $sshKeyPath.Length -gt 0) {
            Write-Warning -Message "You must include the path the SSH Key Location Type if you are specifying the SSH Key"
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
        If ($User.Length -gt 0) {
            $Error.Clear()
            Try {
                If ($PSVersionTable.PSVersion.Major -ge 7) {
                    [string]$password = $Pass | ConvertFrom-SecureString -AsPlainText
                }
                Else {
                    [string]$password = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto([System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($Pass))
                }
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "ConvertFrom-SecureString failed to convert the secure password under Set-AutomateNOWCodeRepository due to [$Message]."
                Break
            }
            $Error.Clear()
            Try {
                [string]$encrypted_password = ('ENCRYPTED::' + (Protect-AutomateNOWEncryptedString -String $password))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Protect-AutomateNOWEncryptedString failed to encrypt the plain text password under Set-AutomateNOWCodeRepository due to [$Message]."
                Break
            }
        }
    }
    Process {
        If ($_.Id.Length -gt 0) {
            [ANOWCodeRepository]$CodeRepository = $_
        }
        [string]$CodeRepository_Id = $CodeRepository.Id
        ## Do not tamper with this code. It ensures that we are not trying to add a branch that already exists
        $Error.Clear()
        Try {
            [ANOWCodeRepository]$existing_repository = Get-AutomateNOWCodeRepository -Id $CodeRepository_Id
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepository failed to check if Code Repository [$CodeRepository_Id] existed under Set-AutomateNOWCodeRepository due to [$Message]."
            Break
        }
        If ($CodeRepository_Id -eq $existing_repository.Id -and $CodeRepository_Id -cne $existing_repository.Id) {
            [string]$existing_repository_Id = $existing_repository.Id
            Write-Warning -Message "Objects in ANOW are case-sensitive! You specified $CodeRepository_Id but the actual case correct name of the Code Repository is $existing_repository_Id. Please check and try again."
            Break
        }
        ##
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Proceed to modify the Code Repository $($CodeRepository_Id)?")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
            $Body.'id' = $CodeRepository_Id
            If ($Description.Length -gt 0) {
                $Body.'description' = $Description
            }
            ElseIf ($UnsetDescription -eq $true) {
                $Body.'description' = $null
            }
            If ($Folder.Length -gt 0) {
                $Error.Clear()
                Try {
                    [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the Folder [$Folder] actually existed while running under Set-AutomateNOWCodeRepository due to [$Message]"
                    Break
                }
                If ($folder_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] running under Set-AutomateNOWCodeRepository. Please check again."
                    Break
                }
                [string]$folder_display = $folder_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Adding Folder $folder_display to [ANOWCodeRepository] [$CodeRepository_id]"
                $Body.'folder' = $Folder
            }
            ElseIf ($UnsetFolder -eq $true) {
                [string]$folder_display = $folder_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Removing [ANOWCodeRepository] [$CodeRepository_id] from Folder $folder_display"
                $Body.'folder' = $null
            }
            If ($Tags.Count -gt 0) {
                [int32]$total_tags = $Tags.Count
                [int32]$current_tag = 1
                ForEach ($tag_id in $Tags) {
                    $Error.Clear()
                    Try {
                        [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] running under Set-AutomateNOWCodeRepository due to [$message]"
                        Break
                    }
                    If ($tag_object.simpleId.length -eq 0) {
                        Throw "Set-AutomateNOWCodeRepository has detected that the tag [$tag_id] does not appear to exist. Please check again."
                        Break
                    }
                    ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                        [string]$tag_object_simpleId = $tag_object.simpleId
                        Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                        Break
                    }
                    [string]$tag_display = $tag_object | ConvertTo-Json -Compress
                    Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
                    [string]$tag_name_sequence = ('tags' + $current_tag)
                    $Body.Add($tag_name_sequence, $tag_id)
                    $current_tag++
                }
            }
            ElseIf ($UnsetTags -eq $true) {
                [string]$tags_display = ($Calendar.tags) | ConvertTo-Json -Compress
                Write-Verbose -Message "Removing tags [$tags_display] from [$CodeRepository_id]"
                $Body.'tags' = $null
            }
            #
            If ($authenticationMethod.Length -gt 0) {
                $Body.'authenticationMethod' = $authenticationMethod
            }
            If ($repositoryURL.Length -gt 0) {
                $Body.'repositoryURL' = $repositoryURL
            }
            If ($localFolder.Length -gt 0) {
                $Body.'localFolder' = $localFolder
            }
            If ($codeRepositoryRoot.Length -gt 0) {
                $Body.'codeRepositoryRoot' = $codeRepositoryRoot
            }
            If ($User.Length -gt 0) {
                $Body.'user' = $User
                $Body.'password' = $encrypted_password
                If ($skipSslVerification -eq $true) {
                    $Body.'skipSslVerification' = 'true'
                }
            }
            If ( $sshKeyLocationType.Length -gt 0) {
                $Body.'sshKeyLocationType' = $sshKeyLocationType
                $Body.'sshKey' = $sshKey
            }
            $Body.'_operationType' = 'update'
            $Body.'_textMatchStyle' = 'exact'
            [string]$old_values = $CodeRepository.CreateOldValues()
            $Body.'_oldValues' = $old_values
            $Body.'_componentId' = 'CodeRepositorySettingsForm'
            $Body.'_dataSource' = 'CodeRepositoryDataSource'
            $Body.'isc_metaDataPrefix' = '_'
            $Body.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $Body
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            If ($null -eq $parameters["Command"]) {
                [string]$command = ('/codeRepository/update')
                $parameters.Add('Command', $command)
            }
            Else {
                $parameters.Command = $command
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            $Error.Clear()
            Try {
                [ANOWCodeRepository]$UpdatedCodeRepository = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the result into an [ANOWCodeRepository] object due to [$Message]."
                Break
            }
            If ($Quiet -ne $True) {
                Return $UpdatedCodeRepository
            }
        }
    }
    End {

    }
}

Function New-AutomateNOWCodeRepository {
    <#
    .SYNOPSIS
    Creates a local Code Repository in an AutomateNOW! instance

    .DESCRIPTION
    Creates a local Code Repository in an AutomateNOW! instance

    .PARAMETER Id
    Mandatory string representing the name of the Code Repository. The name of the Code Repository may consist only of alphanumeric characters and 3 special characters (._-) and not to exceed 1024 characters in length.

    .PARAMETER sshKeyLocationType
    Mandatory string representing the type of SSH Key Location of the remote Git repository. Possible choices are: SSH_KEY_FILE_PATH, INLINE

    .PARAMETER authenticationMethod
    Mandatory string representing the authentication method of the remote Git repository. Possible choices are: SSH, PASSWORD

    .PARAMETER repositoryURL
    Mandatory string representing the URL of the remote Git repository

    .PARAMETER sshKey
    Mandatory (if authenticationMethod is SSH) string representing the path to an authorized SSH Key stored in the ANOW host server

    .PARAMETER sshKeyPassPhrase
    Optional (if authenticationMethod is SSH) securestring representing the pass phrase of the provided SSH key

    .PARAMETER User
    Mandatory (if authenticationMethod is Username/Password) string representing the name of the git user account with access to the remote code repository (the maximum length of this string is unknown)

    .PARAMETER Password
    Mandatory (if authenticationMethod is Username/Password) securestring representing the password of the git user account with access to the remote code repository

    .PARAMETER localFolder
    Mandatory string representing where ANOW will store its local copy of the Git repository in the host server

    .PARAMETER codeRepositoryRoot
    Optional string representing the sub-folder of the Git repository to which the ANOW JSON files will be stored

    .PARAMETER Description
    Optional description of the Code Repository (may not exceed 255 characters). Note that the ANOW console does not currently show this.

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new Code Repository. Do not pass [ANOWTag] objects here.

    .PARAMETER Folder
    Optional name of the folder to place the Code Repository into.

    .PARAMETER Quiet
    Optional switch to suppress the display of the results

    .PARAMETER Force
    Force the creation of the object without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    `New-AutomateNOWCodeRepository` does not accept inputs from the pipeline.

    .OUTPUTS
    The newly created Code Repository object will be returned.

    .EXAMPLE
    Creates a new SSH-based local Code Repository named 'CodeRepository1' with a secure Passphrase

    $sshPassPhrase = Read-Host -Prompt 'Please enter the password' -AsSecureString
    New-AutomateNOWCodeRepository -Id 'CodeRepository1' -repositoryURL 'git@git.contoso.com:projects/CodeRepository1' -authenticationMethod SSH -sshKeyLocationType SSH_KEY_FILE_PATH -sshKeyPath '/appl/anow/.ssh/my-git-account' -sshKeyPassPhrase $sshKeyPassPhrase -localfolder '/appl/archive/Anow/Prod/Git-repos/Prod/CodeRepository1' -codeRepositoryRoot '/'

    .EXAMPLE
    Creates a new user-based local Code Repository named 'CodeRepository1' with SSL verification disabled

    $Password = Read-Host -Prompt 'Please enter the password' -AsSecureString
    New-AutomateNOWCodeRepository -Id 'CodeRepository1' -repositoryURL 'git@git.contoso.com:projects/CodeRepository1' -authenticationMethod PASSWORD -skipSslVerification -User 'username1' -Password $Password -localfolder '/appl/archive/Anow/Prod/Git-repos/Prod/CodeRepository1' -codeRepositoryRoot '/'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This function is not fully tested.

    Be prepared for a long wait if the wrong information is sent.

    #>
    [OutputType([ANOWCodeRepository])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [ValidateScript({ $_ -match '[0-9a-zA-Z._-]{1,1024}' })]
        [Parameter(Mandatory = $true)]
        [string]$Id,
        [Parameter(Mandatory = $true)]
        [string]$repositoryURL,
        [Parameter(Mandatory = $true)]
        [ANOWCodeRepository_authenticationMethod]$authenticationMethod,
        [Parameter(Mandatory = $true, ParameterSetName = 'SSH')]
        [ANOWCodeRepository_sshKeyLocationType]$sshKeyLocationType,
        [Parameter(Mandatory = $true, ParameterSetName = 'SSH')]
        [string]$sshKeyPath,
        [Parameter(Mandatory = $false, ParameterSetName = 'SSH')]
        [SecureString]$sshKeyPassPhrase,
        [Parameter(Mandatory = $true, ParameterSetName = 'Password')]
        [string]$User,
        [Parameter(Mandatory = $true, ParameterSetName = 'Password')]
        [SecureString]$Password,
        [Parameter(Mandatory = $true, ParameterSetName = 'Password')]
        [switch]$skipSslVerification,
        [Parameter(Mandatory = $true)]
        [string]$localFolder,
        [Parameter(Mandatory = $true)]
        [string]$codeRepositoryRoot,
        [Parameter(Mandatory = $false, HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
        If ($User.Length -gt 0) {
            $Error.Clear()
            Try {
                If ($PSVersionTable.PSVersion.Major -ge 7) {
                    [string]$Pass = $Password | ConvertFrom-SecureString -AsPlainText
                }
                Else {
                    [string]$Pass = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto([System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($Password))
                }
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "ConvertFrom-SecureString failed to convert the secure password under New-AutomateNOWCodeRepository due to [$Message]."
                Break
            }
            $Error.Clear()
            Try {
                [string]$encrypted_password = ('ENCRYPTED::' + (Protect-AutomateNOWEncryptedString -String $Pass))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Protect-AutomateNOWEncryptedString failed to encrypt the plain text password under New-AutomateNOWCodeRepository due to [$Message]."
                Break
            }
        }
        If ($sshKeyPassPhrase.Length -gt 0) {
            $Error.Clear()
            Try {
                If ($PSVersionTable.PSVersion.Major -ge 7) {
                    [string]$sshKeyPasswordPhrase = $sshKeyPassPhrase | ConvertFrom-SecureString -AsPlainText
                }
                Else {
                    [string]$sshKeyPasswordPhrase = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto([System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($sshKeyPassPhrase))
                }
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "ConvertFrom-SecureString failed to convert the secure SSH Key Passphrase under New-AutomateNOWCodeRepository due to [$Message]."
                Break
            }
            $Error.Clear()
            Try {
                [string]$encrypted_sshKeyPassPhrase = ('ENCRYPTED::' + (Protect-AutomateNOWEncryptedString -String $sshKeyPasswordPhrase))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Protect-AutomateNOWEncryptedString failed to encrypt the plain text SSH Key Passphrase under New-AutomateNOWCodeRepository due to [$Message]."
                Break
            }
        }
    }
    Process {
        ## Do not tamper with this code. It ensures that we are not trying to add a branch that already exists
        $Error.Clear()
        Try {
            [ANOWCodeRepository]$existing_repository = Get-AutomateNOWCodeRepository -Id $Id
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepository failed to check if Code Repository [$Id] existed under New-AutomateNOWCodeRepository due to [$Message]."
            Break
        }
        If ($Id -eq $existing_repository.Id) {
            Write-Warning -Message "There is already a Code Repository named [$Id]. No action is required."
            Break
        }
        ##
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Proceed to create the Code Repository $($Id) ?")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
            If ($Tags.Count -gt 0) {
                [int32]$total_tags = $Tags.Count
                [int32]$current_tag = 1
                ForEach ($tag_id in $Tags) {
                    $Error.Clear()
                    Try {
                        [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] running under New-AutomateNOWCodeRepository due to [$message]"
                        Break
                    }
                    If ($tag_object.simpleId.length -eq 0) {
                        Throw "New-AutomateNOWCodeRepository has detected that the tag [$tag_id] does not appear to exist. Please check again."
                        Break
                    }
                    ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                        [string]$tag_object_simpleId = $tag_object.simpleId
                        Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                        Break
                    }
                    [string]$tag_display = $tag_object | ConvertTo-Json -Compress
                    Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
                    [string]$tag_name_sequence = ('tags' + $current_tag)
                    $Body."$tag_name_sequence" = $tag_id
                    $current_tag++
                }
            }
            If ($Folder.Length -gt 0) {
                $Error.Clear()
                Try {
                    [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] existed under New-AutomateNOWCodeRepository due to [$Message]"
                    Break
                }
                If ($folder_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] under New-AutomateNOWCodeRepository. Please check again."
                    Break
                }
                [string]$folder_display = $folder_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Adding folder $folder_display to [ANOWCodeRepository] [$Id]"
                $Body.'folder' = $Folder
            }
            If ($Description.Length -gt 0) {
                $Body.'description' = $Description
            }
            $Body.'authenticationMethod' = $authenticationMethod
            $Body.'id' = $Id
            $Body.'repositoryURL' = $repositoryURL
            $Body.'localFolder' = $localFolder
            $Body.'codeRepositoryRoot' = $codeRepositoryRoot
            If ($User.Length -gt 0) {
                $Body.'user' = $User
                $Body.'password' = $encrypted_password
                If ($skipSslVerification -eq $true) {
                    $Body.'skipSslVerification' = 'true'
                }
            }
            Else {
                $Body.'sshKeyLocationType' = $sshKeyLocationType
                $Body.'sshKey' = $sshKeyPath
                If ($sshKeyPassPhrase.Length -gt 0) {
                    $Body.'sshKeyPassphrase' = $encrypted_sshKeyPassPhrase
                }
            }
            $Body.'_operationType' = 'add'
            $Body.'_textMatchStyle' = 'exact'
            $Body.'_oldValues' = '{"authenticationMethod":"PASSWORD","sshKeyLocationType":"SSH_KEY_FILE_PATH"}'
            $Body.'_componentId' = 'CodeRepositoryCreateWindow_form'
            $Body.'_dataSource' = 'CodeRepositoryDataSource'
            $Body.'isc_metaDataPrefix' = '_'
            $Body.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $Body
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            If ($null -eq $parameters["Command"]) {
                [string]$command = ('/codeRepository/create')
                $parameters.Add('Command', $command)
            }
            Else {
                $parameters.Command = $command
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            # Note this code is untested
            $Error.Clear()
            Try {
                [ANOWCodeRepository]$CodeRepository = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the result into an [ANOWCodeRepository] object due to [$Message]."
                Break
            }
            If ($Quiet -ne $True) {
                Return $CodeRepository
            }
        }
    }
    End {

    }
}

Function Export-AutomateNOWCodeRepository {
    <#
    .SYNOPSIS
    Exports the Code Repositories from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Code Repositories from an instance of AutomateNOW! to a local .csv file

    .PARAMETER CodeRepository
    Mandatory [ANOWCodeRepository] object (Use Get-AutomateNOWCodeRepository to retrieve them)

    .INPUTS
    ONLY [ANOWCodeRepository] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWCodeRepository] objects are exported to the local disk in CSV format

    .EXAMPLE
    Get-AutomateNOWCodeRepository | Export-AutomateNOWCodeRepository

    .EXAMPLE
    Get-AutomateNOWCodeRepository -Id 'CodeRepository01' | Export-AutomateNOWCodeRepository

    .EXAMPLE
    @( 'CodeRepository01', 'CodeRepository02' ) | Get-AutomateNOWCodeRepository | Export-AutomateNOWCodeRepository

    .EXAMPLE
    Get-AutomateNOWCodeRepository | Where-Object { $_.simpleId -eq 'CodeRepository01' } | Export-AutomateNOWCodeRepository

    .NOTES
	You must present [ANOWCodeRepository] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWCodeRepository]$CodeRepository
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-CodeRepositories-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWCodeRepository]$CodeRepository = $_
        }
        $Error.Clear()
        Try {
            $CodeRepository | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWCodeRepository] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function Remove-AutomateNOWCodeRepository {

    <#
    .SYNOPSIS
    Deletes a local Code Repository in an AutomateNOW! instance

    .DESCRIPTION
    Deletes a local Code Repository in an AutomateNOW! instance

    .PARAMETER CodeRepository
    Mandatory [ANOWCodeRepository] object (Use Get-AutomateNOWCodeRepository to retrieve them)

    .PARAMETER Quiet
    Optional switch to suppress the display of the results

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    You must present a [ANOWCodeRepository] object

    .OUTPUTS
    An informational message indicating the results. Use -Quiet to suppress this.

    .EXAMPLE
    Uses the pipeline to forcibly and quietly delete a code repository named 'CodeRepository1'.

    Get-AutomateNOWCodeRepository -Id 'CodeRepository1' | Remove-AutomateNOWCodeRepository -Force -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0 ) {
            [ANOWCodeRepository]$CodeRepository = $_
        }
        [string]$CodeRepository_Id = $CodeRepository.Id
        If ($CodeRepository_Id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        ## Do not tamper with this code. It ensures that we are not trying to remove a local Code Repository that doesn't exist
        $Error.Clear()
        Try {
            [ANOWCodeRepository]$existing_repository = Get-AutomateNOWCodeRepository -Id $CodeRepository_Id
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepository failed to retrieve $CodeRepository_Id under Remove-AutomateNOWCodeRepository due to [$Message]."
            Break
        }
        If ($CodeRepository_Id -cne $existing_repository.Id) {
            Write-Warning -Message "There is not a Code repository named $CodeRepository_Id. Please check the spelling and case sensitivity."
            Break
        }
        ##
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Proceed to delete the Code Repository `"$($CodeRepository_Id)`" ?")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
            $Body.'id' = $CodeRepository_Id
            $Body.'_operationType' = 'remove'
            $Body.'_textMatchStyle' = 'exact'
            [string]$old_values = $CodeRepository.CreateOldValues()
            $Body.'_oldValues' = $old_values
            $Body.'_componentId' = 'CodeRepositoryList'
            $Body.'_dataSource' = 'CodeRepositoryDataSource'
            $Body.'isc_metaDataPrefix' = '_'
            $Body.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $Body
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            [string]$command = ('/codeRepository/delete')
            If ($null -eq $parameters["Command"]) {
                $parameters.Add('Command', $command)
            }
            Else {
                $parameters.Command = $command
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            If ($Quiet -ne $True) {
                Write-Information -MessageData "The local Code Repository $CodeRepository_Id was deleted"
            }
        }
    }
    End {

    }
}

Function Confirm-AutomateNOWCodeRepository {
    <#
    .SYNOPSIS
    Confirms that a remote Code Repository on an AutomateNOW! instance is available

    .DESCRIPTION
    Confirms that a remote Code Repository on an AutomateNOW! instance is available

    .PARAMETER CodeRepository
    Mandatory [ANOWCodeRepository] object (Use Get-AutomateNOWCodeRepository to retrieve them)

    .INPUTS
    ONLY [ANOWCodeRepository] objects are accepted (including from the pipeline)

    .OUTPUTS
    A string with the results from the API will returned.

    .EXAMPLE
    Validates a single Code Repository

    Get-AutomateNOWCodeRepository -Id 'CodeRepository01' | Confirm-AutomateNOWCodeRepository

    .EXAMPLE
    Validates a series of Code Repositorys

    @( 'CodeRepository1', 'CodeRepository2', 'CodeRepository3') | Confirm-AutomateNOWCodeRepository

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [string]$CodeRepository_id = $_.id
        }
        ElseIf ($CodeRepository.id.Length -gt 0) {
            [string]$CodeRepository_id = $CodeRepository.id
        }
        Else {
            [string]$CodeRepository_id = $Id
        }
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        $BodyMetaData.Add('id', $CodeRepository_id )
        $BodyMetaData.Add('_operationType', 'fetch')
        $BodyMetaData.Add('_operationId', 'status')
        $BodyMetaData.Add('_textMatchStyle', 'exact')
        $BodyMetaData.Add('_dataSource', 'CodeRepositoryDataSource')
        $BodyMetaData.Add('isc_metaDataPrefix', '_')
        $BodyMetaData.Add('isc_dataFormat', 'json')
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        $parameters.Add('Body', $Body)
        [string]$command = ('/codeRepository/status')
        $parameters.Add('Command', $command)
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$CodeRepository_id] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            If ($Quiet -eq $true) {
                Return $false
            }
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "The response code was [$response_code] instead of 0. The Code Repository $CodeRepository_id is not validated. Please see the full response $full_response_display"
        }
        Else {
            If ($Quiet -eq $true) {
                Return $true
            }
            Else {
                Write-Information -MessageData "The Code Repository $CodeRepository_id is confirmed as available."
            }
        }
    }
    End {

    }
}

Function Sync-AutomateNOWCodeRepository {
    <#
    .SYNOPSIS
    Synchronizes the changes between the local and remote objects within a Code Repository on an AutomateNOW! instance

    .DESCRIPTION
    Synchronizes the changes between the local and remote objects within a Code Repository on an AutomateNOW! instance

    .PARAMETER CodeRepository
    Mandatory [ANOWCodeRepository] object (Use Get-AutomateNOWCodeRepository to retrieve them)

    .PARAMETER Quiet
    Optional switch to suppress the display of the results

    .PARAMETER Force
    Force the synchronization without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWCodeRepository] objects are accepted (including from the pipeline)

    .OUTPUTS
    A table produced from Format-Table will be returned with the same results as the console delivers in this case (including out of sync count)

    .EXAMPLE
    Synchronizes a single git repository using the pipeline

    Get-AutomateNOWCodeRepository -Id 'CodeRepository1' | Sync-AutomateNOWCodeRepository

    .EXAMPLE
    Forcibly synchronizes a single repository

    Sync-AutomateNOWCodeRepository -CodeRepository $repo -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWCodeRepository]$CodeRepository = $_
            [string]$CodeRepository_id = $CodeRepository.id
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($CodeRepository_id)")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                $BodyMetaData.Add('id', $CodeRepository_id )
                $BodyMetaData.Add('_operationType', 'custom')
                $BodyMetaData.Add('_operationId', 'synchronizeAll')
                $BodyMetaData.Add('_textMatchStyle', 'exact')
                $BodyMetaData.Add('_dataSource', 'CodeRepositoryDataSource')
                $BodyMetaData.Add('isc_metaDataPrefix', '_')
                $BodyMetaData.Add('isc_dataFormat', 'json')
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
                $parameters.Add('Body', $Body)
                [string]$command = ('/codeRepository/synchronizeAll')
                $parameters.Add('Command', $command)
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$CodeRepository_id] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    If ($Quiet -eq $true) {
                        Return $false
                    }
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "The response code was [$response_code] instead of 0. The Code Repository $CodeRepository_id sync was not successful. Please see the full response $full_response_display"
                }
                Else {
                    If ($Quiet -ne $true) {
                        $sync_table = $results.response.data
                        $sync_table | Format-Table -Autosize -Wrap
                        Write-Information -MessageData "The Code Repository $CodeRepository_id synchronized successfully."
                    }
                    Else {
                        Write-Verbose -MessageData "The Code Repository $CodeRepository_id synchronized successfully."
                    }
                }
            }
        }
    }
    End {

    }
}

Function Receive-AutomateNOWCodeRepository {
    <#
    .SYNOPSIS
    Pulls (downloads) changes from the remote repository.

    .DESCRIPTION
    Pulls (downloads) changes from the remote repository.

    .PARAMETER CodeRepository
    Mandatory [ANOWCodeRepository] object (Use Get-AutomateNOWCodeRepository to retrieve them)

    .PARAMETER Quiet
    Optional switch to suppress the display of the results

    .PARAMETER Force
    Force the pull without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWCodeRepository] objects are accepted (including from the pipeline)

    .OUTPUTS
    An informational message will be displayed similar to the console (e.g. "@{message=Ok; status=OK; branch=refs/heads/development}"). Use the -Quiet parameter to suppress this.

    .EXAMPLE
    Forcibly pulls a single git repository using the pipeline

    Get-AutomateNOWCodeRepository -Id 'CodeRepository1' | Receive-AutomateNOWCodeRepository -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This function is the equivalent to the 'Push' button in the UI.

    Use Receive-AutomateNOWCodeRepository if you need to perform a Pull operation from the remote repository to the local one.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWCodeRepository]$CodeRepository = $_
        }
        [string]$CodeRepository_id = $CodeRepository.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($CodeRepository_id)")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $CodeRepository_id )
            $BodyMetaData.Add('_operationType', 'custom')
            $BodyMetaData.Add('_operationId', 'pull')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'CodeRepositoryDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            [string]$command = ('/codeRepository/pull')
            $parameters.Add('Command', $command)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on $CodeRepository_id due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                If ($Quiet -eq $true) {
                    Return $false
                }
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "The response code was [$response_code] instead of 0. The Code Repository $CodeRepository_id pull (download) was not successful. Please see the full response $full_response_display"
            }
            Else {
                If ($Quiet -ne $true) {
                    [string]$results_string = $results.response.data
                    If ($results_string.Length -eq 0) {
                        Write-Warning -Message "Somehow there was no response data from executing [$command] on $CodeRepository_id even though the response code indicated success."
                        Break
                    }
                    Write-Information -Message "The Code Repository $CodeRepository_id replied to this pull request with: $results_string."
                }
            }
        }
    }
    End {

    }
}

Function Send-AutomateNOWCodeRepository {
    <#
    .SYNOPSIS
    Pushes (uploads) changes to the remote repository.

    .DESCRIPTION
    Pushes (uploads) changes to the remote repository.

    .PARAMETER CodeRepository
    Mandatory [ANOWCodeRepository] object (Use Get-AutomateNOWCodeRepository to retrieve them)

    .PARAMETER Quiet
    Optional switch to suppress the display of the results

    .PARAMETER Force
    Force the push without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWCodeRepository] objects are accepted (including from the pipeline)

    .OUTPUTS
    #An informational message will be displayed similar to the console (e.g. "Committed [1] objects"). Use the -Quiet parameter to skip this.

    .EXAMPLE
    Forcibly pushes a single git repository using the pipeline

    Get-AutomateNOWCodeRepository -Id 'CodeRepository1' | Send-AutomateNOWCodeRepository -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This function is the equivalent to the 'Push' button in the UI.

    Use Receive-AutomateNOWCodeRepository if you need to perform a Pull operation from the remote repository to the local one.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWCodeRepository]$CodeRepository = $_
        }
        [string]$CodeRepository_id = $CodeRepository.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($CodeRepository_id)")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $CodeRepository_id )
            $BodyMetaData.Add('_operationType', 'custom')
            $BodyMetaData.Add('_operationId', 'push')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'CodeRepositoryDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            [string]$command = ('/codeRepository/push')
            $parameters.Add('Command', $command)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$CodeRepository_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                If ($Quiet -eq $true) {
                    Return $false
                }
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "The response code was [$response_code] instead of 0. The Code Repository $CodeRepository_id push (upload) was not successful. Please see the full response $full_response_display"
            }
            Else {
                If ($Quiet -ne $true) {
                    [string]$results_string = $results.response.data
                    If ($results_string.Length -eq 0) {
                        Write-Warning -Message "Somehow there was no response data from executing [$command] on $CodeRepository_id even though the response code indicated success."
                        Break
                    }
                    Write-Information -Message "The Code Repository $CodeRepository_id replied to this pull request with: $results_string."
                }
            }
        }
    }
    End {

    }
}

Function Publish-AutomateNOWCodeRepository {
    <#
    .SYNOPSIS
    Commits the changes made in the application version to the local git repository for all objects included in the code repository from an instance of AutomateNOW!

    .DESCRIPTION
    Commits the changes made in the application version to the local git repository for all objects included in the code repository from an instance of AutomateNOW!

    .PARAMETER CodeRepository
    Mandatory [ANOWCodeRepository] object (Use Get-AutomateNOWCodeRepository to retrieve them)

    .PARAMETER ForceCommit
    Optional switch to use the /forceCommit endpoint instead of the /commit endpoint. Use this when you want to force the commit despite that none of the items have changed.

    .PARAMETER Force
    Force the commit without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWCodeRepository] objects are accepted (including from the pipeline)

    .OUTPUTS
    An informational message will be displayed similar to the console (e.g. "Committed [1] objects"). Use the -Quiet parameter to skip this.

    .EXAMPLE
    Commits a single git repository using the pipeline

    Get-AutomateNOWCodeRepository -Id 'CodeRepository1' -Branch 'master' | Publish-AutomateNOWCodeRepository

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This function is the equivalent to the 'Commit All' button in the UI.

    Use Unpublish-AutomateNOWCodeRepository if you need to revert a commit.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$ForceCommit,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWCodeRepository]$CodeRepository = $_
        }
        [string]$CodeRepository_id = $CodeRepository.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($CodeRepository_id)")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $CodeRepository_id )
            If ($ForceCommit -eq $true) {
                $BodyMetaData.Add('_operationId', 'forceCommit')
                [string]$command = ('/codeRepository/forceCommit')
            }
            Else {
                $BodyMetaData.Add('_operationId', 'commit')
                [string]$command = ('/codeRepository/commit')
            }
            $BodyMetaData.Add('_operationType', 'custom')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'CodeRepositoryDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            $parameters.Add('Command', $command)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$CodeRepository_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                If ($Quiet -ne $true) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "The response code was [$response_code] instead of 0. The Code Repository $CodeRepository_id commit (Publish) was not successful. Please see the full response $full_response_display"
                }
            }
            Else {
                If ($Quiet -ne $true) {
                    [string]$results_string = $results.response.data
                    If ($results_string.Length -eq 0) {
                        Write-Warning -Message "Somehow there was no response data from executing [$command] on [$CodeRepository_id] even though the response code indicated success."
                        Break
                    }
                    Write-Information -Message "The response from the Code Repository $CodeRepository_id was [Committed $results_string items]"
                }
            }
        }
    }
    End {

    }
}

Function UnPublish-AutomateNOWCodeRepository {
    <#
    .SYNOPSIS
    Reverts (rolls back) the changes made in the application version to the local git repository for all objects included in the code repository from an instance of AutomateNOW!

    .DESCRIPTION
    Reverts (rolls back) the changes made in the application version to the local git repository for all objects included in the code repository from an instance of AutomateNOW!

    .PARAMETER CodeRepository
    Mandatory [ANOWCodeRepository] object (Use Get-AutomateNOWCodeRepository to retrieve them)

    .PARAMETER Quiet
    Optional switch to suppress the display of the results

    .PARAMETER Force
    Force the revert without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWCodeRepository] objects are accepted (including from the pipeline)

    .OUTPUTS
    An informational message will be displayed similar to the console (e.g. "Committed [1] objects"). Use the -Quiet parameter to skip this.

    .EXAMPLE
    Forcibly reverts a single git repository using the pipeline

    Get-AutomateNOWCodeRepository -Id 'CodeRepository1' | UnPublish-AutomateNOWCodeRepository -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This function is the equivalent to the 'Rollback All' button in the UI.

    Use Publish-AutomateNOWCodeRepository if you need to commit a change.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWCodeRepository]$CodeRepository = $_
        }
        [string]$CodeRepository_id = $CodeRepository.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($CodeRepository_id)")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $CodeRepository_id )
            $BodyMetaData.Add('_operationType', 'custom')
            $BodyMetaData.Add('_operationId', 'rollback')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'CodeRepositoryDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            [string]$command = ('/codeRepository/rollback')
            $parameters.Add('Command', $command)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$CodeRepository_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                If ($Quiet -eq $true) {
                    Return $false
                }
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "The response code was [$response_code] instead of 0. The Code Repository $CodeRepository_id rollback (Unpublish) was not successful. Please see the full response $full_response_display"
            }
            Else {
                If ($Quiet -ne $true) {
                    [string]$results_string = $results.response.data
                    If ($results_string.Length -eq 0) {
                        Write-Warning -Message "Somehow there was no response data from executing [$command] on [$CodeRepository_id] even though the response code indicated success."
                        Break
                    }
                    Write-Information -Message "The Code Repository $CodeRepository_id $results_string."
                }
            }
        }
    }
    End {

    }
}

Function Resolve-AutomateNOWCodeRepository {
    <#
    .SYNOPSIS
    Starts the process of resolving a conflict in a code repository by confirming the status of the repository as out-of-sync on an instance of AutomateNOW!

    .DESCRIPTION
    Starts the process of resolving a conflict in a code repository by confirming the status of the repository as out-of-sync on an instance of AutomateNOW!

    .PARAMETER CodeRepository
    Mandatory [ANOWCodeRepository] object (Use Get-AutomateNOWCodeRepository to retrieve them)

    .INPUTS
    ONLY [ANOWCodeRepository] objects are accepted (including from the pipeline)

    .OUTPUTS
    The same [ANOWCodeRepository] object will be returned if there really is a conflict that needs to be resolved.

    .EXAMPLE
    "Resolves" a repository

    Get-AutomateNOWCodeRepository -Id 'CodeRepository01' | Resolve-AutomateNOWCodeRepository

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    It is not yet fully understood exactly what the purpose of the /resolveConflicts endpoint is. The operationType is 'custom', not 'fetch'. The operationId is 'resolveConflicts', not 'status'. Hence this is not the same as Get-AutomateNOWCodeRepository.

    #>
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [string]$CodeRepository_id = $_.id
        }
        ElseIf ($CodeRepository.id.Length -gt 0) {
            [string]$CodeRepository_id = $CodeRepository.id
        }
        Else {
            [string]$CodeRepository_id = $Id
        }
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        $BodyMetaData.Add('id', $CodeRepository_id )
        $BodyMetaData.Add('_operationType', 'custom')
        $BodyMetaData.Add('_operationId', 'resolveConflicts')
        $BodyMetaData.Add('_textMatchStyle', 'exact')
        $BodyMetaData.Add('_dataSource', 'CodeRepositoryDataSource')
        $BodyMetaData.Add('isc_metaDataPrefix', '_')
        $BodyMetaData.Add('isc_dataFormat', 'json')
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        $parameters.Add('Body', $Body)
        [string]$command = ('/codeRepository/resolveConflicts')
        $parameters.Add('Command', $command)
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$CodeRepository_id] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            If ($Quiet -eq $true) {
                Return $false
            }
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "The response code was [$response_code] instead of 0. The Code Repository $CodeRepository_id is not validated. Please see the full response $full_response_display"
        }
        Else {
            $Error.Clear()
            Try {
                [ANOWCodeRepository]$CodeRepository = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the response into a series of [ANOWCodeRepository] objects due to [$Message]."
                Break
            }
            If ($CodeRepository.mergeConflict -eq $true) {
                Return $CodeRepository
            }
            Else {
                Write-Warning -Message "Somehow the code repository $CodeRepository_id is no longer in conflict!"
            }
        }
    }
    End {

    }
}

#endregion

#Region - Code Repository Branches

Function Get-AutomateNOWCodeRepositoryBranch {

    <#
    .SYNOPSIS
    Gets the branches from a local Code Repository in an AutomateNOW! instance

    .DESCRIPTION
    Gets the branches from a local Code Repository in an AutomateNOW! instance

    .PARAMETER CodeRepository
    Mandatory [ANOWCodeRepository] object (Use Get-AutomateNOWCodeRepository to retrieve them)

    .PARAMETER Id
    Optional string to filter the results to a single branch by name. Use this when you only want a specific branch.

    .PARAMETER startRow
    Integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER StringOnly
    Switch parameter that will reduce the output to a string array of the names of the branches instead of returning [ANOWCodeRepositoryBranch] objects

    .INPUTS
    You must present [ANOWCodeRepository] objects

    .OUTPUTS
    [ANOWCodeRepositoryBranch] objects by default. Use the -StringOnly parameter to fetch only the names of the branches.

    .EXAMPLE
    Gets the names of the branches from a Code Repository

    $repo = Get-AutomateNOWCodeRepository -Id 'Repository1'
    $branches = Get-AutomateNOWCodeRepositoryBranch -CodeRepository $repo

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWCodeRepositoryBranch[]])]
    [Cmdletbinding(DefaultParameterSetName = 'All')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'All', ValueFromPipeline = $true)]
        [Parameter(Mandatory = $true, ParameterSetName = 'Single', ValueFromPipeline = $true)]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $true, ParameterSetName = 'Single')]
        [string]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $false, ParameterSetName = 'All')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Single')]
        [switch]$StringOnly
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Id.Length -gt 0 ) {
            $Body.'codeRepository' = $_.Id
        }
        Else {
            $Body.'codeRepository' = $CodeRepository.Id
        }
        $Body.'_startRow' = $startRow
        $Body.'_endRow' = $endRow
        $Body.'_operationType' = 'fetch'
        $Body.'_textMatchStyle' = 'exact'
        $Body.'_componentId' = 'CodeRepositoryBranchList'
        $Body.'_dataSource' = 'CodeRepositoryBranchDataSource'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/codeRepositoryBranch/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWCodeRepositoryBranch[]]$CodeRepositoryBranches = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWCodeRepositoryBranch] objects due to [$Message]."
            Break
        }
        If ($Id.Length -gt 0) {
            [ANOWCodeRepositoryBranch]$CodeRepositoryBranch = $CodeRepositoryBranches | Where-Object { $_.Id -eq $Id }
        }
        If ($Id.Length -eq 0 -and $CodeRepositoryBranches.Count -gt 0) {
            If ($StringOnly -eq $true) {
                [string[]]$branches = $CodeRepositoryBranches.id
                Return $branches
            }
            Else {
                Return $CodeRepositoryBranches
            }
        }
        ElseIf ($Id.Length -gt 0) {
            If ($StringOnly -eq $true) {
                [string]$branch_name = $CodeRepositoryBranch.Id
                Return $branch_name
            }
            Else {
                Return $CodeRepositoryBranch
            }
        }
    }
    End {

    }
}

Function New-AutomateNOWCodeRepositoryBranch {
    <#
    .SYNOPSIS
    Creates a branch on a local Code Repository in an AutomateNOW! instance

    .DESCRIPTION
    Creates a branch on a local Code Repository in an AutomateNOW! instance

    .PARAMETER CodeRepository
    Mandatory [ANOWCodeRepository] object (Use Get-AutomateNOWCodeRepository to retrieve them)

    .PARAMETER Branch
    Mandatory string for the name of the branch. The name of the branch may consist only of alphanumeric characters and 3 special characters (._-) and not to exceed 128 characters in length.

    .PARAMETER Quiet
    Optional switch to suppress the display of the results

    .PARAMETER Force
    Force the creation of the object without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    You must present [ANOWCodeRepository] objects

    .OUTPUTS
    An informational message indicating the results. Use -Quiet to suppress this.

    .EXAMPLE
    Creates a new branch named 'DevBranch2' on a repository named 'CodeRepository1'.

    $repo = Get-AutomateNOWCodeRepository -Id 'CodeRepository1'
    New-AutomateNOWCodeRepositoryBranch -CodeRepository $repo -Branch 'DevBranch2'

    .EXAMPLE
    Uses the pipeline to quietly and forcibly create three branches on a repository named 'CodeRepository1'

    $repo = Get-AutomateNOWCodeRepository -Id 'CodeRepository1'
    @('test', 'dev', 'production') | New-AutomateNOWCodeRepositoryBranch -CodeRepository $repo -Force -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWCodeRepositoryBranch])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWCodeRepository]$CodeRepository,
        [ValidateScript({ $_.Length -gt 0 -and $_.Length -le 128 })]
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [string]$Branch,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.Length -gt 0 ) {
            [string]$Branch = $_
        }
        [string]$CodeRepository_Id = $CodeRepository.Id
        ## Do not tamper with this code. It ensures that we are not trying to add a branch that already exists
        [string[]]$existing_branches = Get-AutomateNOWCodeRepositoryBranch -CodeRepository $CodeRepository
        If ($Branch -in $existing_branches) {
            Write-Warning -Message "The branch [$Branch] already exists in $CodeRepository_id. No action is required."
            Break
        }
        ##
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Proceed to create the branch `"$($Branch)`" on the Code Repository $($CodeRepository_id) ?")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
            $Body.'codeRepository' = $CodeRepository_Id
            $Body.'id' = $Branch
            $Body.'_operationType' = 'add'
            $Body.'_operationId' = 'createBranch'
            $Body.'_textMatchStyle' = 'exact'
            $Body.'_oldValues' = ('{"codeRepository":"' + $CodeRepository_Id + '","id":""}')
            $Body.'_componentId' = 'CodeRepositoryBranchCreateWindow_form'
            $Body.'_dataSource' = 'CodeRepositoryBranchDataSource'
            $Body.'isc_metaDataPrefix' = '_'
            $Body.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $Body
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            If ($null -eq $parameters["Command"]) {
                [string]$command = ('/codeRepositoryBranch/create')
                $parameters.Add('Command', $command)
            }
            Else {
                $parameters.Command = $command
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            $Error.Clear()
            Try {
                [ANOWCodeRepositoryBranch]$CodeRepositoryBranch = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the returned updated object to an [ANOWFolder] object due to [$Message]. The object was still updated though."
                Break
            }
            If ($Quiet -ne $true) {
                Return $CodeRepositoryBranch
            }
        }
    }
    End {

    }
}

Function Remove-AutomateNOWCodeRepositoryBranch {

    <#
    .SYNOPSIS
    Deletes a branch on a local Code Repository in an AutomateNOW! instance

    .DESCRIPTION
    Deletes a branch on a local Code Repository in an AutomateNOW! instance

    .PARAMETER CodeRepository
    Mandatory [ANOWCodeRepository] object (Use Get-AutomateNOWCodeRepository to retrieve them)

    .PARAMETER Branch
    Mandatory string for the name of the branch to delete.

    .PARAMETER Quiet
    Optional switch to suppress the display of the results

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    You must present [ANOWCodeRepository] objects

    .OUTPUTS
    An informational message indicating the results. Use -Quiet to suppress this.

    .EXAMPLE
    Deletes a branch named 'DevBranch2' on a repository named 'CodeRepository1'.

    $repo = Get-AutomateNOWCodeRepository -Id 'CodeRepository1'
    Remove-AutomateNOWCodeRepositoryBranch -CodeRepository $repo -Branch 'DevBranch2'

    .EXAMPLE
    Uses the pipeline to quietly and forcibly delete three branches on a repository named 'CodeRepository1'

    $repo = Get-AutomateNOWCodeRepository -Id 'CodeRepository1'
    @('test1', 'test2', 'test3') | New-AutomateNOWCodeRepositoryBranch -CodeRepository $repo -Force -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWCodeRepository]$CodeRepository,
        [ValidateScript({ $_.Length -gt 0 -and $_.Length -le 128 })]
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [string]$Branch,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.Length -gt 0 ) {
            [string]$Branch = $_
        }
        [string]$CodeRepository_Id = $CodeRepository.Id
        If ($CodeRepository_Id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If ($Branch.Length -eq 0) {
            Write-Warning -Message "Somehow an empty branch name was passed to this function. Please look into this."
            Break
        }
        ## Do not tamper with this code. It ensures that we are not trying to remove a branch that doesn't exist
        $Error.Clear()
        Try {
            [string[]]$existing_branches = Get-AutomateNOWCodeRepositoryBranch -CodeRepository $CodeRepository
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepositoryBranch failed to retrieve the branches from $CodeRepository_Id under Remove-AutomateNOWCodeRepositoryBranch due to [$Message]."
            Break
        }
        If ($Branch -notin $existing_branches) {
            Write-Warning -Message "The branch [$Branch] does not exist in $CodeRepository_id. No action is required."
            Break
        }
        ##
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Proceed to delete the branch `"$($Branch)`" from the Code Repository $($CodeRepository_id) ?")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
            $Body.'codeRepository' = $CodeRepository_Id
            $Body.'id' = $Branch
            $Body.'_operationType' = 'remove'
            $Body.'_textMatchStyle' = 'exact'
            $Body.'_dataSource' = 'CodeRepositoryBranchDataSource'
            $Body.'isc_metaDataPrefix' = '_'
            $Body.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $Body
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            [string]$command = ('/codeRepositoryBranch/delete')
            If ($null -eq $parameters["Command"]) {
                $parameters.Add('Command', $command)
            }
            Else {
                $parameters.Command = $command
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            If ($Quiet -ne $True) {
                [string]$branch_name = $results.response.data.id
                Write-Information -MessageData "The branch [$branch_name] was deleted from $CodeRepository_Id"
            }
        }
    }
    End {

    }
}

Function Select-AutomateNOWCodeRepositoryBranch {
    <#
    .SYNOPSIS
    Selects (checks out) a branch of a Code Repository on an instance of AutomateNOW!

    .DESCRIPTION
    Selects (checks out) a branch of a Code Repository on an instance of AutomateNOW!

    .PARAMETER CodeRepository
    Mandatory [ANOWCodeRepository] object (Use Get-AutomateNOWCodeRepository to retrieve them)

    .PARAMETER Branch
    Mandatory string containing the name of the branch (Use Get-AutomateNOWCodeRepositoryBranch to get the list of available branches)

    .PARAMETER Quiet
    Optional switch to suppress the display of the results

    .PARAMETER Force
    Force the selection without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    You must present both the [ANOWCodeRepository] object and the name of the branch

    .OUTPUTS
    An informational message indicating that the branch was successfully selected. Use the -Quiet parameter to silence this notification.

    .EXAMPLE
    Creates a variable named $repo2 with the needed branch selected.

    $repo1 = Get-AutomateNOWCodeRepository -Id 'CodeRepository1'
    $repo2 = Select-AutomateNOWCodeRepository -CodeRepository $repo1 -Branch 'dev'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This function is the equivalent to the 'Checkout Branch' button when 1 branch is selected in the Branches tab of a Code Repository.

    This function will attempt to ensure that the branch exists before selecting it (checking it out). You will receive back a modified [ANOWCodeRepository] object with the branch selected.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $true)]
        [string]$Branch,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWCodeRepository]$CodeRepository = $_
        }
        [string]$CodeRepository_id = $CodeRepository.id
        $Error.Clear()
        Try {
            [ANOWCodeRepositoryBranch[]]$available_branches = Get-AutomateNOWCodeRepositoryBranch -CodeRepository $CodeRepository
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepositoryBranch failed to retrieve the branches from $CodeRepository_id under Select-AutomateNOWCodeRepositoryBranch due to [$Message]."
            Break
        }
        If ($available_branches.Count -eq 0) {
            Write-Warning -Message "There are no branches in the $CodeRepository_id. Nothing can be selected (checked out)."
            Break
        }
        If ($branch -notin $available_branches.id) {
            [string]$available_branches_display = $available_branches | ConvertTo-Json -Compress
            Write-Warning -Message "The branch [$branch] is not available in $CodeRepository_id which has the following branches: $available_branches_display. Please check and try again."
            Break
        }
        Else {
            Write-Verbose -Message "Confirmed that the brach [$branch] is available in $CodeRepository_Id."
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$CodeRepository_id ($branch branch)")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('branch', $branch )
            $BodyMetaData.Add('id', $CodeRepository_id )
            $BodyMetaData.Add('_operationType', 'custom')
            $BodyMetaData.Add('_operationId', 'selectBranch')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'CodeRepositoryDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            [string]$command = ('/codeRepository/selectBranch')
            $parameters.Add('Command', $command)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on $CodeRepository_id due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                If ($Quiet -eq $true) {
                    Return $false
                }
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "The response code was [$response_code] instead of 0. Selecting the [$branch] branch of the $CodeRepository_id Code Repository failed. Please see the full response $full_response_display"
            }
            Else {
                If ($Quiet -ne $true) {
                    $sync_table = $results.response.data
                    $sync_table | Format-Table -Autosize -Wrap
                    Write-Information -MessageData "The $branch branch has been selected for $CodeRepository_id"
                }
                Else {
                    Write-Verbose -Message "The $branch branch has been selected for $CodeRepository_id"
                }
            }
        }
    }
    End {

    }
}

Function Merge-AutomateNOWCodeRepositoryBranch {
    <#
    .SYNOPSIS
    Merges two branches of a Code Repository on an instance of AutomateNOW! into a single Merge Request object

    .DESCRIPTION
    Merges two branches of a Code Repository on an instance of AutomateNOW! into a single Merge Request object

    .PARAMETER CodeRepository
    Mandatory [ANOWCodeRepository] object (Use Get-AutomateNOWCodeRepository to retrieve them)

    .PARAMETER SourceBranch
    Mandatory [ANOWCodeRepositoryBranch] object from which you want to merge (Use Get-AutomateNOWCodeRepositoryBranch to get the list of available branches)

    .PARAMETER TargetBranch
    Mandatory [ANOWCodeRepositoryBranch] object to where you want to merge (Use Get-AutomateNOWCodeRepositoryBranch to get the list of available branches)

    .PARAMETER Description
    Option description of the Merge Request.

    .PARAMETER Force
    Force the merger without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the display of the results

    .INPUTS
    You must present both the [ANOWCodeRepository] object and the name of the branch. You may not pipe objects to Merge-AutomateNOWCodeRepositoryBranch.

    .OUTPUTS
    An informational message indicating that the branch was successfully selected. Use the -Quiet parameter to silence this notification.

    .EXAMPLE
    Forcibly creates a Merge Request from a branch named 'master1' to a branch named 'master2' in a Code Repository named 'Repository1'

    $repository = Get-AutomateNOWCodeRepository -Id 'Repository1'
    $source_branch = Get-AutomatenowCodeRepositoryBranch -CodeRepository $repository -Id 'master1'
    $target_branch = Get-AutomatenowCodeRepositoryBranch -CodeRepository $repository -Id 'master2'
    Merge-AutomateNOWCodeRepositoryBranch -CodeRepository $repository -SourceBranch $source_branch -TargetBranch $target_branch -Description $desc -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This function will attempt to ensure that both branches exist before attempting to merge them. You will receive back a modified [ANOWCodeRepository] object with the branch selected.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $true)]
        [ANOWCodeRepositoryBranch]$SourceBranch,
        [Parameter(Mandatory = $true)]
        [ANOWCodeRepositoryBranch]$TargetBranch,
        [Parameter(Mandatory = $false)]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.Id.Length -gt 0) {
            [ANOWCodeRepository]$CodeRepository = $_
        }
        [string]$CodeRepository_id = $CodeRepository.Id
        [string]$SourceBranch_id = $SourceBranch.Id
        [string]$TargetBranch_id = $TargetBranch.Id
        $Error.Clear()
        Try {
            [ANOWCodeRepositoryBranch[]]$available_branches = Get-AutomateNOWCodeRepositoryBranch -CodeRepository $CodeRepository
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepositoryBranch failed to retrieve the branches from $CodeRepository_id under Select-AutomateNOWCodeRepositoryBranch due to [$Message]."
            Break
        }
        If ($available_branches.Count -eq 0) {
            Write-Warning -Message "There are no branches in the $CodeRepository_id. There is nothing to merge."
            Break
        }
        Else {
            [string]$available_branches_display = $available_branches.Id | ConvertTo-Json -Compress
        }
        If ($SourceBranch.id -notin $available_branches.id) {
            Write-Warning -Message "The source branch [$SourceBranch_id] is not available in $CodeRepository_id which has the following branches: $available_branches_display. Please check and try again."
            Break
        }
        ElseIf ($TargetBranch.id -notin $available_branches.id) {
            Write-Warning -Message "The target branch [$TargetBranch_id] is not available in $CodeRepository_id which has the following branches: $available_branches_display. Please check and try again."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($CodeRepository_id)")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('codeRepository', $CodeRepository_id )
            $BodyMetaData.Add('sourceBranch', $SourceBranch_id )
            $BodyMetaData.Add('targetBranch', $TargetBranch_id )
            If ($Description.Length -gt 0) {
                $BodyMetaData.Add('description', $Description)
            }
            $BodyMetaData.Add('_operationType', 'add')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'MergeRequestDataSource')
            $BodyMetaData.Add('_oldValues', ('"{codeRepository":"' + $CodeRepository_id + '"}' ) )
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            [string]$command = ('/mergeRequest/create')
            $parameters.Add('Command', $command)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on $CodeRepository_id due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                If ($Quiet -eq $true) {
                    Return $false
                }
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "The response code was [$response_code] instead of 0. The Code Repository $CodeRepository_id Merge Request was not successful. Please see the full response $full_response_display"
            }
            $Error.Clear()
            Try {
                [ANOWCodeRepositoryMergeRequest]$CodeRepositoryMergeRequest = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the response into [ANOWCodeRepositoryMergeRequest] object due to [$Message]."
                Break
            }
            If ($Quiet -ne $true) {
                Return $CodeRepositoryMergeRequest
            }
        }
    }
    End {

    }
}

#endregion

#Region - Code Repository Conflict Items

Function Get-AutomateNOWCodeRepositoryConflictItem {
    <#
    .SYNOPSIS
    Gets all of the conflict items from a local Code Repository in an AutomateNOW! instance

    .DESCRIPTION
    Gets all of the conflict items from a local Code Repository in an AutomateNOW! instance

    .PARAMETER CodeRepository
    Mandatory [ANOWCodeRepository] object (Use Get-AutomateNOWCodeRepository to retrieve them)

    .PARAMETER startRow
    Integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .INPUTS
    You must present [ANOWCodeRepository] objects

    .OUTPUTS
    [ANOWCodeRepositoryConflictItem] objects

    .EXAMPLE
    Gets the conflict items from a Code Repository

    $repo = Get-AutomateNOWCodeRepository -Id 'Repository1'
    $conflicts = Get-AutomateNOWCodeRepositoryConflictItem -CodeRepository $repo

    .EXAMPLE
    Confirms first that the Code Repository is in conflict status and then retrieves the conflict items

    $repo = Get-AutomateNOWCodeRepository -Id 'Repository1' | Resolve-AutomateNOWCodeRepository
    $conflicts = Get-AutomateNOWCodeRepositoryConflictItem -CodeRepository $repo

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWCodeRepositoryConflictItem[]])]
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $False)]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False)]
        [int32]$endRow = 100
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Id.Length -gt 0 ) {
            [ANOWCodeRepository]$CodeRepository = $_
        }
        [string]$CodeRepository_Id = $CodeRepository.Id
        $Body.'codeRepository' = $CodeRepository_Id
        $Body.'_startRow' = $startRow
        $Body.'_endRow' = $endRow
        $Body.'_operationType' = 'fetch'
        $Body.'_textMatchStyle' = 'exact'
        $Body.'_componentId' = 'CodeRepositoryConflictList'
        $Body.'_dataSource' = 'CodeRepositoryConflictDataSource'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/codeRepositoryConflict/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWCodeRepositoryConflictItem[]]$ConflictItems = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWCodeRepositoryConflictItem] objects due to [$Message]."
            Break
        }
        If ($ConflictItems.Count -gt 0) {
            Return $ConflictItems
        }
    }
    End {

    }
}

Function Compare-AutomateNOWCodeRepositoryConflictItem {
    <#
    .SYNOPSIS
    Compares the the local branch and remote branch of a conflict item in a Code Repository on an instance of AutomateNOW!

    .DESCRIPTION
    Compares the the local branch and remote branch of a conflict item in a Code Repository on an instance of AutomateNOW!

    .PARAMETER CodeRepository
    Mandatory [ANOWCodeRepository] object (Use Get-AutomateNOWCodeRepository to retrieve them)

    .PARAMETER ConflictItem
    Mandatory [ANOWCodeRepositoryConflictItem] object (Use Get-AutomateNOWCodeRepositoryConflictItem to retrieve them)

    .INPUTS
    You must present both the [ANOWCodeRepository] object and the [ANOWCodeRepositoryConflictItem] object can be sent across the pipeline

    .OUTPUTS
    A comparison table

    .EXAMPLE
    Returns a custom comparison object showing the differences within a Conflict item from a Code Repository named 'CodeRepository1'

    $repository = Get-AutomateNOWCodeRepository -Id 'CodeRepository1'
    Select-AutomateNOWCodeRepositoryBranch -CodeRepository $repository -Branch 'master' -Quiet -Force
    $repository | Get-AutomateNOWCodeRepositoryConflictItem | Compare-AutomateNOWCodeRepositoryConflictItem -CodeRepository $repository

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This function is the equivalent to what happens when selecting a conflicted item in a Code Repository and the window appears with left/right sides for merger consideration.

    This is the only Object function which uses Invoke-AutomateNOWAPI more than once.

    The intention for this function is to send its results to Show-AutomateNOWCodeRepositoryConflictItemComparison which would help to decide whether to use the -AcceptYours or -AcceptTheirs parameter with Merge-AutomateNOWCodeRepositoryConflictItem.

    The domainClassName is still resolved even though ANOW doesn't seem to ask for it anymore

    #>
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWCodeRepositoryConflictItem]$ConflictItem
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$CodeRepository_Id = $CodeRepository.Id
    }
    Process {
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
        If ($_.id.Length -gt 0) {
            [ANOWCodeRepositoryConflictItem]$ConflictItem = $_
        }
        [string]$ConflictItem_Id = $ConflictItem.id
        If ($ConflictItem_Id -notmatch '^(\[([-._0-9a-zA-Z]{1,})\])?([-._0-9a-zA-Z]{1,})(\|[a-zA-Z]{3,}/)([-._0-9a-zA-Z]{1,})$') {
            Write-Warning -Message "Somehow the Id of the Conflict Item object $ConflictItem_Id did not match the expected format. Please look into this."
            Break
        }
        [string]$ConflictItem_id = $ConflictItem.Id
        $Error.Clear()
        Try {
            [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = $ConflictItem_id -split '\|' -split '/' | Select-Object -Skip 1 -First 1
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to cast $(ConflictItem.Id) to an [ANOWCodeRepositoryObjectSourceCode_domainClassName] enumerator due to due to [$Message]."
            Break
        }
        If ($domainClassName.Length -eq 0) {
            Write-Warning "Somehow the domainClassName could not be extracted from the Conflict item. Please look into this."
            Break
        }
        [string]$ConflictItem_domain = $ConflictItem.domain
        [string]$ConflictItem_filename = $ConflictItem_id -split '\|' | Select-Object -Skip 1 -First 1
        # Getting "your" version
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        $BodyMetaData.Add('file', $ConflictItem_filename )
        $BodyMetaData.Add('codeRepository', $CodeRepository_id )
        $BodyMetaData.Add('_operationType', 'fetch')
        $BodyMetaData.Add('_operationId', 'getYourVersion')
        $BodyMetaData.Add('_textMatchStyle', 'exact')
        $BodyMetaData.Add('_dataSource', 'CodeRepositoryConflictDataSource')
        $BodyMetaData.Add('isc_metaDataPrefix', '_')
        $BodyMetaData.Add('isc_dataFormat', 'json')
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        $parameters.Add('Body', $Body)
        [string]$command = ('/codeRepositoryConflict/getYourVersion')
        $parameters.Add('Command', $command)
        $Error.Clear()
        Try {
            [PSCustomObject]$your_results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on $ConflictItem_id due to [$Message]."
            Break
        }
        [int32]$response_code = $your_results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $your_results.response | ConvertTo-Json -Compress
            Write-Warning -Message "The response code was [$response_code] instead of 0 while attempting to execute [$command] on $ConflictItem_id. Please see the full response $full_response_display"
            Break
        }
        # Getting "their" version
        $parameters.Remove('Body')
        [string]$Body = $Body -replace 'getYourVersion', 'getTheirVersion'
        $parameters.Add('Body', $Body)
        $parameters.Remove('Command')
        [string]$command = ('/codeRepositoryConflict/getTheirVersion')
        $parameters.Add('Command', $command)
        $Error.Clear()
        Try {
            [PSCustomObject]$their_results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on $ConflictItem_id due to [$Message]."
            Break
        }
        [int32]$response_code = $their_results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $their_results.response | ConvertTo-Json -Compress
            Write-Warning -Message "The response code was [$response_code] instead of 0 while attempting to execute [$command] on $ConflictItem_id. Please see the full response $full_response_display"
        }
        [string]$your_version = $your_results.response.data #| ConvertFrom-Json -Depth 10
        [string]$their_version = $their_results.response.data #| ConvertFrom-Json -Depth 10
        If ($your_version.Length -eq 0 -and $their_version.Length -eq 0) {
            Write-Warning -Message "Both objects are somehow empty. There is nothing to compare."
            Break
        }
        [PSCustomObject]$results = [PSCustomObject]@{item_id = $ConflictItem_id; item_domain = $ConflictItem_domain; domainClassName = $domainClassName; codeRepository = $CodeRepository_id; your_version = $your_version; their_version = $their_version; }
        Return $results
    }
    End {

    }
}

Function Show-AutomateNOWCodeRepositoryConflictItemComparison {

    <#
    .SYNOPSIS
    Shows the comparison details of a conflict item from a local Code Repository in an AutomateNOW! instance and allows a left/right decision to be made with Merge-AutomateNOWCodeRepositoryConflictItem

    .DESCRIPTION
    Shows the comparison details of a conflict item from a local Code Repository in an AutomateNOW! instance and allows a left/right decision to be made with Merge-AutomateNOWCodeRepositoryConflictItem

    .PARAMETER AutomateNOWCodeRepositoryConflictItemComparison
    Mandatory results object [PSCustomObject] from Compare-AutomateNOWCodeRepositoryConflictItem

    .PARAMETER header_color
    Optional string to change the color of the git diff hunk header from the default blue.

    .PARAMETER your_version_color
    Optional string to change the color of 'your changes' (left side - database) in the git diff results from the default Red

    .PARAMETER their_version_color
    Optional string to change the color of 'their changes' (right side - repository) in the git diff results from the default Green

    .PARAMETER same_version_color
    Optional string to change the color of git diff results where there is no change from the default Gray

    .PARAMETER DoNotSuppressCRLFWarning
    Optional switch that will disregard trying to suppress the CRLF "safe warning". Use this if you are weary of this module changing your git global config and if you don't mind seeing the unneeded warning.

    .PARAMETER DoNotFormatOutput
    Optional switch that will show the formatted results of the git diff comparison but without colors.

    .PARAMETER JustGiveMeTheRawGitDiff
    Optional switch which skips all processing of the git diff results completely and returns the full results. Use this if you wish to interpret the results manually or with another tool.

    .PARAMETER DoNotShowLegend
    Optional switch which skips showing the legend after the git diff results are shown. Use this if you don't need an explanation on the colors used.

    .INPUTS
    Show-AutomateNOWCodeRepositoryConflictItemComparison accepts [PSCustomObject] result objects emitted from Compare-AutomateNOWCodeRepositoryConflictcItem (including on the pipeline)

    .OUTPUTS
    Informational messages with the results.

    .EXAMPLE
    Shows the left/right sides of a Code Repository Item in conflict residing on a Code Repository named 'CodeRepository1' in a multi-line format
	
    $out_of_sync_repository = Get-AutomateNOWCodeRepository -Id 'CodeRepository1' | Resolve-AutomateNOWCodeRepository
    $conflict_results = $out_of_sync_repository | Get-AutomateNOWCodeRepositoryConflictItem | Compare-AutomateNOWCodeRepositoryConflictItem -CodeRepository $repository
    Show-AutomateNOWCodeRepositoryConflictItemComparison -AutomateNOWCodeRepositoryConflictItemComparison $results

    .EXAMPLE
    Shows the left/right sides of a Code Repository Item in conflict residing on a Code Repository named 'CodeRepository1' in a one-liner format

    Get-AutomateNOWCodeRepository -Id 'CodeRepository1' | Resolve-AutomateNOWCodeRepository | Get-AutomateNOWCodeRepositoryConflictItem | Compare-AutomateNOWCodeRepositoryConflictItem -CodeRepository (Get-AutomateNOWCodeRepository -Id 'CodeRepository1' | Resolve-AutomateNOWCodeRepository) | Show-AutomateNOWCodeRepositoryConflictItemComparison

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Use the left/right results to help you determine whether to use the -AcceptYours or -AcceptTheirs parameter for Sync-AutomateNOWCodeRepositoryConflictItem

    Alternate colors may be specified using any of the standard 16 colors available to Write-Host.

    You can no longer select a branch if it has a merge conflict.

    You cannot pipe the Code Repository object, too. You must include the -repository parameter every time. See the one-liner example.

    #>
	
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [PSCustomObject]$AutomateNOWCodeRepositoryConflictItemComparison,
        [ValidateSet('Black', 'DarkBlue', 'DarkGreen', 'DarkCyan', 'DarkRed', 'DarkMagenta', 'DarkYellow', 'Gray', 'DarkGray', 'Blue', 'Green', 'Cyan', 'Red', 'Magenta', 'Yellow', 'White', ignoreCase = $false)]
        [Parameter(Mandatory = $false)]
        [string]$header_color = 'Blue',
        [ValidateSet('Black', 'DarkBlue', 'DarkGreen', 'DarkCyan', 'DarkRed', 'DarkMagenta', 'DarkYellow', 'Gray', 'DarkGray', 'Blue', 'Green', 'Cyan', 'Red', 'Magenta', 'Yellow', 'White', ignoreCase = $false)]
        [Parameter(Mandatory = $false)]
        [string]$your_version_color = 'Red',
        [ValidateSet('Black', 'DarkBlue', 'DarkGreen', 'DarkCyan', 'DarkRed', 'DarkMagenta', 'DarkYellow', 'Gray', 'DarkGray', 'Blue', 'Green', 'Cyan', 'Red', 'Magenta', 'Yellow', 'White', ignoreCase = $false)]
        [Parameter(Mandatory = $false)]
        [string]$their_version_color = 'Green',
        [ValidateSet('Black', 'DarkBlue', 'DarkGreen', 'DarkCyan', 'DarkRed', 'DarkMagenta', 'DarkYellow', 'Gray', 'DarkGray', 'Blue', 'Green', 'Cyan', 'Red', 'Magenta', 'Yellow', 'White', ignoreCase = $false)]
        [Parameter(Mandatory = $false)]
        [string]$same_version_color = 'Gray',
        [Parameter(Mandatory = $false)]
        [switch]$DoNotSuppressCRLFWarning,
        [Parameter(Mandatory = $false)]
        [switch]$DoNotFormatOutput,
        [Parameter(Mandatory = $false)]
        [switch]$JustGiveMeTheRawGitDiff,
        [Parameter(Mandatory = $false)]
        [switch]$DoNotShowLegend
    )
    Begin {
        $Error.Clear()
        Try {
            [string]$git_version = (git version)
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to find the git executable using 'git version' due to [$Message]. Please note that this function *requires* that the command line version of git is available on the LOCAL PATH."
            Break
        }
        If ($git_version.Length -eq 0) {
            Write-Warning -Message "Failed to detect the git executable. Please note that this function *requires* that the command line version of git is available on the LOCAL PATH."
            Break
        }
        Write-Verbose -Message "Detected $git_version"
        # Note: The below routine is needed to suppress the warning that typically happens on Windows systems when trying to diff local files. This warning cannot be suppressed on the command line directly so modifying the git config is the only way. Use the -DoNotSuppressCRLFWarning switch to include the warning.
        If ($DoNotSuppressCRLFWarning -ne $true) {
            $Error.Clear()
            Try {
                [string[]]$git_config = (git config -l)
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to read the current git config due to [$Message]. Please note that this function requires the command line version of git to be available on the local path of this session."
                Break
            }
            If ($git_config.count -eq 0) {
                Write-Warning -Message "Failed to detect the current git config. Please note that this function requires the command line version of git to be available on the local path of this session."
                Break
            }
            [string]$safecrlf = $git_config -match 'safecrlf'
            If ($safecrlf -ne 'safecrlf = false') {
                $Error.Clear()
                Try {
                    (git config --global core.safecrlf false) | Out-Null
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to set the current git config to silence crlf warnings due to [$Message]. Please note that this function requires the command line version of git to be available on the local path of this session."
                    Break
                }
            }
        }
    }
    Process {
        If ($_.Length -gt 0) {
            [PSCustomObject]$AutomateNOWCodeRepositoryConflictItemComparison = $_
        }
        [string]$item_id = $AutomateNOWCodeRepositoryConflictItemComparison.item_id
        [string]$item_domain = $AutomateNOWCodeRepositoryConflictItemComparison.item_domain
        [string]$domainClassName = $AutomateNOWCodeRepositoryConflictItemComparison.domainClassName
        [string]$codeRepository = $AutomateNOWCodeRepositoryConflictItemComparison.codeRepository
        [string]$your_version = $AutomateNOWCodeRepositoryConflictItemComparison.your_version
        [string]$their_version = $AutomateNOWCodeRepositoryConflictItemComparison.their_version
        [string]$temp_path = $env:TEMP
        If ($null -eq (Test-Path -Path "$temp_path")) {
            Write-Warning -Message "Failed to detect the temporary path. Please note that this function requires to be able to write temporary files to the %TEMP% location to accomodate the git differencing utility."
            Break
        }
        [string]$current_file_time = (Get-Date).ToUniversalTime().ToFileTime()
        [string]$your_version_temp_filename = "AutomateNOWCodeRepositoryConflictItemComparison-$current_file_time-your-version.json"
        [string]$their_version_temp_filename = "AutomateNOWCodeRepositoryConflictItemComparison-$current_file_time-their-version.json"
        [string]$your_version_temp_filepath = ($temp_path + '\' + $your_version_temp_filename)
        [string]$their_version_temp_filepath = ($temp_path + '\' + $their_version_temp_filename)    	
        #Create a temporary text file - This is required by the git utility
        $Error.Clear()
        Try {
            $your_version | Out-File -FilePath "$your_version_temp_filepath" -Force -Encoding UTF8
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Out-File failed to write content of 'your version' to $your_version_temp_filepath under Show-AutomateNOWCodeRepositoryConflictItemComparison due to [$Message] related to $item_id in $item_domain of type $domainClassName residing in Code Repository $CodeRepository"
            Break
        }
        If ($null -eq (Test-Path -Path "$your_version_temp_filepath")) {
            Write-Warning -Message "Somehow the temporary file for 'your version' $your_version_temp_filepath under Show-AutomateNOWCodeRepositoryConflictItemComparison was not written to disk. Please look into this related to $item_id in $item_domain of type $domainClassName residing in Code Repository $CodeRepository"
            Break
        }
        [System.IO.FileSystemInfo]$AutomateNOWCodeRepositoryConflictItemComparisonYourFileDetails = Get-Item -Path "$your_version_temp_filepath"
        [int32]$AutomateNOWCodeRepositoryConflictItemComparisonYourFileLength = $AutomateNOWCodeRepositoryConflictItemComparisonYourFileDetails.Length
        Write-Verbose -Message "$your_version_temp_filepath was detected as $AutomateNOWCodeRepositoryConflictItemComparisonYourFileLength bytes in length"    	
        #Create a temporary text file - This is required by the git utility
        $Error.Clear()
        Try {
            $their_version | Out-File -FilePath "$their_version_temp_filepath" -Force -Encoding UTF8
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Out-File failed to write content of 'their version' to $their_version_temp_filepath under Show-AutomateNOWCodeRepositoryConflictItemComparison due to [$Message]. Please look into this related to $item_id in $item_domain of type $domainClassName residing in Code Repository $CodeRepository"
            Break
        }
        If ($null -eq (Test-Path -Path "$their_version_temp_filepath")) {
            Write-Warning -Message "Somehow the temporary file for 'their version' $their_version_temp_filepath under Show-AutomateNOWCodeRepositoryConflictItemComparison was not written to disk. Please look into this related to $item_id in $item_domain of type $domainClassName residing in Code Repository $CodeRepository"
            Break
        }    	
        [System.IO.FileSystemInfo]$AutomateNOWCodeRepositoryConflictItemComparisonTheirFileDetails = Get-Item -Path "$their_version_temp_filepath"
        [int32]$AutomateNOWCodeRepositoryConflictItemComparisonTheirFileLength = $AutomateNOWCodeRepositoryConflictItemComparisonTheirFileDetails.Length
        Write-Verbose -Message "$their_version_temp_filepath was detected as $AutomateNOWCodeRepositoryConflictItemComparisonTheirFileLength bytes in length"
        #Compare the two text files with the git utility
        [string[]]$git_results = git diff "$your_version_temp_filepath" "$their_version_temp_filepath"
        If ($git_results.count -eq 0) {
            Write-Warning -Message "Somehow we made it this far but the initial git comparison results were empty!"
            Break
        }
        #Remove the temporary text files - These files were required by the git utility
        $Error.Clear()
        Try {
            "$their_version_temp_filepath" | Remove-Item -Force
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Remove-Item failed to delete the temporary file '$their_version_temp_filepath' under Show-AutomateNOWCodeRepositoryConflictItemComparison due to [$Message]. Please look into this related to $item_id in $item_domain of type $domainClassName residing in Code Repository $CodeRepository"
            Break
        }
        $Error.Clear()
        Try {
            "$your_version_temp_filepath" | Remove-Item -Force
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Remove-Item failed to delete the temporary file '$your_version_temp_filepath' under Show-AutomateNOWCodeRepositoryConflictItemComparison due to [$Message]. Please look into this related to $item_id in $item_domain of type $domainClassName residing in Code Repository $CodeRepository"
            Break
        }    	
        If ($JustGiveMeTheRawGitDiff -ne $true) {
            [string[]]$git_results = $git_results | Where-Object { $_ -notmatch '^diff --git ' -and $_ -notmatch '^index ' -and $_ -notmatch '^--- ' -and $_ -notmatch '^\+\+\+' -and $_ -notmatch '\\ No newline at end of file' }
            If ($git_results.count -eq 0) {
                Write-Warning -Message "We made it so far but the git comparison results were empty after filtering!"
                Break
            }
            ForEach ($result in $git_results) {
                If ($DoNotFormatOutput -ne $true) {
                    If ($result -match '^@@') {
                        Write-Host $result -ForegroundColor $header_color
                    }
                    ElseIf ($result -match '^-') {
                        Write-Host $result -ForegroundColor $your_version_color
                    }
                    ElseIf ($result -match '^\+') {
                        Write-Host $result -ForegroundColor $their_version_color
                    }
                    Else {
                        Write-Host $result -ForegroundColor $same_version_color
                    }
                }
                Else {
                    Write-Host $result
                }
            }
            If ($DoNotFormatOutput -ne $true -and $DoNotShowLegend -ne $true) {
                Write-Host ""
                Write-Host "Legend:"
                Write-Host ""
                Write-Host "Entries in [" -NoNewLine
                Write-Host $header_color -NoNewLine -ForegroundColor $header_color
                Write-Host "] are the header for each git diff chunk"
                Write-Host "Entries in [" -NoNewLine
                Write-Host $your_version_color -NoNewLine -ForegroundColor $your_version_color
                Write-Host "] are your different lines in the ANOW database (left side) [-AcceptYours]"
                Write-Host "Entries in [" -NoNewLine
                Write-Host $their_version_color -NoNewLine -ForegroundColor $their_version_color
                Write-Host "] are their different lines in the repository branch (right side) [-AcceptTheirs]"
                Write-Host "Entries in [" -NoNewLine
                Write-Host $same_version_color -NoNewLine -ForegroundColor $same_version_color
                Write-Host "] are identical on both sides"
            }
        }
        Else {
            Return $git_results
        }
    }
    End {

    }
}

Function Merge-AutomateNOWCodeRepositoryConflictItem {

    <#
    .SYNOPSIS
    Merges a Conflict item (Out of Sync item) in a local Code Repository in an AutomateNOW! instance between the database version (yours, left side) and the repository version (theirs, right side)

    .DESCRIPTION
    Merges a Conflict item (Out of Sync item) in a local Code Repository in an AutomateNOW! instance between the database version (yours, left side) and the repository version (theirs, right side)

    .PARAMETER CodeRepository
    Mandatory [ANOWCodeRepository] object (Use Get-AutomateNOWCodeRepository to retrieve them)

    .PARAMETER ConflictItem
    Mandatory [ANOWCodeRepositoryConflictItem] object (Use Get-AutomateNOWCodeRepositoryConflictItem to retreive them)

    .PARAMETER AcceptYours
    Mandatory switch parameter if accepting left side (Yours) on the local code repository

    .PARAMETER AcceptTheirs
    Mandatory switch parameter if accepting right side (Theirs) on the remote code repository

    .PARAMETER Force
    Force the merging of the object without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the display of the results

    .INPUTS
    A [ANOWCodeRepository] object must be presented. [ANOWCodeRepositoryConflictItem] objects are also required and can be sent across the pipeline.

    .OUTPUTS	
    The [ANOWCodeRepositoryConflictItem] object that was Merged will be returned.

    .EXAMPLE
    Forcibly and quietly gets the Conflict items (Out Of Sync items) from a Code Repository named 'CodeRepository1' and then accepts the left side (Yours) in a multi-line format.

    $repository = Get-AutomateNOWCodeRepository -Id 'CodeRepository1'
    $conflict_items = Get-AutomateNOWCodeRepositoryConflictItem -CodeRepository $repository
    $conflict_items | Merge-AutomateNOWCodeRepositoryConflictItem -AcceptYours -CodeRepository $repository -Force -Quiet

    .EXAMPLE
    Gets the Conflict items (Out Of Sync items) from a Code Repository named 'CodeRepository1' and then accepts the left side (Yours) in a one-liner format.

    Get-AutomateNOWCodeRepository -Id 'CodeRepository1' | Resolve-AutomateNOWCodeRepository | Get-AutomateNOWCodeRepositoryConflictItem | Merge-AutomateNOWCodeRepositoryConflictItem -AcceptYours -CodeRepository (Get-AutomateNOWCodeRepository -Id 'CodeRepository1' | Resolve-AutomateNOWCodeRepository)

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([PSCustomObject])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWCodeRepositoryConflictItem]$ConflictItem,
        [Parameter(Mandatory = $true, ParameterSetName = 'AcceptYours')]
        [switch]$AcceptYours,
        [Parameter(Mandatory = $true, ParameterSetName = 'AcceptTheirs')]
        [switch]$AcceptTheirs,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Id.Length -gt 0 ) {
            [ANOWCodeRepositoryConflictItem]$ConflictItem = $_
        }
        [string]$ConflictItem_Id = $ConflictItem.id
        If ($ConflictItem_Id -notmatch '^(\[([-._0-9a-zA-Z]{1,})\])?([-._0-9a-zA-Z]{1,})(\|[a-zA-Z]{3,}/)([-._0-9a-zA-Z]{1,})$') {
            Write-Warning -Message "Somehow the Id of the Conflict Item object $ConflictItem_Id did not match the expected format. Please look into this."
            Break
        }
        $Error.Clear()
        Try {
            [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = $ConflictItem_id -split '\|' -split '/' | Select-Object -Skip 1 -First 1
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to cast $(ConflictItem.Id) to an [ANOWCodeRepositoryObjectSourceCode_domainClassName] enumerator due to due to [$Message]."
            Break
        }
        If ($domainClassName.Length -eq 0) {
            Write-Warning "Somehow the domainClassName could not be extracted from the Conflict item. Please look into this."
            Break
        }
        [string]$ConflictItem_filename = $ConflictItem_id -split '\|' | Select-Object -Skip 1 -First 1
        [string]$CodeRepository_Id = $CodeRepository.Id
        If ($AcceptYours -eq $true) {
            [string]$accept = 'acceptYours'
        }
        ElseIf ($AcceptTheirs -eq $true) {
            [string]$accept = 'acceptTheirs'
        }
        Else {
            Write-Warning -Message "Somehow it was not possible to determine if Merge-AutomateNOWCodeRepositoryConflictItem is accepting yours (left side, database) or their changes (right side, repository). Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Merge Conflict Item $($ConflictItem_Id) with decision: $($accept)?")) -eq $true) {        	
            $Body.'file' = $ConflictItem_filename
            $Body.'codeRepository' = $CodeRepository_Id
            $Body.'_operationType' = 'custom'
            $Body.'_operationId' = $accept
            $Body.'_textMatchStyle' = 'exact'
            $Body.'_dataSource' = 'CodeRepositoryConflictDataSource'
            $Body.'isc_metaDataPrefix' = '_'
            $Body.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $Body
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            If ($null -eq $parameters["Command"]) {
                [string]$command = ("/codeRepositoryConflict/$accept")
                $parameters.Add('Command', $command)
            }
            Else {
                $parameters.Command = $command
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$MergedCodeRepositoryItem = $results.response.data
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the response [PSCustomObject] object due to [$Message]."
                Break
            }
            If ($MergedCodeRepositoryItem.Id -eq $ConflictItem_id) {
                If ($Quiet -ne $true) {
                    Return $MergedCodeRepositoryItem
                }
            }
            Else {
                Write-Warning -Message "Somehow the returned Item $($MergedCodeRepositoryItem.Id) didn't have an Id after being added to Code Repository $CodeRepository_Id. Something must be wrong. Please check into this further."
                Break
            }
        }
    }
    End {

    }
}

#endregion

#Region - Code Repository Items

Function Read-AutomateNOWCodeRepositoryItem {

    <#
    .SYNOPSIS
    Gets the items from a local Code Repository in an AutomateNOW! instance

    .DESCRIPTION
    Gets the items from a local Code Repository in an AutomateNOW! instance

    .PARAMETER CodeRepository
    Mandatory [ANOWCodeRepository] object (Use Get-AutomateNOWCodeRepository to retrieve them)

    .PARAMETER itemType
    Optional string to filter the items by type. Valid choices are: 'ProcessingTemplates', 'Schedules', 'BusinessViews', 'Workspaces', 'ResultMappings', 'Approvals', 'ServerNodes', 'ServerNodeGroups', 'Agents', 'Endpoints', 'Resources', 'DataSources', 'Anomalies', 'Interfaces', 'NotificationGroups', 'NotificationChannels', 'NotificationMessageTemplates', 'RuntimeActions', 'Dashboards', 'AdhocReports', 'UserReports', 'Tags', 'Folders'

    .PARAMETER startRow
    Integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .INPUTS
    Accepts a string representing the simple id of the Code Repository from the pipeline or individually (but not an array).

    .OUTPUTS
    An array of PSCustomObjects representing the selected item types.

    .EXAMPLE
    Gets the first page items from a Code Repository (multi-line format)

    $repo = Get-AutomateNOWCodeRepository -Id 'CodeRepository1'
    $items = Read-AutomateNOWCodeRepositoryItem -CodeRepository $repo

    .EXAMPLE
    Gets only the Processing Template items within a Code Repository (multi-line format)

    $repo = Get-AutomateNOWCodeRepository -Id 'CodeRepository1'
    $items = Read-AutomateNOWCodeRepositoryItem -CodeRepository $repo -itemType 'ProcessingTemplates'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    If -itemType is not specified then all items will be retrieved by default

    #>
    [OutputType([PSCustomObject[]])]
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWCodeRepository]$CodeRepository,
        [ValidateSet('ProcessingTemplates', 'Schedules', 'BusinessViews', 'Workspaces', 'ResultMappings', 'Approvals', 'ServerNodes', 'ServerNodeGroups', 'Agents', 'Endpoints', 'Resources', 'DataSources', 'Anomalies', 'Interfaces', 'NotificationGroups', 'NotificationChannels', 'NotificationMessageTemplates', 'RuntimeActions', 'Dashboards', 'AdhocReports', 'UserReports', 'Tags', 'Folders', ignoreCase = $false)]
        [Parameter(Mandatory = $false)]
        [string]$itemType,
        [Parameter(Mandatory = $false)]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $false)]
        [int32]$endRow = 100
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Id.Length -gt 0 ) {
            [ANOWCodeRepository]$CodeRepository = $_
        }
        [string]$CodeRepository_Id = $CodeRepository.Id
        $Body.'codeRepository' = $CodeRepository_Id
        $Body.'_constructor' = 'AdvancedCriteria'
        $Body.'operator' = 'and'
        $Body.'criteria1' = ('{"fieldName":"codeRepository","operator":"equals","value":"' + $CodeRepository_Id + '"}')
        If ($itemType.Length -eq 0) {
            $Body.'criteria2' = '{"fieldName":"processingType","operator":"notEqual","value":"TRIGGER"}'
            [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'ItemList'
            [int32]$componentId = 1
        }
        Else {
            Switch ($itemType) {
                "ProcessingTemplates" {
                    $Body.'criteria2' = '{"fieldName":"processingType","operator":"notEqual","value":"TRIGGER"}'
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'ProcessingTemplate'
                    [int32]$componentId = 1
                }
                "Schedules" {
                    $Body.'criteria2' = '{"fieldName":"processingType","operator":"equals","value":"TRIGGER"}'
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'ProcessingTemplate'
                    [int32]$componentId = 2
                }
                "BusinessViews" {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'BusinessView'
                    [int32]$componentId = 3
                }
                "Workspaces" {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'Workspace'
                    [int32]$componentId = 4
                }
                "ResultMappings" {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'ResultMapping'
                    [int32]$componentId = 5
                }
                "Approvals" {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'ApprovalConfiguration'
                    [int32]$componentId = 6
                }
                "ServerNodes" {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'ServerNode'
                    [int32]$componentId = 7
                }
                "ServerNodeGroups" {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'ServerNodeGroup'
                    [int32]$componentId = 8
                }
                "Agents" {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'Agent'
                    [int32]$componentId = 9
                }
                "Endpoints" {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'Endpoint'
                    [int32]$componentId = 10
                }
                "Resources" {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'Resource'
                    [int32]$componentId = 11
                }
                "DataSources" {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'DataSource'
                    [int32]$componentId = 12
                }
                "Anomalies" {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'Anomaly'
                    [int32]$componentId = 13
                }
                "Interfaces" {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'Integration'
                    [int32]$componentId = 14
                }
                "NotificationGroups" {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'NotificationGroup'
                    [int32]$componentId = 15
                }
                "NotificationChannels" {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'NotificationChannel'
                    [int32]$componentId = 16
                }
                "NotificationTemplates" {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'NotificationMessageTemplate'
                    [int32]$componentId = 17
                }
                "RuntimeActions" {
                    $Body.'criteria2' = '{"fieldName":"isRule","operator":"equals","value":true}'
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'ProcessingAction'
                    [int32]$componentId = 18
                }
                "Dashboards" {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'Dashboard'
                    [int32]$componentId = 19
                }
                "AdhocReports" {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'AdhocReport'
                    [int32]$componentId = 20
                }
                "UserReports" {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'UserReport'
                    [int32]$componentId = 21
                }
                "Tags" {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'Tag'
                    [int32]$componentId = 22
                }
                "Folders" {
                    $Body.'_constructor' = 'AdvancedCriteria'
                    $Body.'operator' = 'and'
                    $Body.'criteria2' = '{"fieldName":"parent","operator":"isNull"}'
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'Folder'
                    [int32]$componentId = 23
                }
            }
        }
        $Body.'domainClassName' = $domainClassName
        $Body.'_operationType' = 'fetch'
        $Body.'_startRow' = $startRow
        $Body.'_endRow' = $endRow
        $Body.'_textMatchStyle' = 'exact'
        $Body.'_componentId' = "isc_CodeRepositoryDomainClassList_$componentId"
        $Body.'_dataSource' = 'CodeRepositoryObjectDataSource'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/codeRepositoryObject/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [PSCustomObject[]]$CodeRepositoryItems = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [PSCustomObject] objects due to [$Message]."
            Break
        }
        If ($CodeRepositoryItems.Count -gt 0) {
            $CodeRepositoryItems
        }
        If ($repository_items.Count -gt 0) {
            Return $repository_items
        }
    }
    End {

    }
}

Function Add-AutomateNOWCodeRepositoryItem {

    <#
    .SYNOPSIS
    Adds an item to a local Code Repository in an AutomateNOW! instance

    .DESCRIPTION
    Adds an item to a local Code Repository in an AutomateNOW! instance

    .PARAMETER CodeRepository
    Mandatory [ANOWCodeRepository] object (Use Get-AutomateNOWCodeRepository to retrieve them)

    .PARAMETER Item
    Mandatory ANOW object to be added to the Code Repository. Valid ANOW object item types are: 'ProcessingTemplates', 'Schedules', 'BusinessViews', 'Workspaces', 'ResultMappings', 'Approvals', 'ServerNodes', 'ServerNodeGroups', 'Agents', 'Endpoints', 'Resources', 'DataSources', 'Anomalies', 'Interfaces', 'NotificationGroups', 'NotificationChannels', 'NotificationMessageTemplates', 'RuntimeActions', 'Dashboards', 'AdhocReports', 'UserReports', 'Tags', 'Folders'

    .PARAMETER Force
    Force the addition of the object without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the display of the results

    .INPUTS
    You must pass both the [ANOWCodeRepository] object and at least 1 ANOW object.

    .OUTPUTS
    The object that was added to the local Code Repository will be returned

    .EXAMPLE
    Uses the pipeline to forcibly and quietly add a Task Template to a local Code Repository

    $repository = Get-AutomateNOWCodeRepository -Id 'Repository1'
    $task_template = Get-AutomateNOWTaskTemplate -Id 'ShellTask1'
    $task_template | Add-AutomateNOWCodeRepositoryItem -CodeRepository $repository -Force -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    In this context, Schedule Templates are considered Processing Templates

    #>
    [OutputType([PSCustomObject])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [PSCustomObject]$Item,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Id.Length -gt 0 ) {
            [PSCustomObject]$Item = $_
        }
        [string]$Item_id = $Item.Id
        If ($Item_Id.Length -eq 0) {
            Write-Warning -Message "Somehow the Item passed to Add-AutomateNOWCodeRepositoryItem does not have an Id. Please look into this."
            Break
        }
        $Body.'id' = $Item_Id
        [string]$CodeRepository_Id = $CodeRepository.Id
        $Body.'codeRepository' = $CodeRepository_Id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Add $($Item_Id) to Code Repository $($CodeRepository_Id)?")) -eq $true) {
            Switch ($Item) {
                # Processing Templates (THIS INCLUDES SCHEDULE TEMPLATES!)
                { $_ -is [ANOWProcessingTemplate] } {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'ProcessingTemplate'
                    [string]$dataSource = 'ProcessingTemplateDataSource'
                    Break;
                }
                { $_ -is [ANOWBusinessView] } {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'BusinessView'
                    [string]$dataSource = 'BusinessViewDataSource'
                    Break;
                }
                { $_ -is [ANOWWorkspace] } {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'Workspace'
                    [string]$dataSource = 'WorkspaceDataSource'
                    Break;
                }
                { $_ -is [ANOWResultMapping] } {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'ResultMapping'
                    [string]$dataSource = 'ResultMappingDataSource'
                    Break;
                }
                { $_ -is [ANOWApproval] } {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'ApprovalConfiguration'
                    [string]$dataSource = 'ApprovalConfigurationDataSource'
                    Break;
                }
                { $_ -is [ANOWServerNode] } {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'ServerNode'
                    [string]$dataSource = 'ServerNodeDataSource'
                    Break;
                }
                { $_ -is [ANOWServerNodeGroup] } {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'ServerNodeGroup'
                    [string]$dataSource = 'ServerNodeGroupDataSource'
                    Break;
                }
                { $_ -is [ANOWAgent] } {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'Agent'
                    [string]$dataSource = 'AgentDataSource'
                    Break;
                }
                { $_ -is [ANOWEndpoint] } {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'Endpoint'
                    [string]$dataSource = 'EndpointDataSource'
                    Break;
                }
                { $_ -is [ANOWCalendar] -or $_ -is [ANOWEvent] -or $_ -is [ANOWLock] -or $_ -is [ANOWMetric] -or $_ -is [ANOWPhysicalResource] -or $_ -is [ANOWSemaphore] -or $_ -is [ANOWStock] -or $_ -is [ANOWTimeWindow] -or $_ -is [ANOWVariable] } {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'Resource'
                    [string]$dataSource = 'ResourceDataSource'
                    Break;
                }
                { $_ -is [ANOWDataSource] } {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'DataSource'
                    [string]$dataSource = 'DataSourceDataSource'
                    Break;
                }
                { $_ -is [ANOWAnomaly] } {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'Anomaly'
                    [string]$dataSource = 'AnomalyDataSource'
                    Break;
                }
                { $_ -is [ANOWIntegration] } {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'Integration'
                    [string]$dataSource = 'IntegrationDataSource'
                    Break;
                }
                { $_ -is [ANOWNotificationGroup] } {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'NotificationGroup'
                    [string]$dataSource = 'NotificationGroupDataSource'
                    Break;
                }
                { $_ -is [ANOWNotificationChannel] } {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'NotificationChannel'
                    [string]$dataSource = 'NotificationChannelDataSource'
                    Break;
                }
                { $_ -is [ANOWNotificationMessageTemplate] } {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'NotificationMessageTemplate'
                    [string]$dataSource = 'NotificationMessageTemplateDataSource'
                    Break;
                }
                { $_ -is [ANOWProcessingAction] } {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'ProcessingAction'
                    [string]$dataSource = 'ProcessingActionDataSource'
                    $Body.'id' = $_.simpleId # unlike other objects, Runtime Actions are added to code repositories by their simpleId
                    Break;
                }
                { $_ -is [ANOWDashboard] } {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'Dashboard'
                    [string]$dataSource = 'DashboardDataSource'
                    Break;
                }
                { $_ -is [ANOWAdhocReport] } {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'AdhocReport'
                    [string]$dataSource = 'AdhocReportDataSource'
                    Break;
                }
                { $_ -is [ANOWUserReport] } {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'UserReport'
                    [string]$dataSource = 'UserReportDataSource'
                    Break;
                }
                { $_ -is [ANOWTag] } {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'Tag'
                    [string]$dataSource = 'TagDataSource'
                    Break;
                }
                { $_ -is [ANOWFolder] } {
                    [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'Folder'
                    [string]$dataSource = 'FolderDataSource'
                    Break;
                }
            }
            $Body.'domainClassName' = $domainClassName
            $Body.'_operationType' = 'update'
            $Body.'_operationId' = 'addToCodeRepository'
            $Body.'_textMatchStyle' = 'exact'
            $Body.'_dataSource' = $DataSource
            $Body.'isc_metaDataPrefix' = '_'
            $Body.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $Body
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            If ($null -eq $parameters["Command"]) {
                [string]$command = ('/codeRepository/addObject')
                $parameters.Add('Command', $command)
            }
            Else {
                $parameters.Command = $command
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code] when trying to add $Item_id to code repository $CodeRepository_Id under Add-AutomateNOWCodeRepositoryItem. Please look into this. Body: $full_response_display"
                Break
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$CodeRepositoryItem = $results.response.data
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the response [PSCustomObject] object due to [$Message]."
                Break
            }
            If ($CodeRepositoryItem.Id.Length -gt 0) {
                If ($Quiet -ne $true) {
                    Return $CodeRepositoryItem
                }
            }
            Else {
                Write-Warning -Message "Somehow the returned Item ($Item_Id) didn't have an Id after being added to Code Repository $CodeRepository_Id. Something must be wrong. Please check into this further."
                Break
            }
        }
    }
    End {

    }
}

Function Remove-AutomateNOWCodeRepositoryItem {

    <#
    .SYNOPSIS
    Removes (deletes) an item from a local Code Repository in an AutomateNOW! instance

    .DESCRIPTION
    Removes (deletes) an item from a local Code Repository in an AutomateNOW! instance

    .PARAMETER Item
    Mandatory ANOW object to be removed from the Code Repository. Valid ANOW object item types are: 'ProcessingTemplates', 'Schedules', 'BusinessViews', 'Workspaces', 'ResultMappings', 'Approvals', 'ServerNodes', 'ServerNodeGroups', 'Agents', 'Endpoints', 'Resources', 'DataSources', 'Anomalies', 'Interfaces', 'NotificationGroups', 'NotificationChannels', 'NotificationMessageTemplates', 'RuntimeActions', 'Dashboards', 'AdhocReports', 'UserReports', 'Tags', 'Folders'

    .PARAMETER Force
    Force the removal of the object without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the display of the results

    .INPUTS
    You must pass both the [ANOWCodeRepository] object and at least 1 ANOW object.

    .OUTPUTS
    The object that was removed from the local Code Repository will be returned

    .EXAMPLE
    Removes a Task Template named 'TaskTemplate1' from a local Code Repository named 'Repository1'

    .EXAMPLE
    Forcibly and quietly uses the pipeline to remove two Task Templates from a local Code Repository named 'Repository1'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This function does yet have any safety check to ensure that the item is not already removed. However, the ANOW API will not accept the request in this case and the error message indicating this will be displayed back.

    This API call does not require the name of the CodeRepository because every item is unique and no item can be added to more then 1 repository.

    Unlike other update API calls, this one does not generate and apply an "oldValues" property to the payload.

    At the time of this writing, there is a bug where Runtime Actions cannot actually be removed from a Code Repository.

    #>
    [OutputType([PSCustomObject])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [PSCustomObject]$Item,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Id.Length -gt 0 ) {
            [PSCustomObject]$Item = $_
        }
        [string]$Item_simpleId = $Item.simpleId
        If ($Item_simpleId.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        [string]$Item_Domain = $Item.domain
        If ($Item_Domain.Length -eq 0) {
            Write-Warning -Message "Somehow the Item passed to Remove-AutomateNOWCodeRepositoryItem does not have a domain. Please look into this."
            Break
        }
        [ANOWCodeRepositoryObjectSourceCode_domainClassName]$DomainClassName = $Item.domainClassName
        $Body.'domainClassName' = $domainClassName
        If ( $domainClassName -ne 'ProcessingAction') {
            [string]$Item_Id = ('[' + $Item_Domain + ']' + $Item_simpleId) # Note that ANOWCodeRepository items do not contain the full id of the source object. Either this line of code is needed or an additional lookup would be needed to confirm the Id of the object.
        }
        Else {
            [string]$Item_Id = $Item_simpleId
        }
        $Body.'id' = $Item_id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Remove $($Item_Id) from its Code Repository?")) -eq $true) {
            Switch ($Item) {
                # ProcessingTemplates, Schedules (SCHEDULES ARE INCLUDED HERE!)
                { $domainClassName -eq 'ProcessingTemplate' } {
                    [string]$dataSource = 'ProcessingTemplateDataSource'
                    Break;
                }
                { $domainClassName -eq 'BusinessView' } {
                    [string]$dataSource = 'BusinessViewDataSource'
                    Break;
                }
                { $domainClassName -eq 'Workspace' } {
                    [string]$dataSource = 'WorkspaceDataSource'
                    Break;
                }
                { $domainClassName -eq 'ResultMapping' } {
                    [string]$dataSource = 'ResultMappingDataSource'
                    Break;
                }
                { $domainClassName -eq 'ApprovalConfiguration' } {
                    [string]$dataSource = 'ApprovalConfigurationDataSource'
                    Break;
                }
                { $domainClassName -eq 'ServerNode' } {
                    [string]$dataSource = 'ServerNodeDataSource'
                    Break;
                }
                { $domainClassName -eq 'ServerNodeGroup' } {
                    [string]$dataSource = 'ServerNodeGroupDataSource'
                    Break;
                }
                { $domainClassName -eq 'Agent' } {
                    [string]$dataSource = 'AgentDataSource'
                    Break;
                }
                { $domainClassName -eq 'Endpoint' } {
                    [string]$dataSource = 'EndpointDataSource'
                    Break;
                }
                # "Resources" - note that there are 9 total resource types (at the time of this writing)
                { $domainClassName -eq 'Resource' } {
                    [string]$dataSource = 'ResourceDataSource'
                    Break;
                }
                { $domainClassName -eq 'DataSource' } {
                    [string]$dataSource = 'DataSourceDataSource'
                    Break;
                }
                { $domainClassName -eq 'Anomaly' } {
                    [string]$dataSource = 'AnomalyDataSource'
                    Break;
                }
                { $domainClassName -eq 'Integration' } {
                    [string]$dataSource = 'IntegrationDataSource'
                    Break;
                }
                { $domainClassName -eq 'NotificationGroup' } {
                    [string]$dataSource = 'NotificationGroupDataSource'
                    Break;
                }
                { $domainClassName -eq 'NotificationChannel' } {
                    [string]$dataSource = 'NotificationChannelDataSource'
                    Break;
                }
                { $domainClassName -eq 'NotificationMessageTemplate' } {
                    [string]$dataSource = 'NotificationMessageTemplateDataSource'
                    Break;
                }
                { $domainClassName -eq 'ProcessingAction' } {
                    [string]$dataSource = 'ProcessingActionDataSource'
                    Break;
                }
                { $domainClassName -eq 'Dashboard' } {
                    [string]$dataSource = 'DashboardDataSource'
                    Break;
                }
                { $domainClassName -eq 'AdHocReport' } {
                    [string]$dataSource = 'AdhocReportDataSource'
                    Break;
                }
                { $domainClassName -eq 'UserReport' } {
                    [string]$dataSource = 'UserReportDataSource'
                    Break;
                }
                { $domainClassName -eq 'Folder' } {
                    [string]$dataSource = 'FolderDataSource'
                    Break;
                }
                { $domainClassName -eq 'Tag' } {
                    [string]$dataSource = 'TagDataSource'
                    Break;
                }
            }
            $Error.Clear()
            Try {
                [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = $domainClassName
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Somehow the domainClassName of [$domainClassName] is invalid due to [$Message]."
                Break
            }
            $Body.'_operationType' = 'update'
            $Body.'_operationId' = 'removeFromCodeRepository'
            $Body.'_textMatchStyle' = 'exact'
            $Body.'_dataSource' = $DataSource
            $Body.'isc_metaDataPrefix' = '_'
            $Body.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $Body
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            If ($null -eq $parameters["Command"]) {
                [string]$command = ('/codeRepository/removeObject')
                $parameters.Add('Command', $command)
            }
            Else {
                $parameters.Command = $command
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$CodeRepositoryItem = $results.response.data
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the response [PSCustomObject] object due to [$Message]."
                Break
            }
            If ($domainClassName -ne 'ProcessingAction') {
                If ($CodeRepositoryItem.Id.Length -gt 0) {
                    If ($Quiet -ne $true) {
                        Return $CodeRepositoryItem
                    }
                }
                Else {
                    Write-Warning -Message "Somehow the returned Item $Item_Id didn't have an Id after being removed from its Code Repository. Something must be wrong. Please check into this further."
                    Break
                }
            }
        }
    }
    End {

    }
}

#endregion

#Region - CodeRepository Merge Requests

Function Get-AutomateNOWCodeRepositoryMergeRequest {

    <#
    .SYNOPSIS
    Gets the merge requests from a local Code Repository in an AutomateNOW! instance

    .DESCRIPTION
    Gets the merge requests from a local Code Repository in an AutomateNOW! instance

    .PARAMETER CodeRepository
    Mandatory [ANOWCodeRepository] object (Use Get-AutomateNOWCodeRepository to retrieve them)

    .PARAMETER Id
    Optional int64 to filter the results to a single merge request by name. Use this when you only want a specific merge request.

    .PARAMETER startRow
    Integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .INPUTS
    You must present an [ANOWCodeRepository] object

    .OUTPUTS
    [ANOWCodeRepositoryMergeRequest] objects

    .EXAMPLE
    Gets all of the merge requests from a Code Repository named 'Repository1'

    $repo = Get-AutomateNOWCodeRepository -Id 'Repository1'
    $merge_requests = Get-AutomateNOWCodeRepositoryMergeRequest -CodeRepository $repo

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWCodeRepositoryMergeRequest[]])]
    [Cmdletbinding(DefaultParameterSetName = 'All')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'All', ValueFromPipeline = $true)]
        [Parameter(Mandatory = $true, ParameterSetName = 'Single', ValueFromPipeline = $true)]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $true, ParameterSetName = 'Single')]
        [int64]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $false, ParameterSetName = 'All')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Single')]
        [switch]$StringOnly
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Id.Length -gt 0 ) {
            [ANOWCodeRepository]$CodeRepository = $_
        }
        [string]$CodeRepository_Id = $CodeRepository.Id
        $Body.'codeRepository' = $CodeRepository_id
        $Body.'criteria' = ('{"fieldName":"codeRepository","operator":"equals","value":"' + $CodeRepository_Id + '","_constructor":"AdvancedCriteria"}')
        $Body.'_constructor' = 'AdvancedCriteria'
        $Body.'operator' = 'and'
        $Body.'_startRow' = $startRow
        $Body.'_endRow' = $endRow
        $Body.'_operationType' = 'fetch'
        $Body.'_textMatchStyle' = 'exact'
        $Body.'_componentId' = 'MergeRequestList'
        $Body.'_dataSource' = 'MergeRequestDataSource'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/mergeRequest/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWCodeRepositoryMergeRequest[]]$CodeRepositoryMergeRequests = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWCodeRepositoryMergeRequest] objects due to [$Message]."
            Break
        }
        If ($Id -gt 0) {
            [ANOWCodeRepositoryMergeRequest]$CodeRepositoryMergeRequest = $CodeRepositoryMergeRequests | Where-Object { $_.Id -eq $Id }
            Return $CodeRepositoryMergeRequest
        }
        ElseIf ($Id -eq 0 -and $CodeRepositoryMergeRequests.Count -gt 0) {
            Return $CodeRepositoryMergeRequests
        }
    }
}

Function Approve-AutomateNOWCodeRepositoryMergeRequest {

    <#
    .SYNOPSIS
    Approves (accepts) a Merge Request on a local Code Repository in an AutomateNOW! instance

    .DESCRIPTION
    Approves (accepts) a Merge Request on a local Code Repository in an AutomateNOW! instance

    .PARAMETER CodeRepository
    Mandatory [ANOWCodeRepository] object (Use Get-AutomateNOWCodeRepository to retrieve them)

    .PARAMETER MergeRequest
    Mandatory [ANOWCodeRepositoryMergeRequest] object (Use Get-AutomateNOWMergeRequest to retrieve them)

    .PARAMETER Force
    Force the acceptance of the Merge Request without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the display of the results

    .INPUTS
    You must pass both the [ANOWCodeRepository] object and a [ANOWCodeRepositoryMergeRequest] object.

    .OUTPUTS
    The denied [ANOWCodeRepositoryMergeRequest] object will be returned. Use -Quiet to suppress this.

    .EXAMPLE
    Accepts a Merge Request with the id of 9 on a Code Repository named 'Repository1'

    $repository = Get-AutomateNOWCodeRepository -Id 'Repository1'
    $merge_request = Get-AutomateNOWCodeRepositoryMergeRequest -CodeRepository $repository -Id 9
    Approve-AutomateNOwCodeRepositoryMergeRequest -CodeRepository $repository -MergeRequest $merge_request

    .EXAMPLE
    Forcibly accepts a Merge Request with the id of 9 on a Code Repository named 'Repository1'

    $repository = Get-AutomateNOWCodeRepository -Id 'Repository1'
    $merge_request = Get-AutomateNOWCodeRepositoryMergeRequest -CodeRepository $repository -Id 9
    $merge_request | Approve-AutomateNOwCodeRepositoryMergeRequest -CodeRepository $repository -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWCodeRepositoryMergeRequest])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWCodeRepositoryMergeRequest]$MergeRequest,
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.Id.Length -gt 0 ) {
            [ANOWCodeRepositoryMergeRequest]$MergeRequest = $_
        }
        [int64]$MergeRequest_Id = $MergeRequest.Id
        [string]$CodeRepository_id = $CodeRepository.Id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Proceed to accept the merge request `"$($MergeRequest_Id)`" on the Code Repository $($CodeRepository_id) ?")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
            $Body.'id' = $MergeRequest_Id
            $Body.'_operationType' = 'update'
            $Body.'_operationId' = 'accept'
            $Body.'_textMatchStyle' = 'exact'
            $Body.'_dataSource' = 'MergeRequestDataSource'
            $Body.'isc_metaDataPrefix' = '_'
            $Body.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $Body
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            If ($null -eq $parameters["Command"]) {
                [string]$command = ('/mergeRequest/accept')
                $parameters.Add('Command', $command)
            }
            Else {
                $parameters.Command = $command
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            $Error.Clear()
            Try {
                [ANOWCodeRepositoryMergeRequest]$MergeRequest = $results.response.data
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the response into an [ANOWCodeRepositoryMergeRequest] object due to [$Message]."
                Break
            }
            If ($MergeRequest.Id -gt 0) {
                If ($Quiet -ne $true) {
                    Return $MergeRequest
                }
            }
        }
    }
    End {

    }
}

Function Deny-AutomateNOWCodeRepositoryMergeRequest {

    <#
    .SYNOPSIS
    Denies (rejects) a Merge Request on a local Code Repository in an AutomateNOW! instance

    .DESCRIPTION
    Denies (rejects) a Merge Request on a local Code Repository in an AutomateNOW! instance

    .PARAMETER CodeRepository
    Mandatory [ANOWCodeRepository] object (Use Get-AutomateNOWCodeRepository to retrieve them)

    .PARAMETER MergeRequest
    Mandatory [ANOWCodeRepositoryMergeRequest] object (Use Get-AutomateNOWMergeRequest to retrieve them)

    .PARAMETER Force
    Force the rejection of the object without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the display of the results

    .INPUTS
    You must pass both the [ANOWCodeRepository] object and a [ANOWCodeRepositoryMergeRequest] object.

    .OUTPUTS
    The denied [ANOWCodeRepositoryMergeRequest] object will be returned. Use -Quiet to suppress this.

    .EXAMPLE
    Denies (rejects) a Merge Request with the id of 9 on a Code Repository named 'Repository1'

    $repository = Get-AutomateNOWCodeRepository -Id 'Repository1'
    $merge_request = Get-AutomateNOWCodeRepositoryMergeRequest -CodeRepository $repository -Id 9
    Deny-AutomateNOwCodeRepositoryMergeRequest -CodeRepository $repository -MergeRequest $merge_request

    .EXAMPLE
    Forcibly denies (rejects) a Merge Request with the id of 9 on a Code Repository named 'Repository1'

    $repository = Get-AutomateNOWCodeRepository -Id 'Repository1'
    $merge_request = Get-AutomateNOWCodeRepositoryMergeRequest -CodeRepository $repository -Id 9
    $merge_request | Deny-AutomateNOwCodeRepositoryMergeRequest -CodeRepository $repository -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWCodeRepositoryMergeRequest])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWCodeRepositoryMergeRequest]$MergeRequest,
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.Id.Length -gt 0 ) {
            [ANOWCodeRepositoryMergeRequest]$MergeRequest = $_
        }
        [int64]$MergeRequest_Id = $MergeRequest.Id
        [string]$CodeRepository_id = $CodeRepository.Id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Proceed to deny/reject the merge request `"$($MergeRequest_Id)`" on the Code Repository $($CodeRepository_id) ?")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
            $Body.'id' = $MergeRequest_Id
            $Body.'_operationType' = 'update'
            $Body.'_operationId' = 'reject'
            $Body.'_textMatchStyle' = 'exact'
            $Body.'_dataSource' = 'MergeRequestDataSource'
            $Body.'isc_metaDataPrefix' = '_'
            $Body.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $Body
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            If ($null -eq $parameters["Command"]) {
                [string]$command = ('/mergeRequest/reject')
                $parameters.Add('Command', $command)
            }
            Else {
                $parameters.Command = $command
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            $Error.Clear()
            Try {
                [ANOWCodeRepositoryMergeRequest]$MergeRequest = $results.response.data
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the response into an [ANOWCodeRepositoryMergeRequest] object due to [$Message]."
                Break
            }
            If ($MergeRequest.Id -gt 0) {
                If ($Quiet -ne $true) {
                    Return $MergeRequest
                }
            }
        }
    }
    End {

    }
}

#endregion

#Region - Code Repository Object Source Code

Function Get-AutomateNOWCodeRepositoryObjectSource {
    <#
    .SYNOPSIS
    Gets the source code for an object from an AutomateNOW! instance

    .DESCRIPTION
    Gets the source code for an object from an AutomateNOW! instance. This is equivalent to clicking the 'Source Code' button in the UI for the objects which support source code modification.

    .PARAMETER TaskTemplate
    [ANOWTaskTemplate] object to retrieve the source code of. Use Get-AutomateNOWTaskTemplate to obtain these objects.

    .PARAMETER WorkflowTemplate
    [ANOWWorkflowTemplate] object to retrieve the source code of. Use Get-AutomateNOWWorkflowTemplate to obtain these objects.

    .PARAMETER ScheduleTemplate
    [ANOWScheduleTemplate] object to retrieve the source code of. Use Get-AutomateNOWScheduleTemplate to obtain these objects.

    .PARAMETER BusinessView
    [ANOWBusinessView] object to retrieve the source code of. Use Get-AutomateNOWBusinessView to obtain these objects.

    .PARAMETER Workspace
    [ANOWWorkspace] object to retrieve the source code of. Use Get-AutomateNOWWorkspace to obtain these objects.

    .PARAMETER ResultMapping
    [ANOWResultMapping] object to retrieve the source code of. Use Get-AutomateNOWResultMapping to obtain these objects.

    .PARAMETER Approval
    [ANOWApproval] object to retrieve the source code of. Use Get-AutomateNOWApproval to obtain these objects.

    .PARAMETER ServerNode
    [ANOWServerNode] object to retrieve the source code of. Use Get-AutomateNOWServerNode to obtain these objects.

    .PARAMETER ServerNodeGroup
    [ANOWServerNodeGroup] object to retrieve the source code of. Use Get-AutomateNOWServerNodeGroup to obtain these objects.

    .PARAMETER Agent
    [ANOWAgent] object to retrieve the source code of. Use Get-AutomateNOWAgent to obtain these objects.

    .PARAMETER Endpoint
    [ANOWEndpoint] object to retrieve the source code of. Use Get-AutomateNOWEndpoint to obtain these objects.

    .PARAMETER Calendar
    [ANOWCalendar] RESOURCE object to retrieve the source code of. Use Get-AutomateNOWCalendar to obtain these objects.

    .PARAMETER Stock
    [ANOWStock] RESOURCE object to retrieve the source code of. Use Get-AutomateNOWStock to obtain these objects.

    .PARAMETER Lock
    [ANOWLock] RESOURCE object to retrieve the source code of. Use Get-AutomateNOWLock to obtain these objects.

    .PARAMETER TimeWindow
    [ANOWTimeWindow] RESOURCE object to retrieve the source code of. Use Get-AutomateNOWTimeWindow to obtain these objects.

    .PARAMETER Semaphore
    [ANOWSemaphore] RESOURCE object to retrieve the source code of. Use Get-AutomateNOWSemaphore to obtain these objects.

    .PARAMETER Variable
    [ANOWVariable] RESOURCE object to retrieve the source code of. Use Get-AutomateNOWVariable to obtain these objects.

    .PARAMETER Metric
    [ANOWMetric] RESOURCE object to retrieve the source code of. Use Get-AutomateNOWMetric to obtain these objects.

    .PARAMETER PhysicalResource
    [ANOWPhysicalResource] RESOURCE object to retrieve the source code of. Use Get-AutomateNOWPhysicalResource to obtain these objects.

    .PARAMETER Event
    [ANOWEvent] RESOURCE object to retrieve the source code of. Use Get-AutomateNOWEvent to obtain these objects.

    .PARAMETER DataSource
    [ANOWDataSource] object to retrieve the source code of. Use Get-AutomateNOWDataSource to obtain these objects.

    .PARAMETER Anomaly
    [ANOWAnomaly] object to retrieve the source code of. Use Get-AutomateNOWAnomaly to obtain these objects.

    .PARAMETER Interface
    [ANOWIntegration] object to retrieve the source code of. Use Get-AutomateNOWInterface to obtain these objects.

    .PARAMETER NotificationGroup
    [ANOWNotificationGroup] object to retrieve the source code of. Use Get-AutomateNOWNotificationGroup to obtain these objects.

    .PARAMETER NotificationChannel
    [ANOWNotificationChannel] object to retrieve the source code of. Use Get-AutomateNOWNotificationChannel to obtain these objects.

    .PARAMETER NotificationTemplate
    [ANOWNotificationMessageTemplate] object to retrieve the source code of. Use Get-AutomateNOWNotificationTemplate to obtain these objects.

    .PARAMETER RuntimeAction
    [ANOWProcessingAction] object to retrieve the source code of. Use Get-AutomateNOWRuntimeAction to obtain these objects.

    .PARAMETER Dashboard
    [ANOWDashboard] object to retrieve the source code of. Use Get-AutomateNOWDashboard to obtain these objects.

    .PARAMETER AdhocReport
    [ANOWAdhocReport] object to retrieve the source code of. Use Get-AutomateNOWAdhocReport to obtain these objects.

    .PARAMETER UserReport
    [ANOWUserReport] object to retrieve the source code of. Use Get-AutomateNOWUserReport to obtain these objects.

    .PARAMETER Tag
    [ANOWTag] object to retrieve the source code of. Use Get-AutomateNOWTag to obtain these objects.

    .PARAMETER Folder
    [ANOWFolder] object to retrieve the source code of. Use Get-AutomateNOWFolder to obtain these objects.

    .INPUTS
    Accepts many types of [ANOW] objects including TaskTemplate, WorkflowTemplate, ServerNodes, Stocks, Locks & Variables across the pipeline

    .OUTPUTS
    A single [ANOWCodeRepositoryObjectSourceCode] object will be returned containing the source code of the object.

    .EXAMPLE
    Gets the source code of a Task Template

    $task_template = Get-AutomateNOWTaskTemplate -Id 'Template1'
    Get-AutomateNOWCodeRepositoryObjectSource -TaskTemplate $task_template

    .EXAMPLE
    Gets the source code of a Task Template in one line of code

    Get-AutomateNOWCodeRepositoryObjectSource -TaskTemplate (Get-AutomateNOWTaskTemplate -Id 'Template1')

    .EXAMPLE
    Uses the pipeline to get the source code for the first page of Task Templates

    Get-AutomateNOWTaskTemplate | Get-AutomateNOWCodeRepositoryObjectSource

    .EXAMPLE
    Gets 1 of each supported object type. This is the full gamut.

    Get-AutomateNOWAdhocReport -startRow 0 -endRow 1 | Get-AutomateNOWCodeRepositoryObjectSource
    Get-AutomateNOWAgent -startRow 0 -endRow 1 | Get-AutomateNOWCodeRepositoryObjectSource
    Get-AutomateNOWAnomaly -startRow 0 -endRow 1 | Get-AutomateNOWCodeRepositoryObjectSource
    Get-AutomateNOWApproval -startRow 0 -endRow 1 | Get-AutomateNOWCodeRepositoryObjectSource
    Get-AutomateNOWBusinessView -startRow 0 -endRow 1 | Get-AutomateNOWCodeRepositoryObjectSource
    Get-AutomateNOWCalendar -startRow 0 -endRow 1 | Get-AutomateNOWCodeRepositoryObjectSource
    Get-AutomateNOWDashboard -startRow 0 -endRow 1 | Get-AutomateNOWCodeRepositoryObjectSource
    Get-AutomateNOWDataSource -startRow 0 -endRow 1 | Get-AutomateNOWCodeRepositoryObjectSource
    Get-AutomateNOWEndpoint -startRow 0 -endRow 1 | Get-AutomateNOWCodeRepositoryObjectSource
    Get-AutomateNOWEvent -startRow 0 -endRow 1 | Get-AutomateNOWCodeRepositoryObjectSource
    Get-AutomateNOWFolder -startRow 0 -endRow 1 | Get-AutomateNOWCodeRepositoryObjectSource
    Get-AutomateNOWInterface -startRow 0 -endRow 1 | Get-AutomateNOWCodeRepositoryObjectSource
    Get-AutomateNOWLock -startRow 0 -endRow 1 | Get-AutomateNOWCodeRepositoryObjectSource
    Get-AutomateNOWMetric -startRow 0 -endRow 1 | Get-AutomateNOWCodeRepositoryObjectSource
    Get-AutomateNOWNotificationChannel -startRow 0 -endRow 1 | Get-AutomateNOWCodeRepositoryObjectSource
    Get-AutomateNOWNotificationGroup -startRow 0 -endRow 1 | Get-AutomateNOWCodeRepositoryObjectSource
    Get-AutomateNOWNotificationMessageTemplate -startRow 0 -endRow 1 | Get-AutomateNOWCodeRepositoryObjectSource
    Get-AutomateNOWPhysicalResource -startRow 0 -endRow 1 | Get-AutomateNOWCodeRepositoryObjectSource
    Get-AutomateNOWResultMapping -startRow 0 -endRow 1 | Get-AutomateNOWCodeRepositoryObjectSource
    Get-AutomateNOWScheduleTemplate -startRow 0 -endRow 1 | Get-AutomateNOWCodeRepositoryObjectSource
    Get-AutomateNOWSemaphore -startRow 0 -endRow 1 | Get-AutomateNOWCodeRepositoryObjectSource
    Get-AutomateNOWServerNode -startRow 0 -endRow 1 | Get-AutomateNOWCodeRepositoryObjectSource
    Get-AutomateNOWServerNodeGroup -startRow 0 -endRow 1 | Get-AutomateNOWCodeRepositoryObjectSource
    Get-AutomateNOWStock -startRow 0 -endRow 1 | Get-AutomateNOWCodeRepositoryObjectSource
    Get-AutomateNOWTag -startRow 0 -endRow 1 | Get-AutomateNOWCodeRepositoryObjectSource
    Get-AutomateNOWTaskTemplate -startRow 0 -endRow 1 | Get-AutomateNOWCodeRepositoryObjectSource
    Get-AutomateNOWTimeWindow -startRow 0 -endRow 1 | Get-AutomateNOWCodeRepositoryObjectSource
    Get-AutomateNOWUserReport -startRow 0 -endRow 1 | Get-AutomateNOWCodeRepositoryObjectSource
    Get-AutomateNOWVariable -startRow 0 -endRow 1 | Get-AutomateNOWCodeRepositoryObjectSource
    Get-AutomateNOWWorkflowTemplate -startRow 0 -endRow 1 | Get-AutomateNOWCodeRepositoryObjectSource
    Get-AutomateNOWWorkspace -startRow 0 -endRow 1 | Get-AutomateNOWCodeRepositoryObjectSource

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This function is almost complete, of the known domain classes, only Runtime Actions is still missing.

    #>
    [OutputType([ANOWCodeRepositoryObjectSourceCode])]
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'TaskTemplate')] # Processing Template
        [ANOWTaskTemplate]$TaskTemplate,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'WorkflowTemplate')] # Processing Template
        [ANOWWorkflowTemplate]$WorkflowTemplate,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'ScheduleTemplate')] # Schedules
        [ANOWScheduleTemplate]$ScheduleTemplate,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'BusinessView')]
        [ANOWBusinessView]$BusinessView,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Workspace')]
        [ANOWWorkspace]$Workspace,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'ResultMapping')]
        [ANOWResultMapping]$ResultMapping,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Approval')]
        [ANOWApproval]$Approval,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'ServerNode')]
        [ANOWServerNode]$ServerNode,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'ServerNodeGroup')]
        [ANOWServerNodeGroup]$ServerNodeGroup,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Agent')]
        [ANOWAgent]$Agent,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Endpoint')]
        [ANOWEndpoint]$Endpoint,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Calendar')] # Resource
        [ANOWCalendar]$Calendar,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Stock')] # Resource
        [ANOWStock]$Stock,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Lock')] # Resource
        [ANOWLock]$Lock,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'TimeWindow')] # Resource
        [ANOWTimeWindow]$TimeWindow,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Semaphore')] # Resource
        [ANOWSemaphore]$Semaphore,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Variable')] # Resource
        [ANOWVariable]$Variable,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Metric')] # Resource
        [ANOWMetric]$Metric,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'PhysicalResource')] # Resource
        [ANOWPhysicalResource]$PhysicalResource,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Event')] # Resource
        [ANOWEvent]$Event,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'DataSource')]
        [ANOWDataSource]$DataSource,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Anomaly')]
        [ANOWAnomaly]$Anomaly,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Interface')]
        [ANOWIntegration]$Interface,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'NotificationGroup')]
        [ANOWNotificationGroup]$NotificationGroup,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'NotificationChannel')]
        [ANOWNotificationChannel]$NotificationChannel,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'NotificationTemplate')]
        [ANOWNotificationMessageTemplate]$NotificationMessageTemplate,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'RuntimeAction')]
        [ANOWProcessingAction]$RuntimeAction,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Dashboard')]
        [ANOWDashboard]$Dashboard,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'AdhocReport')]
        [ANOWAdhocReport]$AdhocReport,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'UserReport')]
        [ANOWUserReport]$UserReport,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Tag')]
        [ANOWTag]$Tag,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Folder')]
        [ANOWFolder]$Folder
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_ -is [ANOWTaskTemplate] -or $TaskTemplate.Id.Length -gt 0) {
            [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'ProcessingTemplate'
            If ($TaskTemplate.Id.Length -gt 0) {
                $Body.'id' = $TaskTemplate.Id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWWorkflowTemplate] -or $WorkflowTemplate.Id.Length -gt 0) {
            [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'ProcessingTemplate'
            If ($WorkflowTemplate.Id.Length -gt 0) {
                $Body.'id' = $WorkflowTemplate.Id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWScheduleTemplate] -or $ScheduleTemplate.Id.Length -gt 0) {
            [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'ProcessingTemplate'
            If ($ScheduleTemplate.Id.Length -gt 0) {
                $Body.'id' = $ScheduleTemplate.Id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWBusinessView] -or $BusinessView.Id.Length -gt 0) {
            [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'Businessview'
            If ($BusinessView.id.Length -gt 0) {
                $Body.'id' = $BusinessView.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWWorkspace] -or $Workspace.Id.Length -gt 0) {
            [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'Workspace'
            If ($Workspace.id.Length -gt 0) {
                $Body.'id' = $Workspace.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWResultMapping] -or $ResultMapping.Id.Length -gt 0) {
            [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'ResultMapping'
            If ($ResultMapping.id.Length -gt 0) {
                $Body.'id' = $ResultMapping.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWApproval] -or $Approval.Id.Length -gt 0) {
            [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'ApprovalConfiguration'
            If ($Approval.id.Length -gt 0) {
                $Body.'id' = $Approval.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWServerNode] -or $ServerNode.Id.Length -gt 0) {
            [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'ServerNode'
            If ($ServerNode.id.Length -gt 0) {
                $Body.'id' = $ServerNode.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWServerNodeGroup] -or $ServerNodeGroup.Id.Length -gt 0) {
            [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'ServerNodeGroup'
            If ($ServerNodeGroup.id.Length -gt 0) {
                $Body.'id' = $ServerNodeGroup.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWAgent] -or $Agent.Id.Length -gt 0) {
            [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'Agent'
            If ($Agent.id.Length -gt 0) {
                $Body.'id' = $Agent.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWEndpoint] -or $Endpoint.Id.Length -gt 0) {
            [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'Endpoint'
            If ($Endpoint.id.Length -gt 0) {
                $Body.'id' = $Endpoint.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWCalendar] -or $Calendar.Id.Length -gt 0) {
            [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'Resource'
            If ($Calendar.id.Length -gt 0) {
                $Body.'id' = $Calendar.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWStock] -or $Stock.Id.Length -gt 0) {
            [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'Resource'
            If ($Stock.id.Length -gt 0) {
                $Body.'id' = $Stock.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWLock] -or $Lock.Id.Length -gt 0) {
            [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'Resource'
            If ($Lock.id.Length -gt 0) {
                $Body.'id' = $Lock.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWTimeWindow] -or $TimeWindow.Id.Length -gt 0) {
            [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'Resource'
            If ($TimeWindow.id.Length -gt 0) {
                $Body.'id' = $TimeWindow.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWSemaphore] -or $Semaphore.Id.Length -gt 0) {
            [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'Resource'
            If ($Semaphore.id.Length -gt 0) {
                $Body.'id' = $Semaphore.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWVariable] -or $Variable.Id.Length -gt 0) {
            [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'Resource'
            If ($Variable.id.Length -gt 0) {
                $Body.'id' = $Variable.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWMetric] -or $Metric.Id.Length -gt 0) {
            [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'Resource'
            If ($Metric.id.Length -gt 0) {
                $Body.'id' = $Metric.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWPhysicalResource] -or $PhysicalResource.Id.Length -gt 0) {
            [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'Resource'
            If ($PhysicalResource.id.Length -gt 0) {
                $Body.'id' = $PhysicalResource.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWEvent] -or $Event.Id.Length -gt 0) {
            [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'Resource'
            If ($Event.id.Length -gt 0) {
                $Body.'id' = $Event.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWDataSource] -or $DataSource.Id.Length -gt 0) {
            [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'DataSource'
            If ($DataSource.id.Length -gt 0) {
                $Body.'id' = $DataSource.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWAnomaly] -or $Anomaly.Id.Length -gt 0) {
            [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'Anomaly'
            If ($Anomaly.id.Length -gt 0) {
                $Body.'id' = $Anomaly.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWIntegration] -or $Interface.Id.Length -gt 0) {
            [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'Integration'
            If ($Interface.id.Length -gt 0) {
                $Body.'id' = $Interface.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWNotificationGroup] -or $NotificationGroup.Id.Length -gt 0) {
            [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'NotificationGroup'
            If ($NotificationGroup.id.Length -gt 0) {
                $Body.'id' = $NotificationGroup.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWNotificationChannel] -or $NotificationChannel.Id.Length -gt 0) {
            [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'NotificationChannel'
            If ($NotificationChannel.id.Length -gt 0) {
                $Body.'id' = $NotificationChannel.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWNotificationMessageTemplate] -or $NotificationMessageTemplate.Id.Length -gt 0) {
            [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'NotificationMessageTemplate'
            If ($NotificationMessageTemplate.id.Length -gt 0) {
                $Body.'id' = $NotificationMessageTemplate.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWProcessingAction] -or $RuntimeAction.Id.Length -gt 0) {
            [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'ProcessingAction'
            If ($Dashboard.id.Length -gt 0) {
                $Body.'id' = $Dashboard.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWDashboard] -or $Dashboard.Id.Length -gt 0) {
            [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'Dashboard'
            If ($Dashboard.id.Length -gt 0) {
                $Body.'id' = $Dashboard.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWAdhocReport] -or $AdhocReport.Id.Length -gt 0) {
            [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'AdhocReport'
            If ($AdhocReport.id.Length -gt 0) {
                $Body.'id' = $AdhocReport.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWUserReport] -or $UserReport.Id.Length -gt 0) {
            [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'UserReport'
            If ($UserReport.id.Length -gt 0) {
                $Body.'id' = $UserReport.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWTag] -or $Tag.Id.Length -gt 0) {
            [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'Tag'
            If ($Tag.id.Length -gt 0) {
                $Body.'id' = $Tag.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWFolder] -or $Folder.Id.Length -gt 0) {
            [ANOWCodeRepositoryObjectSourceCode_domainClassName]$domainClassName = 'Folder'
            If ($Folder.id.Length -gt 0) {
                $Body.'id' = $Folder.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        Else {
            Write-Warning -Message "Unable to determine input object. Please specify an object of [ANOW] base class type."
            Break
        }
        $Body.'domainClassName' = $domainClassName
        $Body.'_operationType' = 'fetch'
        $Body.'_textMatchStyle' = 'exactCase'
        $Body.'_dataSource' = 'CodeRepositoryObjectDataSource'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/codeRepositoryObject/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] while running Find-AutomateNOWObjectReferral due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWCodeRepositoryObjectSourceCode]$ObjectSourceCode = $results.response.data | Select-Object -First 1
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into an [ANOWCodeRepositoryObjectSourceCode] object under Get-AutomateNOWCodeRepositoryObjectSource due to [$Message]."
            Break
        }
        If ($ObjectSourceCode.id.Length -eq 0) {
            Write-Warning -Message "Somehow the response to Get-AutomateNOWCodeRepositoryObjectSource resulted in an empty object. Please look into this."
            Break
        }
        Else {
            Return $ObjectSourceCode
        }
    }
    End {

    }
}

Function Export-AutomateNOWCodeRepositoryObjectSource {
    <#
    .SYNOPSIS
    Exports the source code for an object from an AutomateNOW! instance

    .DESCRIPTION
    Exports the source code for an object from an AutomateNOW! instance

    .PARAMETER ObjectSource
    Mandatory [ANOWCodeRepositoryObjectSourceCode] object containing the source code you wish to export. Use Get-AutomateNOWCodeRepositoryObjectSource to retrieve this.

    .INPUTS
    ONLY [ANOWCodeRepositoryObjectSourceCode] objects are accepted (including from the pipeline)

    .OUTPUTS
    The [ANOWCodeRepositoryObjectSourceCode] objects are exported to the local disk in CSV format

    .EXAMPLE


    .NOTES
	You must present [ANOWProcessingContextVariable] objects to the pipeline to use this function.

    Carriage returns are replaced with '\r'
    New lines are replaced with '\n'
    Tabs are replaced with '\t'

    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWCodeRepositoryObjectSourceCode]$ObjectSource
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-ObjectSource-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        $parameters.Add('Delimiter', "`t")
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWCodeRepositoryObjectSourceCode]$ObjectSource = $_
        }
        $ObjectSource.sourceCode = ($ObjectSource.sourceCode -replace "`r", '\r' -replace "`n", '\n' -replace "`t", '\t')
        $Error.Clear()
        Try {
            $ObjectSource | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWCodeRepositoryObjectSourceCode] object due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function Update-AutomateNOWCodeRepositoryObjectSource {
    <#
    .SYNOPSIS
    Updates the source code with your changes for an object from an AutomateNOW! instance.

    .DESCRIPTION
    Updates the source code with your changes for an object from an AutomateNOW! instance. This is equivalent to clicking the 'Source Code' button in the UI for the objects which support source code modification.

    .PARAMETER ObjectSource
    The [ANOWCodeRepositoryObjectSourceCode] object containing the source code you wish to update. Use Get-AutomateNOWCodeRepositoryObjectSource to retrieve this.

    .PARAMETER newSourceCode
    Mandatory string containing the updated source code. Note that this *must* be a valid JSON. You *may* pass single-json string which will then be formatted to "pretty mode" which is what ANOW prefers. See example below.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWCodeRepositoryObjectSourceCode] objects are accepted (including from the pipeline)

    .OUTPUTS
    A verbose message indicating success otherwise there is no output.

    .EXAMPLE
    Replaces a string inside the source code of a Stock object

    $stock = Get-AutomateNOWStock -Id 'Stock1'
    $stock_source = Get-AutomateNOWCodeRepositoryObjectSource -Stock $stock
    $source_code = $stock_source.sourceCode
    $source_code = $source_code -replace 'MyString', 'MyString!'
    Update-AutomateNOWCodeRepositoryObjectSource -ObjectSource $stock_source -newSourceCode $source_code -Force

    .EXAMPLE
    Updates the source code of a Stock object using a manually crafted compressed JSON string

    $stock = Get-AutomateNOWStock -Id 'Stock1'
    $stock_source = Get-AutomateNOWCodeRepositoryObjectSource -Stock $stock
    $source_code = '{"codeRepository":"Repository1","description":"My description","resourceType":"STOCK","tags":["Tag1"],"totalPermits":100}'
    Update-AutomateNOWCodeRepositoryObjectSource -ObjectSource $stock_source -newSourceCode $source_code -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This is the equivalent to clicking the 'Save' button after making changes to an object using the 'Source Code' button.

    Not all objects are supported yet.

    #>

    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWCodeRepositoryObjectSourceCode]$ObjectSource,
        [Parameter(Mandatory = $true)]
        [string]$newSourceCode,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    $Error.Clear()
    Try {
        [string]$sourceCode = $newSourceCode | ConvertFrom-Json | ConvertTo-Json -Depth 100
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "ConvertFrom-Json/ConvertTo-Json failed to validate the provided source code string ($newSourceCode) due to [$Message]."
        Break
    }
    [string]$command = '/codeRepositoryObject/updateSourceCode'
    [hashtable]$parameters = @{}
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$ObjectSource_id = $ObjectSource.id
    [string]$ObjectSource_domain = $ObjectSource.domain
    [string]$ObjectSource_rootId = $ObjectSource_id -split '\|' | Select-Object -Last 1
    If ($ObjectSource_rootId.Length -eq 0) {
        Write-Warning -Message "Somehow the root Id of the source code's object could not be determined. Please look into this."
        Break
    }
    [string]$ObjectSource_rootFullId = ('[' + $ObjectSource_domain + ']' + $ObjectSource_rootId)
    Write-Verbose -Message "Derived the full root id of the source code object as $ObjectSource_rootFullId"
    If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ObjectSource_rootId)")) -eq $true) {
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        <#
        $Error.Clear()
        Try {
            [boolean]$object_exists = ($null -eq (Get-AutomateNOWCodeRepositoryObjectSource -Id $ObjectSource_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepositoryObjectSource failed to confirm the source object (under Update-AutomateNOWCodeRepositoryObjectSource) due to [$Message]."
            Break
        }
        If ($object_exists -ne $true) {
            Write-Warning -Message "The object couldn't be verified. Please check into this."
            Break
        }
        #>
        ## End warning ##
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        $BodyMetaData.'id' = $ObjectSource_rootFullId
        $BodyMetaData.'domainClassName' = $ObjectSource.domainClassName
        $BodyMetaData.'sourceCode' = $sourceCode
        $BodyMetaData.'_operationType' = 'custom'
        $BodyMetaData.'_operationId' = 'updateSourceCode'
        $BodyMetaData.'_textMatchStyle' = 'exact'
        $BodyMetaData.'_dataSource' = 'CodeRepositoryObjectDataSource'
        $BodyMetaData.'isc_metaDataPrefix' = '_'
        $BodyMetaData.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        If ($null -eq $parameters.Body) {
            $parameters.Add('Body', $Body)
        }
        Else {
            $parameters.Body = $Body
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ObjectSource_rootId] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        Write-Verbose -Message "The source code for [$ObjectSource_rootId] was updated"
    }
}

Function Edit-AutomateNOWCodeRepositoryObjectSource {
    <#
    .SYNOPSIS
    (Windows-only for now) - Acts as a front-end to other functions for editing the source code with your changes for an object from an AutomateNOW! instance.

    .DESCRIPTION
    (Windows-only for now) - Acts as a front-end to other functions for editing the source code with your changes for an object from an AutomateNOW! instance.

    .PARAMETER ObjectSource
    The [ANOWCodeRepositoryObjectSourceCode] object containing the source code you wish to update. Use Get-AutomateNOWCodeRepositoryObjectSource to retrieve this.

    .PARAMETER Force
    Accepts the change you've made without prompting for confirmation. Make sure you know what you are doing before using this.

    .INPUTS
    ONLY [ANOWCodeRepositoryObjectSourceCode] objects are accepted (including from the pipeline)

    .OUTPUTS
    A verbose message indicating success otherwise there is no output.

    .EXAMPLE
    Edits the source code of a Stock object

    $stock = Get-AutomateNOWStock -Id 'Stock1'
    $stock_source = Get-AutomateNOWCodeRepositoryObjectSource -Stock $stock
    $stock_source | Edit-AutomateNOWCodeRepositoryObjectSource

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This function only works with Windows and uses Notepad (for now). You will need to confirm your changes AFTER you close the text editor.

    Not all objects are supported yet.

    #>

    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWCodeRepositoryObjectSourceCode]$ObjectSource,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
    }
    Process {
        If ($_.Id.Length -gt 0) {
            [ANOWCodeRepositoryObjectSourceCode]$ObjectSource = $_
        }
        [string]$ObjectSource_id = $ObjectSource.id
        [string]$ObjectSource_domain = $ObjectSource.domain
        [string]$ObjectSource_rootId = $ObjectSource_id -split '\|' | Select-Object -Last 1
        If ($ObjectSource_rootId.Length -eq 0) {
            Write-Warning -Message "Somehow the root Id of the source code's object could not be determined. Please look into this."
            Break
        }
        [string]$ObjectSource_rootFullId = ('[' + $ObjectSource_domain + ']' + $ObjectSource_rootId)
        Write-Verbose -Message "Derived the full root id of the source code object as $ObjectSource_rootFullId"
        [string]$sourceCode = $ObjectSource.sourceCode
        If ($sourceCode.Length -eq 0) {
            Write-Warning -Message "Somehow the source code is empty (while editing the source code of $ObjectSource_rootFullId). Please look into this."
            Break
        }
        [string]$temp_dir = $env:TEMP
        [int64]$current_unixtime = [int64](((Get-Date).ToUniversalTime() - (Get-Date -Date '1970/1/1')) | Select-Object -ExpandProperty TotalMilliseconds)
        [string]$temp_filename = "$temp_dir\Edit-AutomateNOWCodeRepositoryObjectSource-$current_unixtime.txt"
        $Error.Clear()
        Try {
            [System.IO.FileSystemInfo]$new_fileinfo = New-Item -Path "$temp_filename" -Force
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "New-Item failed to create the temporary file [$temp_filename] (while editing the source code of $ObjectSource_rootFullId) due to [$Message]."
            Break
        }
        $Error.Clear()
        Try {
            $new_fileinfo | Set-Content -Value $sourceCode -Encoding UTF8
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Set-Content failed (on the first pass) to modify the temporary file [$temp_filename] (while editing the source code of $ObjectSource_rootFullId) due to [$Message]."
            Break
        }
        $Error.Clear()
        Try {
            [datetime]$initial_modified_time_utc = Get-Item -Path "$temp_filename" -Force | Select-Object -ExpandProperty LastWriteTimeUtc
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-Item failed to read the newly modified temporary file [$temp_filename] (while editing the source code of $ObjectSource_rootFullId) due to [$Message]."
            Break
        }
        [string]$textEditorPath = "$env:windir\notepad.exe"
        $Error.Clear()
        Try {
            Start-Process -FilePath "$textEditorPath" -ArgumentList $temp_filename -Wait
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Start-Process failed to open the temporary file [$temp_filename] (while editing the source code of $ObjectSource_rootFullId) due to [$Message]."
            Break
        }
        $Error.Clear()
        Try {
            [datetime]$newly_modified_time_utc = Get-Item -Path "$temp_filename" -Force | Select-Object -ExpandProperty LastWriteTimeUtc
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "New-Item failed to create the temporary file [$temp_filename] (while editing the source code of $ObjectSource_rootFullId) due to [$Message]."
            Break
        }
        If ($newly_modified_time_utc.Ticks -gt $initial_modified_time_utc.Ticks) {
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Are you sure you want to apply the changes you've made to $($ObjectSource_rootFullId)?")) -eq $true) {
                [string]$newSourceCode = Get-Content -Path "$temp_filename" -Encoding UTF8
                If ($newSourceCode.Length -eq 0) {
                    Write-Warning -Message "Somehow (while editing the source code of $ObjectSource_rootFullId) the temporary file ($temp_filename) containing the source code being edited was empty. Please look into this."
                    Break
                }
                $Error.Clear()
                Try {
                    Update-AutomateNOWCodeRepositoryObjectSource -ObjectSource $ObjectSource -newSourceCode $newSourceCode -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Update-AutomateNOWCodeRepositoryObjectSource failed to update the source code of $ObjectSource_rootFullId using the file [$temp_filename] due to [$Message]."
                    Break
                }
            }
        }
        Else {
            Write-Warning -Message "The source code file was not modified for $ObjectSource_rootFullId"
        }
        $Error.Clear()
        Try {
            Remove-Item -Path "$temp_filename" -Force
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Remove-Item failed to remove the temporary file [$temp_filename] (while editing the source code of $ObjectSource_rootFullId) due to [$Message]."
            Break
        }
        Write-Verbose -Message "Successfully deleted the temporary file [$temp_filename]"
    }
    End {

    }
}

#endregion

#Region - Code Repository Tags

Function Get-AutomateNOWCodeRepositoryTag {

    <#
    .SYNOPSIS
    Gets the git tags from a local Code Repository in an AutomateNOW! instance

    .DESCRIPTION
    Gets the git tags from a local Code Repository in an AutomateNOW! instance

    .PARAMETER CodeRepository
    Mandatory [ANOWCodeRepository] object (Use Get-AutomateNOWCodeRepository to retrieve them)

    .PARAMETER startRow
    Integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .INPUTS
    You must present an [ANOWCodeRepository] object

    .OUTPUTS
    An array of PSCustomObjects representing the git tags in the repository.

    .EXAMPLE
    Gets the names of the git tags from a Code Repository

    $repo = Get-AutomateNOWCodeRepository -Id 'Repository1'
    $branches = Get-AutomateNOWCodeRepositoryTag -CodeRepository $repo

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWCodeRepository[]])]
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $False)]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False)]
        [int32]$endRow = 100
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Id.Length -gt 0 ) {
            $Body.'codeRepository' = $_.Id
        }
        Else {
            $Body.'codeRepository' = $CodeRepository.Id
        }
        $Body.'_operationType' = 'fetch'
        $Body.'_startRow' = $startRow
        $Body.'_endRow' = $endRow
        $Body.'_textMatchStyle' = 'exact'
        $Body.'_componentId' = 'CodeRepositoryTagList'
        $Body.'_dataSource' = 'CodeRepositoryTagDataSource'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/codeRepositoryTag/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWCodeRepositoryTag[]]$CodeRepositoryTags = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWCodeRepositoryTag] objects due to [$Message]."
            Break
        }
        If ($CodeRepositoryTags.Count -gt 0) {
            Return $CodeRepositoryTags
        }
    }
    End {

    }
}

Function New-AutomateNOWCodeRepositoryTag {
    <#
    .SYNOPSIS
    Creates a git tag on a local Code Repository in an AutomateNOW! instance

    .DESCRIPTION
    Creates a git tag on a local Code Repository in an AutomateNOW! instance

    .PARAMETER CodeRepository
    Mandatory [ANOWCodeRepository] object (Use Get-AutomateNOWCodeRepository to retrieve them)

    .PARAMETER Tag
    Mandatory string for the name of the git tag. The name of the git tag may consist only of alphanumeric characters and 3 special characters (._-) and not to exceed 128 characters in length.

    .PARAMETER Description
    Optional string for the description of the tag. The maximum length permitted for this string is unknown.

    .PARAMETER Quiet
    Optional switch to suppress the display of the results

    .PARAMETER Force
    Force the creation of the object without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    You must present [ANOWCodeRepository] objects

    .OUTPUTS
    An informational message indicating the results. Use -Quiet to suppress this.

    .EXAMPLE
    Creates a new tag named 'tag1' on a repository named 'CodeRepository1'.

    $repo = Get-AutomateNOWCodeRepository -Id 'CodeRepository1'
    New-AutomateNOWCodeRepositoryTag -CodeRepository $repo -Tag 'tag1'

    .EXAMPLE
    Uses the pipeline to quietly and forcibly create three tags on a repository named 'CodeRepository1'

    $repo = Get-AutomateNOWCodeRepository -Id 'CodeRepository1'
    @('tag1', 'tag2', 'tag3') | New-AutomateNOWCodeRepositoryTag -CodeRepository $repo -Force -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWCodeRepositoryTag])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWCodeRepository]$CodeRepository,
        [ValidateScript({ $_.Length -gt 0 -and $_.Length -le 128 })]
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [string]$Tag,
        [Parameter(Mandatory = $false)]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0 ) {
            [string]$Tag = $_
        }
        [string]$CodeRepository_Id = $CodeRepository.Id
        ## Do not tamper with this code. It ensures that we are not trying to add a git tag that already exists
        [string[]]$existing_tag_names = (Get-AutomateNOWCodeRepositoryTag -CodeRepository $CodeRepository).name
        If ($Tag -in $existing_tag_names) {
            Write-Warning -Message "The git tag [$Tag] already exists in $CodeRepository_id. No action is required."
            Break
        }
        ##
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Proceed to create the git tag `"$($Tag)`" on the Code Repository $($CodeRepository_id) ?")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
            $Body.'codeRepository' = $CodeRepository_Id
            $Body.'name' = $Tag
            If ($Description.Length -gt 0) {
                $Body.'description' = $Description
            }
            $Body.'_operationType' = 'add'
            $Body.'_textMatchStyle' = 'exact'
            $Body.'_oldValues' = ('{"codeRepository":"' + $CodeRepository_Id + '","name":"","description":""}')
            $Body.'_componentId' = 'CodeRepositoryTagCreateWindow_form'
            $Body.'_dataSource' = 'CodeRepositoryTagDataSource'
            $Body.'isc_metaDataPrefix' = '_'
            $Body.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $Body
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            If ($null -eq $parameters["Command"]) {
                [string]$command = ('/codeRepositoryTag/create')
                $parameters.Add('Command', $command)
            }
            Else {
                $parameters.Command = $command
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            $Error.Clear()
            Try {
                [ANOWCodeRepositoryTag]$CodeRepositoryTag = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the returned updated object to an [ANOWCodeRepositoryTag] object due to [$Message]. The object was still updated though."
                Break
            }
            If ($Quiet -ne $true) {
                Return $CodeRepositoryTag
            }
        }
    }
    End {

    }
}

Function Remove-AutomateNOWCodeRepositoryTag {

    <#
    .SYNOPSIS
    Deletes a git tag on a local Code Repository in an AutomateNOW! instance

    .DESCRIPTION
    Deletes a git tag on a local Code Repository in an AutomateNOW! instance

    .PARAMETER CodeRepository
    Mandatory [ANOWCodeRepository] object (Use Get-AutomateNOWCodeRepository to retrieve them)

    .PARAMETER Tag
    Mandatory [ANOWCodeRepositoryTag] object to be deleted from the Code Repository. Use Get-AutomateNOWCodeRepositoryTag to retrieve these.

    .PARAMETER Quiet
    Optional switch to suppress the display of the results

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    You must present a [ANOWCodeRepository] object along with [ANOWCodeRepositoryTag] objects

    .OUTPUTS
    An informational message indicating the results. Use -Quiet to suppress this.

    .EXAMPLE
    Deletes a git tag named 'Tag2' on a repository named 'CodeRepository1'.

    $repo = Get-AutomateNOWCodeRepository -Id 'CodeRepository1'
    $tag = Get-AutomateNOWCodeRepositoryTag -CodeRepository $repo | Where-Object { $_.name -eq 'Tag2' }
    Remove-AutomateNOWCodeRepositoryTag -CodeRepository $repo -Tag $tag

    .EXAMPLE
    Uses the pipeline to quietly and forcibly delete three tags on a repository named 'CodeRepository1'

    $repo = Get-AutomateNOWCodeRepository -Id 'CodeRepository1'
    $tags = Get-AutomateNOWCodeRepositoryTag -CodeRepository $repo | Where-Object { $_.name -in @('Tag1', 'Tag2', 'Tag3') }
    $tags | Remove-AutomateNOWCodeRepositoryTag -CodeRepository $repo -Force -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWCodeRepository]$CodeRepository,
        [ValidateScript({ $_.Length -gt 0 -and $_.Length -le 128 })]
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWCodeRepositoryTag]$Tag,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0 ) {
            [ANOWCodeRepositoryTag]$Tag = $_
        }
        [string]$CodeRepository_Id = $CodeRepository.Id
        If ($CodeRepository_Id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        ## Do not tamper with this code. It ensures that we are not trying to remove a git tag that doesn't exist
        $Error.Clear()
        Try {
            [string[]]$existing_tag_ids = (Get-AutomateNOWCodeRepositoryTag -CodeRepository $CodeRepository).id
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepositoryBranch failed to retrieve the git tags from $CodeRepository_Id under Remove-AutomateNOWCodeRepositoryTag due to [$Message]."
            Break
        }
        [string]$Tag_id = $Tag.id
        If ($Tag.id -notin $existing_tag_ids) {
            Write-Warning -Message "The git tag [$Tag] does not exist in $CodeRepository_id. No action is required."
            Break
        }
        ##
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Proceed to delete the git tag `"$($Tag)`" from the Code Repository $($CodeRepository_id) ?")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
            $Body.'codeRepository' = $CodeRepository_Id
            $Body.'id' = $Tag_id
            $Body.'_operationType' = 'remove'
            $Body.'_textMatchStyle' = 'exact'
            $Body.'_dataSource' = 'CodeRepositoryTagDataSource'
            $Body.'isc_metaDataPrefix' = '_'
            $Body.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $Body
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            [string]$command = ('/codeRepositoryTag/delete')
            If ($null -eq $parameters["Command"]) {
                $parameters.Add('Command', $command)
            }
            Else {
                $parameters.Command = $command
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            If ($Quiet -ne $True) {
                [string]$tag_name = $results.response.data.name
                Write-Information -MessageData "The git tag $tag_name ($Tag_id) was deleted from Code Repository $CodeRepository_Id"
            }
        }
    }
    End {

    }
}

Function Select-AutomateNOWCodeRepositoryTag {
    <#
    .SYNOPSIS
    Selects a git tag for usage from a Code Repository on an instance of AutomateNOW!

    .DESCRIPTION
    Selects a git tag for usage from a Code Repository on an instance of AutomateNOW!

    .PARAMETER CodeRepository
    Mandatory [ANOWCodeRepository] object (Use Get-AutomateNOWCodeRepository to retrieve them)

    .PARAMETER Tag
    Mandatory [ANOWCodeRepositoryTag] object to be selected from the Code Repository. Use Get-AutomateNOWCodeRepositoryTag to retrieve these.

    .PARAMETER Quiet
    Optional switch to suppress the display of the results

    .INPUTS
    You must present both the [ANOWCodeRepository] object for the Code Repository and the [ANOWCodeRepositoryTag] object for the Tag object

    .OUTPUTS
    An informational message indicating that the tag was successfully selected. Use the -Quiet parameter to silence this notification.

    .EXAMPLE
    Selects a git tag named 'Tag2' from a Code Repository named 'Repository1'

    $repo = Get-AutomateNOWCodeRepository -Id 'Repository1'
    $tags = Get-AutomateNOWCodeRepositoryTag -CodeRepository $repo
    $tag = $tags | Where-Object { $_.Name -eq 'Tag2'}
    Select-AutomateNOWCodeRepositoryTag -CodeRepository $repo -Tag $tag

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This function is the equivalent to the 'Select Tag' button when 1 git tag is selected in the Tags tab of a Code Repository.

    This function will ensure that the git tag exists before attempting to select it.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $true)]
        [ANOWCodeRepositoryTag]$Tag,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [string]$CodeRepository_id = $CodeRepository.id
        [string]$tag_name = $Tag.name
        ## Do not tamper with this code. It ensures that we are not trying to remove a git tag that doesn't exist
        $Error.Clear()
        [string[]]$existing_tag_ids = (Get-AutomateNOWCodeRepositoryTag -CodeRepository $CodeRepository).id
        [string]$Tag_id = $Tag.id
        If ($Tag_id -notin $existing_tag_ids) {
            Write-Warning -Message "The git tag $tag_name ($Tag_id) does not exist in $CodeRepository_id. It cannot be selected."
            Break
        }
        ##
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($CodeRepository_id)")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('name', $tag_name )
            $BodyMetaData.Add('id', $CodeRepository_id )
            $BodyMetaData.Add('_operationType', 'custom')
            $BodyMetaData.Add('_operationId', 'selectTag')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'CodeRepositoryDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            [string]$command = ('/codeRepository/selectTag')
            $parameters.Add('Command', $command)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on $CodeRepository_id due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                If ($Quiet -eq $true) {
                    Return $false
                }
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "The response code was [$response_code] instead of 0. The Code Repository $CodeRepository_id push (Upload) was not successful. Please see the full response $full_response_display"
            }
            Else {
                If ($Quiet -ne $true) {
                    $sync_table = $results.response.data
                    $sync_table | Format-Table -Autosize -Wrap
                    Write-Information -MessageData "The git tag $Tag_name ($Tag_id) has been selected for $CodeRepository_id"
                }
                Else {
                    Write-Verbose -Message "The git tag $Tag_name ($Tag_id) has been selected for $CodeRepository_id"
                }
            }
        }
    }
    End {

    }
}

#endregion

#Region - Context Variables

Function Get-AutomateNOWContextVariable {
    <#
    .SYNOPSIS
    Gets the Context Variables associated with a Workflow from an instance of AutomateNOW!

    .DESCRIPTION
    Gets the Context Variables associated with a Workflow from an instance of AutomateNOW!

    .PARAMETER RunId
    Mandatory single or array int64 of the RunId of Workflows from which to retrieve the Context Variables. Use AutomateNOWWorkFlow to retrieve these objects with their Id.

    .PARAMETER Id
    Mandatory Id of the specific Context Variable that you want to retrieve. Use this when you know exactly which variable you want to retrieve. This parameter is not available to the pipeline.

    .PARAMETER startRow
    An optional int32 representing what row to start the download from. This is intended for multi-page transfers.

    .PARAMETER endRow
    An optional int32 representing how many rows of data to receive. The default is 100. This is ideal for testing when you only want a few items.

    .PARAMETER sortBy
    Optional string representing the property by which to sort the results by. Valid choices are: id, dateCreated, lastUpdated, name, value

    .PARAMETER Ascending
    Optional switch parameter that will reverse the sort results

    .PARAMETER PreviewOnly
    Optional switch parameter that increases the speed of the retrieval by ignoring and not expanding truncated values.

    .INPUTS
    The RunId numbers may be sent across the pipeline

    .OUTPUTS
    An array of [ANOWProcessingContextVariable] objects

    .EXAMPLE
    Retrieves the context variables from many Workflow RunId's in a single API call (recommended approach)
    Get-AutomateNOWContextVariable -RunId 5415442, 5415443, 5415444, 5415445, 5415446, 5404544, 5404545, 5404552, 5404554, 5404555, 5404556, 5404557, 5415447

    .EXAMPLE
    Retrieves the context variables individually across the pipeline from a series of Workflow RunId's (inefficient approach)
    1913730, 1924427 | Get-AutomateNOWContextVariable | Export-AutomateNOWContextVariable

    .EXAMPLE
    Retrieves the context variables from a single Workflow RunId
    Get-AutomateNOWContextVariable -RunId 5415442

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Context Variables are considered part of the Processing class.

    Use Trace-AutomateNOWProcessing if you need to have the scope (level) of the variable (i.e. self, parent or root)

    Despite the advanced criteria usage of "InSet", this API call does not seem to support including more than 1 RunId per call.

    Warning: If you send an integer across the pipeline to this function it will be interpreted as the associated RunId (processId) of the variable. If you want to fetch the context variable by its Id then you must use -Id without the pipeline.

    #>
    [OutputType([ANOWProcessingContextVariable[]])]
    [Cmdletbinding( DefaultParameterSetName = 'RunId')]
    Param(
        [ValidateScript({ $_ -gt 0 })]
        [Parameter(Mandatory = $True, ParameterSetName = 'RunId', ValueFromPipeline = $true)]
        [int64[]]$RunId,
        [Parameter(Mandatory = $True, ParameterSetName = 'Id')]
        [int64]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'RunId')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'RunId')]
        [int32]$endRow = 100,
        [ValidateSet('id', 'name', 'value', 'valuePreview', 'dateCreated', 'lastUpdated', ignoreCase = $false)]
        [Parameter(Mandatory = $False, ParameterSetName = 'RunId')]
        [string]$sortBy = 'id',
        [Parameter(Mandatory = $False, ParameterSetName = 'RunId')]
        [switch]$PreviewOnly,
        [Parameter(Mandatory = $False, ParameterSetName = 'RunId')]
        [switch]$Ascending
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -lt $startRow) {
            Write-Warning -Message "The end row must be higher then the start row"
            Break
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$BodyObject = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.count -gt 0) {
            [int64]$RunId = $_
            [string]$RunIdRange = $RunId -join ','
        }
        ElseIf ($RunId.Count -gt 0) {
            [string]$RunIdRange = $RunId -join ','
        }
        If ($Id -gt 0) {
            [string]$command = '/processingContextVariable/get?'
            $BodyObject.Add('id', $Id)
        }
        Else {
            $BodyObject.Add('_constructor', 'AdvancedCriteria')
            $BodyObject.Add('operator', 'and')
            $BodyObject.Add('criteria1', ('{"fieldName":"processing","operator":"inSet","value":[' + $RunIdRange + ']}') )
            $BodyObject.Add('_operationType', 'fetch')
            $BodyObject.Add('_startRow', $startRow)
            $BodyObject.Add('_endRow', $endRow)
            If ($Ascending -ne $true) {
                $BodyObject.Add('_sortBy', $sortBy)
            }
            Else {
                $BodyObject.Add('_sortBy', ('-' + $sortBy))
            }
            $BodyObject.Add('_textMatchStyle', 'substring')
            $BodyObject.Add('_componentId', 'ProcessingContextVariableList')
            [string]$command = '/processingContextVariable/read?'
        }
        $BodyObject.Add('_dataSource', 'ProcessingContextVariableDataSource')
        $BodyObject.Add('isc_metaDataPrefix', '_')
        $BodyObject.Add('isc_dataFormat', 'json')
        [string]$Body = ConvertTo-QueryString -InputObject $BodyObject
        [string]$command = ($command + $Body)
        [string]$Instance = $anow_session.Instance
        [hashtable]$parameters = @{}
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $parameters.Add('Method', 'GET')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        $parameters.Add('Instance', $Instance)
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed due to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        [int32]$ContextVariables_count = $results.response.data.Count
        If ($ContextVariables_count -eq 0 -and $startRow -gt 0) {
            Write-Warning -Message "There are not any more rows of data past this point. Please try different -startRow value."
            Break
        }
        If ($ContextVariables_count -gt 0) {
            If ($PreviewOnly -ne $true) {
                [PSCustomObject[]]$FormattedContextVariables = ForEach ($ContextVariable in $results.response.data) {
                    [int32]$ContextVariableValuePreview_Length = $ContextVariable.valuePreview.Length
                    If ($ContextVariableValuePreview_Length -eq 128) {
                        If (($ContextVariable.valuePreview.substring(125, 3)) -eq '...') {
                            [string]$ContextVariable_Id = $ContextVariable.Id
                            Write-Verbose -Message "$ContextVariable_Id was truncated at 128 characters. Retrieving the full value."
                            $Error.Clear()
                            [System.Collections.Specialized.OrderedDictionary]$BodyObject = [System.Collections.Specialized.OrderedDictionary]@{}
                            $BodyObject.Add('id', $ContextVariable_Id)
                            $BodyObject.Add('_dataSource', 'ProcessingContextVariableDataSource')
                            $BodyObject.Add('isc_metaDataPrefix', '_')
                            $BodyObject.Add('isc_dataFormat', 'json')
                            [string]$Body = ConvertTo-QueryString -InputObject $BodyObject
                            [string]$command = ('/processingContextVariable/get?' + $Body)
                            $parameters.Command = $command
                            Try {
                                [string]$fullValue = Invoke-AutomateNOWAPI @parameters | Select-Object -ExpandProperty response | Select-Object -ExpandProperty Data | Select-Object -ExpandProperty value
                            }
                            Catch {
                                [string]$Message = $_.Exception.Message
                                Write-Warning -Message "Get-AutomateNOWContextVariable failed to retrieve the full (non-preview) value of Context Variable Id $ContextVariable_Id due to [$Message]."
                                Break
                            }
                            $ContextVariable | Add-Member -MemberType NoteProperty -Name value -Value $fullValue
                        }
                        Else {
                            Write-Verbose "Apparently this context variable value is exactly 128 characters and not truncated"
                            $ContextVariable | Add-Member -MemberType NoteProperty -Name value -Value $ContextVariable.valuePreview
                        }
                    }
                    Else {
                        $ContextVariable | Add-Member -MemberType NoteProperty -Name value -Value $ContextVariable.valuePreview
                    }
                    $ContextVariable
                }
                $Error.Clear()
                Try {
                    [ANOWProcessingContextVariable[]]$ContextVariables = $FormattedContextVariables
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to parse the returned results into formatted [ANOWProcessingContextVariable] objects under Get-AutomateNOWContextVariable due to [$Message]."
                    Break
                }
            }
            $Error.Clear()
            Try {
                [ANOWProcessingContextVariable[]]$ContextVariables = $results.response.data
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the returned results into unformatted [ANOWProcessingContextVariable] objects under Get-AutomateNOWContextVariable due to [$Message]."
                Break
            }
        }
        Return $ContextVariables
    }
    End {
    }
}

Function Export-AutomateNOWContextVariable {
    <#
    .SYNOPSIS
    Exports the Context Variables from a Task or Workflow from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Context Variables from a Task or Workflow from an instance of AutomateNOW!

    .PARAMETER ContextVariable
    Mandatory [ANOWProcessingContextVariable] object (Use Get-AutomateNOWContextVariable to retrieve them)

    .INPUTS
    ONLY [ANOWProcessingContextVariable] objects are accepted (including from the pipeline)

    .OUTPUTS
    The [ANOWProcessingContextVariable] objects are exported to the local disk in CSV format

    .EXAMPLE
    Exports the Context Variables from two Workflow RunId's
    1913730, 1924427 | Get-AutomateNOWContextVariable | Export-AutomateNOWContextVariable

    .NOTES
	You must present [ANOWProcessingContextVariable] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWProcessingContextVariable]$ContextVariable
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-ContextVariables-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        $parameters.Add('Delimiter', "`t")
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWProcessingContextVariable]$ContextVariable = $_
        }
        $Error.Clear()
        Try {
            $ContextVariable | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWProcessingContextVariable] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function ConvertFrom-AutomateNOWContextVariable {
    <#
    .SYNOPSIS
    Converts a collection of Context Variables from an instance of AutomateNOW! into an array of key/value pairs (or a hashtable of key/value pairs)

    .DESCRIPTION
    Converts a collection of Context Variables from an instance of AutomateNOW! into an array of key/value pairs (or a hashtable of key/value pairs)

    .PARAMETER ContextVariable
    Mandatory [ANOWProcessingContextVariable] object (Use Get-AutomateNOWContextVariable to retrieve them)

    .PARAMETER AsHashTable
    Optional switch parameter that will provide a hashtable instead of an array of PSCustomObjects. Use this when you have a set of Context Variables that will not have duplicate keys (names).

    .PARAMETER AsJsonString
    Optional switch parameter that will provide a compressed JSON string instead of an array of PSCustomObjects.

    .PARAMETER AsXML
    Optional switch parameter that will provide the context variables in 3 different types of XML

    .PARAMETER xml_type
    Optional string to modify the XML type. Valid choices are: Document*, Stream, String

    .PARAMETER AsCSV
    Optional switch parameter that will provide the context variables in CSV format

    .PARAMETER csv_delimiter
    Optional string to delimit the CSV output. The default is a comma. This value must be one character in length. Character codes such as `t for TAB count as 1 character in length.

    .INPUTS
    ONLY [ANOWProcessingContextVariable] objects are accepted (including from the pipeline)

    .OUTPUTS
    [hashtable] objects will be returned

    .EXAMPLE
    Converts the Context Variables from two Workflow RunId's
    1913730, 1924427 | Get-AutomateNOWContextVariable | ConvertFrom-AutomateNOWContextVariable

    .EXAMPLE
    Converts the Context Variables from two Workflow RunId's into a hash table
    1913730, 1924427 | Get-AutomateNOWContextVariable | ConvertFrom-AutomateNOWContextVariable -AsHashTable

    .EXAMPLE
    Converts the Context Variables from two Workflow RunId's into an XML stream
    1913730, 1924427 | Get-AutomateNOWContextVariable | ConvertFrom-AutomateNOWContextVariable -AsXML -xml_type Stream

    .NOTES
	The collection of Context Variables must all have unique names otherwise an exception will be thrown.

    #>
    [CmdletBinding(DefaultParameterSetName = 'JsonString')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWProcessingContextVariable]$ContextVariable,
        [Parameter(Mandatory = $true, ParameterSetName = 'HashTable')]
        [switch]$AsHashTable,
        [Parameter(Mandatory = $false, ParameterSetName = 'JsonString')]
        [switch]$AsJsonString,
        [Parameter(Mandatory = $true, ParameterSetName = 'CSV')]
        [switch]$AsCSV,
        [ValidateScript({ $_.Length -eq 1 })]
        [Parameter(Mandatory = $false, ParameterSetName = 'CSV')]
        [string]$csv_delimiter = ',',
        [Parameter(Mandatory = $true, ParameterSetName = 'XML')]
        [switch]$AsXML,
        [ValidateSet('Document', 'Stream', 'String')]
        [Parameter(Mandatory = $false, ParameterSetName = 'XML')]
        [string]$xml_type = 'Document'
    )
    Begin {
        [ANOWProcessingContextVariable[]]$ContextVariables = @()
        If ($AsCSV -eq $true) {
            Write-Warning -Message "This parameter is disabled for now :-)"
            Break
        }
    }
    Process {
        If ($_.Id.Length -gt 0) {
            [ANOWProcessingContextVariable]$ContextVariable = $_
        }
        [ANOWProcessingContextVariable[]]$ContextVariables += $ContextVariable
    }
    End {
        If ($AsHashTable -eq $true) {
            [int32]$ContextVariables_count = $ContextVariables.Count
            [int32]$ContextVariables_sorted_count = $ContextVariables.name | Sort-Object -Unique | Measure-Object | Select-Object -ExpandProperty count
            If ($ContextVariables_count -gt $ContextVariables_sorted_count) {
                Write-Warning -Message "You cannot convert a set of context variables to a hash table if the names of each variable are not unique."
                Break
            }
            [hashtable]$ContextVariablesTable = @{}
            ForEach ($Variable in $ContextVariables) {
                [string]$variable_name = $Variable.Name
                [string]$variable_value = $Variable.Value
                [string]$variable_previewValue = $Variable.previewValue
                If ($variable_previewValue.Length -gt $variable_value.Length) {
                    [string]$variable_value = $Variable.previewValue
                }
                $Error.Clear()
                Try {
                    $ContextVariablesTable.Add($variable_name, $variable_value)
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to add the variable [$variable_name] to the outgoing hashtable due to [$Message]"
                    Break
                }
            }
            If ($ContextVariablesTable.Keys.Count -gt 0) {
                Return $ContextVariablesTable
            }
        }
        Else {
            $ContextVariablesArray = ForEach ($Variable in $ContextVariables) {
                [string]$variable_name = $Variable.Name
                [string]$variable_value = $Variable.Value
                [string]$variable_previewValue = $Variable.previewValue
                If ($variable_previewValue.Length -gt $variable_value.Length) {
                    [string]$variable_value = $Variable.previewValue
                }
                [PSCustomObject]@{"$variable_name" = "$variable_value"; }
            }
            If ($ContextVariablesArray.Count -gt 0) {
                [hashtable]$parameters = @{}
                If ($AsJsonString -eq $true) {
                    $parameters.Add('Compress', $true)
                    $Error.Clear()
                    Try {
                        [string]$ContextVariablesJsonString = $ContextVariablesArray | ConvertTo-Json @parameters
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "ConvertTo-Json failed to convert the Context Variables due to [$Message]"
                        Break
                    }
                    Return $ContextVariablesJsonString
                }
                ElseIf ($AsCSV -eq $true) {
                    [hashtable]$parameters = @{}
                    $parameters.Add('Delimiter', $csv_delimiter)
                    If ($PSVersionTable.PSVersion.Major -eq 7) {
                        $parameters.Add('UseQuotes', 'AsNeeded')
                    }
                    Else {
                        $parameters.Add('NoTypeInformation', $true)
                    }
                    $Error.Clear()
                    Try {
                        $ContextVariablesCSV = $ContextVariablesArray | ConvertTo-CSV @parameters
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "ConvertTo-CSV failed to convert the Context Variables due to [$Message]"
                        Break
                    }
                    Return $ContextVariablesCSV
                }
                ElseIf ($AsXML -eq $true) {
                    $parameters.Add('As', $xml_type)
                    $Error.Clear()
                    Try {
                        $ContextVariablesXML = $ContextVariablesArray | ConvertTo-XML @parameters
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "ConvertTo-XML failed to convert the Context Variables due to [$Message]"
                        Break
                    }
                    Return $ContextVariablesXML
                }
                Else {
                    Write-Warning -Message "Somehow there was no decision made under ConvertFrom-AutomateNOWContextVariable"
                }
            }
        }
    }
}

#endregion

#Region - Dashboards

Function Get-AutomateNOWDashboard {
    <#
    .SYNOPSIS
    Gets the Dashboards from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Dashboards from an AutomateNOW! instance

    .PARAMETER Id
    The Id of the Dashboard. Use this when you only want to retrieve a single Dashboard. This parameter cannot be combined with others.

    .PARAMETER startRow
    Integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER sortBy
    Optional string parameter to sort the results by. Valid choices are: 'id'*, 'title', 'dateCreated', 'lastUpdated', 'sortOrder'

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .PARAMETER Folder
    Optional string to filter by a particular Folder

    .PARAMETER Tags
    Optional string array of Tags to filter by. Note that the 'containsAny' operator will be used.

    .INPUTS
    Accepts a string representing the simple id of the Dashboard object from the pipeline or individually (but not an array) or you can specify by start and end rows.

    .OUTPUTS
    An array of one or more [ANOWSecRole] class objects

    .EXAMPLE
    Gets the first page of Dashboards
    Get-AutomateNOWDashboard

    .EXAMPLE
    Gets a specific Dashboard named 'Dashboard1'
    Get-AutomateNOWDashboard -Id 'Dashboard1'

    .EXAMPLE
    Gets a series of Dashboards using the pipeline

    'Dashboard1', 'Dashboard2' | Get-AutomateNOWDashboard

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWDashboard[]])]
    [Cmdletbinding( DefaultParameterSetName = 'Default' )]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $False, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100,
        [ValidateSet('id', 'title', 'dateCreated', 'lastUpdated', 'sortOrder', IgnoreCase = $false)]
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$sortBy = 'id',
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$Descending,
        [Parameter(Mandatory = $False)]
        [string]$Folder,
        [Parameter(Mandatory = $False)]
        [string[]]$Tags
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 -or $Id.Length -gt 0) {
            If ($_.Length -gt 0 ) {
                $Body.'id' = $_
            }
            Else {
                $Body.'id' = $Id
            }
            [string]$textMatchStyle = 'exactCase'
            $Body.'_operationId' = 'read'
        }
        Else {
            $Body.Add('operator', 'or')
            $Body.Add('_constructor', 'AdvancedCriteria')
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
            If ($Folder.Length -gt 0) {
                $Body.'criteria1' = ('{"fieldName":"folder","operator":"equals","value":"' + $Folder + '"}')
            }
            If ($Tags.Count -gt 0) {
                If ($Tags.Count -gt 1) {
                    $Error.Clear()
                    Try {
                        [string]$TagString = $Tags | ConvertTo-Json -Compress
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "ConvertTo-Json failed to convert the provided tag names under Get-AutomateNOWDashboard due to [$Message]."
                        Break
                    }
                }
                Else {
                    [string]$TagString = $Tags
                }
                $Body.'criteria2' = ('{"fieldName":"tags","operator":"containsAny","value":' + $TagString + '}')
            }
            If ($Descending -eq $true) {
                $Body.Add('_sortBy', ('-' + $sortBy))
            }
            Else {
                $Body.Add('_sortBy', $sortBy)
            }
            [string]$textMatchStyle = 'substring'
            $Body.'_componentId' = 'DashboardList'
        }
        $Body.'_textMatchStyle' = $textMatchStyle
        $Body.'_dataSource' = 'DashboardDataSource'
        $Body.'_operationType' = 'fetch'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/dashboard/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] while running Get-AutomateNOWDashboard due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWDashboard[]]$Dashboards = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWDashboard] objects due to [$Message]."
            Break
        }
        If ($Dashboards.Count -gt 0) {
            Return $Dashboards
        }
    }
    End {

    }
}

Function Set-AutomateNOWDashboard {
    <#
    .SYNOPSIS
    Changes the settings of a Dashboard on an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of a Dashboard on an AutomateNOW! instance

    .PARAMETER Dashboard
    An [ANOWDashboard] object representing the Dashboard to be changed.

    .PARAMETER Title
    The "Title" of the dashboard. This string may not exceed 32 characters.

    .PARAMETER NumberOfRows
    Optional int32 to specify the number of rows in the dashboard. This number must be 1 or higher.

    .PARAMETER iconSet
    The name of the icon library (if you choose to use one). Possible choices are: FAT_COW, FUGUE (note that FONT_AWESOME is not an actual icon library)

    .PARAMETER iconCode
    The name of the icon which matches the chosen library. Must be lower-case. To see the list of available iconCodes, use Import-AutomateNOWIcon (or Import-AutomateNOWLocalIcon) then try $anow_assets.icon_library."FUGUE"[0..10] to see the names of the first 10 icons from the Fugue library.

    .PARAMETER RemoveIcon
    Switch parameter that will remove the icon configured for this Dashboard.

    .PARAMETER Folder
    (This parameter does not presently work!) String that specifies the name of the folder to place the Dashboard into.

    .PARAMETER UnsetFolder
    (This parameter does not presently work!) Switch parameter that will remove the Dashboard from its current folder.

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new Dashboard.

    .PARAMETER UnsetTags
    Switch parameter that will remove the tags from the Dashboard.

    .PARAMETER Description
    A text description of at least 1 character. Note that the description property is not currently exposed in the ANOW application.

    .PARAMETER UnsetDescription
    Switch parameter that will remove the description.

    .PARAMETER CodeRepository
    Optional Code Repository to place the Dashboard into. Use Get-AutomateNOWCodeRepository to fetch this object.

    .PARAMETER UnsetCodeRepository
    Switch parameter that will remove the the Dashboard from its Code Repository.

    .PARAMETER PublicDashboard
    Boolean parameter to modify the "Public" status of the Dashboard.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Switch parameter that silences the output of the updated object.

    .INPUTS
    ONLY [ANOWDashboard] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWDashboard] object will be returned

    .EXAMPLE
    Forcibly changes the Title of a dashboard named 'Dashboard1' (one-liner format)
    Get-AutomateNOWDashboard -Id 'Dashboard1' | Set-AutomateNOWDashboard -Title 'Dashboard Title' -Force

    .EXAMPLE
    Quietly changes the number of rows and the icon for a Dashboard named 'Dashboard1' (multi-line format)

    $dashboard = Get-AutomateNOWDashboard -Id 'Dashboard1'
    Import-AutomateNOWLocalIcon
    $dashboard | Set-AutomateNOWDashboard -NumberOfRows 5 -iconSet FAT_COW -iconCode 'accordion' -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The -iconSet and -iconCode parameter set requires that you import the local icon names with Import-AutomateNOWIcon or Import-AutomateNOWLocalIcon. This is only to check that the name of the icon being sent to the API is valid.

    If you have three tags on a Dashboard and wanted to remove one then use the -SetTags parameter to apply the 2 that you want to keep. If you want to remove all tags then use -UnsetTags.

    Although the Description can be set, at the time of this writing, it is not actually exposed anywhere within the ANOW application.

    #>
    [OutputType([ANOWDashboard])]
    [Cmdletbinding(SupportsShouldProcess, DefaultParameterSetName = 'Default', ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'Default', ValueFromPipeline = $true)]
        [Parameter(Mandatory = $true, ParameterSetName = 'Icon', ValueFromPipeline = $true)]
        [ANOWDashboard]$Dashboard,
        [ValidateScript({ $_.length -le 32 })]
        [Parameter(Mandatory = $false, ParameterSetName = 'Default', HelpMessage = "Enter a descriptive string between 1 and 32 characters in length. UTF8 characters are not accepted.")]
        [Parameter(Mandatory = $false, ParameterSetName = 'Icon', HelpMessage = "Enter a descriptive string between 1 and 32 characters in length. UTF8 characters are not accepted.")]
        [string]$Title,
        [ValidateScript({ $_ -gt 0 })]
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Icon')]
        [int32]$NumberOfRows,
        [Parameter(Mandatory = $true, ParameterSetName = 'Icon')]
        [ANOWIcon_IconsOnly]$iconSet,
        [ValidateScript({ $_ -match '^[a-z0-9-_]{1,}$' })]
        [Parameter(Mandatory = $true, ParameterSetName = 'Icon')]
        [string]$iconCode,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$RemoveIcon,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Icon')]
        [string]$Folder,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Icon')]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Icon')]
        [string[]]$Tags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Icon')]
        [switch]$UnsetTags,
        [ValidateScript({ $_.Length -le 255 })]
        [Parameter(Mandatory = $false, ParameterSetName = 'Default', HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [Parameter(Mandatory = $false, ParameterSetName = 'Icon', HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [string]$Description,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Icon')]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetCodeRepository,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Icon')]
        [Nullable[boolean]]$PublicDashboard,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Icon')]
        [switch]$Quiet,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Icon')]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($iconSet.length -gt 0 ) {
            If ($anow_assets.icon_library.length -eq 0) {
                Write-Warning -Message "Please import the ANOW icons into your session with Import-AutomateNOWIcon or Import-AutomateNOWLocalIcon"
                Break
            }
            If ($iconCode -notin ($anow_assets.icon_library."$iconSet")) {
                Write-Warning -Message "The icon [$iconCode] does not appear to exist within the [$iconSet] icon set. Please check again."
                Break
            }
        }
        If (($RemoveIcon -eq $true) -and ($iconCode.Length -gt 0 -or $iconSet.Length -gt 0)) {
            Write-Warning -Message "You cannot unset the Icon and set it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot unset the Description and set it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot unset the Folder and set it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot unset the Tags and set them at the same time. Please choose one or the other."
            Break
        }
        If ($iconCode.Length -gt 0 -and $iconSet.Length -eq 0) {
            Write-Warning -Message "You must include the -iconSet when specifying an -iconCode"
            Break
        }
        ElseIf ($iconCode.Length -eq 0 -and $iconSet.Length -gt 0) {
            Write-Warning -Message "You must include the -iconCode when specifying an -iconSet"
            Break
        }
        If ($UnsetCodeRepository -eq $true -and $CodeRepository.Id.Length -gt 0) {
            Write-Warning -Message "You cannot unset the Code Repository and set it at the same time. Please choose one or the other."
            Break
        }
        [string]$command = '/dashboard/update'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWDashboard]$Dashboard = $_
        }
        [string]$Dashboard_id = $Dashboard.id
        If ($null -eq $Dashboard.dashboardDefinition) {
            [PSCustomObject]$dashboardDefinition = [PSCustomObject]@{}
            Write-Verbose -Message "$Dashboard_id did not have a definition yet. Creating one now..."
        }
        Else {
            [PSCustomObject]$dashboardDefinition = $Dashboard.dashboardDefinition
            $Error.Clear()
            Try {
                [string]$dashboardDefinitionJSON = $dashboardDefinition | ConvertTo-Json -Compress
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "ConvertTo-JSON somehow failed to convert the Dashboard definition from $Dashboard_id due to [$Message]."
                Break
            }
            Write-Verbose -Message "Dashboard definition from $Dashboard_id : $dashboardDefinitionJSON"
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$Dashboard_id")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$Dashboard_exists = ($null -eq (Get-AutomateNOWDashboard -Id $Dashboard_id))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWDashboard failed to check if the Dashboard [$Dashboard_id] already existed due to [$Message]."
                Break
            }
            If ($Dashboard_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not a Dashboard named [$Dashboard_id] in the current domain [$current_domain]. Please check into this."
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $Dashboard_id
            If ($dashboardDefinition.numColumns.Count -gt 0) {
                [int32]$CurrentNumberOfRows = $dashboardDefinition.numColumns | Measure-Object | Select-Object -ExpandProperty Count # This is not a typo. The ANOW product mistakenly refers to the number of rows as numColumns.
            }
            Else {
                [int32]$CurrentNumberOfRows = 2 # 2 is the default number of rows (i.e. "columns") for a newly created dashboard after its definition has been created.
            }
            If ($CurrentNumberOfRows -eq 0) {
                Write-Warning -Message "Somehow could not extract the number of rows from the definition of the provided Dashboard $Dashboard_id"
                Break
            }
            If ($NumberOfRows -gt 0) {
                If ($CurrentNumberOfRows -eq $NumberOfRows) {
                    Write-Warning -Message "$Dashboard_id already has $NumberOfRows number of rows. Please do not use the -NumberOfRows parameter unless you intend to change it from its current value."
                    Break
                }
                If ($null -eq $dashboardDefinition.numColumns) {
                    $dashboardDefinition | Add-Member -MemberType NoteProperty -Name 'numColumns' -Value $NumberOfRows
                }
                Else {
                    $dashboardDefinition.numColumns = $NumberOfRows
                }
            }
            $Error.Clear()
            Try {
                [string]$dashboardDefinitionJSON = $dashboardDefinition | ConvertTo-Json -Compress
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "ConvertTo-Json failed to convert the updated definition for $Dashboard_id under Set-AutomateNOWDashboard due to [$message]"
                Break
            }
            $BodyMetaData.'dashboardDefinition' = $dashboardDefinitionJSON
            If ($Description.Length -gt 0) {
                $BodyMetaData.'description' = $Description
            }
            ElseIf ($UnsetDescription -eq $true) {
                $BodyMetaData.'description' = $null
            }

            If ($iconCode.Length -gt 0) {
                $BodyMetaData.'iconCode' = $iconCode
                $BodyMetaData.'iconSet' = $iconSet
            }
            ElseIf ($RemoveIcon -eq $true) {
                $BodyMetaData.'iconSet' = $null
                $BodyMetaData.'iconCode' = $null
                $BodyMetaData.'fugueIcon' = $null
                $BodyMetaData.'fatCowIcon' = $null
            }
            If ($Tags.Count -gt 0) {
                [int32]$total_tags = $Tags.Count
                [int32]$current_tag = 1
                ForEach ($tag_id in $Tags) {
                    $Error.Clear()
                    Try {
                        [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] under Set-AutomateNOWDashboard due to [$message]"
                        Break
                    }
                    If ($tag_object.simpleId.length -eq 0) {
                        Throw "Set-AutomateNOWDashboard has detected that the tag [$tag_id] does not appear to exist. Please check again."
                        Break
                    }
                    ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                        [string]$tag_object_simpleId = $tag_object.simpleId
                        Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                        Break
                    }
                    [string]$tag_display = $tag_object | ConvertTo-Json -Compress
                    Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
                    [string]$tag_name_sequence = ('tags' + $current_tag)
                    $BodyMetaData.$tag_name_sequence = $tag_id
                    $current_tag++
                }
            }
            ElseIf ($UnsetTags -eq $true) {
                $BodyMetaData.'tags' = $null
            }
            If ($Folder.Length -gt 0) {
                $Error.Clear()
                Try {
                    [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] actually existed under Set-AutomateNOWDashboard due to [$Message]"
                    Break
                }
                If ($folder_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] under Set-AutomateNOWDashboard. Please check again."
                    Break
                }
                [string]$folder_display = $folder_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Adding folder $folder_display to [ANOWDashboard] [$Id]"
                $BodyMetaData.'folder' = $Folder
            }
            ElseIf ($UnsetFolder -eq $true) {
                $BodyMetaData.'folder' = $null
            }
            If ($CodeRepository.Id.Length -gt 0) {
                [string]$CodeRepository_Id = $CodeRepository.Id
                $Error.Clear()
                Try {
                    [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository_Id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository_Id] actually existed under Set-AutomateNOWDashboard due to [$Message]"
                    Break
                }
                If ($code_repository_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository_Id] under Set-AutomateNOWDashboard. Please check again."
                    Break
                }
                $BodyMetaData.'codeRepository' = $CodeRepository_Id
            }
            ElseIf ($UnsetCodeRepository -eq $true) {
                $BodyMetaData.'codeRepository' = $null
            }
            If ($Title.Length -gt 0) {
                $BodyMetaData.'title' = $Title
            }
            Else {
                If ($Dashboard.title.Length -gt 0) {
                    [string]$Title = $Dashboard.title
                    $BodyMetaData.'title' = $Title
                }
            }
            If ($PublicDashboard -eq $true -and $Dashboard.publicDashboard -eq $false) {
                $BodyMetaData.'publicDashboard' = 'true'
            }
            ElseIf ($PublicDashboard -eq $false -and $Dashboard.publicDashboard -eq $true) {
                $BodyMetaData.'publicDashboard' = 'false'
            }
            [string]$oldValues = $Dashboard.CreateOldValues()
            $BodyMetaData.'_oldValues' = $oldValues
            $BodyMetaData.'_operationType' = 'update'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_componentId' = 'isc_InfiniteDashboardEditor_0_dashboardEditor'
            $BodyMetaData.'_dataSource' = 'DashboardDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Dashboard_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            $Error.Clear()
            Try {
                [ANOWDashboard]$UpdatedDashboard = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Somehow was not able to parse the response from Set-AutomateNOWDashboard into an [ANOWDashboard] object due to [$Message]."
                Break
            }
            Write-Verbose -Message "Dashboard $Dashboard_id was successfully updated"
            If ($Quiet -ne $true) {
                Return $UpdatedDashboard
            }
        }
    }
    End {
    }
}

Function New-AutomateNOWDashboard {
    <#
    .SYNOPSIS
    Creates a Dashboard within an AutomateNOW! instance

    .DESCRIPTION
    Creates a Dashboard within an AutomateNOW! instance and returns back the newly created [ANOWDashboard] object

    .PARAMETER Id
    The intended unique Id of the Dashboard. For example: 'Dashboard1'. This value may not contain the domain in brackets.

    .PARAMETER Title
    The intended "Title" of the Dashboard. This is a display name which does not need to be unique and may not exceed 32 characters in length.

    .PARAMETER Description
    Optional description of the Dashboard (may not exceed 255 characters).

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new Dashboard.

    .PARAMETER Folder
    Optional name of the folder to place the Dashboard into.

    .PARAMETER iconSet
    Mandatory string representing a choice between three icon sets. Valid choices are: FAT_COW, FUGUE, FONT_AWESOME

    .PARAMETER iconCode
    The name of the icon which matches the chosen library. Must be lower-case.

    .PARAMETER CodeRepository
    Optional name of the code repository to place the Dashboard into.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWDashboard.

    .OUTPUTS
    An [ANOWDashboard] object representing the newly created Dashboard

    .EXAMPLE
    New-AutomateNOWDashboard -Id 'Dashboard1' -Description 'Dashboard1 description' -Tags 'Tag1', 'Tag2' -Folder 'Folder1' -iconSet 'FAT_COW' -iconCode 'paper_airplane' -codeRepository 'Repository1'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The name (id) of the Dashboard must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    The names of the icon is not enforced here! If you want to know the names of the available icons try running Import-AutomateNOWLocalIcon then review the $anow_assets.icon_library global variable.

    #>
    [OutputType([ANOWDashboard])]
    [Cmdletbinding(DefaultParameterSetName = 'Default')]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $true, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $true, ParameterSetName = 'iconSet')]
        [string]$Id,
        [ValidateScript({ $_.length -le 32 })]
        [Parameter(Mandatory = $true, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $true, ParameterSetName = 'iconSet')]
        [string]$Title,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'iconSet', HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'iconSet')]
        [string[]]$Tags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'iconSet')]
        [string]$Folder,
        [Parameter(Mandatory = $true, ParameterSetName = 'iconSet')]
        [ANOWIcon_IconsOnly]$iconSet,
        [ValidateScript({ $_ -match '^[a-z0-9-_]{1,}$' })]
        [Parameter(Mandatory = $true, ParameterSetName = 'iconSet')]
        [string]$iconCode,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'iconSet')]
        [string]$CodeRepository,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'iconSet')]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [boolean]$Dashboard_exists = ($null -ne (Get-AutomateNOWDashboard -Id $Id))
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWDashboard failed to check if the Dashboard [$Id] already existed due to [$Message]."
        Break
    }
    If ($Dashboard_exists -eq $true) {
        [string]$current_domain = $anow_session.header.domain
        Write-Warning -Message "There is already a Dashboard with the Id [$Id] in [$current_domain]. Please check into this."
        Break
    }
    ## End warning ##
    [System.Collections.Specialized.OrderedDictionary]$ANOWDashboard = [System.Collections.Specialized.OrderedDictionary]@{}
    $ANOWDashboard.Add('id', $Id)
    $ANOWDashboard.Add('title', $Title)
    If ($Description.Length -gt 0) {
        $ANOWDashboard.Add('description', $Description)
    }
    If ($Tags.Count -gt 0) {
        [int32]$total_tags = $Tags.Count
        [int32]$current_tag = 1
        ForEach ($tag_id in $Tags) {
            $Error.Clear()
            Try {
                [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] under New-AutomateNOWDashboard due to [$message]"
                Break
            }
            If ($tag_object.simpleId.length -eq 0) {
                Throw "New-AutomateNOWDashboard has detected that the tag [$tag_id] does not appear to exist. Please check again."
                Break
            }
            ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                [string]$tag_object_simpleId = $tag_object.simpleId
                Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                Break
            }
            [string]$tag_display = $tag_object | ConvertTo-Json -Compress
            Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
            [string]$tag_name_sequence = ('tags' + $current_tag)
            $ANOWDashboard.Add($tag_name_sequence, $tag_id)
            $include_properties += $tag_name_sequence
            $current_tag++
        }
    }
    If ($Folder.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] actually existed under New-AutomateNOWDashboard due to [$Message]"
            Break
        }
        If ($folder_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] under New-AutomateNOWDashboard. Please check again."
            Break
        }
        [string]$folder_display = $folder_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding folder $folder_display to [ANOWDashboard] [$Id]"
        $ANOWDashboard.Add('folder', $Folder)
        $include_properties += 'folder'
    }
    If ($CodeRepository.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository] actually existed under New-AutomateNOWDashboard due to [$Message]"
            Break
        }
        If ($code_repository_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository] under New-AutomateNOWDashboard. Please check again."
            Break
        }
        [string]$code_repository_display = $code_repository_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding code repository $code_repository_display to [ANOWDashboard] [$Id]"
        $ANOWDashboard.Add('codeRepository', $CodeRepository)
        $include_properties += 'codeRepository'
    }
    If ($iconSet.Length -gt 0) {
        $ANOWDashboard.'iconSet' = $iconSet
    }
    If ($iconCode.Length -gt 0) {
        $ANOWDashboard.'iconCode' = $iconCode
    }
    [string]$BodyObject = ConvertTo-QueryString -InputObject $ANOWDashboard
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    $BodyMetaData.'_operationType' = 'add'
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_oldValues' = '{"publicDashboard":false}'
    $BodyMetaData.'_componentId' = 'DashboardCreateWindow_form'
    $BodyMetaData.'_dataSource' = 'DashboardDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$BodyMetaDataString = ConvertTo-QueryString -InputObject $BodyMetaData
    [string]$Body = ($BodyObject + '&' + $BodyMetaDataString)
    [string]$command = '/dashboard/create'
    [hashtable]$parameters = @{}
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('Body', $Body)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWDashboard]$Dashboard = $results.response.data | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to create a new [ANOWDashboard] object due to [$Message]."
        Break
    }
    If ($Dashboard.id.Length -eq 0) {
        Write-Warning -Message "Somehow the newly created [ANOWDashboard] object is empty!"
        Break
    }
    # Modify phase
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    [string]$oldValues = $Dashboard.CreateOldValues()
    $BodyMetaData.'id' = $Dashboard.id
    $BodyMetaData.'dashboardDefinition' = '{"numColumns":2,"colWidths":["*","*","*","*","*","*","*","*","*","*"],"portlets":[]}'
    $BodyMetaData.'_operationType' = 'update'
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_oldValues' = $oldValues
    $BodyMetaData.'_componentId' = 'isc_InfiniteDashboardEditor_0_dashboardEditor'
    $BodyMetaData.'_dataSource' = 'DashboardDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$BodyMetaDataString = ConvertTo-QueryString -InputObject $BodyMetaData
    [string]$Body = ($BodyMetaDataString)
    [string]$command = '/dashboard/update'
    [hashtable]$parameters = @{}
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('Body', $Body)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWDashboard]$Dashboard = $results.response.data | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to finish modifying the newly created [ANOWDashboard] object due to [$Message]."
        Break
    }
    If ($Dashboard.id.Length -eq 0) {
        Write-Warning -Message "Somehow the newly created [ANOWDashboard] object (after being modified) is empty!"
        Break
    }
    If ($Quiet -ne $true) {
        Return $Dashboard
    }
}

Function Remove-AutomateNOWDashboard {
    <#
    .SYNOPSIS
    Removes a Dashboard from an AutomateNOW! instance

    .DESCRIPTION
    Removes a Dashboard from an AutomateNOW! instance

    .Parameter Dashboard
    Mandatory [ANOWDashboard] object representing the Dashboard that is being removed. Use Get-AutomateNOWDashboard to retrieve them.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    You must present a [ANOWDashboard] object to the -Dashboard parameter (or to the pipeline).

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Forcibly removes a dashboard named 'Dashboard1' (one-liner format)

    Get-AutomateNOWDashboard -Id 'Dashboard1' | Remove-AutomateNOWDashboard -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWDashboard]$Dashboard,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/dashboard/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWDashboard]$Dashboard = $_
        }
        [string]$Dashboard_id = $Dashboard.Id
        If ($Dashboard_id.Length -eq 0) {
            Write-Warning -Message "Somehow an empty Id was passed to this function (Remove-AutomateNOWDashboard). Please look into this."
            Break
        }
        Else {
            Write-Verbose -Message "Received [$Dashboard_id] for the Id of the Dashboard Item to be removed"
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Dashboard_id)")) -eq $true) {
            [string]$old_values = $Dashboard.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $Dashboard_id )
            $BodyMetaData.Add('_oldValues', $old_values )
            $BodyMetaData.Add('_operationType', 'remove')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_componentId', 'DashboardList')
            $BodyMetaData.Add('_dataSource', 'DashboardDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Dashboard_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Dashboard $Dashboard_id was removed"
        }
    }
    End {

    }
}

Function Export-AutomateNOWDashboard {
    <#
    .SYNOPSIS
    Exports the Dashboards from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Dashboards from an instance of AutomateNOW! to a local .csv file

    .PARAMETER Dashboard
    Mandatory [ANOWDashboard] object (Use Get-AutomateNOWDashboard to retrieve them)

    .INPUTS
    ONLY [ANOWDashboard] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWDashboard] objects are exported to the local disk in CSV format

    .EXAMPLE
    Get-AutomateNOWDashboard | Export-AutomateNOWDashboard

    .EXAMPLE
    Get-AutomateNOWDashboard -Id 'Dashboard01' | Export-AutomateNOWDashboard

    .EXAMPLE
    'Dashboard01', 'Dashboard02' | Get-AutomateNOWDashboard | Export-AutomateNOWDashboard

    .NOTES
	You must present [ANOWDashboard] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWDashboard]$Dashboard
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-Dashboards-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWDashboard]$Dashboard = $_
        }
        $Error.Clear()
        Try {
            $Dashboard | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWDashboard] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function Copy-AutomateNOWDashboard {
    <#
    .SYNOPSIS
    Copies a Dashboard from an AutomateNOW! instance

    .DESCRIPTION
    Copies a Dashboard from an AutomateNOW! instance. AutomateNOW object id can never be changed, but we can copy the object to a new id and it will include all of the items therein.

    .PARAMETER Dashboard
    Mandatory [ANOWDashboard] object to be copied.

    .PARAMETER NewId
    The name (Id) of the new Dashboard. The new Id must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen (128 character maximum)

    .PARAMETER Title
    An optional different Title for the newly copied Dashboard (255 character maximum). If omitted, the title from the source Dashboard will be used.

    .PARAMETER UnsetDescription
    Optional switch that will ensure that the newly created Dashboard will not have a description set.

    .PARAMETER Description
    Optional description to set on the new Dashboard object. If you do not set this, the new Dashboard object will copy the Description of the source object.

    .PARAMETER UnsetFolder
    Optional switch that will ensure that the newly created Dashboard will not have a Folder set.

    .PARAMETER Folder
    Optional description to set a different folder on the new Dashboard object. If you do not set this, the new Dashboard object will use the same Folder of the source object.

    .PARAMETER UnsetTags
    Optional switch that will ensure that the newly created Dashboard will not have any Tags set.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the new Dashboard object. If you do not set this, the new Dashboard object will apply the same Tags of the source object.

    .PARAMETER Force
    Force the copy without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    ONLY an [ANOWDashboard] object is accepted. Pipeline support is intentionally unavailable.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Creates a copy of a Dashboard named 'Dashboard1' to 'Dashboard2' and changes the description of the new Dashboard (multi-line format)

    $Dashboard1 = Get-AutomateNOWDashboard -Id 'Dashboard1'
    Copy-AutomateNOWDashboard -Dashboard $Dashboard1 -NewId 'Dashboard2' -Description 'This is Dashboard2'

    .EXAMPLE
    Creates a copy of a Dashboard named 'Dashboard1' to 'Dashboard2' and removes the description while adding two tags to the new Dashboard (multi-line format)

    $Dashboard1 = Get-AutomateNOWDashboard -Id 'Dashboard1'
    Copy-AutomateNOWDashboard -Dashboard (Get-AutomateNOWDashboard -Id 'Dashboard1') -NewId 'Dashboard2' -UnsetDescription -Tags 'Tag1', 'Tag2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWDashboard]$Dashboard,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,128}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.length -le 32 })]
        [string]$Title,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot set the Tags and unset them at the same time. Please choose one or the other. Tags from the source object will be carried over to the new object if you do not specify any tag-related parameters."
            Break
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$Dashboard_exists = ($null -ne (Get-AutomateNOWDashboard -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWDashboard failed to check if the Dashboard [$NewId] already existed due to [$Message]."
            Break
        }
        If ($Dashboard_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Dashboard named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End warning ##
        [string]$command = '/dashboard/copy'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            [string]$Dashboard_oldId = $Dashboard.id
            [string]$Dashboard_simpleId = $Dashboard.simpleId
            If ($Dashboard_oldId -eq $NewId) {
                Write-Warning -Message "The new id cannot be the same as the old id."
                Break
            }
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Copy the Dashboard $($Dashboard_simpleId) to $($NewId)?")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                If ($UnsetFolder -eq $True) {
                    $BodyMetaData.'folder' = $Null
                }
                ElseIf ($Folder.Length -gt 0) {
                    $BodyMetaData.'folder' = $Folder
                }
                Else {
                    If ($Dashboard.folder.Length -gt 0) {
                        $BodyMetaData.'folder' = $Dashboard.folder
                    }
                }
                If ($Tags.Count -gt 0) {
                    [int32]$tag_count = 1
                    ForEach ($tag in $Tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
                ElseIf ($UnsetTags -eq $true) {
                    $BodyMetaData.'tags' = $Null
                }
                Else {
                    If ($Dashboard.Tags -gt 0) {
                        [int32]$tag_count = 1
                        ForEach ($tag in $Dashboard.tags) {
                            $BodyMetaData.('tags' + $tag_count ) = $tag
                            $tag_count++
                        }
                    }
                }
                $BodyMetaData.'oldId' = $Dashboard_oldId
                $BodyMetaData.'domain' = $Dashboard.domain
                $BodyMetaData.'id' = $NewId
                If ($UnsetDescription -ne $true) {
                    If ($Description.Length -gt 0) {
                        $BodyMetaData.'description' = $Description
                    }
                    Else {
                        $BodyMetaData.'description' = $Dashboard.description
                    }
                }
                If ($Title.Length -eq 0) {
                    [string]$Title = $Dashboard.title
                }
                $BodyMetaData.'title' = $Title
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_operationId' = 'copy'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_dataSource' = 'DashboardDataSource'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties oldId, domain, NewId, description, folder, tags
                $parameters.Body = $Body
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Dashboard_oldId] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                $Error.Clear()
                Try {
                    [ANOWDashboard]$NewDashboard = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to create copied [ANOWDashboard] object [$NewId] due to [$Message]."
                    Break
                }
                If ($NewDashboard.id.Length -eq 0) {
                    Write-Warning -Message "Somehow the newly created (copied) [ANOWDashboard] object [$NewId] is empty!"
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $NewDashboard
                }
            }
        }
    }
    End {

    }
}

Function Rename-AutomateNOWDashboard {
    <#
    .SYNOPSIS
    Renames a Dashboard on an AutomateNOW! instance

    .DESCRIPTION
    Performs a psuedo-rename operations of a Dashboard from an AutomateNOW! instance by copying it first and then deleting the source. This function merely combines Copy-AutomateNOWDashboard and Remove-AutomateNOWDashboard therefore it is to be considered destructive.

    .PARAMETER Dashboard
    An [ANOWDashboard] object representing the Dashboard to be renamed.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the Dashboard. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER Force
    Force the renaming without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly renamed object.

    .INPUTS
    ONLY [ANOWDashboard] objects are accepted. There is intentionally no support for the pipeline.

    .OUTPUTS
    The newly renamed [ANOWDashboard] object will be returned.

    .EXAMPLE
    Renames a Dashboard named 'Dashboard1' to 'Dashboard2' (multi-line format)

    $Dashboard = Get-AutomateNOWDashboard -Id 'Dashboard1'
    Rename-AutomateNOWDashboard -Dashboard $Dashboard -NewId 'Dashboard2'

    .EXAMPLE
    Forcibly and quietly renames a Dashboard named 'Dashboard1' to 'Dashboard2' (one-liner format)

    Rename-AutomateNOWDashboard -Dashboard (Get-AutomateNOWDashboard -Id 'Dashboard1') -NewId 'Dashboard2' -Force -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    When renaming, you may only specify a different Id (name).

    #>
    [OutputType([ANOWDashboard])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWDashboard]$Dashboard,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin standard warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$new_Dashboard_exists = ($null -ne (Get-AutomateNOWDashboard -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWDashboard failed to check if the Dashboard [$NewId] already existed due to [$Message]."
            Break
        }
        If ($new_Dashboard_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Dashboard named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        #[string]$Dashboard_id = $Dashboard.id
        [string]$Dashboard_id = $Dashboard.simpleId
        $Error.Clear()
        Try {
            [boolean]$old_Dashboard_exists = ($null -ne (Get-AutomateNOWDashboard -Id $Dashboard_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWDashboard failed to check if the Dashboard [$Dashboard_id] already existed due to [$Message]."
            Break
        }
        If ($old_Dashboard_exists -eq $false) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not a Dashboard named [$Dashboard_id] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End standard warning ##
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Dashboard_id)")) -eq $true) {
                $Error.Clear()
                Try {
                    [ANOWDashboard]$new_Dashboard = Copy-AutomateNOWDashboard -Dashboard $Dashboard -NewId $NewId -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Copy-AutomateNOWDashboard failed to create a new Dashboard [$NewId] as Part 1 of the renaming process due to [$Message]."
                    Break
                }
                If ($new_Dashboard.simpleId -eq $NewId) {
                    Write-Verbose -Message "Part 1: Dashboard [$Dashboard_id] successfully copied to [$NewId]"
                }
                Else {
                    Write-Warning -Message "Somehow the first phase (Copy-AutomateNOWDashboard) failed. Please look into this."
                    Break
                }
                $Error.Clear()
                Try {
                    Remove-AutomateNOWDashboard -Dashboard $Dashboard -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Remove-AutomateNOWDashboard failed to remove [$Dashboard_id] as Part 2 of the renaming process due to [$Message]."
                    Break
                }
                Write-Verbose -Message "Part 2: Dashboard [$Dashboard_id] removed"
                Write-Verbose -Message "Task [$Dashboard_id] successfully renamed to [$NewId]"
                If ($Quiet -ne $true) {
                    Return $Dashboard
                }
            }
        }
        Else {
            Write-Warning -Message "No action was taken because either the source object didn't exist or the new object already existed"
        }
    }
    End {
    }
}

Function Push-AutomateNOWDashboard {
    <#
    .SYNOPSIS
    Moves (pushes) a Dashboard to the top of the list.

    .DESCRIPTION
    Moves (pushes) a Dashboard to the top of the list.

    .PARAMETER Dashboard
    An [ANOWDashboard] object representing the Dashboard to be moved (popped) to the top of the list (stack).

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWDashboard] objects are accepted (including from the pipeline)

    .OUTPUTS
    A verbose information message will be sent indicating success

    .EXAMPLE
    Forcibly pushes a Dashboard named 'Dashboard1' to the top of the list (one-liner format)

    Get-AutomateNOWDashboard -Id 'Dashboard1' | Push-AutomateNOWDashboard -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This function is equivalent to selecting a Dashboard and clicking 'Move Up' until it is at the top.

    This function will reset the sort order of all Dashboards starting from 0

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWDashboard]$Dashboard,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/dashboard/update'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.Id.Length -gt 0) {
            [ANOWDashboard]$Dashboard = $_
        }
        [string]$Dashboard_id = $Dashboard.id
        [string]$Dashboard_title = $Dashboard.title
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("'$($Dashboard_title)' (a.k.a. $($Dashboard_id)) to the top of the sort order?")) -eq $true) {
            $Error.Clear()
            Try {
                [ANOWDashboard[]]$Dashboards = Get-AutomateNOWDashboard -startRow 0 -endRow 10000
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWDashboard failed to parse the response into [ANOWDashboard] objects under Push-AutomateNOWDashboard due to [$Message]."
                Break
            }
            If ($Dashboards.count -eq 0) {
                Write-Warning -Message "Somehow there are no Dashboards at all on this instance. Please look into this."
                Break
            }
            [string]$old_values = $Dashboard.CreateOldValues()
            [PSCustomObject[]]$Dashboard_collection = (@($Dashboard | Select-Object -Property id, title, sortOrder) + @($Dashboards | Sort-Object -Property sortOrder | Where-Object { $_.id -ne $Dashboard_id } | Select-Object -Property id, title, sortOrder))
            [int32]$Dashboard_order_count = $Dashboard_collection.count
            Write-Verbose -Message "Discovered [$Dashboard_order_count] Dashboards"
            [int32]$current_dashboard = 0
            ForEach ($temp_dashboard in $Dashboard_collection) {
                [string]$temp_Dashboard_id = $temp_dashboard.id
                [string]$temp_Dashboard_title = $temp_dashboard.title
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                $BodyMetaData.Add('id', $temp_Dashboard_id )
                $BodyMetaData.Add('sortOrder', $current_dashboard )
                $BodyMetaData.Add('_operationType', 'update')
                $BodyMetaData.Add('_textMatchStyle', 'exact')
                $BodyMetaData.Add('_oldValues', $old_values)
                $BodyMetaData.Add('_componentId', 'DashboardList')
                $BodyMetaData.Add('_dataSource', 'DashboardDataSource')
                $BodyMetaData.Add('isc_metaDataPrefix', '_')
                $BodyMetaData.Add('isc_dataFormat', 'json')
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
                If ($null -eq $parameters.'Body') {
                    $parameters.Add('Body', $Body)
                }
                Else {
                    $parameters.'Body' = $Body
                }
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on ($temp_Dashboard_title / $temp_Dashboard_id) due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                Write-Verbose -Message "Dashboard ($temp_Dashboard_title / $temp_Dashboard_id) was successfully set to sortOrder [$current_dashboard]"
                $current_dashboard++
            }
        }
        Write-Verbose -Message "Dashboard ($Dashboard_title / $Dashboard_id) should now be at the top of the list."
    }
    End {

    }
}

Function Pop-AutomateNOWDashboard {
    <#
    .SYNOPSIS
    Moves (pops) a Dashboard to the bottom of the list.

    .DESCRIPTION
    Moves (pops) a Dashboard to the bottom of the list.

    .PARAMETER Dashboard
    An [ANOWDashboard] object representing the Dashboard to be moved (popped) to the bottom of the list.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWDashboard] objects are accepted (including from the pipeline)

    .OUTPUTS
    A verbose information message will be sent indicating success

    .EXAMPLE
    Forcibly pops a Dashboard named 'Dashboard1' to the bottom of the list (one-liner format)

    Get-AutomateNOWDashboard -Id 'Dashboard1' | Pop-AutomateNOWDashboard -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This function is equivalent to selecting a Dashboard and clicking 'Move Down' until it is at the bottom.

    This function will reset the sort order of all Dashboards starting from 0

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWDashboard]$Dashboard,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/dashboard/update'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.Id.Length -gt 0) {
            [ANOWDashboard]$Dashboard = $_
        }
        [string]$Dashboard_id = $Dashboard.id
        [string]$Dashboard_title = $Dashboard.title
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("'$($Dashboard_title)' (a.k.a. $($Dashboard_id)) to the top of the sort order?")) -eq $true) {
            $Error.Clear()
            Try {
                [ANOWDashboard[]]$Dashboards = Get-AutomateNOWDashboard -startRow 0 -endRow 10000
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWDashboard failed to parse the response into [ANOWDashboard] objects under Push-AutomateNOWDashboard due to [$Message]."
                Break
            }
            If ($Dashboards.count -eq 0) {
                Write-Warning -Message "Somehow there are no Dashboards at all on this instance. Please look into this."
                Break
            }
            [string]$old_values = $Dashboard.CreateOldValues()
            [PSCustomObject[]]$Dashboard_collection = (@($Dashboards | Sort-Object -Property sortOrder | Where-Object { $_.id -ne $Dashboard_id } | Select-Object -Property id, title, sortOrder) + @($Dashboard | Select-Object -Property id, title, sortOrder))
            [int32]$Dashboard_order_count = $Dashboard_collection.count
            Write-Verbose -Message "Discovered [$Dashboard_order_count] Dashboards"
            [int32]$current_dashboard = 0
            ForEach ($temp_dashboard in $Dashboard_collection) {
                [string]$temp_Dashboard_id = $temp_dashboard.id
                [string]$temp_Dashboard_title = $temp_dashboard.title
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                $BodyMetaData.Add('id', $temp_Dashboard_id )
                $BodyMetaData.Add('sortOrder', $current_dashboard )
                $BodyMetaData.Add('_operationType', 'update')
                $BodyMetaData.Add('_textMatchStyle', 'exact')
                $BodyMetaData.Add('_oldValues', $old_values)
                $BodyMetaData.Add('_componentId', 'DashboardList')
                $BodyMetaData.Add('_dataSource', 'DashboardDataSource')
                $BodyMetaData.Add('isc_metaDataPrefix', '_')
                $BodyMetaData.Add('isc_dataFormat', 'json')
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
                If ($null -eq $parameters.'Body') {
                    $parameters.Add('Body', $Body)
                }
                Else {
                    $parameters.'Body' = $Body
                }
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on ($temp_Dashboard_title / $temp_Dashboard_id) due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                Write-Verbose -Message "Dashboard ($temp_Dashboard_title / $temp_Dashboard_id) was successfully set to sortOrder [$current_dashboard]"
                $current_dashboard++
            }
        }
        Write-Verbose -Message "Dashboard ($Dashboard_title / $Dashboard_id) should now be at the bottom of the list."
    }
    End {

    }
}

Function Read-AutomateNOWDashboardPortlet {
    <#
    .SYNOPSIS
    Reads the Dashboard portlets from a Dashboard in an AutomateNOW! instance

    .DESCRIPTION
    Reads the Dashboard portlets from a Dashboard in an AutomateNOW! instance

    .PARAMETER Dashboard
    The [ANOWDashboard] object representing the Dashboard to read the portlets from.

    .PARAMETER Title
    Optional string to filter against the Title of the Dashboard portlet.

    .INPUTS
    ONLY [ANOWDashboard] objects are accepted (including from the pipeline)

    .OUTPUTS
    [ANOWDashboardPortlet] objects will be returned.

    .EXAMPLE
    Gets the Dashboard portlets from a Dashboard named 'Dashboard1'

    Get-AutomateNOWDashboard -Id 'Dashboard1' | Read-AutomateNOWDashboardPortlet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWDashboardPortlet[]])]
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWDashboard]$Dashboard,
        [Parameter(Mandatory = $false)]
        [string]$Title
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWDashboard]$Dashboard = $_
        }
        [string]$Dashboard_Id = $Dashboard.id
        If ($null -eq $Dashboard.dashboardDefinition) {
            Write-Warning -Message "$Dashboard_Id does not have a Dashboard definition yet"
            Break
        }
        [PSCustomObject]$DashboardDefinition = $Dashboard.dashboardDefinition
        If ($DashboardDefinition.portlets.count -eq 0) {
            Write-Warning -Message "$Dashboard_Id does not have any Dashboard portlets yet. Use Add-AutomateNOWDashboardPortlet to add some."
        }
        Else {
            $Error.Clear()
            Try {
                [ANOWDashboardPortlet[]]$portlets = $DashboardDefinition.portlets
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the Dashboard portlets from $Dashboard_Id into [ANOWDashboardPortlet] objects due to [$Message]."
                Break
            }
            If ($Title.Length -gt 0) {
                [ANOWDashboardPortlet[]]$portlets = $portlets | Where-Object { $_.reportOptions.title -eq "$Title" }
            }
            $Error.Clear()
            Try {
                ForEach ($portlet in $portlets) {
                    $portlet.Validate()
                }
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to validate the Dashboard portlets from $Dashboard_Id due to [$Message]."
                Break
            }
            Return $portlets
        }
    }
    End {

    }
}

Function Add-AutomateNOWDashboardPortlet {
    <#
    .SYNOPSIS
    Adds a Dashboard portlet to a Dashboard within an AutomateNOW! instance

    .DESCRIPTION
    Adds a Dashboard portlet to a Dashboard within an AutomateNOW! instance

    .PARAMETER Dashboard
    Mandatory [ANOWDashboard] object. Use Get-AutomateNOWDashboard to get this object.

    .PARAMETER ReportType
    Mandatory type of Dashboard portlet. Valid options are: InfiniteDashboardFailedTaskListReport; InfiniteDashboardExecutingTaskListReport; InfiniteDashboardCompletedTaskListReport; InfiniteDashboardFailedWorkflowListReport; InfiniteDashboardExecutingWorkflowListReport; InfiniteDashboardCompletedWorkflowListReport; InfiniteDashboardSkewedTaskListReport; InfiniteDashboardCriticalTaskListReport; InfiniteProcessingScorecardChart; InfiniteDashboardServerNodeWeightListReport; InfiniteDashboardServerNodeDeviatedListReport; InfiniteDashboardServerNodeDisconnectedListReport; InfiniteServerNodeGaugeChart; InfiniteDashboardOccupiedStockListReport; InfiniteDashboardEngagedLockListReport; InfiniteMetricScatteredChart; InfiniteMetricGaugeChart; InfiniteMetricHistoryBarChart; InfiniteUserReport;

    .PARAMETER rowNum
    Mandatory row number position where the Dashboard portlet will reside.

    .PARAMETER colNum
    Mandatory column number position where the Dashboard portlet will reside.

    .PARAMETER Title
    Optional Title of the Dashboard portlet. If you do not specify this an automatic name will be used. There is seemingly no limit to the length of this property.

    .PARAMETER ProcessingTemplate
    If the ReportType is InfiniteProcessingScorecardChart then a mandatory Processing Template object must be included. Use Get-AutomateNOWTaskTemplate, Get-AutomateNOWWorkflowTemplate, Get-AutomateNOWScheduleTemplate or Get-AutomateNOWServiceManagerTemplate to retrieve these.

    .PARAMETER MonthsAgo
    If the ReportType is InfiniteProcessingScorecardChart then an optional "Months Ago" int32 may be optionally included. The default value is not included is 0.

    .PARAMETER UseDate
    If the ReportType is InfiniteProcessingScorecardChart then an optional date property from the processing template may be chosen. Valid choices are: dateCreated* and timestamp

    .PARAMETER IncludeArchive
    If the ReportType is InfiniteProcessingScorecardChart then this optional switch parameter will include the "Include Archive" checkbox.

    .PARAMETER ServerNode
    If the ReportType is InfiniteServerNodeGaugeChart then this mandatory Server Node object must be included. Use Get-AutomateNOWServerNode to retrieve this.

    .PARAMETER Metric
    If the ReportType is (InfiniteMetricScatteredChart or InfiniteMetricGaugeChart or InfiniteMetricHistoryBarChart) then this mandatory Metric object must be included. Use Get-AutomateNOWMetric to retrieve this.

    .PARAMETER Mode
    If the ReportType is InfiniteMetricHistoryBarChart then this mandatory string sets the "Mode". Valid values are: PERIOD; LAST_N_STATES;

    .PARAMETER ShowStatesFromPeriod
    If the ReportType is InfiniteMetricHistoryBarChart AND the mode is PERIOD then this string sets the "Show States From Period" value. Valid values are: hour, day*, week, month, year

    .PARAMETER ShowLastNStates
    If the ReportType is InfiniteMetricHistoryBarChart AND the mode is LAST_N_STATES then this mandatory int32 sets the "Show Last N States" value. This value must be 1 or greater. The default is 20.

    .PARAMETER AggregationType
    If the ReportType is InfiniteMetricHistoryBarChart then this mandatory string sets the "Aggregation Type". Valid values are: AVG, ?

    .PARAMETER AggregationPeriod
    If the ReportType is InfiniteMetricHistoryBarChart then this mandatory string sets the "Aggregation Period". Valid values are: HOUR, ?

    .PARAMETER UserReport
    If the ReportType is InfiniteUserReport then this mandatory User Report object must be included. Use Get-AutomateNOWUserReport to retrieve this.

    .PARAMETER ShowHeader
    If the ReportType is InfiniteUserReport then this optional switch parameter will include the 'Show Header' checkbox.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object

    .PARAMETER Force
    Force the addition of the object without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    An [ANOWDashboard] object, the type of Item being added and other objects depending on the parameters.

    .OUTPUTS
    An [ANOWDashboardPortlet] object representing the newly created Dashboard portlet

    .EXAMPLE
    Forcefully and quietly sets up an empty Dashboard with a 3x3 grid of various portlets that don't require additional parameters (simple portlets) with automatically chosen names by omitting the Title parameter (multi-line format)

    $dashboard = Get-AutomateNOWDashboard -Id 'Dashboard1'
    Add-AutomateNOWDashboardPortlet -Dashboard $dashboard -rowNum 1 -colNum 1 -reportType InfiniteDashboardFailedTaskListReport -Force -Quiet
    Add-AutomateNOWDashboardPortlet -Dashboard $dashboard -rowNum 2 -colNum 1 -reportType InfiniteDashboardCompletedTaskListReport -Force -Quiet
    Add-AutomateNOWDashboardPortlet -Dashboard $dashboard -rowNum 3 -colNum 1 -reportType InfiniteDashboardFailedWorkflowListReport -Force -Quiet
    Add-AutomateNOWDashboardPortlet -Dashboard $dashboard -rowNum 1 -colNum 2 -reportType InfiniteDashboardCompletedWorkflowListReport -Force -Quiet
    Add-AutomateNOWDashboardPortlet -Dashboard $dashboard -rowNum 2 -colNum 2 -reportType InfiniteDashboardServerNodeWeightListReport -Force -Quiet
    Add-AutomateNOWDashboardPortlet -Dashboard $dashboard -rowNum 3 -colNum 2 -reportType InfiniteDashboardServerNodeDeviatedListReport -Force -Quiet
    Add-AutomateNOWDashboardPortlet -Dashboard $dashboard -rowNum 1 -colNum 3 -reportType InfiniteDashboardServerNodeDisconnectedListReport -Force -Quiet
    Add-AutomateNOWDashboardPortlet -Dashboard $dashboard -rowNum 2 -colNum 3 -reportType InfiniteDashboardOccupiedStockListReport -Force -Quiet
    Add-AutomateNOWDashboardPortlet -Dashboard $dashboard -rowNum 3 -colNum 3 -reportType InfiniteDashboardEngagedLockListReport -Force -Quiet

    .EXAMPLE
    Adds a 'Processing Scorecard' Dashboard portlet to a Dashboard named 'Dashboard1' at position 1, 1 based on the "Processing Timestamp" of a Task Template named 'TaskTemplate1' from 1 month ago with a custom title and archive included (one-liner format)

    Add-AutomateNOWDashboardPortlet -Dashboard (Get-AutomateNOWDashboard -Id 'Dashboard1') -rowNum 1 -colNum 1 -reportType InfiniteProcessingScorecardChart -ProcessingTemplate (Get-AutomateNOWTaskTemplate -Id 'TaskTemplate1') -MonthsAgo 1 -UseDate timestamp -IncludeArchive -Title 'Processing Scorecard!'

    .EXAMPLE
    Forcefully and quietly adds a 'Node Guage' Dashboard portlet to a Dashboard named 'Dashboard1' at position 1, 1 with otherwise default options (one-liner format)

    Add-AutomateNOWDashboardPortlet -Dashboard (Get-AutomateNOWDashboard -Id 'Dashboard1') -rowNum 1 -colNum 1 -reportType InfiniteServerNodeGaugeChart -ServerNode (Get-AutomateNOWServerNode -Id 'ServerNode1') -Force -Quiet

    .EXAMPLE
    Adds a 'Metric Scatter Chart' Dashboard portlet to a Dashboard named 'Dashboard1' at position 1, 1 based on a Metric named 'Metric1'

    Add-AutomateNOWDashboardPortlet -Dashboard (Get-AutomateNOWDashboard -Id 'Dashboard1') -rowNum 1 -colNum 1 -reportType InfiniteMetricScatteredChart -Metric (Get-AutomateNOWMetric -Id 'Metric1')

    .EXAMPLE
    Forcefully and quietly adds a 'Metric Guage Chart' Dashboard portlet to a Dashboard named 'Dashboard1' at position 1, 1 based on a Metric named 'Metric1' and with a custom title.

    Add-AutomateNOWDashboardPortlet -Dashboard $dashboard -rowNum 1 -colNum 1 -reportType InfiniteMetricGaugeChart -Metric (Get-AutomateNOWMetric -Id 'Metric1') -Title 'Custom Title' -Force -Quiet

    .EXAMPLE
    Adds a 'Metric History Bar Chart' Dashboard portlet to a Dashboard named 'Dashboard1' at position 1, 1 based on a Metric named 'Metric1' with a mode of 'Show states for a given period' by hour with an aggregation type of Minimum and an aggregation period of 1 hour.

    Add-AutomateNOWDashboardPortlet -Dashboard $dashboard -rowNum 1 -colNum 1 -reportType InfiniteMetricHistoryBarChart -Metric (Get-AutomateNOWMetric -Id 'Metric1.met') -mode PERIOD -ShowStatesFromPeriod hour -AggregationType MIN -AggregationPeriod HOUR

    .EXAMPLE
    Adds a 'Metric History Bar Chart' Dashboard portlet to a Dashboard named 'Dashboard1' at position 1, 1 based on a Metric named 'Metric1' with a mode of 'Show last N states' showing the last 10 N states with an aggregation type of Maximum and an aggregation period of 1 day.

    Add-AutomateNOWDashboardPortlet -Dashboard $dashboard -rowNum 1 -colNum 2 -reportType InfiniteMetricHistoryBarChart -Metric (Get-AutomateNOWMetric -Id 'Metric1.met') -mode LAST_N_STATES -NStates 10 -AggregationType MAX -AggregationPeriod DAY

    .EXAMPLE
    Adds a 'User Report' Dashboard portlet based on 'UserReport1' to a Dashboard named 'Dashboard1' at position 1, 1 with the 'Show Header' checkbox enabled.

    Add-AutomateNOWDashboardPortlet -Dashboard (Get-AutomateNOWDashboard -Id 'Dashboard1') -rowNum 1 -colNum 1 -reportType InfiniteUserReport -UserReport (Get-AutomateNOWUserReport -Id 'UserReport1') -ShowHeader

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    At the time of this writing there is a bug in the AggregationType for the Metric History Bar Chart where if "Minimum" is specified then "Maximum" will be set in the portlet config (and vice-versa). This function DOES NOT carry over this bug.

    For MetricHistoryBarChart, be aware of the default values for the two non-mandatory parameters: -NStates -ShowStatesFromPeriod

    #>
    [OutputType([ANOWDashboardPortlet[]])]
    [Cmdletbinding(SupportsShouldProcess, DefaultParameterSetName = 'Default', ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $true, ParameterSetName = 'ProcessingScorecard')]
        [Parameter(Mandatory = $true, ParameterSetName = 'ServerNode')]
        [Parameter(Mandatory = $true, ParameterSetName = 'UserReport')]
        [Parameter(Mandatory = $true, ParameterSetName = 'MetricSimpleChart')]
        [Parameter(Mandatory = $true, ParameterSetName = 'MetricHistoryBarChart')]
        [ANOWDashboard]$Dashboard,
        [Parameter(Mandatory = $true, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $true, ParameterSetName = 'ProcessingScorecard')]
        [Parameter(Mandatory = $true, ParameterSetName = 'ServerNode')]
        [Parameter(Mandatory = $true, ParameterSetName = 'UserReport')]
        [Parameter(Mandatory = $true, ParameterSetName = 'MetricSimpleChart')]
        [Parameter(Mandatory = $true, ParameterSetName = 'MetricHistoryBarChart')]
        [ANOWDashboardPortlet_reportType]$reportType,
        [ValidateScript({ $_ -gt 0 })]
        [Parameter(Mandatory = $true, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $true, ParameterSetName = 'ProcessingScorecard')]
        [Parameter(Mandatory = $true, ParameterSetName = 'ServerNode')]
        [Parameter(Mandatory = $true, ParameterSetName = 'UserReport')]
        [Parameter(Mandatory = $true, ParameterSetName = 'MetricSimpleChart')]
        [Parameter(Mandatory = $true, ParameterSetName = 'MetricHistoryBarChart')]
        [int32]$rowNum,
        [ValidateScript({ $_ -gt 0 })]
        [Parameter(Mandatory = $true, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $true, ParameterSetName = 'ProcessingScorecard')]
        [Parameter(Mandatory = $true, ParameterSetName = 'ServerNode')]
        [Parameter(Mandatory = $true, ParameterSetName = 'UserReport')]
        [Parameter(Mandatory = $true, ParameterSetName = 'MetricSimpleChart')]
        [Parameter(Mandatory = $true, ParameterSetName = 'MetricHistoryBarChart')]
        [int32]$colNum,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'ProcessingScorecard')]
        [Parameter(Mandatory = $false, ParameterSetName = 'ServerNode')]
        [Parameter(Mandatory = $false, ParameterSetName = 'UserReport')]
        [Parameter(Mandatory = $false, ParameterSetName = 'MetricSimpleChart')]
        [Parameter(Mandatory = $false, ParameterSetName = 'MetricHistoryBarChart')]
        [string]$Title,
        [Parameter(Mandatory = $true, ParameterSetName = 'ProcessingScorecard')]
        [ANOWProcessingTemplate]$ProcessingTemplate,
        [ValidateScript({ $_ -ge 0 })]
        [Parameter(Mandatory = $false, ParameterSetName = 'ProcessingScorecard')]
        [int32]$MonthsAgo = 0,
        [ValidateSet('dateCreated', 'timestamp', ignoreCase = $false)]
        [Parameter(Mandatory = $false, ParameterSetName = 'ProcessingScorecard')]
        [string]$UseDate = 'dateCreated',
        [Parameter(Mandatory = $false, ParameterSetName = 'ProcessingScorecard')]
        [switch]$includeArchive,
        [Parameter(Mandatory = $true, ParameterSetName = 'ServerNode')]
        [ANOWServerNode]$ServerNode,
        [Parameter(Mandatory = $true, ParameterSetName = 'MetricSimpleChart')]
        [Parameter(Mandatory = $true, ParameterSetName = 'MetricHistoryBarChart')]
        [ANOWMetric]$Metric,
        [Parameter(Mandatory = $true, ParameterSetName = 'MetricHistoryBarChart')]
        [ANOWDashboardPortlet_mode]$Mode,
        [ValidateSet('hour', 'day', 'week', 'month', 'year', ignoreCase = $false)]
        [Parameter(Mandatory = $false, ParameterSetName = 'MetricHistoryBarChart')]
        [string]$ShowStatesFromPeriod,
        [ValidateScript({ $_ -ge 1 })]
        [Parameter(Mandatory = $false, ParameterSetName = 'MetricHistoryBarChart')]
        [int32]$NStates = 20,
        [Parameter(Mandatory = $true, ParameterSetName = 'MetricHistoryBarChart')]
        [ANOWDashboardPortlet_aggregationType]$AggregationType,
        [Parameter(Mandatory = $true, ParameterSetName = 'MetricHistoryBarChart')]
        [ANOWDashboardPortlet_aggregationPeriod]$AggregationPeriod,
        [Parameter(Mandatory = $true, ParameterSetName = 'UserReport')]
        [ANOWUserReport]$UserReport,
        [Parameter(Mandatory = $false, ParameterSetName = 'UserReport')]
        [switch]$ShowHeader,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'ProcessingScorecard')]
        [Parameter(Mandatory = $false, ParameterSetName = 'ServerNode')]
        [Parameter(Mandatory = $false, ParameterSetName = 'UserReport')]
        [Parameter(Mandatory = $false, ParameterSetName = 'MetricSimpleChart')]
        [Parameter(Mandatory = $false, ParameterSetName = 'MetricHistoryBarChart')]
        [switch]$Quiet,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'ProcessingScorecard')]
        [Parameter(Mandatory = $false, ParameterSetName = 'ServerNode')]
        [Parameter(Mandatory = $false, ParameterSetName = 'UserReport')]
        [Parameter(Mandatory = $false, ParameterSetName = 'MetricSimpleChart')]
        [Parameter(Mandatory = $false, ParameterSetName = 'MetricHistoryBarChart')]
        [switch]$Force
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    If ($Mode -eq 'PERIOD' -and $ShowStatesFromPeriod.Length -eq 0 ) {
        Write-Warning -Message "For MetricHistoryBarChart: Please include -ShowStatesFromPeriod if the -Mode is [PERIOD]"
        Break
    }
    ElseIf ($Mode -eq 'LAST_N_STATES' -and $ShowStatesFromPeriod.Length -gt 0 ) {
        Write-Warning -Message "For MetricHistoryBarChart: Please do not include -ShowStatesFromPeriod if the -Mode is [LAST_N_STATES]"
    }
    [string]$Dashboard_id = $Dashboard.Id
    [int32]$rowNum = $rowNum - 1
    [int32]$colNum = $colNum - 1
    If ($Title.Length -eq 0) {
        [string]$Title = Switch ($reportType) {
            'InfiniteDashboardFailedTaskListReport' { "Failed Tasks"; Break; }
            'InfiniteDashboardExecutingTaskListReport' { "Executing Tasks"; Break; }
            'InfiniteDashboardCompletedTaskListReport' { "Completed Tasks"; Break; }
            'InfiniteDashboardFailedWorkflowListReport' { "Failed Workflows"; Break; }
            'InfiniteDashboardExecutingWorkflowListReport' { "Executing Workflows"; Break; }
            'InfiniteDashboardCompletedWorkflowListReport' { "Completed Workflows"; Break; }
            'InfiniteDashboardSkewedTaskListReport' { "Skewed Tasks"; Break; }
            'InfiniteDashboardCriticalTaskListReport' { "Critical Tasks"; Break; }
            'InfiniteProcessingScorecardChart' { "Processing Scorecard"; Break; }
            'InfiniteDashboardServerNodeWeightListReport' { "Occupied Nodes"; Break; }
            'InfiniteDashboardServerNodeDeviatedListReport' { "Deviated Nodes"; Break; }
            'InfiniteDashboardServerNodeDisconnectedListReport' { "Disconnected Nodes"; Break; }
            'InfiniteServerNodeGaugeChart' { "Node Guage"; Break; }
            'InfiniteDashboardOccupiedStockListReport' { "Occupied Stocks"; Break; }
            'InfiniteDashboardEngagedLockListReport' { "Engaged Locks"; Break; }
            'InfiniteMetricScatteredChart' { "Metric Scatter Chart"; Break; }
            'InfiniteMetricGaugeChart' { "Metric Guage Chart"; Break; }
            'InfiniteMetricHistoryBarChart' { "Metric History Bar Chart"; Break; }
            'InfiniteUserReport' { "User Report"; Break; }
            Default { "Untitled Window" }
        }
    }
    [ANOWDashboardPortlet]$new_portlet = New-Object -TypeName ANOWDashboardPortlet
    [PSCustomObject]$portletPosition = [PSCustomObject]@{rowNum = $colNum; colNum = $rowNum; position = 0; }
    [PSCustomObject]$reportOptions = [PSCustomObject]@{reportType = $reportType.ToString(); title = $Title; }
    If ($reportType -eq 'InfiniteProcessingScorecardChart') {
        [string]$ProcessingTemplateSimpleId = $ProcessingTemplate.simpleId
        $reportOptions | Add-Member -MemberType NoteProperty -Name 'monthOffset' -Value $MonthsAgo -TypeName int32
        $reportOptions | Add-Member -MemberType NoteProperty -Name 'dateType' -Value $UseDate -TypeName string
        $reportOptions | Add-Member -MemberType NoteProperty -Name 'recordId' -Value "$ProcessingTemplateSimpleId" -TypeName string
        If ($IncludeArchive -eq $true) {
            $reportOptions | Add-Member -MemberType NoteProperty -Name 'includeArchive' -Value 'true' -TypeName string
        }
        Else {
            $reportOptions | Add-Member -MemberType NoteProperty -Name 'includeArchive' -Value 'false' -TypeName string
        }
    }
    ElseIf ($reportType -eq 'InfiniteServerNodeGaugeChart') {
        [string]$ServerNodeSimpleId = $ServerNode.simpleId
        $reportOptions | Add-Member -MemberType NoteProperty -Name 'recordId' -Value "$ServerNodeSimpleId" -TypeName string
    }
    ElseIf ($reportType -eq 'InfiniteMetricScatteredChart' -or $reportType -eq 'InfiniteMetricGaugeChart') {
        [string]$MetricId = $Metric.simpleId
        $reportOptions | Add-Member -MemberType NoteProperty -Name 'recordId' -Value "$MetricId" -TypeName string
    }
    ElseIf ($reportType -eq 'InfiniteMetricHistoryBarChart') {
        [string]$MetricId = $Metric.simpleId
        $reportOptions | Add-Member -MemberType NoteProperty -Name 'recordId' -Value "$MetricId" -TypeName string
        $reportOptions | Add-Member -MemberType NoteProperty -Name 'mode' -Value ($Mode.ToString()) -TypeName string
        If ($mode -eq 'PERIOD') {
            [string]$period = ('1 ' + $ShowStatesFromPeriod)
            $reportOptions | Add-Member -MemberType NoteProperty -Name 'period' -Value $period -TypeName string
        }
        ElseIf ($mode -eq 'LAST_N_STATES') {
            $reportOptions | Add-Member -MemberType NoteProperty -Name 'nStates' -Value $NStates -TypeName int32
        }
        Else {
            Write-Warning -Message "Somehow it was not possible to determine the mode of this Dashboard portlet. Are you debugging?"
            Break
        }
        [string]$AggregationType = ($AggregationType).ToString()
        If ($AggregationType -eq 'MIN') {
            [string]$AggregationType = 'MAX'
        }
        ElseIf ($AggregationType -eq 'MAX') {
            [string]$AggregationType = 'MIN'
        }
        $reportOptions | Add-Member -MemberType NoteProperty -Name 'aggregationType' -Value $AggregationType -TypeName string
        $reportOptions | Add-Member -MemberType NoteProperty -Name 'aggregationPeriod' -Value ($AggregationPeriod).ToString() -TypeName string
    }
    ElseIf ($reportType -eq 'InfiniteUserReport') {
        [string]$UserReportSimpleId = $UserReport.simpleId
        $reportOptions | Add-Member -MemberType NoteProperty -Name 'report' -Value "$UserReportSimpleId" -TypeName string
        If ($ShowHeader -eq $true) {
            $reportOptions | Add-Member -MemberType NoteProperty -Name 'showHeader' -Value 'true' -TypeName string
        }
        Else {
            $reportOptions | Add-Member -MemberType NoteProperty -Name 'showHeader' -Value 'false' -TypeName string
        }
    }
    $new_portlet.portletPosition = $portletPosition
    $new_portlet.reportOptions = $reportOptions
    $new_portlet.Validate()
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [boolean]$Dashboard_exists = ($null -eq (Get-AutomateNOWDashboard -Id $Dashboard_id))
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWDashboard failed to check if the Dashboard [$Dashboard_id] already existed (under Add-AutomateNOWDashboardPortlet due to [$Message]."
        Break
    }
    If ($Dashboard_exists -eq $true) {
        [string]$current_domain = $anow_session.header.domain
        Write-Warning -Message "There is not a Dashboard named [$Dashboard_id] in the current domain [$current_domain]. Please check into this."
        Break
    }
    ## End warning ##
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    If ($null -eq $Dashboard.dashboardDefinition) {
        Write-Warning -Message "$Dashboard_id does not have a definition yet. This is not expected. You can force create the definition by modifying the number of rows with Set-AutomateNOWDashboard"
        Break
    }
    [PSCustomObject]$dashboardDefinition = $Dashboard.dashboardDefinition
    $Error.Clear()
    Try {
        [string]$dashboardDefinitionJSON = $dashboardDefinition | ConvertTo-Json -Compress -Depth 10
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "ConvertTo-JSON somehow failed to convert the Dashboard definition from $Dashboard_id due to [$Message]."
        Break
    }
    Write-Verbose -Message "Dashboard definition from $Dashboard_id before making any changes: $dashboardDefinitionJSON"
    [hashtable]$parameters = @{}
    $parameters.Add('Command', '/dashboard/update')
    $parameters.Add('Method', 'POST')
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$oldValues = $Dashboard.CreateOldValues()
    If ($dashboardDefinition.portlets.Count -eq 0) {
        Write-Verbose -Message "There are no Dashboard portlets in this Dashboard yet"
    }
    Else {
        [int32]$dashboardDefinition_portlets_Count = $dashboardDefinition.portlets.Count
        Write-Verbose -Message "There are $dashboardDefinition_portlets_Count Dashboard portlets within $Dashboard_id"
        $Error.Clear()
        Try {
            [ANOWDashboardPortlet[]]$current_portlets = Read-AutomateNOWDashboardPortlet -Dashboard $Dashboard
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Read-AutomateNOWDashboardPortlet failed to read the Dashboard portlets from $Dashboard_id due to [$Message]."
            Break
        }
    }
    [int32]$MaximumRows = $dashboardDefinition.numColumns
    If ($rowNum -gt $MaximumRows) {
        Write-Warning -Message "You specified a row number of $rowNum but this Dashboard only has $MaximumRows rows. Please use Set-AutomateNOWDashboard with the -NumberOfRows to change the number of rows"
        Break
    }
    [ANOWDashboardPortlet]$portlet_exists = $current_portlets | Where-Object { $_.portletPosition.rowNum -eq $colNum -and $_.portletPosition.colNum -eq $rowNum } | Select-Object -First 1
    If ($null -ne $portlet_exists.reportOptions.reportType) {
        [string]$existing_portlet_type = $portlet_exists.reportOptions.reportType
        [string]$existing_portlet_title = $portlet_exists.reportOptions.title
        If ($existing_portlet_title.Length -gt 0) {
            Write-Warning -Message "There is already a Dashboard portlet named '$existing_portlet_title' in the postion of $rowNum, $colNum within $Dashboard_id. Please choose different coordinates."
        }
        Else {
            Write-Warning -Message "There is already a Dashboard portlet (type $existing_portlet_type) in the postion of $rowNum, $colNum within $Dashboard_id. Please choose different coordinates."
        }
        Break
    }
    [ANOWDashboardPortlet[]]$updated_portlets = ($current_portlets + $new_portlet) | Sort-Object { $_.portletPosition.colNum, $_.portletPosition.rowNum }
    $dashboardDefinition.portlets = $updated_portlets
    $Error.Clear()
    Try {
        [string]$dashboardDefinitionJSON = $dashboardDefinition | ConvertTo-Json -Compress -Depth 10
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "ConvertTo-JSON somehow failed to convert the updated Dashboard definition from $Dashboard_id due to [$Message]."
        Break
    }
    Write-Verbose -Message "Dashboard definition from $Dashboard_id after making changes: $dashboardDefinitionJSON"
    If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Dashboard_id)?")) -eq $true) {
        $BodyMetaData.'id' = $Dashboard_id
        $BodyMetaData.'dashboardDefinition' = $dashboardDefinitionJSON
        $BodyMetaData.'_oldValues' = $oldValues
        $BodyMetaData.'_operationType' = 'update'
        $BodyMetaData.'_textMatchStyle' = 'exact'
        $BodyMetaData.'_componentId' = 'isc_InfiniteDashboardEditor_0_dashboardEditor'
        $BodyMetaData.'_dataSource' = 'DashboardDataSource'
        $BodyMetaData.'isc_metaDataPrefix' = '_'
        $BodyMetaData.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        If ($null -eq $parameters.Body) {
            $parameters.Add('Body', $Body)
        }
        Else {
            $parameters.Body = $Body
        }
        [string]$parameters_display = $parameters | ConvertTo-Json -Compress
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        Write-Verbose -Message "Dashboard portlet ($Title) of type $reportType was added to Dashboard $Dashboard_id at position $rowNum, $colNum"
        If ($Quiet -ne $true) {
            Return $results.response.data
        }
    }
}

Function Remove-AutomateNOWDashboardPortlet {
    <#
    .SYNOPSIS
    Removes a Dashboard portlet from a Dashboard within an AutomateNOW! instance

    .DESCRIPTION
    Removes a Dashboard portlet from a Dashboard within an AutomateNOW! instance

    .PARAMETER Dashboard
    Mandatory [ANOWDashboard] object. Use Get-AutomateNOWDashboard to get this object.

    .PARAMETER DashboardPortlet
    Mandatory [ANOWDashboardPortlet] object. Use Read-AutomateNOWDashboardPortlet to get these objects.

    .PARAMETER Force
    Force the removal of the object without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    1 [ANOWDashboard] object and at least 1 [ANOWDashboardPortlet] object (pipeline capable)

    .OUTPUTS
    A verbose message indicating success will be emitted.

    .EXAMPLE
    Forcefully removes all of the Dashboard portlets from a Dashboard named 'Dashboard1' (multi-line format)

    $dashboard = Get-AutomateNOWDashboard -Id 'Dashboard1'
    $portlets = $dashboard | Read-AutomateNOWDashboardPortlet
    $portlets | Remove-AutomateNOWDashboardPortlet -Dashboard $dashboard -Force

    .EXAMPLE
    Removes a Dashboard portlet with a Title of 'Critical Tasks' from a Dashboard named 'Dashboard1' (multi-line format)

    $dashboard = Get-AutomateNOWDashboard -Id 'Dashboard1'
    $dashboard | Read-AutomateNOWDashboardPortlet -Title 'Critical Tasks' | Remove-AutomateNOWDashboardPortlet -Dashboard $dashboard

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This function will throw an exception if the Title of the Dashboard portlet to be removed exists more than once.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWDashboard]$Dashboard,
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWDashboardPortlet]$DashboardPortlet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$Dashboard_id = $Dashboard.Id
    }
    Process {
        If ($null -ne $_.portletPosition) {
            [ANOWDashboardPortlet]$DashboardPortlet = $_
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$Dashboard_exists = ($null -eq (Get-AutomateNOWDashboard -Id $Dashboard_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWDashboard failed to check if the Dashboard [$Dashboard_id] already existed (under Remove-AutomateNOWDashboardPortlet due to [$Message]."
            Break
        }
        If ($Dashboard_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not a Dashboard named [$Dashboard_id] in the current domain [$current_domain]. Please check into this."
            Break
        }
        ## End warning ##
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($null -eq $Dashboard.dashboardDefinition) {
            Write-Warning -Message "$Dashboard_id does not have a definition yet. This is not expected. You can force create the definition by modifying the number of rows with Set-AutomateNOWDashboard"
            Break
        }
        [PSCustomObject]$dashboardDefinition = $Dashboard.dashboardDefinition
        If ($dashboardDefinition.portlets.Count -eq 0) {
            Write-Verbose -Message "There are no Dashboard portlets in this Dashboard yet. There is nothing to remove."
            Break
        }
        $Error.Clear()
        Try {
            [string]$dashboardDefinitionJSON = $dashboardDefinition | ConvertTo-Json -Compress -Depth 10
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "ConvertTo-JSON somehow failed to convert the Dashboard definition from $Dashboard_id due to [$Message]."
            Break
        }
        Write-Verbose -Message "Dashboard definition from $Dashboard_id before making any changes: $dashboardDefinitionJSON"
        [hashtable]$parameters = @{}
        $parameters.Add('Command', '/dashboard/update')
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
        [string]$oldValues = $Dashboard.CreateOldValues()
        [int32]$dashboardDefinition_portlets_Count = $dashboardDefinition.portlets.Count
        Write-Verbose -Message "There are $dashboardDefinition_portlets_Count Dashboard portlets within $Dashboard_id"
        $Error.Clear()
        Try {
            [ANOWDashboardPortlet[]]$current_portlets = Read-AutomateNOWDashboardPortlet -Dashboard $Dashboard
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Read-AutomateNOWDashboardPortlet failed to read the Dashboard portlets from $Dashboard_id due to [$Message]."
            Break
        }
        [int32]$current_portlets_count = $current_portlets.Count
        [int32]$portlet_exists_count = $current_portlets | Where-Object { ($_ | ConvertTo-Json -Compress) -eq ($DashboardPortlet | ConvertTo-Json -Compress) } | Measure-Object | Select-Object -ExpandProperty Count
        If ($portlet_exists_count -eq 0) {
            Write-Warning -Message "The Dashboard portlet you specified ($dashboardDefinitionJSON) does not actually exist within $Dashboard_id. Please look into this."
            Break
        }
        $Error.Clear()
        Try {
            [ANOWDashboardPortlet]$current_portlet = $current_portlets | Where-Object { ($_ | ConvertTo-Json -Compress) -eq ($DashboardPortlet | ConvertTo-Json -Compress) } | Select-Object -First 1
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Somehow failed to cast the identified Dashboard portlet from $Dashboard_id into an [ANOWDashboardPortlet] object due to [$Message]."
            Break
        }
        [ANOWDashboardPortlet[]]$updated_portlets = $current_portlets | Where-Object { ($_ | ConvertTo-Json -Compress) -ne ($current_portlet | ConvertTo-Json -Compress) }
        [int32]$updated_portlets_count = $updated_portlets.Count
        If ($updated_portlets_count -ne ($current_portlets_count - 1)) {
            Write-Warning -Message "Somehow the number of portlets in this Dashboard does not tally correctly. There were [$current_portlets_count] portlets before and there should be that number minus one for the updated portlets but instead the value for updated portlets is $updated_portlets_count. Please look into this."
            Break
        }
        Else {
            Write-Verbose -Message "The before/after of Dashboard portlets within $Dashboard_id tallies as expected"
        }
        [int32]$rowNum = $current_portlet.portletPosition.rowNum + 1
        [int32]$colNum = $current_portlet.portletPosition.colNum + 1
        [string]$Title = $current_portlet.reportOptions.title
        [string]$reportType = $current_portlet.reportOptions.reportType
        $dashboardDefinition.portlets = $updated_portlets
        $Error.Clear()
        Try {
            [string]$dashboardDefinitionJSON = $dashboardDefinition | ConvertTo-Json -Compress -Depth 10
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "ConvertTo-JSON somehow failed to convert the updated Dashboard definition from $Dashboard_id due to [$Message]."
            Break
        }
        Write-Verbose -Message "Dashboard definition from $Dashboard_id after making changes: $dashboardDefinitionJSON"
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Dashboard_id)?")) -eq $true) {
            $BodyMetaData.'id' = $Dashboard_id
            $BodyMetaData.'dashboardDefinition' = $dashboardDefinitionJSON
            $BodyMetaData.'_oldValues' = $oldValues
            $BodyMetaData.'_operationType' = 'update'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_componentId' = 'isc_InfiniteDashboardEditor_0_dashboardEditor'
            $BodyMetaData.'_dataSource' = 'DashboardDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            [string]$parameters_display = $parameters | ConvertTo-Json -Compress
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Dashboard portlet ($Title) of type $reportType was removed from Dashboard $Dashboard_id at position $rowNum, $colNum"
        }
    }
    End {

    }
}

#endregion

#Region - DataSources

Function Get-AutomateNOWDataSource {
    <#
    .SYNOPSIS
    Gets the DataSources from an AutomateNOW! instance

    .DESCRIPTION
    Gets the DataSources from an AutomateNOW! instance

    .PARAMETER Type
    String identifying the type of DataSource. Valid options are: LOCAL_DICTIONARY, LOCAL_KEY_VALUE_STORE, LOCAL_FILE_STORE, LOCAL_TEXT_FILE_STORE

    .PARAMETER Id
    String containing the simple id of the DataSource to fetch or you can pipeline a series of simple id strings. You may not enter an array here.

    .PARAMETER startRow
    Integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER Folder
    Optional string to filter by a particular Folder

    .PARAMETER Tags
    Optional string array of Tags to filter by. Note that the 'containsAny' operator will be used.

    .INPUTS
    Accepts a string representing the simple id of the DataSource from the pipeline or individually (but not an array) or you can specify by start and end rows.

    .OUTPUTS
    An array of one or more [ANOWDataSource] class objects

    .EXAMPLE
    Gets the first page of DataSource objects

    Get-AutomateNOWDataSource

    .EXAMPLE
    Gets a DataSource object named 'DataSource1'

    Get-AutomateNOWDataSource -Id 'DataSource1'

    .EXAMPLE
    Gets the first page of DataSource objects of type LOCAL_DICTIONARY

    Get-AutomateNOWDataSource -Type LOCAL_DICTIONARY

    .EXAMPLE
    Gets the first 500 DataSource objects

    Get-AutomateNOWDataSource -startRow 0 -endRow 500

    .EXAMPLE
    Gets a series of DataSource objects using the pipeline

    'DataSource1', 'DataSource2' | Get-AutomateNOWDataSource

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWDataSource[]])]
    [Cmdletbinding(DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $True, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [string]$Id,
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [ANOWDataSource_dataSourceType]$Type,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$Folder,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string[]]$Tags
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 -or $Id.Length -gt 0) {
            If ($_.Length -gt 0 ) {
                $Body.'id' = $_
            }
            Else {
                $Body.'id' = $Id
            }
        }
        Else {
            $Body.'operator' = 'and'
            $Body.'_constructor' = 'AdvancedCriteria'
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
            If ($Type.Length -gt 0) {
                $Body.'criteria1' = ('{"fieldName":"dataSourceType","operator":"equals","value":["' + $Type + '"]}')
            }
            If ($Folder.Length -gt 0) {
                $Body.'criteria2' = ('{"fieldName":"folder","operator":"equals","value":"' + $Folder + '"}')
            }
            If ($Tags.Count -gt 0) {
                If ($Tags.Count -gt 1) {
                    $Error.Clear()
                    Try {
                        [string]$TagString = $Tags | ConvertTo-Json -Compress
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "ConvertTo-Json failed to convert the provided tag names under Get-AutomateNOWDataSource due to [$Message]."
                        Break
                    }
                }
                Else {
                    [string]$TagString = $Tags
                }
                $Body.'criteria3' = ('{"fieldName":"tags","operator":"containsAny","value":' + $TagString + '}')
            }
        }
        $Body.'_operationType' = 'fetch'
        $Body.'_textMatchStyle' = 'exact'
        $Body.'_componentId' = 'DataSourceList'
        $Body.'_dataSource' = 'DataSourceDataSource'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/dataSource/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] while running Get-AutomateNOWDataSource due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWDataSource[]]$DataSources = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWDataSource] objects due to [$Message]."
            Break
        }
        If ($Type.Length -gt 0) {
            $DataSources = $DataSources | Where-Object { $_.datasourceType -eq $Type }
        }
        If ($DataSources.Count -gt 0) {
            Return $DataSources
        }
    }
    End {

    }
}

Function Export-AutomateNOWDataSource {
    <#
    .SYNOPSIS
    Exports the DataSources from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the DataSources from an instance of AutomateNOW! to a local .csv file

    .PARAMETER DataSource
    Mandatory [ANOWDataSource] object (Use Get-AutomateNOWDataSource to retrieve them)

    .INPUTS
    ONLY [ANOWDataSource] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWDataSource] objects are exported to the local disk in CSV format

    .EXAMPLE
    Get-AutomateNOWDataSource | Export-AutomateNOWDataSource

    .EXAMPLE
    Get-AutomateNOWDataSource -Id 'DataSource01' | Export-AutomateNOWDataSource

    .EXAMPLE
    @( 'DataSource01', 'DataSource02' ) | Get-AutomateNOWDataSource | Export-AutomateNOWDataSource

    .EXAMPLE
    Get-AutomateNOWDataSource -Type LOCAL_DICTIONARY | Export-AutomateNOWDataSource

    .NOTES
	You must present [ANOWDataSource] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWDataSource]$DataSource
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-DataSources-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWDataSource]$DataSource = $_
        }
        $Error.Clear()
        Try {
            $DataSource | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWDataSource] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function New-AutomateNOWDataSource {
    <#
    .SYNOPSIS
    Creates a DataSource within an AutomateNOW! instance

    .DESCRIPTION
    Creates a DataSource within an AutomateNOW! instance and returns back the newly created [ANOWDataSource] object

    .PARAMETER Id
    The intended name of the DataSource. For example: 'LinuxDataSource1'. This value may not contain the domain in brackets.

    .PARAMETER Type
    Required type of the DataSource. Valid options are: LOCAL_DICTIONARY, LOCAL_KEY_VALUE_STORE, LOCAL_FILE_STORE, LOCAL_TEXT_FILE_STORE

    .PARAMETER Description
    Optional description of the DataSource (may not exceed 255 characters).

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new DataSource.

    .PARAMETER Folder
    Optional name of the folder to place the DataSource into.

    .PARAMETER CodeRepository
    Optional name of the code repository to place the DataSource into.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWDataSource.

    .OUTPUTS
    An [ANOWDataSource] object representing the newly created DataSource

    .EXAMPLE
    New-AutomateNOWDataSource

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The name (id) of the DataSource must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    #>
    [OutputType([ANOWDataSource])]
    [Cmdletbinding()]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $true)]
        [string]$Id,
        [Parameter(Mandatory = $true)]
        [ANOWDataSource_dataSourceType]$Type,
        [Parameter(Mandatory = $false, HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [string]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [boolean]$DataSource_exists = ($null -ne (Get-AutomateNOWDataSource -Id $Id))
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWDataSource failed to check if the DataSource [$Id] already existed due to [$Message]."
        Break
    }
    If ($DataSource_exists -eq $true) {
        [string]$current_domain = $anow_session.header.domain
        Write-Warning -Message "There is already a DataSource named [$Id] in [$current_domain]. Please check into this."
        Break
    }
    ## End warning ##
    $Error.Clear()
    Try {
        [ANOWDataSource]$ANOWDataSource = New-Object -TypeName ANOWDataSource
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "New-Object failed to create the object of type [ANOWDataSource] due to [$Message]."
        Break
    }
    $ANOWDataSource.'id' = $Id
    $ANOWDataSource.'dataSourceType' = $Type
    $ANOWDataSource.'description' = $Description
    If ($Tags.Count -eq 0) {
        [string]$Tags = ""
    }
    $ANOWDataSource.'tags' = $Tags
    $ANOWDataSource.'folder' = $Folder
    $ANOWDataSource.'codeRepository' = $codeRepository
    [string]$BodyObject = ConvertTo-QueryString -InputObject $ANOWDataSource -IncludeProperties id, dataSourceType, description, tags, folder, codeRepository
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_operationType' = 'add'
    $BodyMetaData.'_oldValues' = ('{"dataSourceType":"' + $Type + '"}')
    $BodyMetaData.'_componentId' = 'DataSourceCreateWindow_form'
    $BodyMetaData.'_dataSource' = 'DataSourceDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$BodyMetaDataString = ConvertTo-QueryString -InputObject $BodyMetaData
    [string]$Body = ($BodyObject + '&' + $BodyMetaDataString)
    [string]$command = '/dataSource/create'
    [hashtable]$parameters = @{}
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('Body', $Body)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWDataSource]$DataSource = $results.response.data | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to create [ANOWDataSource] object due to [$Message]."
        Break
    }
    If ($DataSource.id.Length -eq 0) {
        Write-Warning -Message "Somehow the newly created [ANOWDataSource] DataSource is empty!"
        Break
    }
    If ($Quiet -ne $true) {
        Return $DataSource
    }
}

Function Remove-AutomateNOWDataSource {
    <#
    .SYNOPSIS
    Removes a DataSource from an AutomateNOW! instance

    .DESCRIPTION
    The `Remove-AutomateNOWDataSource` function removes a DataSource from an AutomateNOW! instance

    .PARAMETER DataSource
    An [ANOWDataSource] object representing the DataSource to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWDataSource] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Get-AutomateNOWDataSource -Id 'DataSource01' | Remove-AutomateNOWDataSource

    .EXAMPLE
    Get-AutomateNOWDataSource -Id 'DataSource01', 'DataSource02' | Remove-AutomateNOWDataSource

    .EXAMPLE
    @( 'DataSource1', 'DataSource2', 'DataSource3') | Remove-AutomateNOWDataSource

    .EXAMPLE
    Get-AutomateNOWDataSource -Type LOCAL_DICTIONARY | Remove-AutomateNOWDataSource

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWDataSource]$DataSource,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/dataSource/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWDataSource]$DataSource = $_
        }
        [string]$DataSource_id = $DataSource.id
        If ($DataSource_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($DataSource_id)")) -eq $true) {
            [string]$oldvalues = $DataSource.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $DataSource_id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'DataSourceList'
            $BodyMetaData.'_dataSource' = 'DataSourceDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$DataSource_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "DataSource $DataSource_id successfully removed"
        }
    }
    End {

    }
}

Function Set-AutomateNOWDataSource {
    <#
    .SYNOPSIS
    Changes the settings of a DataSource on an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of a DataSource on an AutomateNOW! instance

    .PARAMETER DataSource
    An [ANOWDataSource] object representing the DataSource to be changed.

    .PARAMETER Description
    Optional description of the DataSource (may not exceed 255 characters).

    .PARAMETER UnsetDescription
    Optional switch that will remove the Description from the DataSource.

    .PARAMETER Folder
    A string representing the name of the Folder to move the Task Template into.

    .PARAMETER UnsetFolder
    A switch parameter that will move the Task Template out of its current folder.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to include with this object.

    .PARAMETER UnsetTags
    A switch parameter that will remove the Tags from the Task Template

    .PARAMETER CodeRepository
    Optional Code Repository to place the Data Source into. Use Get-AutomateNOWCodeRepository to fetch this object.

    .PARAMETER UnsetCodeRepository
    Switch parameter that will remove the the Data Source from its Code Repository.

    .PARAMETER DataType
    These settings are currently unexplained in the documentation. The valid choices are: STRING*; NUMBER; TIMESTAMP; TIME; DATE; OBJECT;

    .PARAMETER IsArray
    These settings are currently unexplained in the documentation. The valid choices are: TRUE, FALSE* (in the UI it would be checked or unchecked)

    .PARAMETER ErrorHandling
    These settings are currently unexplained in the documentation. The valid choices are: ERROR; INIT*;

    .PARAMETER Validity
    These settings are currently unexplained in the documentation. The valid choices are: ALL; FREE*; HOST; JOB; WORKFLOW_NAME; WORKFLOW_SESSION; USER; USER_SESSION;

    .PARAMETER Quiet
    Switch parameter that silences the output of the updated object.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWDataSource] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWDataSource] object will be returned

    .EXAMPLE
    Changes the settings of a DataSource

    $datasource = Get-AutomateNOWDataSource -Id 'DataSource1'
    Set-AutomateNOWDataSource -DataSource $datasource -DataType STRING -ErrorHandling INIT -Validity FREE

    .EXAMPLE
    Quietly changes the settings of two DataSources by way of the pipeline

    @((Get-AutomateNOWDataSource -Id 'DataSource1'), (Get-AutomateNOWDataSource -Id 'DataSource2')) | Set-AutomateNOWDataSource -DataType NUMBER -ErrorHandling INIT -Validity JOB -Description 'description!' -Force

    .EXAMPLE
    Removes the tags from a Data Source

    $DataSource = Get-AutomateNOWDataSource -Id 'MyDataSource'
    Set-AutomateNOWDataSource -DataSource $DataSource -UnsetTags

    .EXAMPLE
    Forcibly adds multiple tags to a Data Source

    $DataSource = Get-AutomateNOWDataSource -Id 'MyDataSource'
    Set-AutomateNOWDataSource -DataSource $DataSource -CodeRepository -Tags 'Tag1', 'Tag2' -Force

    .EXAMPLE
    Changes the Folder of a Data Source

    $DataSource = Get-AutomateNOWDataSource -Id 'MyDataSource'
    Set-AutomateNOWDataSource -DataSource $DataSource -Folder 'Folder01'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This function is for modifying the settings of a DataSource. Use Add-AutomateNOWDataSourceItem if you want to add a DataSource Item to the DataSource.

    #>
    [OutputType([ANOWDataSource])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWDataSource]$DataSource,
        [Parameter(Mandatory = $false)]
        [ANOWDataSource_dataType]$DataType,
        [Parameter(Mandatory = $false)]
        [boolean]$IsArray,
        [Parameter(Mandatory = $false)]
        [ANOWDataSource_errorHandling]$ErrorHandling,
        [Parameter(Mandatory = $false)]
        [ANOWDataSource_validity]$Validity,
        [ValidateScript({ $_.Length -le 255 })]
        [Parameter(Mandatory = $false)]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetCodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($Description.Length -gt 0 -and $UnsetDescription -eq $true) {
            Write-Warning -Message 'You cannot set the Description and unset it at the same time. Please choose one or the other.'
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Exit
        }
        If ($Tags.count -gt 0 -and $UnsetTags -eq $true) {
            Write-Warning -Message "You cannot set the tags and unset them at the same time. Please choose one or the other."
        }
        [string]$command = '/dataSource/update'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWDataSource]$DataSource = $_
        }
        [string]$DataSource_id = $DataSource.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($DataSource_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$DataSource_exists = ($null -eq (Get-AutomateNOWDataSource -Id $DataSource_id))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWDataSource failed to check if the DataSource [$DataSource_id] already existed due to [$Message]."
                Break
            }
            If ($DataSource_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not a DataSource named [$DataSource_id] in the [$current_domain] domain. Please check into this."
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $DataSource_id
            If ($Description.Length -gt 0) {
                $BodyMetaData.'description' = $Description
            }
            ElseIf ($UnsetDescription -eq $true) {
                $BodyMetaData.'description' = $null
                $include_properties += 'description'
            }
            ElseIf ($DataSource.description.length -gt 0) {
                $BodyMetaData.'description' = $DataSource.description
                $include_properties += 'description'
            }
            If ($Folder.Length -gt 0) {
                $Error.Clear()
                Try {
                    [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the Folder [$Folder] actually existed while running under Set-AutomateNOWDataSource due to [$Message]"
                    Break
                }
                If ($folder_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] running under Set-AutomateNOWDataSource. Please check again."
                    Break
                }
                [string]$folder_display = $folder_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Adding Data Source $folder_display to Data Source [$DataSource_id]"
                $BodyMetaData.'folder' = $Folder
                $include_properties += 'folder'
            }
            ElseIf ($UnsetFolder -eq $true) {
                [string]$folder_display = $folder_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Removing Data Source [$DataSource_id] from Folder $folder_display"
                $BodyMetaData.'folder' = $null
                $include_properties += 'folder'
            }
            If ($Tags.Count -gt 0) {
                [int32]$total_tags = $Tags.Count
                [int32]$current_tag = 1
                ForEach ($tag_id in $Tags) {
                    $Error.Clear()
                    Try {
                        [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] running under Set-AutomateNOWDataSource due to [$message]"
                        Break
                    }
                    If ($tag_object.simpleId.length -eq 0) {
                        Write-Warning -Message "Set-AutomateNOWDataSource has detected that the tag [$tag_id] does not appear to exist. Please check again."
                        Break
                    }
                    ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                        [string]$tag_object_simpleId = $tag_object.simpleId
                        Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                        Break
                    }
                    [string]$tag_display = $tag_object | ConvertTo-Json -Compress
                    Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
                    [string]$tag_name_sequence = ('tags' + $current_tag)
                    $BodyMetaData.Add($tag_name_sequence, $tag_id)
                    $include_properties += $tag_name_sequence
                    $current_tag++
                }
            }
            ElseIf ($UnsetTags -eq $true) {
                [string]$tags_display = ($DataSource.tags) | ConvertTo-Json -Compress
                Write-Verbose -Message "Removing tags [$tags_display] from $DataSource_id"
                $BodyMetaData.'tags' = $null
                $include_properties += 'tags'
            }
            If ($CodeRepository.Id.Length -gt 0) {
                [string]$CodeRepository_Id = $CodeRepository.Id
                $Error.Clear()
                Try {
                    [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository_Id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository_Id] actually existed under Set-AutomateNOWDataSource due to [$Message]"
                    Break
                }
                If ($code_repository_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository_Id] under Set-AutomateNOWDataSource. Please check again."
                    Break
                }
                $BodyMetaData.'codeRepository' = $CodeRepository_Id
            }
            ElseIf ($UnsetCodeRepository -eq $true) {
                $BodyMetaData.'codeRepository' = $null
            }
            If ($DataType.Length -gt 0) {
                $BodyMetaData.'dataType' = $DataType
            }
            Else {
                $BodyMetaData.'dataType' = $DataSource.DataType
            }
            If ($IsArray -ne $DataSource.IsArray) {
                If ($IsArray -eq $true) {
                    $BodyMetaData.'isArray' = 'true'
                }
                Else {
                    $BodyMetaData.'isArray' = 'false'
                }
            }
            If ($ErrorHandling.Length -gt 0) {
                $BodyMetaData.'errorHandling' = $ErrorHandling
            }
            Else {
                $BodyMetaData.'errorHandling' = $DataSource.errorHandling
            }
            If ($Validity.Length -gt 0) {
                $BodyMetaData.'validity' = $Validity
            }
            Else {
                $BodyMetaData.'validity' = $DataSource.validity
            }
            $BodyMetaData.'_oldValues' = $DataSource.CreateOldValues()
            $BodyMetaData.'_operationType' = 'update'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_componentId' = 'DataSourceValuesManager'
            $BodyMetaData.'_dataSource' = 'DataSourceDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$DataSource_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Data Source [$DataSource_id] was successfully updated"
            $Error.Clear()
            Try {
                [ANOWDataSource]$UpdatedDataSource = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the returned updated object to an [ANOWDataSource] object due to [$Message]. The object was still updated though."
                Break
            }
            If ($Quiet -ne $true) {
                Return $UpdatedDataSource
            }
        }
    }
    End {
    }
}

Function Copy-AutomateNOWDataSource {
    <#
    .SYNOPSIS
    Copies a DataSource from an AutomateNOW! instance (copies the items within the Data Source as well)

    .DESCRIPTION
    Copies a DataSource from an AutomateNOW! instance (copies the items within the Data Source as well). AutomateNOW object id can never be changed, but we can copy the object to a new id and it will include all of the items therein.

    .PARAMETER DataSource
    Mandatory [ANOWDataSource] object to be copied.

    .PARAMETER NewId
    The name (Id) of the new DataSource. The new Id must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    .PARAMETER UnsetDescription
    Optional switch that will ensure that the newly created DataSource will not have a description set.

    .PARAMETER Description
    Optional description to set on the new DataSource object. If you do not set this, the new DataSource object will copy the Description of the source object.

    .PARAMETER UnsetFolder
    Optional switch that will ensure that the newly created DataSource will not have a Folder set.

    .PARAMETER Folder
    Optional description to set a different folder on the new DataSource object. If you do not set this, the new DataSource object will use the same Folder of the source object.

    .PARAMETER UnsetTags
    Optional switch that will ensure that the newly created DataSource will not have any Tags set.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the new DataSource object. If you do not set this, the new DataSource object will apply the same Tags of the source object.

    .PARAMETER Force
    Force the copy without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    ONLY [ANOWDataSource] object is accepted. Pipeline support is intentionally unavailable.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Creates a copy of an DataSource and changes the description (multi-line format)
    $DataSource01 = Get-AutomateNOWDataSource -Id 'DataSource_01'
    Copy-AutomateNOWDataSource -DataSource $DataSource01 -NewId 'DataSource_01_production' -Description 'DataSource 01 Production'

    .EXAMPLE
    Creates a copy of an DataSource that omits the description (one-liner format)
    Copy-AutomateNOWDataSource -DataSource (Get-AutomateNOWDataSource -Id 'DataSource_01') -NewId 'DataSource_01_production' -UnsetDescription -Tags 'Tag1', 'Tag2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The individual Data Source Items within the Data Source -will- be included in the newly created Data Source.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWDataSource]$DataSource,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot set the Tags and unset them at the same time. Please choose one or the other. Tags from the source object will be carried over to the new object if you do not specify any tag-related parameters."
            Break
        }
        [string]$DataSourceType = $DataSource.dataSourceType
        Write-Verbose -Message "This is a [$DataSourceType] type of Data Source"
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$DataSource_exists = ($null -ne (Get-AutomateNOWDataSource -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWDataSource failed to check if the DataSource [$NewId] already existed due to [$Message]."
            Break
        }
        If ($DataSource_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a DataSource named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End warning ##
        [string]$command = '/dataSource/copy'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            [string]$DataSource_oldId = $DataSource.id
            [string]$DataSource_simpleId = $DataSource.simpleId
            If ($DataSource_oldId -eq $NewId) {
                Write-Warning -Message "The new id cannot be the same as the old id."
                Break
            }
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Copy the Data Source $($DataSource_simpleId) to $($NewId)?")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                If ($UnsetFolder -eq $True) {
                    $BodyMetaData.'folder' = $Null
                }
                ElseIf ($Folder.Length -gt 0) {
                    $BodyMetaData.'folder' = $Folder
                }
                Else {
                    If ($DataSource.folder.Length -gt 0) {
                        $BodyMetaData.'folder' = $DataSource.folder
                    }
                }
                If ($Tags.Count -gt 0) {
                    [int32]$tag_count = 1
                    ForEach ($tag in $Tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
                ElseIf ($UnsetTags -eq $true) {
                    $BodyMetaData.'tags' = $Null
                }
                Else {
                    If ($DataSource.Tags -gt 0) {
                        [int32]$tag_count = 1
                        ForEach ($tag in $DataSource.tags) {
                            $BodyMetaData.('tags' + $tag_count ) = $tag
                            $tag_count++
                        }
                    }
                }
                $BodyMetaData.'oldId' = $DataSource_oldId
                $BodyMetaData.'domain' = $DataSource.domain
                $BodyMetaData.'id' = $NewId
                If ($UnsetDescription -ne $true) {
                    If ($Description.Length -gt 0) {
                        $BodyMetaData.'description' = $Description
                    }
                    Else {
                        $BodyMetaData.'description' = $DataSource.description
                    }
                }
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_operationId' = 'copy'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_dataSource' = 'DataSourceDataSource'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties oldId, domain, NewId, description, folder, tags
                $parameters.Body = $Body
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$DataSource_oldId] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                $Error.Clear()
                Try {
                    [ANOWDataSource]$NewDataSource = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to create copied [ANOWDataSource] object [$NewId] due to [$Message]."
                    Break
                }
                If ($NewDataSource.id.Length -eq 0) {
                    Write-Warning -Message "Somehow the newly created (copied) [ANOWDataSource] object [$NewId] is empty!"
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $NewDataSource
                }
            }
        }
    }
    End {

    }
}

Function Rename-AutomateNOWDataSource {
    <#
    .SYNOPSIS
    Renames a DataSource on an AutomateNOW! instance

    .DESCRIPTION
    Performs a psuedo-rename operations of a DataSource from an AutomateNOW! instance by copying it first and then deleting the source. This function merely combines Copy-AutomateNOWDataSource and Remove-AutomateNOWDataSource therefore it is to be considered destructive.

    .PARAMETER DataSource
    An [ANOWDataSource] object representing the DataSource to be renamed.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the DataSource. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER Force
    Force the renaming without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly renamed object.

    .INPUTS
    ONLY [ANOWDataSource] objects are accepted. There is intentionally no support for the pipeline.

    .OUTPUTS
    The newly renamed [ANOWDataSource] object will be returned.

    .EXAMPLE
    $DataSource = Get-AutomateNOWDataSource -Id 'DataSource01'
    Rename-AutomateNOWDataSource -DataSource $DataSource -NewId 'DataSource_02'

    .EXAMPLE
    Rename-AutomateNOWDataSource -DataSource (Get-AutomateNOWDataSource -Id 'DataSource01') -NewId 'DataSource_02'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    When renaming, you may only specify a different Id (name).

    Referrals do not exist on this object type.

    If at first glance the newly renamed Data Source is empty of objects when it should not be, try using the refresh data button and they will appear.
    #>
    [OutputType([ANOWDataSource])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWDataSource]$DataSource,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin standard warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$new_DataSource_exists = ($null -ne (Get-AutomateNOWDataSource -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWDataSource failed to check if the DataSource [$NewId] already existed due to [$Message]."
            Break
        }
        If ($new_DataSource_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a DataSource named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        [string]$DataSource_id = $DataSource.simpleId
        $Error.Clear()
        Try {
            [boolean]$old_DataSource_exists = ($null -ne (Get-AutomateNOWDataSource -Id $DataSource_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWDataSource failed to check if the DataSource [$DataSource_id] already existed due to [$Message]."
            Break
        }
        If ($old_DataSource_exists -eq $false) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not a DataSource named [$DataSource_id] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End standard warning ##
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($DataSource_id)")) -eq $true) {
                $Error.Clear()
                Try {
                    [ANOWDataSource]$new_DataSource = Copy-AutomateNOWDataSource -DataSource $DataSource -NewId $NewId -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Copy-AutomateNOWDataSource failed to create a new DataSource [$NewId] as Part 1 of the renaming process due to [$Message]."
                    Break
                }
                If ($new_DataSource.simpleId -eq $NewId) {
                    Write-Verbose -Message "Part 1: DataSource [$DataSource_id] successfully copied to [$NewId]"
                }
                Else {
                    Write-Warning -Message "Somehow the first phase (Copy-AutomateNOWDataSource) failed. Please look into this."
                    Break
                }
                $Error.Clear()
                Try {
                    Remove-AutomateNOWDataSource -DataSource $DataSource -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Remove-AutomateNOWDataSource failed to remove [$DataSource_id] as Part 2 of the renaming process due to [$Message]."
                    Break
                }
                Write-Verbose -Message "Part 2: DataSource [$DataSource_id] removed"
                Write-Verbose -Message "Task [$DataSource_id] successfully renamed to [$NewId]"
                If ($Quiet -ne $true) {
                    Return $new_DataSource
                }
            }
        }
        Else {
            Write-Warning -Message "No action was taken because either the source object didn't exist or the new object already existed"
        }
    }
    End {
    }
}

#endregion

#Region - DataSource Items

Function Read-AutomateNOWDataSourceItem {
    <#
    .SYNOPSIS
    Reads the DataSourceItems from an AutomateNOW! instance

    .DESCRIPTION
    Reads the DataSourceItems from an AutomateNOW! instance

    .PARAMETER DataSource
    Mandatory [ANOWDataSource] object. Use Get-AutomateNOWDataSource to get this object.

    .PARAMETER Key
    Optional name of the key (only applies to: LocalKeyValueStoreRecord, LocalFileStoreRecord and ANOWLocalTextFileStoreRecord). This parameter is intended for when you only want to retrieve a single item from the Data Source by its unique key.

    .PARAMETER Value
    Optional name of the key (only applies to: LocalDictionaryRecord). This parameter is intended for when you only want to retrieve item(s) from the Data Source by dictionary value.

    .PARAMETER FileName
    Optional name of the file (only applies to: LocalFileStoreRecord and ANOWLocalTextFileStoreRecord). This parameter is intended for when you only want to retrieve item(s) from the Data Source by filename.

    .PARAMETER startRow
    Integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .INPUTS
    Accepts [ANOWDataSource] objects either individually or from the pipeline.

    .OUTPUTS
    An array of one or more [ANOWDataSourceItem] class objects that are linked to the provided [ANOWDataSource] object

    .EXAMPLE
    Gets the first page of items within a Data Source named 'DataSource1'

    Get-AutomateNOWDataSource -Id 'DataSource1' | Read-AutomateNOWDataSourceItem

    .EXAMPLE
    Gets the first page of items from the first page of data sources of type local dictionary

    Get-AutomateNOWDataSource -Type LOCAL_DICTIONARY | Read-AutomateNOWDataSourceItem

    .EXAMPLE
    Uses the pipeline to fetch the first page of items from two data sources named 'DataSource1' and 'DataSource1'

    'DataSource1', 'DataSource2' | Get-AutomateNOWDataSource | Read-AutomateNOWDataSourceItem

    .EXAMPLE
    Fetches a specific key named 'Key1' from a Data Source (local key value store) named 'DataSource1'

    'DataSource1' | Get-AutomateNOWDataSource | Read-AutomateNOWDataSourceItem -Key 'Key1'

    .EXAMPLE
    Fetches a specific value named 'Value1' from a Data Source (local dictionary store) named 'DataSource1'

    'DataSource1' | Get-AutomateNOWDataSource | Read-AutomateNOWDataSourceItem -Value 'Value1'

    .EXAMPLE
    Fetches a specific file named 'readme.txt' from a Data Source (local text file store) named 'DataSource1'

    'DataSource1' | Get-AutomateNOWDataSource | Read-AutomateNOWDataSourceItem -Filename 'readme.txt'

    .EXAMPLE
    Fetches a specific file by its key (not the filename) from a Data Source (local text file store) named 'DataSource1'

    'DataSource1' | Get-AutomateNOWDataSource | Read-AutomateNOWDataSourceItem -Key 'file1'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Run this function without parameters to retrieve the first page of items.

    Remember that both file types (text and binary) contain a key which is not the same as the filename!

    #>
    [OutputType([ANOWDataSourceItem[]])]
    [Cmdletbinding(DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $True, ValueFromPipeline = $True)]
        [ANOWDataSource]$DataSource,
        [Parameter(Mandatory = $True, ParameterSetName = 'Key')]
        [string]$Key,
        [Parameter(Mandatory = $True, ParameterSetName = 'Value')]
        [string]$Value,
        [Parameter(Mandatory = $True, ParameterSetName = 'Filename')]
        [string]$Filename,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.Id.Length -gt 0) {
            [ANOWDataSource]$DataSource = $_
        }
        [string]$Type = $DataSource.dataSourceType
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        [string]$DataSource_id = $DataSource.id
        $Body.Add('masterDataSource', $DataSource_id)
        $Body.Add('_operationType', 'fetch')
        $Body.Add('_startRow', $startRow)
        $Body.Add('_endRow', $endRow)
        If ($Type -eq 'LOCAL_DICTIONARY') {
            [string]$command = '/localDictionaryRecord/read?'
            $Body.Add('_sortBy', 'value')
            $Body.Add('_componentId', 'LocalDictionaryRecordList')
            $Body.Add('_dataSource', 'LocalDictionaryRecordDataSource')
        }
        ElseIf ($Type -eq 'LOCAL_KEY_VALUE_STORE') {
            [string]$command = '/localKeyValueStoreRecord/read?'
            $Body.Add('_sortBy', 'key')
            $Body.Add('_componentId', 'LocalKeyValueStoreRecordList')
            $Body.Add('_dataSource', 'LocalKeyValueStoreRecordDataSource')
        }
        ElseIf ($Type -eq 'LOCAL_FILE_STORE') {
            [string]$command = '/localFileStoreRecord/read?'
            $Body.Add('_sortBy', 'key')
            $Body.Add('_componentId', 'LocalFileStoreRecordList')
            $Body.Add('_dataSource', 'LocalFileStoreRecordDataSource')
        }
        ElseIf ($Type -eq 'LOCAL_TEXT_FILE_STORE') {
            [string]$command = '/localTextFileStoreRecord/read?'
            $Body.Add('_sortBy', 'key')
            $Body.Add('_componentId', 'LocalTextFileStoreRecordList')
            $Body.Add('_dataSource', 'LocalTextFileStoreRecordDataSource')
        }
        Else {
            Write-Warning -Message "Failed to determine DataSourceItem type!"
            Break
        }
        If (($Key.Length -gt 0 -or ($Value.Length -gt 0) -or ($Filename.Length -gt 0))) {
            $Body.Remove('_componentId')
            $Body.Add('_textMatchStyle', 'exactCase')
            $Body.Add('_operationId', 'read')
            $Body.Add('_constructor', 'AdvancedCriteria')
            $Body.Add('operator', 'and')
            $Body.Add('criteria1', ('{"fieldName":"masterDataSource","operator":"equals","value":"' + $DataSource_id + '"}'))
            If ($Key.Length -gt 0) {
                If ($Type -ne 'LOCAL_DICTIONARY') {
                    $Body.Add('criteria2', ('{"fieldName":"key","operator":"equals","value":"' + $Key + '"}'))
                }
                Else {
                    Write-Warning -Message 'Please use the -Value parameter instead to fetch values from local dictionaries.'
                    Break
                }
            }
            ElseIf ($Value.Length -gt 0) {
                If ($Type -eq 'LOCAL_DICTIONARY') {
                    $Body.Add('criteria2', ('{"fieldName":"value","operator":"equals","value":"' + $Value + '"}'))
                }
                Else {
                    If ($Type -eq 'LOCAL_KEY_VALUE_STORE') {
                        Write-Warning -Message 'Please use the -Key parameter instead for to fetch values from local key value stores.'
                        Break
                    }
                    Else {
                        Write-Warning -Message 'Please use the -Key or -Filename parameter to fetch specific files in the DataSource'
                        Break
                    }
                    Break
                }
            }
            ElseIf ($Filename.Length -gt 0) {
                If ($Type -in @('LOCAL_TEXT_FILE_STORE', 'LOCAL_FILE_STORE')) {
                    $Body.Add('criteria2', ('{"fieldName":"fileName","operator":"equals","value":"' + $Filename + '"}'))
                }
                Else {
                    Write-Warning -Message 'Please use the -Key or -Value parameter to fetch specific Keys or Values within a local dictionary or a local key value store'
                    Break
                }
            }
            Else {
                Write-Warning -Message "Somehow was unable to parse the parameters under Read-AutomateNOWDataSourceItem"
                Break
            }
        }
        Else {
            $Body.Add('_textMatchStyle', 'substring')
        }
        $Body.Add('isc_metaDataPrefix', '_')
        $Body.Add('isc_dataFormat', 'json')
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ($command + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        [int32]$DataSourceItemsCount = $results.response.data.count
        If ($DataSourceItemsCount -gt 50000) {
            Write-Warning -Message "This Data Source has over 50,000 items! This module does not support that yet."
            Break
        }
        If ($DataSourceItemsCount -gt 0) {
            If ($Type -eq 'LOCAL_DICTIONARY') {
                $Error.Clear()
                Try {
                    [ANOWLocalDictionaryRecord[]]$DataSourceItems = ForEach ($result in $results.response.data) {
                        $result.masterDataSource = $DataSource
                        $result
                    }
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to parse the response into a series of [ANOWLocalDictionaryRecord] objects due to [$Message]."
                    Break
                }
            }
            ElseIf ($Type -eq 'LOCAL_KEY_VALUE_STORE') {
                $Error.Clear()
                Try {
                    [ANOWLocalKeyValueStoreRecord[]]$DataSourceItems = ForEach ($result in $results.response.data) {
                        $result.masterDataSource = $DataSource
                        $result
                    }
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to parse the response into a series of [ANOWLocalKeyValueStoreRecord] objects due to [$Message]."
                    Break
                }
                If ($DataSourceItems.Count -gt 0) {
                    Return $DataSourceItems
                }
            }
            ElseIf ($Type -eq 'LOCAL_FILE_STORE') {
                $Error.Clear()
                Try {
                    [ANOWLocalFileStoreRecord[]]$DataSourceItems = ForEach ($result in $results.response.data) {
                        $result.masterDataSource = $DataSource
                        $result
                    }
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to parse the response into a series of [ANOWLocalFileStoreRecord] objects due to [$Message]."
                    Break
                }
                If ($DataSourceItems.Count -gt 0) {
                    Return $DataSourceItems
                }
            }
            ElseIf ($Type -eq 'LOCAL_TEXT_FILE_STORE') {
                $Error.Clear()
                Try {
                    [ANOWLocalTextFileStoreRecord[]]$DataSourceItems = ForEach ($result in $results.response.data) {
                        $result.masterDataSource = $DataSource
                        $result
                    }
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to parse the response into a series of [ANOWLocalTextFileStoreRecord] objects due to [$Message]."
                    Break
                }
            }
            Else {
                Write-Warning -Message "Failed to determine DataSourceItem type!"
                Break
            }
        }
        Else {
            Write-Verbose -Message "There no items in DataSource ($DataSource_id)"
        }
        If ($DataSourceItems.Count -gt 0) {
            Return $DataSourceItems
        }
    }
    End {

    }
}

Function Export-AutomateNOWDataSourceItem {
    <#
    .SYNOPSIS
    Exports the DataSourceItems from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the DataSourceItems from an instance of AutomateNOW! to a local .csv file

    .PARAMETER DataSourceItem
    Mandatory [ANOWDataSourceItem] object (Use Read-AutomateNOWDataSourceItem to retrieve them)

    .PARAMETER Type
    Mandatory string indicating the type of DataSourceItem to be exported. Valid choices are: LOCAL_DICTIONARY, LOCAL_KEY_VALUE_STORE, LOCAL_FILE_STORE, LOCAL_TEXT_FILE_STORE

    .INPUTS
    ONLY [ANOWDataSourceItem] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWDataSourceItem] objects are exported to the local disk in CSV format

    .EXAMPLE
    Exports all of the local dictionary values from all local dictionary data sources

    Get-AutomateNOWDataSource -Type LOCAL_DICTIONARY | Read-AutomateNOWDataSourceItem | Export-AutomateNOWDataSourceItem -Type LOCAL_DICTIONARY

    .EXAMPLE
    Exports all of the local dictionary values from a single local dictionary data source

    Get-AutomateNOWDataSource -Id 'DataSource01' | Read-AutomateNOWDataSourceItem | Export-AutomateNOWDataSourceItem -Type LOCAL_DICTIONARY

    .EXAMPLE
    Exports the the first 5 local dictionary values from a series of local dictionary data sources

    @( 'DataSource01', 'DataSource02' ) | Get-AutomateNOWDataSource | Read-AutomateNOWDataSourceItem -startRow 0 -endRow 5 | Export-AutomateNOWDataSourceItem -Type LOCAL_DICTIONARY

    .NOTES
	You must present [ANOWDataSourceItem] objects to the pipeline to use this function.
    #>

    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWDataSourceItem]$DataSourceItem,
        [Parameter(Mandatory = $true)]
        [ANOWDataSource_dataSourceType]$Type
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = "Export-AutomateNOW-DataSourceItems-$Type-" + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            $DataSourceItem = $_ # do not hard type this variable
        }
        If ($DataSourceItem.masterDataSource.dataSourceType -ne $Type) {
            [string]$dataSourceType = $DataSourceItem.masterDataSource.dataSourceType
            Write-Warning -Message "You specified [$Type] as the DataSource Type but a DataSource of type [$dataSourceType] was sent instead. Exiting."
            Break
        }
        $Error.Clear()
        Try {
            $DataSourceItem | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWDataSourceItem] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function Add-AutomateNOWDataSourceItem {
    <#
    .SYNOPSIS
    Adds a DataSourceItem to a DataSource within an AutomateNOW! instance

    .DESCRIPTION
    Adds a DataSourceItem to a DataSource within an AutomateNOW! instance and returns back the newly created [ANOWDataSourceItem]

    .PARAMETER DataSource
    Mandatory [ANOWDataSource] object. Use Get-AutomateNOWDataSource to get this object.

    .PARAMETER Type
    Required type of the DataSourceItem. Valid options are: LOCAL_DICTIONARY, LOCAL_KEY_VALUE_STORE, LOCAL_FILE_STORE, LOCAL_TEXT_FILE_STORE

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object

    .PARAMETER Force
    Force the addition of the object without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER key
    [LOCAL_KEY_VALUE_STORE] ONLY - The unique key of the item (must be unique within the datasource)

    .PARAMETER value
    [LOCAL_DICTIONARY] OR [LOCAL_KEY_VALUE_STORE] Either the key of the dictionary item (must be unique within the datasource) OR the value of your key/value pair and does NOT need to be unique.

    .PARAMETER displayValue
    [LOCAL_DICTIONARY] ONLY - The value of the dictionary item. This does not need to be unique within the dictionary data store.

    .PARAMETER file_id
    [LOCAL_FILE_STORE] OR [LOCAL_TEXT_FILE_STORE] This is the unique id of the file which you must supply. This is -not the same- as the name of the file. This property serves the same purpose as the key in a key/value pair.

    .PARAMETER text_file
    [LOCAL_TEXT_FILE_STORE] ONLY - Use Get-Item or Get-ChildItem to get the text file first as a [System.IO.FileSystemInfo] object. See examples below.

    .PARAMETER binary_file
    [LOCAL_FILE_STORE] ONLY - Use Get-Item or Get-ChildItem to get the binary file first as a [System.IO.FileSystemInfo] object. See examples below.

    .PARAMETER mime_type
    [LOCAL_FILE_STORE] ONLY - Mandatory string to specify the mime type. If you're not sure, you can use 'application/octet-stream'. However, it would be good of you to more precisely define the mime type of the file that you are uploading. For now, this needs to be supplied by you, the end-user. For now, you will have to use the console to determine the mime type :( : Examples: .wav = 'audio/wav', .exe = 'application/x-msdownload', .pptx = 'application/vnd.openxmlformats-officedocument.presentationml.presentation'. You could check the registry and go by file extension alone. The console -is- inspecting the file.

    .INPUTS
    None. You cannot pipe objects to Add-AutomateNOWDataSourceItem.

    .OUTPUTS
    An [ANOWDataSourceItem] object representing the newly created DataSourceItem

    .EXAMPLE
    How to upload an entry to a local dictionary store data source

    $data_source = Get-AutomateNOWDataSource -Id 'data_source_dictionary'
    Add-AutomateNOWDataSourceItem -Type LOCAL_DICTIONARY -DataSource $data_source -value '2' -displayValue 'two'

    .EXAMPLE
    How to upload a key/value pair to a local key value store data source

    $data_source = Get-AutomateNOWDataSource -Id 'local_key_value_store'
    Add-AutomateNOWDataSourceItem -Type LOCAL_KEY_VALUE_STORE -DataSource $data_source -key '3' -value 'three'

    .EXAMPLE
    A three-line code that uploads a binary file to a local store data source.

    $data_source = Get-AutomateNOWDataSource -Id 'local_file_store'
    $local_binary_file = Get-Item -Path 'c:\temp\file.exe'
    Add-AutomateNOWDataSourceItem -DataSource $data_source -Type LOCAL_FILE_STORE -file_id 'binary_file_01-file.exe' -binary_file $local_binary_file -mime_type 'application/x-msdownload'

    .EXAMPLE
    Same as above example except as a one-liner

    Add-AutomateNOWDataSourceItem -DataSource (Get-AutomateNOWDataSource -Id 'local_file_store') -Type LOCAL_FILE_STORE -file_id 'binary_file_01-file.exe' -binary_file (Get-Item -Path 'c:\temp\file.exe') -mime_type 'application/x-msdownload'

    .EXAMPLE
    Reads all of the text files from your 7-Zip installation and uploads them to a local text file store data source. ASCII or UTF-8 files will be differentiated automatically.

    $data_source = Get-AutomateNOWDataSource -Id 'local_text_file_store'
    ForEach($local_file in (Get-ChildItem -File -Recurse -Path 'C:\Program Files (x86)\7-Zip\*.txt')){
        [string]$file_name = $local_file.name
        Add-AutomateNOWDataSourceItem -DataSource $data_source -Type LOCAL_TEXT_FILE_STORE -file_id $file_name -text_file $local_file -Quiet
    }

    .EXAMPLE
    Reads all of the .wav files from your local Windows installation and uploads them to a local file store data source. The mime type is supplied manually.

    $data_source = Get-AutomateNOWDataSource -Id 'local_file_store'
    ForEach($local_file in (Get-ChildItem -File -Path 'C:\windows\media\*.wav')){
        [string]$file_name = $local_file.name
        Add-AutomateNOWDataSourceItem -DataSource $data_source -Type LOCAL_FILE_STORE -file_id $file_name -binary_file $local_file -Quiet -mime_type 'audio/wav'
    }

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    MimeType does not need to be specified on a text file upload. It is either text/plain or text/plain;charset=UTF-8.

    #>
    [OutputType([ANOWDataSourceItem])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'LOCAL_DICTIONARY')]
        [Parameter(Mandatory = $true, ParameterSetName = 'LOCAL_KEY_VALUE_STORE')]
        [Parameter(Mandatory = $true, ParameterSetName = 'LOCAL_FILE_STORE')]
        [Parameter(Mandatory = $true, ParameterSetName = 'LOCAL_TEXT_FILE_STORE')]
        [ANOWDataSource]$DataSource,
        [Parameter(Mandatory = $true, ParameterSetName = 'LOCAL_DICTIONARY')]
        [Parameter(Mandatory = $true, ParameterSetName = 'LOCAL_KEY_VALUE_STORE')]
        [Parameter(Mandatory = $true, ParameterSetName = 'LOCAL_FILE_STORE')]
        [Parameter(Mandatory = $true, ParameterSetName = 'LOCAL_TEXT_FILE_STORE')]
        [ANOWDataSource_dataSourceType]$Type,
        [Parameter(Mandatory = $true, ParameterSetName = 'LOCAL_KEY_VALUE_STORE')]
        [string]$key,
        [Parameter(Mandatory = $true, ParameterSetName = 'LOCAL_DICTIONARY')]
        [Parameter(Mandatory = $true, ParameterSetName = 'LOCAL_KEY_VALUE_STORE')]
        [string]$value,
        [Parameter(Mandatory = $true, ParameterSetName = 'LOCAL_DICTIONARY')]
        [string]$displayValue,
        [Parameter(Mandatory = $true, ParameterSetName = 'LOCAL_FILE_STORE')]
        [Parameter(Mandatory = $true, ParameterSetName = 'LOCAL_TEXT_FILE_STORE')]
        [string]$file_id,
        [Parameter(Mandatory = $true, ParameterSetName = 'LOCAL_TEXT_FILE_STORE')]
        [System.IO.FileSystemInfo]$text_file,
        [ValidateScript({ (Test-Path -Path $_.FullName) -eq $true })]
        [Parameter(Mandatory = $true, ParameterSetName = 'LOCAL_FILE_STORE')]
        [System.IO.FileSystemInfo]$binary_file,
        [Parameter(Mandatory = $true, ParameterSetName = 'LOCAL_FILE_STORE')]
        [string]$mime_type,
        [Parameter(Mandatory = $false, ParameterSetName = 'LOCAL_DICTIONARY')]
        [Parameter(Mandatory = $false, ParameterSetName = 'LOCAL_KEY_VALUE_STORE')]
        [Parameter(Mandatory = $false, ParameterSetName = 'LOCAL_FILE_STORE')]
        [Parameter(Mandatory = $false, ParameterSetName = 'LOCAL_TEXT_FILE_STORE')]
        [switch]$Quiet,
        [Parameter(Mandatory = $false, ParameterSetName = 'LOCAL_DICTIONARY')]
        [Parameter(Mandatory = $false, ParameterSetName = 'LOCAL_KEY_VALUE_STORE')]
        [Parameter(Mandatory = $false, ParameterSetName = 'LOCAL_FILE_STORE')]
        [Parameter(Mandatory = $false, ParameterSetName = 'LOCAL_TEXT_FILE_STORE')]
        [switch]$Force
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    [string]$cr = "`r`n"
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    [string]$DataSource_Id = $DataSource.Id
    [hashtable]$parameters = @{}
    $parameters.Add('Method', 'POST')
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Add the Data Source Item to $($DataSource_Id)?")) -eq $true) {
        If ($Type -eq 'LOCAL_DICTIONARY') {
            If ($value.length -eq 0) {
                Write-Warning -Message "Please include the -value parameter with LOCAL_DICTIONARY type"
                Break
            }
            ElseIf ($displayValue.length -eq 0) {
                Write-Warning -Message "Please include the -displayValue parameter with LOCAL_DICTIONARY type"
                Break
            }
            [ANOWLocalDictionaryRecord[]]$current_items = Read-AutomateNOWDataSourceItem -DataSource $DataSource
            If ($value -in $current_items.value) {
                Write-Warning -Message "An item with the value of [$value] already exists in this dictionary. Please note that every value in the dictionary must be unique (the displayValue does not need to be unique)"
                Break
            }
            $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
            [string]$command = '/localDictionaryRecord/create'
            $Error.Clear()
            Try {
                [ANOWLocalDictionaryRecord]$ANOWDataSourceItem = New-Object -TypeName ANOWLocalDictionaryRecord
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "New-Object failed to create the object of type [ANOWLocalDictionaryRecord] due to [$Message]."
                Break
            }
            $ANOWDataSourceItem.value = $value
            $ANOWDataSourceItem.displayValue = $displayValue
            [string]$BodyObject = ConvertTo-QueryString -InputObject $ANOWDataSourceItem -IncludeProperties value, displayValue
            $BodyMetaData.'masterDataSource' = "$DataSource_Id"
            $BodyMetaData.'_componentId' = 'LocalDictionaryRecordEditForm'
            $BodyMetaData.'_dataSource' = 'LocalDictionaryRecordDataSource'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'add'
            $BodyMetaData.'_oldValues' = '{}'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$BodyMetaDataString = ConvertTo-QueryString -InputObject $BodyMetaData
            [string]$Body = ($BodyObject + '&' + $BodyMetaDataString)
            $parameters.Add('Body', $Body)
        }
        ElseIf ($Type -eq 'LOCAL_KEY_VALUE_STORE') {
            If ($key.length -eq 0) {
                Write-Warning -Message "Please include the -key parameter with LOCAL_KEY_VALUE_STORE type"
                Break
            }
            ElseIf ($value.length -eq 0) {
                Write-Warning -Message "Please include the -value parameter with LOCAL_KEY_VALUE_STORE type"
                Break
            }
            [ANOWLocalKeyValueStoreRecord[]]$current_items = Read-AutomateNOWDataSourceItem -DataSource $DataSource
            If ($value -in $current_items.value) {
                Write-Warning -Message "An item with the value of [$value] already exists in this dictionary. Please note that every value in the dictionary must be unique (the displayValue does not need to be unique)"
                Break
            }
            $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
            [string]$command = '/localKeyValueStoreRecord/create'
            $Error.Clear()
            Try {
                [ANOWLocalKeyValueStoreRecord]$ANOWDataSourceItem = New-Object -TypeName ANOWLocalKeyValueStoreRecord
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "New-Object failed to create the object of type [ANOWLocalKeyValueStoreRecord] due to [$Message]."
                Break
            }
            $ANOWDataSourceItem.key = $key
            $ANOWDataSourceItem.value = $value
            [string]$BodyObject = ConvertTo-QueryString -InputObject $ANOWDataSourceItem -IncludeProperties key, value
            $BodyMetaData.'masterDataSource' = "$DataSource_Id"
            $BodyMetaData.'_componentId' = 'LocalKeyValueStoreRecordEditForm'
            $BodyMetaData.'_dataSource' = 'LocalKeyValueStoreRecordDataSource'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'add'
            $BodyMetaData.'_oldValues' = '{}'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$BodyMetaDataString = ConvertTo-QueryString -InputObject $BodyMetaData
            [string]$Body = ($BodyObject + '&' + $BodyMetaDataString)
            $parameters.Add('Body', $Body)
        }
        ElseIf ($Type -eq 'LOCAL_FILE_STORE') {
            If ($file_id.length -eq 0) {
                Write-Warning -Message "Please include the -file_id parameter with LOCAL_KEY_VALUE_STORE type"
                Break
            }
            [ANOWLocalFileStoreRecord[]]$current_items = Read-AutomateNOWDataSourceItem -DataSource $DataSource
            If ($file_id -in $current_items.key) {
                Write-Warning -Message "A file with the file_id [$file_id] already exists in this local file store $DataSource_Id. Please note that every file_id in a local file store must be unique (the contents do not need to be unique)"
                Break
            }
            [hashtable]$get_file_parameters = @{}
            If ($PSVersionTable.PSVersion.Major -eq 5) {
                $get_file_parameters.Add('Encoding', 'Byte')
                $get_file_parameters.Add('Raw', $true)
            }
            Else {
                $get_file_parameters.Add('AsByteStream', $true)
            }
            [string]$binary_file_fullname = $binary_file.fullname
            $get_file_parameters.Add('Path', "$binary_file_fullname")
            $Error.Clear()
            Try {
                [byte[]]$file_bytes = Get-Content @get_file_parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-Content failed to import the file $binary_file_fullname due to [$Message]."
                Break
            }
            [string]$object_id = $DataSource.id
            [string]$uploaded_filename = $binary_file.name
            [string]$boundary_string = New-WebkitBoundaryString
            [System.Collections.ArrayList]$form_prefix = New-Object -TypeName System.Collections.ArrayList
            [void]$form_prefix.Add("------WebKitFormBoundary$boundary_string")
            [void]$form_prefix.Add("Content-Disposition: form-data; name=`"id`"" + $cr + $cr)
            [void]$form_prefix.Add("------WebKitFormBoundary$boundary_string")
            [void]$form_prefix.Add("Content-Disposition: form-data; name=`"key`"" + $cr)
            [void]$form_prefix.Add($file_id)
            [void]$form_prefix.Add("------WebKitFormBoundary$boundary_string")
            [void]$form_prefix.Add("Content-Disposition: form-data; name=`"masterDataSource`"" + $cr)
            [void]$form_prefix.Add($object_id)
            [void]$form_prefix.Add("------WebKitFormBoundary$boundary_string")
            [void]$form_prefix.Add("Content-Disposition: form-data; name=`"uploadWindow`"" + $cr)
            [void]$form_prefix.Add("isc_InfiniteWindow_0")
            [void]$form_prefix.Add("------WebKitFormBoundary$boundary_string")
            [void]$form_prefix.Add("Content-Disposition: form-data; name=`"access_token`"" + $cr)
            [void]$form_prefix.Add($anow_session.AccessToken)
            [void]$form_prefix.Add("------WebKitFormBoundary$boundary_string")
            [void]$form_prefix.Add("Content-Disposition: form-data; name=`"file`"; filename=`"$uploaded_filename`"")
            [void]$form_prefix.Add("Content-Type: $mime_type" + $cr + $cr)
            [System.Collections.ArrayList]$form_suffix = New-Object -TypeName System.Collections.ArrayList
            [void]$form_suffix.Add($cr + "------WebKitFormBoundary$boundary_string--" + $cr)
            [string]$body_prefix = $form_prefix -join $cr
            [string]$body_suffix = $form_suffix -join ''
            [byte[]]$body_prefix_bytes = [System.Text.Encoding]::UTF8.GetBytes($body_prefix)
            [byte[]]$body_suffix_bytes = [System.Text.Encoding]::UTF8.GetBytes($body_suffix)
            [byte[]]$Body = $body_prefix_bytes + $file_bytes + $body_suffix_bytes
            [int32]$content_length = $body.count
            [string]$domain = $anow_session.header.domain
            [string]$command = "/localFileStoreRecord/uploadFile?domain=$domain"
            $parameters.Add('ContentType', "multipart/form-data; boundary=----WebKitFormBoundary$boundary_string")
            $Error.Clear()
            Try {
                [ANOWLocalFileStoreRecord]$ANOWDataSourceItem = New-Object -TypeName ANOWLocalFileStoreRecord
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "New-Object failed to create the object of type [ANOWLocalFileStoreRecord] due to [$Message]."
                Break
            }
            $parameters.Add('BinaryBody', $Body)
            $parameters.Add('Headers', [hashtable]@{"Content-Length" = $content_length; "Upgrade-Insecure-Requests" = 1; }) # is this header really needed?
        }
        ElseIf ($Type -eq 'LOCAL_TEXT_FILE_STORE') {
            If ($file_id.length -eq 0) {
                Write-Warning -Message "Please include the -file_id parameter with LOCAL_TEXT_FILE_STORE type"
                Break
            }
            If ($mime_type -notmatch '^[a-z-]{1,}\/[a-z0-9-.+]{1,}$') {
                Write-Warning -Message "[$mime_type] does not appear to be a valid mime type. Please, check the mime type or contact the author of this script if there is a mistake."
                Break
            }
            [ANOWLocalTextFileStoreRecord[]]$current_items = Read-AutomateNOWDataSourceItem -DataSource $DataSource
            If ($file_id -in $current_items.key) {
                Write-Warning -Message "A file with the file_id [$file_id] already exists in this local file store $DataSource_Id. Please note that every file_id in a local file store must be unique (the contents do not need to be unique)"
                Break
            }
            [hashtable]$get_file_parameters = @{}
            If ($PSVersionTable.PSVersion.Major -eq 5) {
                $get_file_parameters.Add('Encoding', 'Byte')
                $get_file_parameters.Add('Raw', $true)
            }
            Else {
                $get_file_parameters.Add('AsByteStream', $true)
            }
            [string]$text_file_fullname = $text_file.fullname
            $get_file_parameters.Add('Path', "$text_file_fullname")
            $Error.Clear()
            Try {
                [byte[]]$file_bytes = Get-Content @get_file_parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-Content failed to import the file $text_file_fullname due to [$Message]."
                Break
            }
            [string]$object_id = $DataSource.id
            [string]$uploaded_filename = $text_file.name
            If ((($file_bytes | Sort-Object -Unique) | ForEach-Object { $_ -eq 10 -or $_ -eq 13 -or ( $_ -ge 32 -and $_ -le 126) }) -contains $false) {
                [string]$mime_type = 'text/plain;charset=UTF-8'
            }
            Else {
                [string]$mime_type = 'text/plain'
            }
            [int32]$content_length = $file_bytes.count
            [string]$domain = $anow_session.header.domain
            [string]$command = "/localTextFileStoreRecord/create"
            $parameters.Add('ContentType', "application/x-www-form-urlencoded; charset=UTF-8")
            $Error.Clear()
            Try {
                [ANOWLocalTextFileStoreRecord]$ANOWDataSourceItem = New-Object -TypeName ANOWLocalTextFileStoreRecord
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "New-Object failed to create the object of type [ANOWLocalTextFileStoreRecord] due to [$Message]."
                Break
            }
            $ANOWDataSourceItem.key = $file_id
            $ANOWDataSourceItem.fileName = $uploaded_filename
            $ANOWDataSourceItem.mimeType = $mime_type
            $ANOWDataSourceItem.size = $content_length
            [string]$content = [char[]]$file_bytes -join ''
            [string]$formatted_content = [System.Uri]::UnescapeDataString($content)
            $ANOWDataSourceItem.content = $formatted_content
            [string]$BodyObject = ConvertTo-QueryString -InputObject $ANOWDataSourceItem -IncludeProperties key, fileName, mimeType, size, content
            $BodyMetaData.'masterDataSource' = "$DataSource_Id"
            $BodyMetaData.'_componentId' = 'LocalTextFileStoreRecordEditForm'
            $BodyMetaData.'_dataSource' = 'LocalTextFileStoreRecordDataSource'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'add'
            $BodyMetaData.'_oldValues' = '{}'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$BodyMetaDataString = ConvertTo-QueryString -InputObject $BodyMetaData
            [string]$Body = ($BodyObject + '&' + $BodyMetaDataString)
            $parameters.Add('Body', $Body)
        }
        Else {
            Write-Warning -Message "Failed to determine DataSourceItem type!"
            Break
        }
        $parameters.Add('Command', $command)
        [string]$parameters_display = $parameters | ConvertTo-Json -Compress
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        Write-Verbose -Message "DataSourceItem item added"
        If ($Quiet -ne $true) {
            Return $DataSourceItem
        }
    }
}

Function Remove-AutomateNOWDataSourceItem {
    <#
    .SYNOPSIS
    Removes a DataSourceItem from an AutomateNOW! instance

    .DESCRIPTION
    Removes a DataSourceItem from an AutomateNOW! instance

    .PARAMETER DataSourceItem
    An [ANOWDataSourceItem] object representing the DataSourceItem to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWDataSourceItem] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Get-AutomateNOWDataSource -Id 'DataSource01' | Read-AutomateNOWDataSourceItem | Remove-AutomateNOWDataSourceItem

    .EXAMPLE
    @( 'DataSource01', 'DataSource02' ) | Get-AutomateNOWDataSource | Read-AutomateNOWDataSourceItem | Remove-AutomateNOWDataSourceItem -Force

    .EXAMPLE
    Get-AutomateNOWDataSource | Where-Object { $_.createdBy -eq 'me'} | Read-AutomateNOWDataSourceItem | Remove-AutomateNOWDataSourceItem

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWDataSourceItem]$DataSourceItem,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWDataSourceItem]$DataSourceItem = $_
        }
        [string]$DataSourceItem_id = $DataSourceItem.id
        If ($DataSourceItem_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If ($DataSourceItem -is [ANOWLocalDictionaryRecord]) {
            [string]$command = '/localDictionaryRecord/delete'
            [string]$componentId = 'LocalDictionaryRecordList'
            [string]$dataSource = 'LocalDictionaryRecordDataSource'
        }
        ElseIf ($DataSourceItem -is [ANOWLocalKeyValueStoreRecord]) {
            [string]$command = '/localKeyValueStoreRecord/delete'
            [string]$componentId = 'LocalKeyValueStoreRecordList'
            [string]$dataSource = 'LocalKeyValueStoreRecordDataSource'
        }
        ElseIf ($DataSourceItem -is [ANOWLocalFileStoreRecord]) {
            [string]$command = '/localFileStoreRecord/delete'
            [string]$componentId = 'LocalFileStoreRecordList'
            [string]$dataSource = 'LocalFileStoreRecordDataSource'
        }
        ElseIf ($DataSourceItem -is [ANOWLocalTextFileStoreRecord]) {
            [string]$command = '/localTextFileStoreRecord/delete'
            [string]$componentId = 'LocalTextFileStoreRecordList'
            [string]$dataSource = 'LocalTextFileStoreRecordDataSource'
        }
        Else {
            Write-Warning -Message "Unable to determine DataSourceItem type"
            Break
        }
        If ($null -ne $parameters.Command) {
            $parameters.Remove('Command')
        }
        $parameters.Add('Command', $command)
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($DataSourceItem_id)")) -eq $true) {
            [string]$oldvalues = $DataSourceItem.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $DataSourceItem_id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = $componentId
            $BodyMetaData.'_dataSource' = $dataSource
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$DataSourceItem_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "DataSourceItem $DataSourceItem_id successfully removed"
        }
    }
    End {

    }
}

Function Edit-AutomateNOWDataSourceItem {
    <#
    .SYNOPSIS
    Edits a specified DataSourceItem from an AutomateNOW! instance

    .DESCRIPTION
    Edits a specified DataSourceItem from an AutomateNOW! instance (Only Local Dictionary & Local Key Value DataStores are supported, Text Files & Binary Files are not supported yet)

    .PARAMETER DataSourceItem
    An [ANOWDataSourceItem] object representing the DataSourceItem to be deleted.

    .INPUTS
    One [ANOWDataSourceItem] object is accepted, including from the pipeline

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Forcibly sets the value of a specific key in a LOCAL_KEY_VALUE_STORE DataSourceItem to '123'

    Get-AutomateNOWDataSource -Id 'DataSource1' | Read-AutomateNOWDataSourceItem | Where-Object { $_.Id -eq '16a428be-82af-4d71-85ce-2e77cbeb0b74'} | Edit-AutomateNOWDataSourceItem -dataSourceType LOCAL_KEY_VALUE_STORE -Value '123' -Force

    .EXAMPLE
    Sets the "display value" of a specific dictionary entry in a LOCAL_DICTIONARY DataSourceItem to '123' and the "value" to "MyValue"
    Get-AutomateNOWDataSource -Id 'DataSource1' | Read-AutomateNOWDataSourceItem | Where-Object { $_.Id -eq '131ac757-9087-4008-8fa1-8ec8ec2b1215'} | Edit-AutomateNOWDataSourceItem -displayValue '123' -Value 'MyValue' -dataSourceType LOCAL_DICTIONARY

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Supported DataSource Item types for this function: LOCAL_DICTIONARY; LOCAL_KEY_VALUE_STORE;
    Not supported DataSource Item types for this function: LOCAL_FILE_STORE; LOCAL_TEXT_FILE_STORE;

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High', DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'Default', ValueFromPipeline = $true)]
        [Parameter(Mandatory = $true, ParameterSetName = 'LOCAL_KEY_VALUE_STORE', ValueFromPipeline = $true)]
        [Parameter(Mandatory = $true, ParameterSetName = 'LOCAL_DICTIONARY', ValueFromPipeline = $true)]
        [Parameter(Mandatory = $true, ParameterSetName = 'LOCAL_TEXT_FILE_STORE', ValueFromPipeline = $true)]
        [Parameter(Mandatory = $true, ParameterSetName = 'LOCAL_FILE_STORE', ValueFromPipeline = $true)]
        [ANOWDataSourceItem]$DataSourceItem,
        [Parameter(Mandatory = $true, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $true, ParameterSetName = 'LOCAL_KEY_VALUE_STORE')]
        [Parameter(Mandatory = $true, ParameterSetName = 'LOCAL_DICTIONARY')]
        [Parameter(Mandatory = $true, ParameterSetName = 'LOCAL_TEXT_FILE_STORE')]
        [Parameter(Mandatory = $true, ParameterSetName = 'LOCAL_FILE_STORE')]
        [ANOWDataSource_dataSourceType]$dataSourceType, #LOCAL_DICTIONARY; LOCAL_KEY_VALUE_STORE; LOCAL_FILE_STORE; LOCAL_TEXT_FILE_STORE;
        [Parameter(Mandatory = $true, ParameterSetName = 'LOCAL_DICTIONARY')]
        [Parameter(Mandatory = $true, ParameterSetName = 'LOCAL_KEY_VALUE_STORE')]
        [string]$value,
        [Parameter(Mandatory = $true, ParameterSetName = 'LOCAL_DICTIONARY')]
        [string]$displayValue,
        [Parameter(Mandatory = $true, ParameterSetName = 'LOCAL_FILE_STORE')]
        [Parameter(Mandatory = $true, ParameterSetName = 'LOCAL_TEXT_FILE_STORE')]
        [string]$file_id,
        [Parameter(Mandatory = $true, ParameterSetName = 'LOCAL_TEXT_FILE_STORE')]
        [System.IO.FileSystemInfo]$text_file,
        [ValidateScript({ (Test-Path -Path $_.FullName) -eq $true })]
        [Parameter(Mandatory = $true, ParameterSetName = 'LOCAL_FILE_STORE')]
        [System.IO.FileSystemInfo]$binary_file,
        [Parameter(Mandatory = $true, ParameterSetName = 'LOCAL_FILE_STORE')]
        [string]$mime_type,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'LOCAL_KEY_VALUE_STORE')]
        [Parameter(Mandatory = $true, ParameterSetName = 'LOCAL_DICTIONARY')]
        [Parameter(Mandatory = $true, ParameterSetName = 'LOCAL_TEXT_FILE_STORE')]
        [Parameter(Mandatory = $true, ParameterSetName = 'LOCAL_FILE_STORE')]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($dataSourceType -in ('LOCAL_FILE_STORE', 'LOCAL_TEXT_FILE_STORE')) {
            Write-Warning -Message "[$dataSourceType] dataSourceType is not supported yet"
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWDataSourceItem]$DataSourceItem = $_
        }
        [string]$DataSourceItem_id = $DataSourceItem.id
        If ($DataSourceItem_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($DataSourceItem_id)")) -eq $true) {
            [string]$oldvalues = $DataSourceItem.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            If ($DataSourceItem -is [ANOWLocalDictionaryRecord]) {
                [string]$command = '/localDictionaryRecord/update'
                [string]$componentId = 'LocalDictionaryRecordEditForm'
                [string]$dataSource = 'LocalDictionaryRecordDataSource'
                $BodyMetaData.'value' = $value
                $BodyMetaData.'displayValue' = $displayValue
            }
            ElseIf ($DataSourceItem -is [ANOWLocalKeyValueStoreRecord]) {
                [string]$command = '/localKeyValueStoreRecord/update'
                [string]$componentId = 'LocalKeyValueStoreRecordEditForm'
                [string]$dataSource = 'LocalKeyValueStoreRecordDataSource'
                $BodyMetaData.'value' = $value
            }
            ElseIf ($DataSourceItem -is [ANOWLocalFileStoreRecord]) {
                [string]$command = '/localFileStoreRecord/update'
                [string]$componentId = 'LocalFileStoreRecordEditForm'
                [string]$dataSource = 'LocalFileStoreRecordDataSource'
                [string]$file_id = $DataSourceItem.file_id
                If ($file_id.length -eq 0) {
                    Write-Warning -Message "Somehow the LOCAL_KEY_VALUE_STORE object you passed did not include a file_id. This is not possible. Please look into it. Are you debugging?"
                    Break
                }
                [ANOWLocalFileStoreRecord[]]$current_items = Read-AutomateNOWDataSourceItem -DataSource $DataSource
                If ($file_id -notin $current_items.key) {
                    Write-Warning -Message "A file with the file_id [$file_id] DOES NOT ALREADY Exist in this local file store $DataSource_Id. This is not possible to edit."
                    Break
                }
                [hashtable]$get_file_parameters = @{}
                If ($PSVersionTable.PSVersion.Major -eq 5) {
                    $get_file_parameters.Add('Encoding', 'Byte')
                    $get_file_parameters.Add('Raw', $true)
                }
                Else {
                    $get_file_parameters.Add('AsByteStream', $true)
                }
                [string]$binary_file_fullname = $binary_file.fullname
                $get_file_parameters.Add('Path', "$binary_file_fullname")
                $Error.Clear()
                Try {
                    [byte[]]$file_bytes = Get-Content @get_file_parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-Content failed to import the file $binary_file_fullname due to [$Message]."
                    Break
                }
                [string]$object_id = $DataSource.id
                [string]$uploaded_filename = $binary_file.name
                [string]$boundary_string = New-WebkitBoundaryString
                [System.Collections.ArrayList]$form_prefix = New-Object -TypeName System.Collections.ArrayList
                [void]$form_prefix.Add("------WebKitFormBoundary$boundary_string")
                [void]$form_prefix.Add("Content-Disposition: form-data; name=`"id`"" + $cr + $cr)
                [void]$form_prefix.Add("------WebKitFormBoundary$boundary_string")
                [void]$form_prefix.Add("Content-Disposition: form-data; name=`"key`"" + $cr)
                [void]$form_prefix.Add($file_id)
                [void]$form_prefix.Add("------WebKitFormBoundary$boundary_string")
                [void]$form_prefix.Add("Content-Disposition: form-data; name=`"masterDataSource`"" + $cr)
                [void]$form_prefix.Add($object_id)
                [void]$form_prefix.Add("------WebKitFormBoundary$boundary_string")
                [void]$form_prefix.Add("Content-Disposition: form-data; name=`"uploadWindow`"" + $cr)
                [void]$form_prefix.Add("isc_InfiniteWindow_0")
                [void]$form_prefix.Add("------WebKitFormBoundary$boundary_string")
                [void]$form_prefix.Add("Content-Disposition: form-data; name=`"access_token`"" + $cr)
                [void]$form_prefix.Add($anow_session.AccessToken)
                [void]$form_prefix.Add("------WebKitFormBoundary$boundary_string")
                [void]$form_prefix.Add("Content-Disposition: form-data; name=`"file`"; filename=`"$uploaded_filename`"")
                [void]$form_prefix.Add("Content-Type: $mime_type" + $cr + $cr)
                [System.Collections.ArrayList]$form_suffix = New-Object -TypeName System.Collections.ArrayList
                [void]$form_suffix.Add($cr + "------WebKitFormBoundary$boundary_string--" + $cr)
                [string]$body_prefix = $form_prefix -join $cr
                [string]$body_suffix = $form_suffix -join ''
                [byte[]]$body_prefix_bytes = [System.Text.Encoding]::UTF8.GetBytes($body_prefix)
                [byte[]]$body_suffix_bytes = [System.Text.Encoding]::UTF8.GetBytes($body_suffix)
                [byte[]]$body = $body_prefix_bytes + $file_bytes + $body_suffix_bytes
                [int32]$content_length = $body.count
                [string]$domain = $anow_session.header.domain
                [string]$command = "/localFileStoreRecord/uploadFile?domain=$domain"
                $parameters.Add('ContentType', "multipart/form-data; boundary=----WebKitFormBoundary$boundary_string")
                $Error.Clear()
                Try {
                    [ANOWLocalFileStoreRecord]$ANOWDataSourceItem = New-Object -TypeName ANOWLocalFileStoreRecord
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "New-Object failed to create the object of type [ANOWLocalFileStoreRecord] due to [$Message]."
                    Break
                }
                $ANOWDataSourceItem.key = $file_id
                [string]$BodyObject = ConvertTo-QueryString -InputObject $ANOWDataSourceItem -IncludeProperties key
                $parameters.Add('BinaryBody', $Body)
                $parameters.Add('Headers', [hashtable]@{"Content-Length" = $content_length; "Upgrade-Insecure-Requests" = 1; }) # is this header really needed?
            }
            ElseIf ($DataSourceItem -is [ANOWLocalTextFileStoreRecord]) {
                [string]$command = '/localTextFileStoreRecord/update'
                [string]$componentId = 'LocalTextFileStoreRecordEditForm'
                [string]$dataSource = 'LocalTextFileStoreRecordDataSource'
                If ($file_id.length -eq 0) {
                    Write-Warning -Message "Please include the -file_id parameter with LOCAL_TEXT_FILE_STORE type"
                    Break
                }
                If ($mime_type -notmatch '^[a-z-]{1,}\/[a-z0-9-.+]{1,}$') {
                    Write-Warning -Message "[$mime_type] does not appear to be a valid mime type. Please, check the mime type or contact the author of this script if there is a mistake."
                    Break
                }
                [ANOWLocalTextFileStoreRecord[]]$current_items = Read-AutomateNOWDataSourceItem -DataSource $DataSource
                If ($file_id -in $current_items.key) {
                    Write-Warning -Message "A file with the file_id [$file_id] already exists in this local file store $DataSource_Id. Please note that every file_id in a local file store must be unique (the contents do not need to be unique)"
                    Break
                }
                [hashtable]$get_file_parameters = @{}
                If ($PSVersionTable.PSVersion.Major -eq 5) {
                    $get_file_parameters.Add('Encoding', 'Byte')
                    $get_file_parameters.Add('Raw', $true)
                }
                Else {
                    $get_file_parameters.Add('AsByteStream', $true)
                }
                [string]$text_file_fullname = $text_file.fullname
                $get_file_parameters.Add('Path', "$text_file_fullname")
                $Error.Clear()
                Try {
                    [byte[]]$file_bytes = Get-Content @get_file_parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-Content failed to import the file $text_file_fullname due to [$Message]."
                    Break
                }
                [string]$object_id = $DataSource.id
                [string]$uploaded_filename = $text_file.name
                If ((($file_bytes | Sort-Object -Unique) | ForEach-Object { $_ -eq 10 -or $_ -eq 13 -or ( $_ -ge 32 -and $_ -le 126) }) -contains $false) {
                    [string]$mime_type = 'text/plain;charset=UTF-8'
                }
                Else {
                    [string]$mime_type = 'text/plain'
                }
                [int32]$content_length = $file_bytes.count
                [string]$domain = $anow_session.header.domain
                [string]$command = "/localTextFileStoreRecord/create"
                $parameters.Add('ContentType', "application/x-www-form-urlencoded; charset=UTF-8")
                $Error.Clear()
                Try {
                    [ANOWLocalTextFileStoreRecord]$ANOWDataSourceItem = New-Object -TypeName ANOWLocalTextFileStoreRecord
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "New-Object failed to create the object of type [ANOWLocalTextFileStoreRecord] due to [$Message]."
                    Break
                }
                $ANOWDataSourceItem.key = $file_id
                $ANOWDataSourceItem.fileName = $uploaded_filename
                $ANOWDataSourceItem.mimeType = $mime_type
                $ANOWDataSourceItem.size = $content_length
                [string]$content = [char[]]$file_bytes -join ''
                [string]$formatted_content = [System.Uri]::UnescapeDataString($content)
                $ANOWDataSourceItem.content = $formatted_content
                [string]$BodyObject = ConvertTo-QueryString -InputObject $ANOWDataSourceItem -IncludeProperties key, fileName, mimeType, size, content
                $BodyMetaData.'masterDataSource' = "$DataSource_Id"
                $BodyMetaData.'_componentId' = 'LocalTextFileStoreRecordEditForm'
                $BodyMetaData.'_dataSource' = 'LocalTextFileStoreRecordDataSource'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_oldValues' = '{}'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$BodyMetaDataString = ConvertTo-QueryString -InputObject $BodyMetaData
                [string]$Body = ($BodyObject + '&' + $BodyMetaDataString)
                $parameters.Add('Body', $Body)

                ####

            }
            Else {
                Write-Warning -Message "Unable to determine DataSourceItem type"
                Break
            }
            If ($null -ne $parameters.Command) {
                $parameters.Remove('Command')
            }
            $parameters.Add('Command', $command)
            $BodyMetaData.'id' = $DataSourceItem_id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'update'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = $componentId
            $BodyMetaData.'_dataSource' = $dataSource
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$DataSourceItem_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "DataSourceItem $DataSourceItem_id successfully updated"
        }
    }
    End {

    }
}

#endregion

#Region - Deleted Domains

Function Get-AutomateNOWDeletedDomain {
    <#
    .SYNOPSIS
    Gets the deleted domains from an instance of AutomateNOW!

    .DESCRIPTION
    Gets the deleted domains from an instance of AutomateNOW!

    .PARAMETER Id
    Optional string array to specify the Id (or name) of the deleted domain to retrieve.

    .PARAMETER startRow
    An optional int32 representing what row to start the download from. This is intended for multi-page transfers.

    .PARAMETER endRow
    An optional int32 representing how many rows of data to receive. The default is 100. This is ideal for testing when you only want a few items.

    .INPUTS
    Accepts a string Id (or a series of them)

    .OUTPUTS
    An array of [ANOWDeletedDomain] class objects

    .EXAMPLE
    Gets the first page of Deleted Domains

    Get-AutomateNOWDeletedDomain

    .EXAMPLE
    Gets a Deleted Domain by Id named 'Domain1'

    Get-AutomateNOWDeletedDomain -Id 'Domain1'

    .EXAMPLE
    Gets the first page of deleted domains

    Get-AutomateNOWDeletedDomain

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWDomain[]])]
    [Cmdletbinding( DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $false, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
        [string]$command = '/deletedDomain/read?'
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$BodyObject = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 -or $Id.Length -gt 0) {
            If ($_.Length -gt 0) {
                [string]$domain_id = $_
            }
            Else {
                [string]$domain_id = $Id
            }
            [string]$textMatchStyle = 'exactCase'
            $BodyObject.'id' = $domain_id
            $BodyObject.'_operationId' = 'read'
        }
        Else {
            $BodyObject.'_startRow' = $startRow
            $BodyObject.'_endRow' = $endRow
            [string]$textMatchStyle = 'exact'
        }
        $BodyObject.'_operationType' = 'fetch'
        $BodyObject.'_textMatchStyle' = $textMatchStyle
        $BodyObject.'_componentId' = 'DeletedDomainList'
        $BodyObject.'_dataSource' = 'DeletedDomainDataSource'
        $BodyObject.'isc_metaDataPrefix' = '_'
        $BodyObject.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $BodyObject
        [string]$command = ($command + $Body)
        If ($null -ne $parameters["Command"]) {
            $parameters.'Command' = $command
        }
        Else {
            $parameters.Add('Command', $command)
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        If ($results.response.data.count -gt 0) {
            $Error.Clear()
            Try {
                [ANOWDeletedDomain[]]$DeletedDomains = $results.response.data
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the response into [ANOWDeletedDomain] objects due to [$Message]."
                Break
            }
            Return $DeletedDomains
        }
    }
    End {

    }
}

Function Export-AutomateNOWDeletedDomain {
    <#
    .SYNOPSIS
    Exports the deleted domains from an instance of AutomateNOW! This is not the same as downloading the deleted domain!

    .DESCRIPTION
    Exports the domains from an instance of AutomateNOW! to a local .csv file

    .PARAMETER DeletedDomain
    Mandatory [ANOWDeletedDomain] object (Use Get-AutomateNOWDeletedDomain to retrieve them)

    .INPUTS
    ONLY [ANOWDeletedDomain] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWDeletedDomain] objects are exported to the local disk in CSV format

    .EXAMPLE
    Get-AutomateNOWDeletedDomain | Export-AutomateNOWDeletedDomain

    .EXAMPLE
    Get-AutomateNOWDeletedDomain -Id 'Domain1' | Export-AutomateNOWDeletedDomain

    .EXAMPLE
    'Domain1', 'Domain2' | Get-AutomateNOWDeletedDomain | Export-AutomateNOWDeletedDomain

    .NOTES
	You must present [ANOWDomain] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWDeletedDomain]$DeletedDomain
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-DeletedDomains-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWDeletedDomain]$DeletedDomain = $_
        }
        $Error.Clear()
        Try {
            $DeletedDomain | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWDeletedDomain] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function Save-AutomateNOWDeletedDomain {
    <#
    .SYNOPSIS
    Downloads and saves a Deleted Domain from an AutomateNOW! instance and writes it to .json file.

    .DESCRIPTION
    Downloads and saves a Deleted Domain from an AutomateNOW! instance and writes it to .json file.

    .PARAMETER DeletedDomain
    An [ANOWDeletedDomain] object representing the Deleted Domain to be downloaded to .json file.

    .PARAMETER DestinationFilepath
    Optional path for the .json export file to be written to. Use this if you want the exported JSON file to be written somewhere other than the current path.

    .PARAMETER OverwriteExportFile
    Switch parameter that will force the exported file to be overwritten if it exists

    .INPUTS
    ONLY [ANOWDeletedDomain] objects are accepted (including from the pipeline)

    .OUTPUTS
    A verbose information message will be sent indicating success

    .EXAMPLE
    Saves a Deleted Domain named 'Domain1' to disk

    Get-AutomateNOWDeletedDomain -Id 'Domain1' | Save-AutomateNOWDeletedDomain

    .EXAMPLE
    Saves the first page of Deleted Domains to disk while overwriting the exported file if it exists

    Get-AutomateNOWDeletedDomain | Save-AutomateNOWDeletedDomain -OverwriteExportFile

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWDeletedDomain]$DeletedDomain,
        [ValidateScript({ (Test-Path -Path "$_") -eq $true })]
        [Parameter(Mandatory = $false)]
        [string]$DestinationPath,
        [Parameter(Mandatory = $false)]
        [switch]$OverwriteExportFile
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWDeletedDomain]$DeletedDomain = $_
        }
        [int64]$DeletedDomain_DataSize = $DeletedDomain.dataSize
        If ($DeletedDomain_DataSize -eq 0) {
            Write-Warning -Message "Somehow this Deleted Domain has a datasize of 0? Something is wrong..."
            Break
        }
        If ($DeletedDomain_DataSize -lt 1024) {
            [string]$DeletedDomain_DisplaySize = ("$DeletedDomain_DataSize" + ' B')
        }
        ElseIf ($DeletedDomain_DataSize -lt 1048576) {
            [string]$DeletedDomain_DataSize = [math]::Round(($DeletedDomain_DataSize / 1024), 2)
            [string]$DeletedDomain_DisplaySize = ("$DeletedDomain_DataSize" + ' kB')
        }
        Else {
            [string]$DeletedDomain_DataSize = [math]::Round(($DeletedDomain_DataSize / 1048576), 2)
            [string]$DeletedDomain_DisplaySize = ("$DeletedDomain_DataSize" + ' MB')
        }
        [string]$DeletedDomain_id = $DeletedDomain.id
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [ANOWDeletedDomain]$current_DeletedDomain = Get-AutomateNOWDeletedDomain -Id $DeletedDomain_id
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWDeletedDomain failed to check if the Deleted Domain [$DeletedDomain_id] existed under Save-AutomateNOWDeletedDomain due to [$Message]."
            Break
        }
        If ($current_DeletedDomain.id.length -eq 0) {
            Write-Warning -Message "The Deleted Domain you specified does not seem to exist (under Save-AutomateNOWDeletedDomain)"
            Break
        }
        ## End warning ##
        Write-Information -MessageData "Downloading Deleted Domain [$DeletedDomain_id] with expected filesize: $DeletedDomain_DisplaySize"
        [string]$command = ('/deletedDomain/downloadFile?id=' + $DeletedDomain_id)
        If ($null -ne $parameters["Command"]) {
            $parameters.'command' = $command
        }
        Else {
            $parameters.Add('Command', $command)
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$DeletedDomain_id] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [string]$DeletedDomain_JSON = $results | ConvertTo-Json -Compress -Depth 100
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "ConvertTo-Json failed to convert the download of [$DeletedDomain_id] to JSON due to [$Message]."
            Break
        }
        If ($DestinationPath.Length -eq 0) {
            [string]$DestinationPath = '.'
        }
        [string]$outgoing_filename = ($DeletedDomain_id + '.json')
        [string]$ExportFilePath = Join-Path -Path $DestinationPath -ChildPath $outgoing_filename
        [boolean]$outgoing_file_exists = Test-Path -Path "$ExportFilePath"
        If ($outgoing_file_exists -eq $true -and $OverwriteExportFile -ne $true) {
            Write-Warning -Message "The export file $outgoing_filename already exists at $DestinationPath. Use the -OverwriteExportFile switch parameter to bypass this exception and overwrite the file."
            Break
        }
        $Error.Clear()
        [hashtable]$parameters2 = @{}
        $parameters2.Add('InputObject', $DeletedDomain_JSON)
        $parameters2.Add('Path', $ExportFilePath)
        $parameters2.Add('NoNewLine', $true)
        If ($OverwriteExportFile -eq $true) {
            $parameters2.Add('Force', $true)
        }
        Try {
            Out-File @parameters2
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Out-File failed to write the outgoing file [$outgoing_filename] to disk (under Save-AutomateNOWDeletedDomain) due to [$Message]."
            Break
        }
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Successfully saved Deleted Domain [$DeletedDomain_id] to disk as: $outgoing_filename - $filelength_display bytes"
        }
    }
    End {

    }
}

#endregion

#Region - Deleted Objects

Function Get-AutomateNOWDeletedObject {
    <#
    .SYNOPSIS
    Gets the Deleted Objects from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Deleted Objects from an AutomateNOW! instance

    .PARAMETER Id
    Optional CASE-SENSITIVE string containing the 36-character GUID (Id) of the specific Deleted Object

    .PARAMETER itemId
    Optional CASE-SENSITIVE string containing the ItemId of the specific Deleted Object. This is the same as the Id of the object before it was deleted.

    .PARAMETER DeletedBy
    Optional CASE-SENSITIVE string containing the DeletedBy of the specific Deleted Object. This is the Id of the user that deleted the object.

    .PARAMETER ItemType
    Optional string to filter by domain class. See enum ANOWCodeRepositoryObjectSourceCode_domainClassName for valid values.

    .PARAMETER startRow
    Integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER Folder
    Optional string to filter by a particular Folder (case-sensitive)

    .PARAMETER Tags
    Optional string array of Tags to filter by. Note that by default only one Tag needs to be present. Use the -AllTags switch parameter to require all Tags.

    .PARAMETER AllTags
    Optional switch parameter to indicate that all Tags must be present.

    .INPUTS
    Inputs are not required. This function accepts one more strings representing the GUID (Id) of the Deleted Object or the ItemType can be specified.

    .OUTPUTS
    An array of one or more [ANOWDeletedObject] class objects

    .EXAMPLE
    Gets the first page of Deleted Objects

    Get-AutomateNOWDeletedObject

    .EXAMPLE
    Gets the first 10,000 Deleted Objects

    Get-AutomateNOWDeletedObject -startRow 0 -endRow 10000

    .EXAMPLE
    Gets a specific Deleted Object by its Id

    Get-AutomateNOWDeletedObject -Id '3a6db63b-d590-4b53-9921-966f279fd501'

    .EXAMPLE
    Gets a specific Deleted Object by its itemId

    Get-AutomateNOWDeletedObject -itemId 'MyScript'

    .EXAMPLE
    Gets the first 10,000 Deleted Objects of type Endpoint

    Get-AutomateNOWDeletedObject -itemType Endpoint -startRow 0 -endRow 10000

    .EXAMPLE
    Gets the first page of Deleted Objects of type Tag deleted by 'User1'

    Get-AutomateNOWDeletedObject -itemType Tag -DeletedBy 'User1'

    .EXAMPLE
    Gets the first 10,000 Deleted Objects that were deleted by 'User1'

    Get-AutomateNOWDeletedObject -DeletedBy 'User1' -startRow 0 -endRow 10000

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWDeletedObject[]])]
    [Cmdletbinding(DefaultParameterSetName = 'All')]
    Param(
        [ValidateScript({ $_ -cmatch '[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}' })]
        [Parameter(Mandatory = $True, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $True, ParameterSetName = 'ItemId')]
        [string]$itemId,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [string]$DeletedBy,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [ANOWCodeRepositoryObjectSourceCode_domainClassName]$ItemType,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [string]$Folder,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [string[]]$Tags,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [switch]$AllTags
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($Tags.Count -le 1 -and $AllTags -eq $true) {
            Write-Warning -Message "Please do not use -AllTags unless you are specifying two or more Tags."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
        If ($AllLoadBalancers -eq $true -and $AllChildNodes -eq $true) {
            Write-Warning -Message "You can't request only load balancer and then only load balancer nodes in the same request. Please choose one or the other."
            Break
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If (($_.Length -gt 0 -or $Id.Length -gt 0) ) {
            If ($_.Length -gt 0) {
                $Body.'id' = $_
            }
            Else {
                $Body.'id' = $Id
            }
            [string]$textMatchStyle = 'exactCase'
        }
        ElseIf ($itemId.Length -gt 0) {
            $Body.'itemId' = $itemId
            [string]$textMatchStyle = 'exactCase'
        }
        Else {
            $Body.'operator' = 'and'
            $Body.'_componentId' = 'DeletedObjectsList'
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
            [string]$textMatchStyle = 'substring'
            If ($ItemType.Length -gt 0 -or $DeletedBy.Length -gt 0) {
                $Body.'_constructor' = 'AdvancedCriteria'
                $Body.'_operationId' = 'read'
                If ($ItemType.Length -gt 0) {
                    $Body.'criteria1' = ('{"fieldName":"domainClass","operator":"iContains","value":"' + $ItemType + '"}')
                }
                If ($DeletedBy.Length -gt 0) {
                    $Body.'criteria2' = ('{"fieldName":"deletedBy","operator":"equals","value":"' + $DeletedBy + '"}')
                }
            }
        }
        $Body.'_operationId' = 'read'
        $Body.'_operationType' = 'fetch'
        $Body.'_textMatchStyle' = $textMatchStyle
        $Body.'_dataSource' = 'DeletedObjectDataSource'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/deletedObject/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWDeletedObject[]]$DeletedObjects = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWDeleteObject] objects due to [$Message]."
            Break
        }
        If ($DeletedObjects.Count -gt 0) {
            If ($Folder.Length -gt 0 -or $Tags.Count -gt 0) {
                [PSCustomObject[]]$DeletedObjectDefinitionCache = $DeletedObjects | ForEach-Object { [PSCustomObject]@{ Id = $_.Id; Definition = ( $_.definition -replace '"Failed":', '"FAILED":' | ConvertFrom-Json ); } }
                [PSCustomObject[]]$DeletedObjectDefinitionCache = $DeletedObjectDefinitionCache | ForEach-Object { [PSCustomObject]@{ Id = $_.Id; Definition = $_.definition ; Folder = $_.definition.Folder; Tags = $_.definition.Tags; } }
                If ($Folder.Length -gt 0) {
                    [PSCustomObject[]]$DeletedObjectDefinitionCache = $DeletedObjectDefinitionCache | Where-Object { $_.Folder -ceq $Folder }
                }
                If ($Tags.Count -gt 0) {
                    If ($AllTags -eq $true) {
                        [int32]$Tags_Count = $Tags.Count
                        [PSCustomObject[]]$DeletedObjectDefinitionCache = $DeletedObjectDefinitionCache | Where-Object { ( Compare-Object -ReferenceObject ($_.Tags) -DifferenceObject $Tags -IncludeEqual | Where-Object { $_.SideIndicator -eq '==' } | Measure-Object | Select-Object -ExpandProperty Count ) -ge $Tags_Count }
                    }
                    Else {
                        [PSCustomObject[]]$DeletedObjectDefinitionCache = $DeletedObjectDefinitionCache | Where-Object { ( Compare-Object -ReferenceObject ($_.Tags) -DifferenceObject $Tags -IncludeEqual | Where-Object { $_.SideIndicator -eq '==' } | Measure-Object | Select-Object -ExpandProperty Count ) -gt 0 }
                    }
                }
                If ($DeletedObjectDefinitionCache.Count -gt 0) {
                    [ANOWDeletedObject[]]$DeletedObjects = $DeletedObjects | Where-Object { $_.id -in ($DeletedObjectDefinitionCache.id) }
                }
            }
            Return $DeletedObjects
        }
    }
    End {

    }
}

Function Export-AutomateNOWDeletedObject {
    <#
    .SYNOPSIS
    Exports the Deleted Objects from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Deleted Objects from an instance of AutomateNOW! to a local .csv file

    .PARAMETER DeletedObject
    Mandatory [ANOWDeletedObject] object (Use Get-AutomateNOWDeletedObject to retrieve them)

    .INPUTS
    ONLY [ANOWDeletedObject] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWDeletedObject] objects are exported to the local disk in CSV format

    .EXAMPLE
    Get-AutomateNOWDeletedObject | Export-AutomateNOWDeletedObject

    .EXAMPLE
    Get-AutomateNOWDeletedObject -Id '776db63b-d590-4b53-9921-966f279fd502' | Export-AutomateNOWDeletedObject

    .EXAMPLE
    '3a6db63b-d590-4b53-9921-966f279fd501', '776db63b-d590-4b53-9921-966f279fd502' | Get-AutomateNOWDeletedObject | Export-AutomateNOWDeletedObject

    .EXAMPLE
    Get-AutomateNOWDeletedObject -itemType Endpoint | Export-AutomateNOWDeletedObject

    .NOTES
	You must present [ANOWDeletedObject] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWDeletedObject]$DeletedObject
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-DeletedObjects-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWDeletedObject]$DeletedObject = $_
        }
        $Error.Clear()
        Try {
            $DeletedObject | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWDeletedObject] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function Remove-AutomateNOWDeletedObject {
    <#
    .SYNOPSIS
    Removes (permanently deletes) a Deleted Object from the Recycle Bin of an AutomateNOW! instance

    .DESCRIPTION
    Removes (permanently deletes) a Deleted Object from the Recycle Bin of an AutomateNOW! instance

    .PARAMETER DeletedObject
    An [ANOWDeletedObject] object representing the Deleted Object to be permanently deleted.

    .PARAMETER Force
    Force the removal (permanent deletion) without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWDeletedObject] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Removes (permanently deletes) the first page of Deleted Objects

    Get-AutomateNOWDeletedObject | Remove-AutomateNOWDeletedObject

    .EXAMPLE
    Removes (permanently deletes) 2 specific Deleted Objects by Id across the pipeline

    '3a6db63b-d590-4b53-9921-966f279fd501', '776db63b-d590-4b53-9921-966f279fd502' | Get-AutomateNOWDeletedObject | Remove-AutomateNOWDeletedObject

    .EXAMPLE
    Forcibly removes (permanently deletes) the first page of Deleted Objects of type Endpoint

    Get-AutomateNOWDeletedObject -itemType Endpoint | Remove-AutomateNOWDeletedObject -Force

    .EXAMPLE
    Forcibly removes (permanently deletes) the first page of Deleted Objects that were deleted by 'User1'

    Get-AutomateNOWDeletedObject -DeletedBy 'User1' | Remove-AutomateNOWDeletedObject -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWDeletedObject]$DeletedObject,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/deletedObject/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWDeletedObject]$DeletedObject = $_
        }
        [string]$DeletedObject_id = $DeletedObject.id
        If ($DeletedObject_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($DeletedObject_id)")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $DeletedObject_id
            $BodyMetaData.'_operationId' = 'delete'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_dataSource' = 'DeletedObjectDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$DeletedObject_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Deleted Object $DeletedObject_id was permanently deleted"
        }
    }
    End {

    }
}

Function Restore-AutomateNOWDeletedObject {
    <#
    .SYNOPSIS
    Restores (undeletes) a Deleted Object from an AutomateNOW! instance

    .DESCRIPTION
    Restores (undeletes) a Deleted Object from an AutomateNOW! instance

    .PARAMETER DeletedObject
    An [ANOWDeletedObject] object representing the object to be restored (undeleted).

    .PARAMETER Force
    Switch parameter that forces the restore without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Switch parameter to silence the output of the restored [ANOWDeletedObject] object.

    .INPUTS
    ONLY [ANOWDeletedObject] objects are accepted (including from the pipeline)

    .OUTPUTS
    An [ANOWDeletedObject] object representing the object that was restored will be returned.

    .EXAMPLE
    Forcibly and quietly restores (undeletes) an object formerly known as 'DeletedObject1'

    Get-AutomateNOWDeletedObject -itemId 'DeletedObject1' | Restore-AutomateNOWDeletedObject -Force -Quiet

    .EXAMPLE
    Restores (undeleted) the first page of Deleted Objects that were deleted by a user named 'User1'

    Get-AutomateNOWDeletedObject -DeletedBy 'User1' | Restore-AutomateNOWDeletedObject

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    If an object with the same name (Id) already exists then this API call will fail with the message "Object already exists. Undelete is cancelled."

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWDeletedObject]$DeletedObject,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/deletedObject/undelete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWDeletedObject]$DeletedObject = $_
        }
        [string]$DeletedObject_id = $DeletedObject.id
        If ($DeletedObject_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        [string]$DeletedObject_itemId = $DeletedObject.itemId
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$DeletedObject_id ($DeletedObject_itemId)?")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $DeletedObject_id
            $BodyMetaData.'_operationId' = 'undelete'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_dataSource' = 'DeletedObjectDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$DeletedObject_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Deleted Object $DeletedObject_id was successfully restored"
            $Error.Clear()
            Try {
                [ANOWDeletedObject]$DeletedObject = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the response into an [ANOWDeleteObject] object due to [$Message]."
                Break
            }
            If ($Quiet -ne $true) {
                Return $DeletedObject
            }
        }
    }
    End {

    }
}

#endregion

#Region - Design Templates

Function Get-AutomateNOWDesignTemplate {
    <#
    .SYNOPSIS
    Gets the Design Template Objects from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Design Template Objects from an AutomateNOW! instance

    .PARAMETER Id
    Optional string containing the Id of the specific Design Template

    .PARAMETER startRow
    Integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER sortBy
    Optional string parameter to sort the results by (may not be used with the Id parameter). Valid choices are: id*, dateCreated, lastUpdated, createdBy, defaultTemplate, processingType, serverNodeType, taskType, designTemplateType

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .INPUTS
    A single Id or a string of Id's across the pipeline will be accepted.

    .OUTPUTS
    Either one or more [ANOWDesignTemplate] objects

    .EXAMPLE
    Gets the first page of Design Template objects

    Get-AutomateNOWDesignTemplate

    .EXAMPLE
    Gets a single Design Template named 'DesignTemplate1'

    Get-AutomateNOWDesignTemplate -Id 'DesignTemplate1'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWDesignTemplate[]])]
    [Cmdletbinding(DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $True, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100,
        [ValidateSet('id', 'dateCreated', 'lastUpdated', 'createdBy', 'defaultTemplate', 'processingType', 'serverNodeType', 'taskType', 'designTemplateType', IgnoreCase = $false)]
        [Parameter(Mandatory = $False, ParameterSetName = 'Public')]
        [string]$sortBy = 'id',
        [Parameter(Mandatory = $False, ParameterSetName = 'Public')]
        [switch]$Descending
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
        If ($AllLoadBalancers -eq $true -and $AllChildNodes -eq $true) {
            Write-Warning -Message "You can't request only load balancer and then only load balancer nodes in the same request. Please choose one or the other."
            Break
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If (($_.Length -gt 0 -or $Id.Length -gt 0) ) {
            If ($_.Length -gt 0) {
                $Body.'id' = $_
            }
            Else {
                $Body.'id' = $Id
            }
            [string]$textMatchStyle = 'exactCase'
        }
        ElseIf ($itemId.Length -gt 0) {
            $Body.'itemId' = $itemId
            [string]$textMatchStyle = 'exactCase'
        }
        Else {
            $Body.'_constructor' = 'AdvancedCriteria'
            $Body.'operator' = 'and'
            $Body.'_componentId' = 'DesignTemplateList'
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
            [string]$textMatchStyle = 'exact'
            If ($Descending -eq $true) {
                $Body.'_sortBy' = '-' + $sortBy
            }
            Else {
                $Body.'_sortBy' = $sortBy
            }
        }
        $Body.'_operationId' = 'DesignTemplateDataSource_fetch'
        $Body.'_operationType' = 'fetch'
        $Body.'_textMatchStyle' = $textMatchStyle
        $Body.'_dataSource' = 'DesignTemplateDataSource'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/designTemplate/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWDesignTemplate[]]$DesignTemplates = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWDesignTemplate] objects due to [$Message]."
            Break
        }
        If ($DesignTemplates.Count -gt 0) {
            Return $DesignTemplates
        }
    }
    End {

    }
}

Function Set-AutomateNOWDesignTemplate {
    <#
    .SYNOPSIS
    Changes the settings of a Design Template on an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of a Design Template on an AutomateNOW! instance

    .PARAMETER ServerNodeEndpoint
    An [ANOWDesignTemplate] object representing the Design Template to be modified.

    .PARAMETER SetAsDefault
    A [boolean] parameter indicating if the Default status of the Design Template should be true or false.

    .PARAMETER Description
    Optional description of the Design Template (may not exceed 255 characters).

    .PARAMETER UnsetDescription
    Switch parameter that will remove the description.

    .PARAMETER templateDefinition
    Optional PSCustomObject to replace the current templateDefinition with (as JSON). You should use Edit-AutomateNOWDesignTemplate instead if you want to modify the templateDefinition.

    .PARAMETER Quiet
    An optional switch parameter that silences the output of this function

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWDesignTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWDesignTemplate] object will be returned

    .EXAMPLE
    Quietly changes the weight property (to 3) inside of the template definition within a Design Template named 'DesignTemplate1' (multi-line format)

    $design_template = Get-AutomateNOWDesignTemplate -Id 'DesignTemplate1'
    $template_definition = $design_template.templateDefinition
    $template_definition.weight = 3
    $design_template | Set-AutomateNOWDesignTemplate -templateDefinition $template_definition -Quiet

    .EXAMPLE
    Quietly and forcefully changes the description on a Design Template named 'DesignTemplate1' (one-liner format)

    Get-AutomateNOWDesignTemplate -Id 'DesignTemplate1' | Set-AutomateNOWDesignTemplate -Description 'New Description' -Force -Quiet

    .EXAMPLE
    Forcefully removes the default status from a Design Template named 'DesignTemplate1' (one-liner format)

    Set-AutomateNOWDesignTemplate -DesignTemplate (Get-AutomateNOWDesignTemplate -Id 'DesignTemplate1') -SetAsDefault $false -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The -SetAsDefault parameter cannot be combined with -Description or -templateDefinition

    #>
    [OutputType([ANOWDesignTemplate])]
    [Cmdletbinding(DefaultParameterSetName = 'Default', SupportsShouldProcess = $true, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'Default', ValueFromPipeline = $True)]
        [Parameter(Mandatory = $true, ParameterSetName = 'SetDefault', ValueFromPipeline = $True)]
        [ANOWDesignTemplate]$DesignTemplate,
        [Parameter(Mandatory = $false, ParameterSetName = 'SetDefault')]
        [Nullable[boolean]]$SetAsDefault,
        [ValidateScript({ $_.Length -le 255 })]
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [string]$Description,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [PSCustomObject]$templateDefinition,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        If ($SetAsDefault -eq $true) {
            [string]$command = '/designTemplate/setDefault'
        }
        ElseIf ($SetAsDefault -eq $false) {
            [string]$command = '/designTemplate/unsetDefault'
        }
        Else {
            [string]$command = '/designTemplate/update'
        }
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWDesignTemplate]$DesignTemplate = $_
        }
        [string]$DesignTemplate_id = $DesignTemplate.id
        If ($DesignTemplate.serviceManagerType.Length -gt 0) {
            [string]$DesignTemplateType = $DesignTemplate.serviceManagerType
            [string]$DesignTemplateSummary = "Service Manager Templates of type: $DesignTemplateType"
        }
        ElseIf ($DesignTemplate.workflowType.Length -gt 0) {
            [string]$DesignTemplateType = $DesignTemplate.workflowType
            [string]$DesignTemplateSummary = "Workflow Templates of type: $DesignTemplateType"
        }
        ElseIf ($DesignTemplate.triggerType.Length -gt 0) {
            [string]$DesignTemplateType = $DesignTemplate.processingType
            [string]$DesignTemplateSummary = "Schedule Templates of type: $DesignTemplateType"
        }
        ElseIf ($DesignTemplate.taskType.Length -gt 0) {
            [string]$DesignTemplateType = $DesignTemplate.taskType
            [string]$DesignTemplateSummary = "Task Templates of type: $DesignTemplateType"
        }
        Else {
            Write-Warning -Message "Somehow could not determine the type of Processing Template for $DesignTemplate_id"
            Break
        }
        If ($SetAsDefault -eq $true -and $DesignTemplate.defaultTemplate -eq $true) {
            Write-Warning -Message "$DesignTemplate_id is already the default Design Template for $DesignTemplateSummary (No action is required)"
            Break
        }
        ElseIf ($SetAsDefault -eq $false -and $DesignTemplate.defaultTemplate -eq $false) {
            Write-Warning -Message "$DesignTemplate_id is already not the default Design Template for $DesignTemplateSummary (No action is required)"
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$DesignTemplate_id")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$DesignTemplate_exists = ($null -eq (Get-AutomateNOWDesignTemplate -Id $DesignTemplate_id))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWDesignTemplate failed to check if the Design Template [$DesignTemplate_id] under Set-AutomateNOWDesignTemplate already existed due to [$Message]."
                Break
            }
            If ($DesignTemplate_exists -eq $true) {
                Write-Warning -Message "There is not a Design Template named $DesignTemplate_id"
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            If ($SetAsDefault -eq $true) {
                $BodyMetaData.'_operationId' = 'setDefault'
            }
            ElseIf ($SetAsDefault -eq $false) {
                $BodyMetaData.'_operationId' = 'unsetDefault'
            }
            $BodyMetaData.'id' = $DesignTemplate_id
            If ($Description.Length -gt 0) {
                $BodyMetaData.'description' = $Description
            }
            If ($null -ne $templateDefinition) {
                $Error.Clear()
                Try {
                    [string]$templateDefinition_JSON = $templateDefinition | ConvertTo-Json -Depth 100 -Compress
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "ConvertTo-Json failed to convert the provided templateDefinition object due to [$Message]."
                    Break
                }
                $BodyMetaData.'templateDefinition' = $templateDefinition_JSON
            }
            $BodyMetaData.'_operationType' = 'update'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_dataSource' = 'DesignTemplateDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$DesignTemplate_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Design Template $DesignTemplate_id was successfully updated"
            $Error.Clear()
            Try {
                [ANOWDesignTemplate]$Modified_DesignTemplate = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the successful result of Set-AutomateNOWDesignTemplate to an [ANOWDesignTemplate] object due to [$Message]."
                Break
            }
            If ($Quiet -ne $true) {
                Return $Modified_DesignTemplate
            }
        }
    }
    End {
    }
}

Function New-AutomateNOWDesignTemplate {
    <#
    .SYNOPSIS
    Creates a Design Template within an AutomateNOW! instance

    .DESCRIPTION
    Creates a Design Template within an AutomateNOW! instance and returns back the newly created [ANOWDesignTemplate] object

    .PARAMETER Id
    Mandatory name of the Design Template. For example: 'DesignTemplate1'. This value may not contain the domain in brackets.

    .PARAMETER ProcessingTemplate
    Mandatory [ANOWProcessingTemplate] object. Use Get-AutomateNOWTaskTemplate (Workflow Template, Service Manager Template or Schedule Template) to retrieve them

    .PARAMETER Description
    Optional description of the Design Template (may not exceed 255 characters).

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWDesignTemplate.

    .OUTPUTS
    An [ANOWDesignTemplate] object representing the newly created DesignTemplate

    .EXAMPLE
    Creates a new Design Template named 'DesignTemplate1' based on a Task Template named 'TaskTemplate1'

    New-AutomateNOWDesignTemplate -Id 'DesignTemplate1' -Description 'the description' -ProcessingTemplate (Get-AutomateNOWTaskTemplate -id 'TaskTemplate1')

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Only Processing Template objects are supported despite there being indicators that some other design template types may be supported.

    #>
    [OutputType([ANOWDesignTemplate])]
    [Cmdletbinding()]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $true)]
        [string]$Id,
        [Parameter(Mandatory = $true)]
        [ANOWProcessingTemplate]$ProcessingTemplate,
        [Parameter(Mandatory = $false, HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [boolean]$DesignTemplate_exists = ($null -ne (Get-AutomateNOWDesignTemplate -Id $Id))
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWDesignTemplate failed to check if the Design Template [$Id] already existed due to [$Message]."
        Break
    }
    If ($DesignTemplate_exists -eq $true) {
        [string]$current_domain = $anow_session.header.domain
        Write-Warning -Message "There is already an DesignTemplate named [$Id] in [$current_domain]. Please check into this."
        Break
    }
    ## End warning ##
    [string]$ProcessingTemplate_Id = $ProcessingTemplate.id
    [string]$oldValues = ('{"recordId":"' + $ProcessingTemplate_Id + '","domainClass":"ProcessingTemplate"}')
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    $BodyMetaData.Add('id', $Id)
    If ($Description.Length -gt 0) {
        $BodyMetaData.Add('description', $Description)
    }
    $BodyMetaData.Add('recordId', $ProcessingTemplate_Id)
    $BodyMetaData.Add('domainClass', 'ProcessingTemplate')
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_operationType' = 'add'
    $BodyMetaData.'_oldValues' = $oldValues
    $BodyMetaData.'_componentId' = 'DesignTemplateCreateWindow_form'
    $BodyMetaData.'_dataSource' = 'DesignTemplateDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
    [string]$command = '/designTemplate/create'
    [hashtable]$parameters = @{}
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('Body', $Body)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWDesignTemplate]$DesignTemplate = $results.response.data | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to create [ANOWDesignTemplate] object due to [$Message]."
        Break
    }
    If ($DesignTemplate.id.Length -eq 0) {
        Write-Warning -Message "Somehow the newly created [ANOWDesignTemplate] object is empty!"
        Break
    }
    If ($Quiet -ne $true) {
        Return $DesignTemplate
    }
}

Function Export-AutomateNOWDesignTemplate {
    <#
    .SYNOPSIS
    Exports the Design Template objects from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Design Template objects from an instance of AutomateNOW! to a local .csv file

    .PARAMETER DesignTemplate
    Mandatory [ANOWDesignTemplate] object (Use Get-AutomateNOWDesignTemplate to retrieve them)

    .INPUTS
    ONLY [ANOWDesignTemplate] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWDesignTemplate] objects are exported to the local disk in CSV format

    .EXAMPLE
    Exports the first page of Design Template objects

    Get-AutomateNOWDesignTemplate | Export-AutomateNOWDesignTemplate

    .EXAMPLE
    Exports a single Design Template by id

    Get-AutomateNOWDesignTemplate -Id 'DesignTemplate1' | Export-AutomateNOWDesignTemplate

    .EXAMPLE
    Exports a series of Design Template objects by Id across the pipeline

    'DesignTemplate1', 'DesignTemplate2' | Get-AutomateNOWDesignTemplate | Export-AutomateNOWDesignTemplate

    .NOTES
	You must present [ANOWDesignTemplate] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWDesignTemplate]$DesignTemplate
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-DesignTemplates-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWDesignTemplate]$DesignTemplate = $_
        }
        $Error.Clear()
        Try {
            $DesignTemplate | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWDesignTemplate] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function Remove-AutomateNOWDesignTemplate {
    <#
    .SYNOPSIS
    Removes a Design Template from an AutomateNOW! instance

    .DESCRIPTION
    Removes a Design Template from an AutomateNOW! instance

    .PARAMETER DesignTemplate
    An [ANOWDesignTemplate] object representing the Design Template to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWDesignTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Remove a single DesignTemplate named 'DesignTemplate1'

    Get-AutomateNOWDesignTemplate -Id 'DesignTemplate1'| Remove-AutomateNOWDesignTemplate

    .EXAMPLE
    Forcefully removes a series of DesignTemplate objects by sending their name (Id) across the pipeline.

    'DesignTemplate1', 'DesignTemplate2' | Get-AutomateNOWDesignTemplate | Remove-AutomateNOWDesignTemplate -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWDesignTemplate]$DesignTemplate,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/designTemplate/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWDesignTemplate]$DesignTemplate = $_
        }
        [string]$DesignTemplate_id = $DesignTemplate.id
        If ($DesignTemplate_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($DesignTemplate_id)")) -eq $true) {
            [string]$oldvalues = $DesignTemplate.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $DesignTemplate.id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'DesignTemplateList'
            $BodyMetaData.'_dataSource' = 'DesignTemplateDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$DesignTemplate_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Design Template [$DesignTemplate_id] successfully removed"
        }
    }
    End {

    }
}

Function Copy-AutomateNOWDesignTemplate {
    <#
    .SYNOPSIS
    Copies a Design Template object from an AutomateNOW! instance

    .DESCRIPTION
    Copies a Design Template object from an AutomateNOW! instance.

    .PARAMETER DesignTemplate
    Mandatory [ANOWDesignTemplate] object to be copied.

    .PARAMETER NewId
    The name (Id) of the new Design Template object. The new Id must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    .PARAMETER Force
    Force the copy without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    ONLY [ANOWDesignTemplate] object is accepted. Pipeline support is intentionally unavailable.

    .OUTPUTS
    The newly created [ANOWDesignTemplate] object will be emitted. Use the -Quiet parameter to suppress this.

    .EXAMPLE
    Creates a copy of a DesignTemplate named 'DesignTemplate1' to 'DesignTemplate2'
    $DesignTemplate1 = Get-AutomateNOWDesignTemplate -Id 'DesignTemplate1'
    Copy-AutomateNOWDesignTemplate -DesignTemplate $DesignTemplate1 -NewId 'DesignTemplate2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global DesignTemplate.

    AutomateNOW object id's can never change, but we can copy the object to a new id and it will (typically) include all of the items therein.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWDesignTemplate]$DesignTemplate,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$DesignTemplate_exists = ($null -ne (Get-AutomateNOWDesignTemplate -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWDesignTemplate failed to check if the Design Template object [$NewId] already existed due to [$Message]."
            Break
        }
        If ($DesignTemplate_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Design Template object named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End warning ##
        [string]$command = '/designTemplate/copy'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            [string]$DesignTemplate_oldId = $DesignTemplate.id
            [string]$DesignTemplate_simpleId = $DesignTemplate.simpleId
            If ($DesignTemplate_oldId -eq $NewId) {
                Write-Warning -Message "The new id cannot be the same as the old id."
                Break
            }
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Copy the DesignTemplate $($DesignTemplate_simpleId) to $($NewId)?")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                $BodyMetaData.'oldId' = $DesignTemplate_oldId
                $BodyMetaData.'domain' = $DesignTemplate.domain
                $BodyMetaData.'id' = $NewId
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_operationId' = 'copy'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_dataSource' = 'DesignTemplateDataSource'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
                $parameters.Body = $Body
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$DesignTemplate_oldId] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                $Error.Clear()
                Try {
                    [ANOWDesignTemplate]$NewDesignTemplate = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to create copied [ANOWDesignTemplate] object [$NewId] due to [$Message]."
                    Break
                }
                If ($NewDesignTemplate.id.Length -eq 0) {
                    Write-Warning -Message "Somehow the newly created (copied) [ANOWDesignTemplate] object [$NewId] is empty!"
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $NewDesignTemplate
                }
            }
        }
    }
    End {

    }
}

Function Rename-AutomateNOWDesignTemplate {
    <#
    .SYNOPSIS
    Renames a Design Template object on an AutomateNOW! instance

    .DESCRIPTION
    Performs a psuedo-rename operations of a Design Template object from an AutomateNOW! instance by copying it first and then deleting the source. This function merely combines Copy-AutomateNOWDesignTemplate and Remove-AutomateNOWDesignTemplate therefore it is to be considered destructive.

    .PARAMETER DesignTemplate
    An [ANOWDesignTemplate] object representing the Design Template object to be renamed.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the Design Template object. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER Force
    Force the renaming without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly renamed object.

    .INPUTS
    ONLY [ANOWDesignTemplate] objects are accepted. There is intentionally no support for the pipeline.

    .OUTPUTS
    The newly renamed [ANOWDesignTemplate] object will be returned.

    .EXAMPLE
    Renames a Design Template object from 'DesignTemplate1' to 'DesignTemplate2' in a multi-line format

    $DesignTemplate = Get-AutomateNOWDesignTemplate -Id 'DesignTemplate1'
    Rename-AutomateNOWDesignTemplate -DesignTemplate $DesignTemplate -NewId 'DesignTemplate2'

    .EXAMPLE
    Renames a Design Template object from 'DesignTemplate1' to 'DesignTemplate2' in a single-line format

    Rename-AutomateNOWDesignTemplate -DesignTemplate (Get-AutomateNOWDesignTemplate -Id 'DesignTemplate1') -NewId 'DesignTemplate2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global DesignTemplate.

    When renaming, you may only specify a different Id (name).
    #>
    [OutputType([ANOWDesignTemplate])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWDesignTemplate]$DesignTemplate,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin standard warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$new_DesignTemplate_exists = ($null -ne (Get-AutomateNOWDesignTemplate -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWDesignTemplate failed to check if the Design Template object [$NewId] already existed due to [$Message]."
            Break
        }
        If ($new_DesignTemplate_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Design Template object named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        #[string]$DesignTemplate_id = $DesignTemplate.id
        [string]$DesignTemplate_id = $DesignTemplate.simpleId
        $Error.Clear()
        Try {
            [boolean]$old_DesignTemplate_exists = ($null -ne (Get-AutomateNOWDesignTemplate -Id $DesignTemplate_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWDesignTemplate failed to check if the Design Template object [$DesignTemplate_id] already existed due to [$Message]."
            Break
        }
        If ($old_DesignTemplate_exists -eq $false) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not a Design Template object named [$DesignTemplate_id] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End standard warning ##
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($DesignTemplate_id)")) -eq $true) {
                $Error.Clear()
                Try {
                    [ANOWDesignTemplate]$new_DesignTemplate = Copy-AutomateNOWDesignTemplate -DesignTemplate $DesignTemplate -NewId $NewId -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Copy-AutomateNOWDesignTemplate failed to create a new Design Template object [$NewId] as Part 1 of the renaming process due to [$Message]."
                    Break
                }
                If ($new_DesignTemplate.simpleId -eq $NewId) {
                    Write-Verbose -Message "Part 1: Design Template object [$DesignTemplate_id] successfully copied to [$NewId]"
                }
                Else {
                    Write-Warning -Message "Somehow the first phase (Copy-AutomateNOWDesignTemplate) failed. Please look into this."
                    Break
                }
                $Error.Clear()
                Try {
                    Remove-AutomateNOWDesignTemplate -DesignTemplate $DesignTemplate -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Remove-AutomateNOWDesignTemplate failed to remove Design Template object [$DesignTemplate_id] as Part 2 of the renaming process due to [$Message]."
                    Break
                }
                Write-Verbose -Message "Part 2: Design Template object [$DesignTemplate_id] removed"
                Write-Verbose -Message "Task [$DesignTemplate_id] successfully renamed to [$NewId]"
                If ($Quiet -ne $true) {
                    Return $DesignTemplate
                }
            }
        }
        Else {
            Write-Warning -Message "No action was taken because either the source object didn't exist or the new object already existed"
        }
    }
    End {
    }
}

#endregion

#Region - Domains

Function Get-AutomateNOWDomain {
    <#
    .SYNOPSIS
    Gets the domains from an instance of AutomateNOW!

    .DESCRIPTION
    `Get-AutomateNOWDomain` gets the domains from an instance of AutomateNOW!

    .PARAMETER Id
    Optional string array to specify the name(s) of the domain to retrieve.

    .PARAMETER startRow
    An optional int32 representing what row to start the download from. This is intended for multi-page transfers.

    .PARAMETER endRow
    An optional int32 representing how many rows of data to receive. The default is 100. This is ideal for testing when you only want a few items.

    .INPUTS
    `Get-AutomateNOWDomain` accepts strings representing the simpleId (name) of the domain from the pipeline

    .OUTPUTS
    An array of [ANOWDomain] class objects

    .EXAMPLE
    Gets the first page of domains

    Get-AutomateNOWDomain

    .EXAMPLE
    Gets a single domain by name

    Get-AutomateNOWDomain -Id 'Training'

    .EXAMPLE
    Gets a series of domains based on an array of strings presented to the pipeline

    'Training', 'Production', 'Test' | Get-AutomateNOWDomain

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWDomain[]])]
    [Cmdletbinding( DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $false, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
        [string]$command = '/domain/read?'
        $parameters.Add('Command', $command)
        [System.Collections.Specialized.OrderedDictionary]$BodyObject = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 -or $Id.Length -gt 0) {
            If ($_.Length -gt 0 ) {
                $BodyObject.'id' = $_
            }
            Else {
                $BodyObject.'id' = $Id
                [string]$textMatchStyle = 'exactCase'
            }
        }
        Else {
            $BodyObject.'_startRow' = $startRow
            $BodyObject.'_endRow' = $endRow
            [string]$textMatchStyle = 'substring'
        }
        $BodyObject.'_operationType' = 'fetch'
        $BodyObject.'_textMatchStyle' = $textMatchStyle
        $BodyObject.'_componentId' = 'DomainSourceList'
        $BodyObject.'_dataSource' = 'DomainDataSource'
        $BodyObject.'isc_metaDataPrefix' = '_'
        $BodyObject.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $BodyObject
        [string]$command = ($command + $Body)
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        If ($results.response.data.count -gt 0) {
            [ANOWDomain[]]$Domains = ForEach ($Domain in $results.response.data) {
                [string]$Domain_name = $Domain.id
                If ($Domain_name.Length -eq 0) {
                    Write-Warning -Message 'Somehow the domain information could not be read during Get-AutomateNOWDomain'
                    Break
                }
                If ($Domain.adhocReportEndpoint.Length -gt 0) {
                    [string]$adhocReportEndpoint_Id = $Domain.adhocReportEndpoint
                    $Error.Clear()
                    Try {
                        [ANOWEndpoint]$AdhocReportEndpoint = Get-AutomateNOWEndpoint -Id $adhocReportEndpoint_Id
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Failed to parse the response into an [ANOWEndpoint] object under Get-AutomateNOWDomain due to [$Message]."
                        Break
                    }
                    $Domain.adhocReportEndpoint = $AdhocReportEndpoint
                }
                [string]$defaultTimeZoneId = $Domain.defaultTimeZone
                If ($defaultTimezoneId.Length -eq 0) {
                    Write-Verbose -Message "There is not a default timezone set for this domain, therefore will use the server default"
                    Try {
                        $Domain | Add-Member -MemberType NoteProperty -Name defaultTimezone -Value $anow_session.server_timezone
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Add-Member failed to add the server timezone to the domain [$Domain_name] due to [$Message]."
                        Break
                    }
                }
                Else {
                    $Error.Clear()
                    Try {
                        [ANOWTimeZone]$defaultTimezone = Get-AutomateNOWTimeZone -Id $defaultTimeZoneId
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Get-AutomateNOWTimeZone failed to get [$defaultTimeZoneId] under Get-AutomateNOWDomain due to [$Message]."
                        Break
                    }
                    $Domain.defaultTimeZone = $defaultTimezone
                }
                If ($Domain.logofile.Count -gt 0) {
                    $Error.Clear()
                    Try {
                        $Domain.logofile = $Domain.logofile | ForEach-Object { $_ + 128 }
                    }
                    Catch {

                    }
                }
                [ANOWDomain]$Domain
            }
        }
    }
    Process {
        If ($_.Length -gt 0 -or $Id.Length -gt 0) {
            If ($_.Length -gt 0) {
                [string]$domain_id = $_
            }
            Else {
                [string]$domain_id = $Id
            }
            [ANOWDomain]$selected_domain = $Domains | Where-Object { $_.Id -eq $domain_id }
            If ($selected_domain.Id.Length -gt 0) {
                [ANOWDomain]$Domain = $selected_domain
                Return $Domain
            }
        }
        Else {
            Return $Domains
        }
    }
    End {

    }
}

Function Set-AutomateNOWDomain {
    <#
    .SYNOPSIS
    Changes the settings of a Domain on an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of a Domain on an AutomateNOW! instance

    .PARAMETER Domain
    An [ANOWDomain] object representing the Domain to be changed.

    .PARAMETER logoFile
    Optional file object of the organization's distinctive image or graphic file into the application. Use Get-Item to retrieve the logo image file. The filename extension must match the format. Only the following formats are supported: jpg, jpeg, png, gif

    .PARAMETER unsetLogoFile
    Optional [boolean] to unset the logo file.

    .PARAMETER Description
    Optional description of the Domain (may not exceed 255 characters).

    .PARAMETER UnsetDescription
    Optional switch that will remove the Description from the Domain object.

    .PARAMETER adhocReportEndpoint
    Optional [ANOWEndpoint] object (of type PostgreSQL) that refers to a designated system endpoint that enables users to dynamically generate and retrieve custom reports on-demand.

    .PARAMETER unsetAdhocReportEndpoint
    Optional [boolean] to unset the Adhoc Report Endpoint object.

    .PARAMETER processingRegistryDayLimit
    Optional [int32] that denotes the maximum number of business days allowed for processing and handling a specific registry.

    .PARAMETER processingTemplatePrefixEnabled
    Optional [switch] that indicates if all Processing Templates in the domain must be prefixed. Set this to $false if you want to untick the checkbox. If you set this to $true then you must also include at least one string in a string array to the -processingTemplatePrefixList parameter.

    .PARAMETER processingTemplatePrefixList
    Mandatory (if processingTemplatePrefixEnabled is set to $true) string array of the prefixes. See examples.

    .PARAMETER defaultTimeZone
    Optional [ANOWTimeZone] object that refers to the preconfigured time zone setting that establishes the baseline for all date and time-related operations within the domain.

    .PARAMETER unsetDefaultTimeZone
    Optional [boolean] to unset the default time zone.

    .PARAMETER LabelTextColor
    Optional color string of a custom RGB value (in hex) of the Domain's foreground (text) color (or use the word 'transparent') that denotes the specific color assigned to text labels within the application's user interface which aims to aid visual distinction and provide contextual cues. You must include the # character and it is case sensitive. Example: #FF00FF

    .PARAMETER LabelBackgroundColor
    Optional color string of a custom RGB value (in hex) of the Domain's foreground (text) color (or use the word 'transparent') that refers to the specific color applied to the background of text labels within the application's user interface, allowing for effective differentiation and visual hierarchy so that users can quickly identify and associate relevant information. You must include the # character and it is case sensitive. Example: #FF00FF

    .PARAMETER ToolbarBackgroundColor
    Optional color string of a custom RGB value (in hex) of the Domain's foreground (text) color (or use the word 'transparent') that represents the specific color scheme applied to the top section of the application's interface where various functional buttons and controls are located. You must include the # character and it is case sensitive. Example: #FF00FF

    .PARAMETER iconSet
    The name of the icon library (if you choose to use one). Possible choices are: FAT_COW, FUGUE and FONT_AWESOME.

    .PARAMETER iconCode
    The name of the icon which matches the chosen library. Must be lower-case.

    .PARAMETER Quiet
    Switch parameter that silences the output of the updated object.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWDomain] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWDomain] object will be returned

    .EXAMPLE
    Forcibly uploads a PNG logo to a domain named 'Domain1' in a single line.

    Get-AutomateNOWDomain -Id 'Domain1' | Set-AutomateNOWDomain -logoFile $logoFile (Get-Item -Path 'C:\temp\logo.png') -Force

    .EXAMPLE
    Sets many different properties of a domain named 'Domain1' in a single line.

    Get-AutomateNOWDomain -Id 'Domain1' | Set-AutomateNOWDomain -Description "Description!" -unsetAdhocReportEndpoint -processingRegistryDayLimit 23 -defaultTimeZone (Get-AutomateNOWTimeZone -Id 'America/New_York') -processingTemplatePrefixEnabled -processingTemplatePrefixList 'Prefix_1', 'Prefix_2' -LabelTextColor '#FFFFFF' -LabelBackgroundColor '#000000' -ToolbarBackgroundColor '#888888' -iconSet FAT_COW -iconCode 'abacus'

    .NOTES
    Constraint: You must use Connect-AutomateNOW to establish the token by way of global variable.

    Constraint: The Label Text and Label Text Background colors cannot be unset.

    Constraint: The 2 parameters related to the icon setting are restricted to a parameter set. Also, if you specify an icon library then you must also specify an icon.

    Constraint: The 2 parameters related to the domain logo file are restricted to a parameter set.

    Info: In the 'New Domain' dialog the 'Label Text Color' and 'Label Text Background Color' properties are labeled as 'Text Color' and 'Background'. Within the Settings of the domain the correct names are used.

    Warning: The -adhocReportEndpoint parameter is calling for an Endpoint object, not an Adhoc Report object!

    #>
    [OutputType([ANOWDomain])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High', DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $true, ValueFromPipeline = $True, ParameterSetName = 'WithIcon')]
        [Parameter(Mandatory = $true, ValueFromPipeline = $True, ParameterSetName = 'LogoFile')]
        [ANOWDomain]$Domain,
        [ValidateScript({ (Test-Path -Path $_.FullName) -eq $true })]
        [Parameter(Mandatory = $false, ParameterSetName = 'LogoFile')]
        [System.IO.FileSystemInfo]$logoFile,
        [Parameter(Mandatory = $false, ParameterSetName = 'LogoFile')]
        [switch]$unsetLogoFile,
        [ValidateScript({ $_.Length -le 255 })]
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [string]$Description,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [ANOWEndpoint]$adhocReportEndpoint,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [switch]$unsetAdhocReportEndpoint,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [ValidateRange(1, 2147483647 )]
        [int32]$processingRegistryDayLimit,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [ANOWTimeZone]$defaultTimeZone,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [switch]$unsetdefaultTimeZone,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [switch]$processingTemplatePrefixEnabled,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [string[]]$processingTemplatePrefixList,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [switch]$unsetProcessingTemplatePrefixEnabled,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [ValidateScript( { $_ -cmatch '^#[0-9A-F]{6}$' -or $_ -cmatch '^transparent$' } ) ]
        [string]$LabelTextColor,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [ValidateScript( { $_ -cmatch '^#[0-9A-F]{6}$' -or $_ -cmatch '^transparent$' } ) ]
        [string]$LabelBackgroundColor,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [ValidateScript( { $_ -cmatch '^#[0-9A-F]{6}$' -or $_ -cmatch '^transparent$' } ) ]
        [string]$ToolbarBackgroundColor,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [switch]$unsetToolbarBackgroundColor,
        [Parameter(Mandatory = $true, ParameterSetName = 'WithIcon')]
        [ANOWIcon_iconSet]$iconSet,
        [ValidateScript({ $_ -match '^[a-z0-9-_]{1,}$' })]
        [Parameter(Mandatory = $true, ParameterSetName = 'WithIcon')]
        [string]$iconCode,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [Parameter(Mandatory = $false, ParameterSetName = 'LogoFile')]
        [switch]$Quiet,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [Parameter(Mandatory = $false, ParameterSetName = 'LogoFile')]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
        If ($Description.Length -gt 0 -and $UnsetDescription -eq $true) {
            Write-Warning -Message 'You cannot set the Description and unset it at the same time. Please choose one or the other.'
            Break
        }
        If ($adhocReportEndpoint.Id.Length -gt 0 -and $unsetAdhocReportEndpoint -eq $true) {
            Write-Warning -Message 'You cannot set the set the Adhoc Report Endpoint object for this domain and unset it at the same time. Please choose one or the other.'
            Break
        }
        If ($adhocReportEndpoint.id.Length -gt 0 -and $adhocReportEndpoint.endpointType -ne 'POSTGRESQL') {
            [string]$endpointType = $adhocReportEndpoint.endpointType
            Write-Warning -Message "The Adhoc Report Endpoint object must be of type POSTGRESQL, not [$endpointType]. Please submit that type of Endpoint for this parameter."
            Break
        }
        If ($processingTemplatePrefixEnabled -eq $true -and $processingTemplatePrefixList.count -eq 0) {
            Write-Warning -Message 'If you enable the Processing Template Prefix feature then you must supply the prefixes with -processingTemplatePrefixList as a string array.'
            Break
        }
        ElseIf ($processingTemplatePrefixEnabled -ne $true -and $processingTemplatePrefixList.count -gt 0) {
            Write-Warning -Message 'If you specify a list of prefixes for Processing Templates then you must also include the -processingTemplatePrefixEnabled switch parameter'
            Break
        }
        ElseIf ($processingTemplatePrefixEnabled -eq $true -and $unsetProcessingTemplatePrefixEnabled -eq $true) {
            Write-Warning -Message 'You cannot set the Processing Template Prefix to enabled and unset it at the same time. Please choose one or the other.'
            Break
        }
        If ($ToolbarBackgroundColor.Length -gt 0 -and $unsetToolbarBackgroundColor -eq $true) {
            Write-Warning -Message 'You cannot set the Background Color of the Domain Toolbar and unset it at the same time. Please choose one or the other.'
            Break
        }
        If ($logoFile.count -gt 0 -and $unsetLogoFile -eq $true) {
            Write-Warning -Message "You cannot unset the logo file and set one at the same time. Please choose one or the other."
            Break
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWDomain]$Domain = $_
        }
        [string]$Domain_id = $Domain.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Make changes to $($Domain_id)?")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$Domain_exists = ($null -eq (Get-AutomateNOWDomain -Id $Domain_id))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWDomain failed to check if the Domain [$Domain_id] already existed under Set-AutomateNOWDomain due to [$Message]."
                Break
            }
            If ($Domain_exists -eq $true) {
                Write-Warning -Message "There is not a Domain named [$Domain_id]. Please check into this."
                Break
            }
            ## End warning ##
            [System.Collections.ArrayList]$include_properties = [System.Collections.ArrayList]@()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $Domain_id
            If ($Description.Length -gt 0) {
                $BodyMetaData.'description' = $Description
            }
            ElseIf ($UnsetDescription -eq $true) {
                $BodyMetaData.'description' = $null
                $include_properties += 'description'
            }
            If ($processingRegistryDayLimit -gt 0) {
                $BodyMetaData.'processingRegistryDayLimit' = $processingRegistryDayLimit
            }
            If ($adhocReportEndpoint.Id.Length -gt 0) {
                [string]$AdhocReportEndpoint_id = $adhocReportEndpoint.simpleId
                $Error.Clear()
                Try {
                    [ANOWEndpoint]$AdhocReportEndpoint_object = Get-AutomateNOWEndpoint -Id $AdhocReportEndpoint_id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWEndpoint failed to confirm that the Adhoc Report Endpoint object [$AdhocReportEndpoint_id] actually existed while running under Set-AutomateNOWDomain due to [$Message]"
                    Break
                }
                If ($AdhocReportEndpoint_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWEndpoint failed to locate the Endpoint object [$AdhocReportEndpoint_id] running under Set-AutomateNOWDomain. Please check again."
                    Break
                }
                Write-Verbose -Message "Adding Adhoc Report Endpoint object [$AdhocReportEndpoint_id] to [ANOWDomain] [$Domain_id]"
                $BodyMetaData.'adhocReportEndpoint' = $AdhocReportEndpoint_id
                $include_properties += 'adhocReportEndpoint'
            }
            ElseIf ($unsetAdhocReportEndpoint -eq $true) {
                [string]$AdhocReport_id = $AdhocReport.simpleId
                Write-Verbose -Message "Removing [ANOWAdhocReport] [$AdhocReport_id] from [ANOWDomain] [$Domain_id]"
                $BodyMetaData.'adhocReportEndpoint' = $null
                $include_properties += 'adhocReportEndpoint'
            }
            If ($defaultTimeZone.id.Length -gt 0) {
                $defaultTimeZone_id = $defaultTimeZone.Id
                $BodyMetaData.'defaultTimeZone' = $defaultTimeZone_id
                $include_properties += 'defaultTimeZone'
            }
            ElseIf ($unsetDefaultTimeZone -eq $true) {
                $BodyMetaData.'defaultTimeZone' = $null
                $include_properties += 'defaultTimeZone'
            }
            If ($processingTemplatePrefixEnabled -eq $true) {
                $BodyMetaData.'processingTemplatePrefixEnabled' = $true
                [string]$processingTemplatePrefixListJoined = $processingTemplatePrefixList -join "`n"
                $BodyMetaData.'processingTemplatePrefixList' = $processingTemplatePrefixListJoined
            }
            ElseIf ($unsetProcessingTemplatePrefixEnabled -eq $true) {
                $BodyMetaData.'processingTemplatePrefixEnabled' = $false
            }
            If ($LabelTextColor.Length -gt 0) {
                $BodyMetaData.'textColor' = $LabelTextColor
            }
            If ($LabelBackgroundColor.Length -gt 0) {
                $BodyMetaData.'backgroundColor' = $LabelBackgroundColor
            }
            If ($ToolbarBackgroundColor.Length -gt 0) {
                $BodyMetaData.'instanceToolbarBackgroundColor' = $ToolbarBackgroundColor
            }
            ElseIf ($unsetToolbarBackgroundColor -eq $true) {
                $BodyMetaData.'instanceToolbarBackgroundColor' = $null
            }
            If ($iconSet.Length -gt 0) {
                $BodyMetaData.'iconSet' = $iconSet
            }
            If ($iconCode.Length -gt 0) {
                $BodyMetaData.'iconCode' = $iconCode
            }
            If ($logofile.count -gt 0) {
                [hashtable]$get_file_parameters = @{}
                If ($PSVersionTable.PSVersion.Major -eq 5) {
                    $get_file_parameters.Add('Encoding', 'Byte')
                    $get_file_parameters.Add('Raw', $true)
                }
                Else {
                    $get_file_parameters.Add('AsByteStream', $true)
                }
                [string]$binary_file_fullname = $logoFile.fullname
                $get_file_parameters.Add('Path', "$binary_file_fullname")
                $Error.Clear()
                Try {
                    [byte[]]$file_bytes = Get-Content @get_file_parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-Content failed to create a byte array from the content of [$binary_file_fullname] due to [$Message]."
                    Break
                }
                [string]$cr = "`r`n"
                [string]$mime_type = 'image/png'
                [string]$uploaded_filename = $logoFile.name
                [string]$boundary_string = New-WebkitBoundaryString -numerical
                [System.Collections.ArrayList]$form_prefix = New-Object -TypeName System.Collections.ArrayList
                [void]$form_prefix.Add("-----------------------------$boundary_string")
                [void]$form_prefix.Add("Content-Disposition: form-data; name=`"access_token`"" + $cr)
                [void]$form_prefix.Add($anow_session.AccessToken)
                [void]$form_prefix.Add("-----------------------------$boundary_string")
                [void]$form_prefix.Add("Content-Disposition: form-data; name=`"file`"; filename=`"$uploaded_filename`"")
                [void]$form_prefix.Add("Content-Type: $mime_type" + $cr + $cr)
                [System.Collections.ArrayList]$form_suffix = New-Object -TypeName System.Collections.ArrayList
                [void]$form_suffix.Add($cr + "-----------------------------$boundary_string--" + $cr)
                [string]$body_prefix = $form_prefix -join $cr
                [string]$body_suffix = $form_suffix -join ''
                [byte[]]$body_prefix_bytes = [System.Text.Encoding]::UTF8.GetBytes($body_prefix)
                [byte[]]$body_suffix_bytes = [System.Text.Encoding]::UTF8.GetBytes($body_suffix)
                [byte[]]$body = $body_prefix_bytes + $file_bytes + $body_suffix_bytes
                [int32]$content_length = $body.count
                [string]$domain = $anow_session.header.domain
                [string]$command = "/domain/uploadLogo?id=$Domain_id"
                $parameters.Add('Command', $command)
                If ($null -ne $parameters.ContentType) {
                    $parameters.Remove('ContentType')
                }
                $parameters.Add('ContentType', "multipart/form-data; boundary=---------------------------$boundary_string")
                $parameters.Add('BinaryBody', $Body)
                $parameters.Add('Headers', [hashtable]@{"Content-Length" = $content_length; "Upgrade-Insecure-Requests" = 1; }) # is this header really needed?
            }
            ElseIf ($unsetLogoFile -eq $true) {
                $BodyMetaData.'logoFile' = $null
                $BodyMetaData.'logoFileFormat' = $null
            }
            If ($logofile.count -eq 0) {
                $parameters.Add('Command', '/domain/update')
                $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
                $BodyMetaData.'_operationType' = 'update'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_oldValues' = $Domain.CreateOldValues()
                $BodyMetaData.'_componentId' = 'DomainVM'
                $BodyMetaData.'_dataSource' = 'DomainDataSource'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties $include_properties
                If ($null -eq $parameters.Body) {
                    $parameters.Add('Body', $Body)
                }
                Else {
                    $parameters.Body = $Body
                }
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Domain_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            If ($logofile.count -eq 0) {
                $Error.Clear()
                Try {
                    [PSCustomObject]$result = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to parse the response into a [PSCustomObject] object (under Set-AutomateNOWDomain) for further parsing due to [$Message]."
                    Break
                }
                If ($result.adhocReportEndpoint.Length -gt 0) {
                    [string]$adhocReportEndpoint_Id = $result.adhocReportEndpoint
                    $Error.Clear()
                    Try {
                        [ANOWEndpoint]$AdhocReportEndpoint = Get-AutomateNOWEndpoint -Id $adhocReportEndpoint_Id
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Get-AutomateNOWEndpoint failed to parse the response to Get-AutomateNOWEndpoint while trying to assemble the updated [ANOWEndpoint] object (under Set-AutomateNOWDomain) due to [$Message]."
                        Break
                    }
                    $result.adhocReportEndpoint = $AdhocReportEndpoint
                }
                If ($result.defaultTimeZone.Length -gt 0) {
                    [string]$defaultTimeZone_Id = $result.defaultTimeZone
                    $Error.Clear()
                    Try {
                        [ANOWTimeZone]$defaultTimeZone = Get-AutomateNOWtimeZone -Id $defaultTimeZone_Id
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Get-AutomateNOWTimeZone failed to parse the response to Get-AutomateNOWTimeZone while trying to assemble the updated [ANOWDomain] object (under Set-AutomateNOWDomain) due to [$Message]."
                        Break
                    }
                    $result.defaultTimeZone = $defaultTimeZone
                }
                $Error.Clear()
                Try {
                    [ANOWDomain]$UpdatedDomain = $result
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to parse the response the returned [ANOWDomain] object into a final valid [ANOWDomain] object (under Set-AutomateNOWDomain) due to [$Message]."
                    Break
                }
                If ($UpdatedDomain.id -eq $Domain_id) {
                    Write-Verbose -Message "Domain $Domain_id was successfully updated"
                }
                Else {
                    Write-Warning -Message "Somehow the returned Domain [ANOWDomain] object [$Domain_id] has an error (under Set-AutomateNOWDomain). Please look into this."
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $UpdatedDomain
                }
            }
        }
    }
    End {
    }
}

Function Export-AutomateNOWDomain {
    <#
    .SYNOPSIS
    Exports the domains from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the domains from an instance of AutomateNOW! to a local .csv file

    .PARAMETER Domain
    Mandatory [ANOWDomain] object (Use Get-AutomateNOWDomain to retrieve them)

    .INPUTS
    ONLY [ANOWDomain] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWDomain] objects are exported to the local disk in CSV format

    .EXAMPLE
    Get-AutomateNOWDomain | Export-AutomateNOWDomain

    .EXAMPLE
    Get-AutomateNOWDomain -Id 'Training' | Export-AutomateNOWDomain

    .EXAMPLE
    @( 'Training', 'Test', 'Prod' ) | Get-AutomateNOWDomain | Export-AutomateNOWDomain

    .EXAMPLE
    Get-AutomateNOWDomain | Where-Object { $_.id -like '*Test*' } | Export-AutomateNOWDomain

    .NOTES
	You must present [ANOWDomain] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWDomain]$Domain
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-Domains-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWDomain]$Domain = $_
        }
        $Error.Clear()
        Try {
            $Domain | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWDomain] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function New-AutomateNOWDomain {
    <#
    .SYNOPSIS
    Creates a new Domain on an AutomateNOW! instance

    .DESCRIPTION
    Creates a new Domain on an AutomateNOW! instance and returns back the created [ANOWDomain] object

    .PARAMETER Id
    The intended name of the Domain. For example: 'MyCoolDomain'.

    .PARAMETER description
    Optional description of the Domain (may not exceed 255 characters).

    .PARAMETER iconSet
    Optional name of the icon library to use. Possible choices are: FAT_COW, FUGUE and FONT_AWESOME.

    .PARAMETER iconCode
    Mandatory (if you use -iconSet) name of the icon which matches the chosen icon library. Must be lower-case.

    .PARAMETER textColor
    Optional custom RGB value (in hex) of the Domain's foreground (text) color or use 'transparent'. You must include the # character and it is case sensitive. Example: #FF00FF

    .PARAMETER backgroundColor
    Optional custom RGB value (in hex) of the Domain's backgroundground (text) color or use 'transparent'. You must include the # character and it is case sensitive. Example: #FF00FF

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWDomain.

    .OUTPUTS
    An [ANOWDomain] object representing the newly created Domain

    .EXAMPLE
    Creates a new domain with a transparent background color.

    New-AutomateNOWDomain -id 'MyCoolDomain123' -description 'My Domains description' -iconSet 'FUGUE' -IconCode 'abacus' -textColor '#0A0A0A' -backgroundColor 'transparent'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Note that transparent is an available option for either background or foreground color.

    The name (id) of the Domain must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    #>
    [OutputType([ANOWDomain])]
    [Cmdletbinding(DefaultParameterSetName = 'Default')]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $true, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $true, ParameterSetName = 'WithIcon')]
        [string]$Id,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default', HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon', HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $true, ParameterSetName = 'WithIcon')]
        [ANOWIcon_iconSet]$iconSet,
        [ValidateScript({ $_ -match '^[a-z0-9-_]{1,}$' })]
        [Parameter(Mandatory = $true, ParameterSetName = 'WithIcon')]
        [string]$iconCode,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [ValidateScript( { $_ -cmatch '^#[0-9A-F]{6}$' -or $_ -cmatch '^transparent$' } ) ]
        [string]$textColor = '#FFFFFF',
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [ValidateScript( { $_ -cmatch '^#[0-9A-F]{6}$' -or $_ -cmatch '^transparent$' } ) ]
        [string]$backgroundColor = '#FF0000',
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is no global session token"
            Break
        }
        If ($Id.Length -eq 0) {
            Write-Warning -Message "The Id must be at least 1 character in length. Please try again."
            Break
        }
        If (($iconSet.Length -gt 0) -and ($iconCode.Length -eq 0)) {
            Write-Warning -Message "If you specify an icon library then you must also specify an icon"
            Break
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$Domain_exists = ($null -ne (Get-AutomateNOWDomain -Id $Id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWDomain failed to check if the Domain [$Id] under New-AutomateNOWDomain already existed due to [$Message]."
            Break
        }
        If ($Domain_exists -eq $true) {
            Write-Warning -Message "There is already a Domain named [$Id]. Please check into this."
            Break
        }
        ## End warning ##
        [hashtable]$parameters = @{}
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        $parameters.Add('Method', 'POST')
    }
    Process {
        $Error.Clear()
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        $Body.'id' = $Id
        If ($null -ne $textColor) {
            $Body.'textColor' = $textColor
        }
        If ($null -ne $backgroundColor) {
            $Body.'backgroundColor' = $backgroundColor
        }
        If ($null -ne $description) {
            $Body.'description' = $description
        }
        If ($null -ne $iconSet) {
            $Body.'iconSet' = $iconSet
        }
        If ($null -ne $iconCode) {
            $Body.'iconCode' = $iconCode
        }
        $Body.'_textMatchStyle' = 'exact'
        $Body.'_operationType' = 'add'
        $Body.'_oldValues' = '{"textColor":"#FFFFFF","backgroundColor":"#FF0000"}'
        $Body.'_componentId' = 'DomainCreateWindow_form'
        $Body.'_dataSource' = 'DomainDataSource'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body -IncludeProperties textColor, backgroundColor, id, description, iconSet, iconCode
        [string]$command = '/domain/create'
        $parameters.Add('Command', $command)
        $parameters.Add('Body', $Body)
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed due to [$Message]"
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWDomain]$Domain_data = $results.response.data | Select-Object -First 1
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Unable to form an [ANOWDomain] object with the response to [$command] due to [$message]"
            Break
        }
        [string]$Domain_id = $Domain_data.Id
        Write-Verbose -Message "The Domain [$Domain_id] was created"
        If ($Quiet -ne $true) {
            Return $Domain_data
        }
    }
    End {
    }
}

Function Copy-AutomateNOWDomain {
    <#
    .SYNOPSIS
    Copies a Domain from an AutomateNOW! instance

    .DESCRIPTION
    Copies a Domain from an AutomateNOW! instance. AutomateNOW object id can never be changed, but we can copy the object to a new id and it will include all of the items therein.

    .PARAMETER Domain
    Mandatory [ANOWDomain] object to be copied.

    .PARAMETER NewId
    The name (Id) of the new Domain. The new Id must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    .PARAMETER Force
    Force the copy without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    ONLY [ANOWDomain] object is accepted. Pipeline support is intentionally unavailable.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Creates a copy of a Domain
    $domain = Get-AutomateNOWDomain -Id 'Domain1'
    Copy-AutomateNOWDomain -Domain $domain -NewId 'Domain2'

    .EXAMPLE
    Forcibly and quietly creates a copy of a Domain
    $domain = Get-AutomateNOWDomain -Id 'Domain1'
    Copy-AutomateNOWDomain -Domain $domain -NewId 'Domain2' -Force -Quiet

    .EXAMPLE
    Creates a copy of a Domain in a single line
    Copy-AutomateNOWDomain -Domain (Get-AutomateNOWDomain -Id 'Domain1') -NewId 'Domain2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Unlike other Copy dialogs, only the Id may be set when creating the copy. This function mimics that behavior.

    #>
    [OutputType([ANOWDomain])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWDomain]$Domain,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$Domain_exists = ($null -ne (Get-AutomateNOWDomain -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWDomain failed to check if the Domain [$NewId] already existed due to [$Message]."
            Break
        }
        If ($Domain_exists -eq $true) {
            Write-Warning -Message "There is already a Domain named [$NewId]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End warning ##
        [string]$command = '/domain/copy'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            [string]$Domain_oldId = $Domain.id
            If ($Domain_oldId -eq $NewId) {
                Write-Warning -Message "The name of the destination copy of the Domain cannot be identical the source Domain."
                Break
            }
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Copy the Domain $($Domain_oldId) to $($NewId)?")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                $BodyMetaData.'oldId' = $Domain_oldId
                $BodyMetaData.'id' = $NewId
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_operationId' = 'copy'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_dataSource' = 'DomainDataSource'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
                $parameters.Body = $Body
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Domain_id] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                $Error.Clear()
                Try {
                    [PSCustomObject]$result = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to parse the response into a [PSCustomObject] object (under Copy-AutomateNOWDomain) for further parsing due to [$Message]."
                    Break
                }
                If ($result.adhocReportEndpoint.Length -gt 0) {
                    [string]$adhocReportEndpoint_Id = $result.adhocReportEndpoint
                    $Error.Clear()
                    Try {
                        [ANOWEndpoint]$AdhocReportEndpoint = Get-AutomateNOWEndpoint -Id $adhocReportEndpoint_Id
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Get-AutomateNOWEndpoint failed to parse the response to Get-AutomateNOWEndpoint while trying to assemble the updated [ANOWEndpoint] object (under Set-AutomateNOWDomain) due to [$Message]."
                        Break
                    }
                    $result.adhocReportEndpoint = $AdhocReportEndpoint
                }
                If ($result.defaultTimeZone.Length -gt 0) {
                    [string]$defaultTimeZone_Id = $result.defaultTimeZone
                    $Error.Clear()
                    Try {
                        [ANOWTimeZone]$defaultTimeZone = Get-AutomateNOWtimeZone -Id $defaultTimeZone_Id
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Get-AutomateNOWTimeZone failed to parse the response to Get-AutomateNOWTimeZone while trying to assemble the updated [ANOWDomain] object (under Set-AutomateNOWDomain) due to [$Message]."
                        Break
                    }
                    $result.defaultTimeZone = $defaultTimeZone
                }
                $Error.Clear()
                Try {
                    [ANOWDomain]$Domain = $result
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to create a [ANOWDomain] object from the copied domain $NewId due to [$Message]."
                    Break
                }
                If ($Domain.id.Length -eq 0) {
                    Write-Warning -Message "Somehow the newly created (copied) [ANOWDomain] object is empty!"
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $Domain
                }
            }
        }
    }
    End {

    }
}

Function Rename-AutomateNOWDomain {
    <#
    .SYNOPSIS
    Renames a Domain on an AutomateNOW! instance

    .DESCRIPTION
    Performs a psuedo-rename operations of a Domain from an AutomateNOW! instance by copying it first and then deleting the source. This function merely combines Copy-AutomateNOWDomain and Remove-AutomateNOWDomain therefore it is to be considered destructive.

    .PARAMETER Domain
    An [ANOWDomain] object representing the Domain to be renamed.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the Domain. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER Force
    Force the renaming without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly renamed object.

    .INPUTS
    ONLY [ANOWDomain] objects are accepted. There is intentionally no support for the pipeline.

    .OUTPUTS
    The newly renamed [ANOWDomain] object will be returned.

    .EXAMPLE
    $domain = Get-AutomateNOWDomain -Id 'Domain1'
    Rename-AutomateNOWDomain -Domain $domain -NewId 'Domain2'

    .EXAMPLE
    Rename-AutomateNOWDomain -Domain (Get-AutomateNOWDomain -Id 'Domain1') -NewId 'Domain2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    When renaming, you may only specify a different Id (name).

    Unlike other Rename functions, a referral is not done for Domains
    #>
    [OutputType([ANOWDomain])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWDomain]$Domain,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin standard warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$new_Domain_exists = ($null -ne (Get-AutomateNOWDomain -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWDomain failed to check if the Domain [$NewId] already existed due to [$Message]."
            Break
        }
        If ($new_Domain_exists -eq $true) {
            Write-Warning -Message "There is already a Domain named [$NewId]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        [string]$Domain_id = $Domain.id
        $Error.Clear()
        Try {
            [boolean]$old_Domain_exists = ($null -ne (Get-AutomateNOWDomain -Id $Domain_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWDomain failed to check if the source Domain [$Domain_id] already existed due to [$Message]."
            Break
        }
        If ($old_Domain_exists -eq $false) {
            Write-Warning -Message "There is not a source Domain named [$Domain_id] so you can't rename it."
            [boolean]$PermissionToProceed = $false
        }
        ## End standard warning ##
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Rename $($Domain_id) to $($NewId)?")) -eq $true) {
                $Error.Clear()
                Try {
                    [ANOWDomain]$new_Domain = Copy-AutomateNOWDomain -Domain $Domain -NewId $NewId -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Copy-AutomateNOWDomain failed to create a new Domain [$NewId] as Part 1 of the renaming process due to [$Message]."
                    Break
                }
                If ($new_Domain.simpleId -eq $NewId) {
                    Write-Verbose -Message "Part 1: Domain [$Domain_id] successfully copied to [$NewId]"
                }
                Else {
                    Write-Warning -Message "Somehow the first phase (Copy-AutomateNOWDomain) failed. Please look into this."
                    Break
                }
                $Error.Clear()
                Try {
                    Remove-AutomateNOWDomain -Domain $Domain -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Remove-AutomateNOWDomain failed to remove [$Domain_id] as Part 2 of the renaming process due to [$Message]."
                    Break
                }
                Write-Verbose -Message "Part 2: Domain [$Domain_id] removed"
                Write-Verbose -Message "Task [$Domain_id] successfully renamed to [$NewId]"
                If ($Quiet -ne $true) {
                    Return $new_Domain
                }
            }
        }
        Else {
            Write-Warning -Message "No action was taken because either the source object didn't exist or the new object already existed"
        }
    }
    End {
    }
}

Function Remove-AutomateNOWDomain {
    <#
    .SYNOPSIS
    Removes a Domain from an AutomateNOW! instance

    .DESCRIPTION
    Removes a Domain from an AutomateNOW! instance

    .PARAMETER Domain
    An [ANOWDomain] object representing the Domain to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWDomain] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Remove a single Domain based on its name.
    Get-AutomateNOWDomain -Id 'Domain01' | Remove-AutomateNOWDomain

    .EXAMPLE
    Remove a series of Domains based on the pipeline
    @( 'Domain1', 'Domain2', 'Domain3') | Get-AutomateNOWDomain | Remove-AutomateNOWDomain

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWDomain]$Domain,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/domain/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWDomain]$Domain = $_
        }
        [string]$Domain_id = $Domain.id
        If ($Domain_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("ARE YOU SURE YOU WANT TO DELETE THE DOMAIN $($Domain_id)?")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            [string]$old_values = $Domain.CreateOldValues()
            $BodyMetaData.'id' = $Domain_id
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_oldValues' = $old_values
            $BodyMetaData.'_componentId' = 'DomainList'
            $BodyMetaData.'_dataSource' = 'DomainDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$BodyMetaDataString = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $BodyMetaDataString)
            }
            Else {
                $parameters.Body = $BodyMetaDataString
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Domain_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Domain $Domain_id successfully removed"
        }
    }
    End {

    }
}

Function Suspend-AutomateNOWDomain {
    <#
    .SYNOPSIS
    Suspends all activities within a specific domain on an AutomateNOW! instance.

    .DESCRIPTION
    Suspends all activities within a specific domain on an AutomateNOW! instance, ensuring a temporary freeze on all automated processes and Workflows until further action is taken.

    .PARAMETER Domain
    An [ANOWDomain] object representing the Domain to be suspended (placed on hold)

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWDomain] objects are accepted (including from the pipeline)

    .OUTPUTS
    A verbose information message will be sent indicating success

    .EXAMPLE
    Get-AutomateNOWDomain -Id 'MyCoolDomain' | Suspend-AutomateNOWDomain -Force

    .EXAMPLE
    @( 'Domain1', 'Domain2' ) | Get-AutomateNOWDomain | Suspend-AutomateNOWDomain

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWDomain]$Domain,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/domain/hold'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWDomain]$Domain = $_
        }
        [string]$Domain_id = $Domain.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Suspend the domain $($Domain_id)?")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [ANOWDomain]$current_Domain = Get-AutomateNOWDomain -Id $Domain_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWDomain failed to check if the Domain [$Domain_id] existed under Suspend-AutomateNOWDomain due to [$Message]."
                Break
            }
            If ($current_Domain.id.length -eq 0) {
                Write-Warning -Message "The Domain you specified does not seem to exist (Suspend-AutomateNOWDomain)"
                Break
            }
            [boolean]$current_Domain_hold_status = $current_Domain.globalHold
            If ($current_Domain_hold_status -eq $true) {
                Write-Warning -Message "[$Domain_id] cannot be suspended (placed on hold) as it is already suspended (on hold)"
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $Domain_id )
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_operationId', 'hold')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'DomainDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Domain_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Domain $Domain_id successfully suspended (placed on hold)"
        }
    }
    End {

    }
}

Function Resume-AutomateNOWDomain {
    <#
    .SYNOPSIS
    Removes the temporary freeze placed on all automated processes and workflows within a specific domain on an AutomateNOW! instance.

    .DESCRIPTION
    Removes the temporary freeze placed on all automated processes and workflows within a specific domain on an AutomateNOW! instance, allowing the resumption of normal operations.

    .PARAMETER Domain
    An [ANOWDomain] object representing the Domain to be resumed

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWDomain] objects are accepted (including from the pipeline)

    .OUTPUTS
    A verbose information message will be sent indicating success

    .EXAMPLE
    Get-AutomateNOWDomain -Id 'MyCoolDomain' | Resume-AutomateNOWDomain -Force

    .EXAMPLE
    @( 'Domain1', 'Domain2' ) | Get-AutomateNOWDomain | Resume-AutomateNOWDomain

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWDomain]$Domain,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/domain/resume'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWDomain]$Domain = $_
        }
        [string]$Domain_id = $Domain.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Resume the domain $($Domain_id)?")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [ANOWDomain]$current_Domain = Get-AutomateNOWDomain -Id $Domain_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWDomain failed to check if the Domain [$Domain_id] existed under Resume-AutomateNOWDomain due to [$Message]."
                Break
            }
            If ($current_Domain.id.length -eq 0) {
                Write-Warning -Message "The Domain you specified does not seem to exist (Resume-AutomateNOWDomain)"
                Break
            }
            [boolean]$current_Domain_hold_status = $current_Domain.globalHold
            If ($current_Domain_hold_status -eq $false) {
                Write-Warning -Message "[$Domain_id] cannot be resumed because it is not currently suspended (on hold)"
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $Domain_id )
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_operationId', 'resume')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'DomainDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Domain_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Domain $Domain_id successfully resumed (placed on hold)"
        }
    }
    End {

    }
}

Function Sync-AutomateNOWDomainServerNode {
    <#
    .SYNOPSIS
    Rebuilds the server node cache.

    .DESCRIPTION
    Rebuilds the server node cache. Involves regenerating and updating the cache of an AutomateNOW! server node enhancing system performance.

    .PARAMETER Domain
    An [ANOWDomain] object representing the Domain to rebuild the server node cache on.

    .INPUTS
    `Sync-AutomateNOWDomainServerNode` requires [ANOWDomain] objects which can be sent across the pipeline.

    .OUTPUTS
    A verbose message indicating success.

    .EXAMPLE

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWDomain]$Domain
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        [string]$command = '/domain/synchronizeServerNodes'
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
        $parameters.Add('Command', $command)
    }
    Process {
        If ($_.Length -gt 0) {
            [ANOWDomain]$Domain = $_
        }
        [string]$Domain_Id = $Domain.Id
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        $BodyMetaData.Add('id', $Domain_id )
        $BodyMetaData.Add('_operationType', 'custom')
        $BodyMetaData.Add('_operationId', 'synchronizeServerNodes')
        $BodyMetaData.Add('_textMatchStyle', 'exact')
        $BodyMetaData.Add('_dataSource', 'DomainDataSource')
        $BodyMetaData.Add('isc_metaDataPrefix', '_')
        $BodyMetaData.Add('isc_dataFormat', 'json')
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        $parameters.Add('Body', $Body)
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        Else {
            Write-Verbose -Message "The server node cache was rebuilt on $Domain_Id"
        }
    }
    End {

    }
}

Function Sync-AutomateNOWDomainResource {
    <#
    .SYNOPSIS
    Rebuilds the resources cache.

    .DESCRIPTION
    Rebuilds the resources cache. Involves refreshing and updating the cache of essential system resources, optimizing resource retrieval and enhancing application performance.

    .PARAMETER Domain
    An [ANOWDomain] object representing the Domain to rebuild the resource node cache on.

    .INPUTS
    `Sync-AutomateNOWDomainResource` requires [ANOWDomain] objects which can be sent across the pipeline.

    .OUTPUTS
    A verbose message indicating success.

    .EXAMPLE

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWDomain]$Domain
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        [string]$command = '/domain/synchronizeResources'
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
        $parameters.Add('Command', $command)
    }
    Process {
        If ($_.Length -gt 0) {
            [ANOWDomain]$Domain = $_
        }
        [string]$Domain_Id = $Domain.Id
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        $BodyMetaData.Add('id', $Domain_id )
        $BodyMetaData.Add('_operationType', 'custom')
        $BodyMetaData.Add('_operationId', 'synchronizeResources')
        $BodyMetaData.Add('_textMatchStyle', 'exact')
        $BodyMetaData.Add('_dataSource', 'DomainDataSource')
        $BodyMetaData.Add('isc_metaDataPrefix', '_')
        $BodyMetaData.Add('isc_dataFormat', 'json')
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        $parameters.Add('Body', $Body)
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        Else {
            Write-Verbose -Message "The resource cache was rebuilt on $Domain_Id"
        }
    }
    End {

    }
}

Function Clear-AutomateNOWDomain {
    <#
    .SYNOPSIS
    Completely reset and remove all data, configurations, and activities within a specific domain

    .DESCRIPTION
    Completely reset and remove all data, configurations, and activities within a specific domain, ensuring a clean slate and enabling users to start afresh with a clean environment for new workflows or system deployments.

    .PARAMETER Domain
    An [ANOWDomain] object representing the Domain to be cleared of items.

    .PARAMETER clearAll
    Switch parameter that clears ALL items in the Domain except for the Domain itself. Cannot be combined with other parameters. This parameter is the same as using the other 4 parameters combined.

    .PARAMETER clearDesign
    Switch parameter that clears design items including Tasks, Workflows, Schedules.

    .PARAMETER clearMonitoring
    Switch parameter that clears monitoring data including all Processing Items, Archive and Events.

    .PARAMETER clearServerNodes
    Switch parameter that clears server node items including Agents, Server Nodes and Endpoints

    .PARAMETER clearResources
    Switch parameter that clears resource items including Resource definitions and their state

    .INPUTS
    `Clear-AutomateNOWDomainResource` requires [ANOWDomain] objects which can be sent across the pipeline.

    .OUTPUTS
    A verbose message indicating success.

    .EXAMPLE
    Clears multiple domains of all items using the pipeline
    'Domain4', 'Domain5' | Get-AutomateNOWDomain | Clear-AutomateNOWDomain -clearAll

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    There is intentionally no force parameter for this function due to how DESTRUCTIVE it can be. If you really must provide confirmation then you can add the common parameter -confirm:$false to achieve the same effect.
    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High', DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'Default', ValueFromPipeline = $True)]
        [Parameter(Mandatory = $true, ParameterSetName = 'clearAll', ValueFromPipeline = $True)]
        [ANOWDomain]$Domain,
        [Parameter(Mandatory = $true, ParameterSetName = 'clearAll')]
        [switch]$clearAll,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$clearDesign,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$clearMonitoring,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$clearServerNodes,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$clearResources
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }

        If ($clearAll -ne $true -and $clearDesign -ne $true -and $clearMonitoring -ne $true -and $clearServerNodes -ne $true -and $clearResources -ne $true) {
            Write-Warning -Message "You must specify at least one clear-related parameter."
            Break
        }
        [hashtable]$parameters = @{}
        [string]$command = '/domain/clearAreas'
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
        $parameters.Add('Command', $command)
    }
    Process {
        If ($_.Length -gt 0) {
            [ANOWDomain]$Domain = $_
        }
        [string]$Domain_Id = $Domain.Id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("ARE YOU SURE YOU WANT TO CLEAR ITEMS FROM $($Domain_Id)? THIS IS VERY DESTRUCTIVE!")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $Domain_id )
            If ($clearAll -eq $true) {
                $BodyMetaData.Add('clearAll', 'true')
            }
            Else {
                $BodyMetaData.Add('clearAll', 'false')
                If ($clearDesign -eq $true) {
                    $BodyMetaData.Add('clearDesign', 'true')
                }
                If ($clearMonitoring -eq $true) {
                    $BodyMetaData.Add('clearMonitoring', 'true')
                }
                If ($clearServerNodes -eq $true) {
                    $BodyMetaData.Add('clearServerNodes', 'true')
                }
                If ($clearResources -eq $true) {
                    $BodyMetaData.Add('clearResources', 'true')
                }
            }
            $BodyMetaData.Add('_operationType', 'custom')
            $BodyMetaData.Add('_operationId', 'clearAreas')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'DomainDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Else {
                Write-Verbose -Message "The resource cache was rebuilt on $Domain_Id was cleared of the specified items"
            }
        }
    }
    End {

    }
}

#endregion

#Region - Endpoints

Function Get-AutomateNOWEndpoint {
    <#
    .SYNOPSIS
    Gets the Endpoints from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Endpoints from an AutomateNOW! instance

    .PARAMETER Id
    Optional string containing the simple id of the Endpoint to fetch or you can pipeline a series of simple id strings. You may not enter an array here.

    .PARAMETER EndpointType
    Optional string that will return all endpoints of that type. Valid choices are: USER; FTP; MAINFRAME_FTP; FTPS; MAINFRAME_FTPS; SFTP; S3; HDFS; AZURE_BLOB; AZURE_FILE; GOOGLE_COULD_STORAGE_BUCKET; PGP; HTTP; REST_WEB_SERVICE; SOAP_WEB_SERVICE; EMAIL; EMAIL_EWS; AWS; AZURE; GOOGLE_CLOUD; GOOGLE_DATA_FLOW; AZURE_DATABRICKS; INFORMATICA_CLOUD; AWS_COMMON; IBM_MQ; RABBIT_MQ; SQS; ACTIVE_MQ; QPID; IBM_SIBUS; HORNETQ; SOLACE; JORAM_MQ; QMQ; ZERO_MQ; KAFKA; PULSAR; AMAZON_KINESIS; GOOGLE_CLOUD_PUB_SUB; MICROSOFT_AZURE_EVENT_HUB; AMQP; XMPP; STOMP; REDIS; HADOOP; HIVE; IMPALA; SQOOP; YARN; SPARK; FLUME; FLINK; STORM; OOZIE; AMBARI; ELASTIC_SEARCH; CASSANDRA; SAP_HANA; MONGO_DB; COUCH_DB; COUCH_BASE; DYNAMO_DB; ARANGO_DB; NEO4J; ORIENT_DB; TITAN; SSH; WINRM; HIVE_QL; GOOGLE_BIG_QUERY; DASHDB; DB2; MYSQL; NETEZZA; AZURE_SQL_DATABASE; AZURE_SQL_DATA_WAREHOUSE; ORACLE; POSTGRESQL; SQL_SERVER; SQL_SERVER_JTDS; TERADATA; SINGLESTORE; VERTICA; SNOWFLAKE; PRESTO_DB; SYBASE; INFORMIX; H2; AS400; Z_OS; Z_OS_REST; RAINCODE; OPENTEXT; CTRL_M; INFORMATICA; INFORMATICA_WS; SAS; SAS_VIYA; IBM_DATASTAGE; ODI; MS_SSIS; AB_INITIO; SAP_BODI; SKYVIA; TALEND; DBT; SAP; SAP_S4_HANA; SAP_S4_HANA_CLOUD; SAP_IBP; JD_EDWARDS; ORACLE_EBS; PEOPLESOFT; MICROSOFT_DYNAMICS; JIRA; SERVICE_NOW; ORACLE_SERVICE_CENTER; BMC_REMEDY; CA_SERVICE_MANAGEMENT; IBM_CONTROL_DESK; HP_OPEN_VIEW_SERVICE_MANAGER; SAP_SOLUTION_MANAGER; FACEBOOK; INSTAGRAM; TWITTER; YOUTUBE; LINKED_IN; TUMBLR; TIKTOK; REDDIT; TELEGRAM; WHATSAPP; MICROSOFT_POWER_BI; TABLEAU; BLUE_PRISM; UI_PATH; AUTOMATION_ANYWHERE; WORK_FUSION; PEGA; ROBOT_FRAMEWORK; AUTOMATE_NOW; APACHE_AIRFLOW; ANSIBLE;

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100. The console default hard limit is 10,000.

    .INPUTS
    Accepts a string representing the simple id of the Endpoint from the pipeline or individually (but not an array).

    .OUTPUTS
    An array of one or more [ANOWEndpoint] class objects

    .EXAMPLE
    Gets the first page of Endpoints

    Get-AutomateNOWEndpoint

    .EXAMPLE
    Gets a single Endpoint named 'Endpoint1'

    Get-AutomateNOWEndpoint -Id 'Endpoint1'

    .EXAMPLE
    Gets a series of Endpoints by feeding their names through the pipeline.

    Endpoint1', 'Endpoint2' | Get-AutomateNOWEndpoint

    .EXAMPLE
    Gets the first page of Endpoint objects of type AZURE_BLOB

    Get-AutomateNOWEndpoint -EndpointType 'AZURE_BLOB'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWEndpoint[]])]
    [Cmdletbinding(DefaultParameterSetName = 'All')]
    Param(
        [Parameter(Mandatory = $False, ParameterSetName = 'Single', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [ANOWEndpoint_endpointType]$EndpointType,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [string]$Folder,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [string[]]$Tags
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 -or $Id.Length -gt 0 ) {
            If ($_.Length -gt 0) {
                $Body.'id' = $_
            }
            Else {
                $Body.'id' = $Id
            }
            [string]$textMatchStyle = 'exactCase'
            $Body.'_operationId' = 'read'
        }
        Else {
            $Body.'operator' = 'and'
            $Body.'_constructor' = 'AdvancedCriteria'
            If ($EndpointType.Length -gt 0) {
                $Body.'criteria1' = ('{"fieldName":"endpointType","operator":"equals","value":' + $EndpointType + '}')
            }
            If ($Folder.Length -gt 0) {
                $Body.'criteria2' = ('{"fieldName":"folder","operator":"equals","value":"' + $Folder + '"}')
            }
            If ($Tags.Count -gt 0) {
                If ($Tags.Count -gt 1) {
                    $Error.Clear()
                    Try {
                        [string]$TagString = $Tags | ConvertTo-Json -Compress
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "ConvertTo-Json failed to convert the provided tag names under Get-AutomateNOWEndpoint due to [$Message]."
                        Break
                    }
                }
                Else {
                    [string]$TagString = $Tags
                }
                $Body.'criteria3' = ('{"fieldName":"tags","operator":"containsAny","value":' + $TagString + '}')
            }
            $Body.'_componentId' = 'EndpointList'
            [string]$textMatchStyle = 'substring'
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
        }
        $Body.'_operationType' = 'fetch'
        $Body.'_textMatchStyle' = $textMatchStyle
        $Body.'_dataSource' = 'EndpointDataSource'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/endpoint/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWEndpoint[]]$Endpoints = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWEndpoint] objects due to [$Message]."
            Break
        }
        If ($Endpoints.Count -gt 0) {
            Return $Endpoints
        }
    }
    End {

    }
}

Function Export-AutomateNOWEndpoint {
    <#
    .SYNOPSIS
    Exports the Endpoints from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Endpoints from an instance of AutomateNOW! to a local .csv file

    .PARAMETER Endpoint
    Mandatory [ANOWEndpoint] object (Use Get-AutomateNOWEndpoint to retrieve them)

    .INPUTS
    ONLY [ANOWEndpoint] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWEndpoint] objects are exported to the local disk in CSV format

    .EXAMPLE
    Exports all endpoints
    Get-AutomateNOWEndpoint | Export-AutomateNOWEndpoint

    .EXAMPLE
    Exports a single endpoint
    Get-AutomateNOWEndpoint -Id 'Endpoint01' | Export-AutomateNOWEndpoint

    .EXAMPLE
    Exports a series of endpoints through the pipeline
    @( 'Endpoint01', 'Endpoint02' ) | Get-AutomateNOWEndpoint | Export-AutomateNOWEndpoint

    .EXAMPLE
    Exports all endpoints of a given type
    Get-AutomateNOWEndpoint -Type AZURE_BLOB | Export-AutomateNOWEndpoint

    .NOTES
	You must present [ANOWEndpoint] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWEndpoint]$Endpoint
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-Endpoints-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWEndpoint]$Endpoint = $_
        }
        $Error.Clear()
        Try {
            $Endpoint | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWEndpoint] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function New-AutomateNOWEndpoint {
    <#
    .SYNOPSIS
    Creates a Endpoint within an AutomateNOW! instance

    .DESCRIPTION
    Creates a Endpoint within an AutomateNOW! instance and returns back the newly created [ANOWEndpoint] object

    .PARAMETER Id
    The intended name of the Endpoint. For example: 'LinuxEndpoint1'. This value may not contain the domain in brackets.

    .PARAMETER EndpointType
    Required type of the Endpoint. Valid choices are: USER; FTP; MAINFRAME_FTP; FTPS; MAINFRAME_FTPS; SFTP; S3; HDFS; AZURE_BLOB; AZURE_FILE; GOOGLE_COULD_STORAGE_BUCKET; PGP; HTTP; REST_WEB_SERVICE; SOAP_WEB_SERVICE; EMAIL; EMAIL_EWS; AWS; AZURE; GOOGLE_CLOUD; GOOGLE_DATA_FLOW; AZURE_DATABRICKS; INFORMATICA_CLOUD; AWS_COMMON; IBM_MQ; RABBIT_MQ; SQS; ACTIVE_MQ; QPID; IBM_SIBUS; HORNETQ; SOLACE; JORAM_MQ; QMQ; ZERO_MQ; KAFKA; PULSAR; AMAZON_KINESIS; GOOGLE_CLOUD_PUB_SUB; MICROSOFT_AZURE_EVENT_HUB; AMQP; XMPP; STOMP; REDIS; HADOOP; HIVE; IMPALA; SQOOP; YARN; SPARK; FLUME; FLINK; STORM; OOZIE; AMBARI; ELASTIC_SEARCH; CASSANDRA; SAP_HANA; MONGO_DB; COUCH_DB; COUCH_BASE; DYNAMO_DB; ARANGO_DB; NEO4J; ORIENT_DB; TITAN; SSH; WINRM; HIVE_QL; GOOGLE_BIG_QUERY; DASHDB; DB2; MYSQL; NETEZZA; AZURE_SQL_DATABASE; AZURE_SQL_DATA_WAREHOUSE; ORACLE; POSTGRESQL; SQL_SERVER; SQL_SERVER_JTDS; TERADATA; SINGLESTORE; VERTICA; SNOWFLAKE; PRESTO_DB; SYBASE; INFORMIX; H2; AS400; Z_OS; Z_OS_REST; RAINCODE; OPENTEXT; CTRL_M; INFORMATICA; INFORMATICA_WS; SAS; SAS_VIYA; IBM_DATASTAGE; ODI; MS_SSIS; AB_INITIO; SAP_BODI; SKYVIA; TALEND; DBT; SAP; SAP_S4_HANA; SAP_S4_HANA_CLOUD; SAP_IBP; JD_EDWARDS; ORACLE_EBS; PEOPLESOFT; MICROSOFT_DYNAMICS; JIRA; SERVICE_NOW; ORACLE_SERVICE_CENTER; BMC_REMEDY; CA_SERVICE_MANAGEMENT; IBM_CONTROL_DESK; HP_OPEN_VIEW_SERVICE_MANAGER; SAP_SOLUTION_MANAGER; FACEBOOK; INSTAGRAM; TWITTER; YOUTUBE; LINKED_IN; TUMBLR; TIKTOK; REDDIT; TELEGRAM; WHATSAPP; MICROSOFT_POWER_BI; TABLEAU; BLUE_PRISM; UI_PATH; AUTOMATION_ANYWHERE; WORK_FUSION; PEGA; ROBOT_FRAMEWORK; AUTOMATE_NOW; APACHE_AIRFLOW; ANSIBLE;

    .PARAMETER Description
    Optional description of the Endpoint (may not exceed 255 characters).

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new Endpoint. Do not pass [ANOWTag] objects here.

    .PARAMETER Folder
    Optional name of the folder to place the Endpoint into.

    .PARAMETER CodeRepository
    Optional name of the code repository to place the Endpoint into.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWEndpoint.

    .OUTPUTS
    An [ANOWEndpoint] object representing the newly created Endpoint

    .EXAMPLE
    New-AutomateNOWEndpoint -Id 'endpoint_01' -EndpointType 'AZURE_BLOB' -Description 'Description!' -Tags 'Tag1', 'Tag2' -Folder 'Folder1'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The name (id) of the Endpoint must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    #>
    [OutputType([ANOWEndpoint])]
    [Cmdletbinding()]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $true)]
        [string]$Id,
        [Parameter(Mandatory = $true)]
        [ANOWEndpoint_endpointType]$endpointType,
        [Parameter(Mandatory = $false, HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [string]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [boolean]$Endpoint_exists = ($null -ne (Get-AutomateNOWEndpoint -Id $Id))
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWEndpoint failed to check if the Endpoint [$Id] already existed due to [$Message]."
        Break
    }
    If ($Endpoint_exists -eq $true) {
        [string]$current_domain = $anow_session.header.domain
        Write-Warning -Message "There is already an Endpoint named [$Id] in [$current_domain]. Please check into this."
        Break
    }
    ## End warning ##
    [System.Collections.Specialized.OrderedDictionary]$ANOWEndpoint = [System.Collections.Specialized.OrderedDictionary]@{}
    $ANOWEndpoint.Add('id', $Id)
    $ANOWEndpoint.Add('endpointType', $endpointType)
    If ($Description.Length -gt 0) {
        $ANOWEndpoint.Add('description', $Description)
    }
    If ($Tags.Count -gt 0) {
        [int32]$total_tags = $Tags.Count
        [int32]$current_tag = 1
        ForEach ($tag_id in $Tags) {
            $Error.Clear()
            Try {
                [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] running under New-AutomateNOWEndpoint due to [$message]"
                Break
            }
            If ($tag_object.simpleId.length -eq 0) {
                Throw "New-AutomateNOWEndpoint has detected that the tag [$tag_id] does not appear to exist. Please check again."
                Break
            }
            ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                [string]$tag_object_simpleId = $tag_object.simpleId
                Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                Break
            }
            [string]$tag_display = $tag_object | ConvertTo-Json -Depth 100 -Compress
            Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
            [string]$tag_name_sequence = ('tags' + $current_tag)
            $ANOWEndpoint.Add($tag_name_sequence, $tag_id)
            $include_properties += $tag_name_sequence
            $current_tag++
        }
    }
    If ($Folder.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] existed under New-AutomateNOWEndpoint due to [$Message]"
            Break
        }
        If ($folder_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] under New-AutomateNOWEndpoint. Please check again."
            Break
        }
        [string]$folder_display = $folder_object | ConvertTo-Json -Depth 100 -Compress
        Write-Verbose -Message "Adding folder $folder_display to [ANOWEndpoint] [$Id]"
        $ANOWEndpoint.Add('folder', $Folder)
        $include_properties += 'folder'
    }
    If ($CodeRepository.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository] existed under New-AutomateNOWEndpoint due to [$Message]"
            Break
        }
        If ($code_repository_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository] under New-AutomateNOWEndpoint. Please check again."
            Break
        }
        [string]$code_repository_display = $code_repository_object | ConvertTo-Json -Depth 100 -Compress
        Write-Verbose -Message "Adding code repository $code_repository_display to [ANOWEndpoint] [$Id]"
        $ANOWEndpoint.Add('codeRepository', $CodeRepository)
        $include_properties += 'codeRepository'
    }
    [string]$BodyObject = ConvertTo-QueryString -InputObject $ANOWEndpoint -IncludeProperties id, serverEndpointType, loadBalancer, totalWeightCapacity, description, tags, folder, codeRepository
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_operationType' = 'add'
    $BodyMetaData.'_oldValues' = '{"endpointType":"' + $endpointType + '"}'
    $BodyMetaData.'_componentId' = 'EndpointCreateWindow_form'
    $BodyMetaData.'_dataSource' = 'EndpointDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$BodyMetaDataString = ConvertTo-QueryString -InputObject $BodyMetaData
    [string]$Body = ($BodyObject + '&' + $BodyMetaDataString)
    [string]$command = '/endpoint/create'
    [hashtable]$parameters = @{}
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('Body', $Body)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWEndpoint]$Endpoint = $results.response.data | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to create [ANOWEndpoint] object due to [$Message]."
        Break
    }
    If ($Endpoint.id.Length -eq 0) {
        Write-Warning -Message "Somehow the newly created [ANOWEndpoint] Endpoint is empty!"
        Break
    }
    If ($Quiet -ne $true) {
        Return $Endpoint
    }
}

Function Set-AutomateNOWEndpoint {
    <#
    .SYNOPSIS
    Changes the settings of an Endpoint on an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of an Endpoint on an AutomateNOW! instance (but not the credential)

    .PARAMETER Endpoint
    An [ANOWEndpoint] object representing the Endpoint to be modified.

    .PARAMETER UnsetDescription
    Optional switch that will remove the Description from the Endpoint object.

    .PARAMETER Description
    Optional string to set the description on the new Endpoint object.

    .PARAMETER UnsetFolder
    Optional switch that will remove the Folder assignment from the Endpoint object.

    .PARAMETER Folder
    Optional string to set a different folder on the Endpoint object.

    .PARAMETER UnsetTags
    Optional switch that will remove the Tags from the Endpoint object.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the new Endpoint object.

    .PARAMETER CodeRepository
    Optional Code Repository to place the Endpoint into. Use Get-AutomateNOWCodeRepository to fetch this object.

    .PARAMETER UnsetCodeRepository
    Switch parameter that will remove the the Endpoint from its Code Repository.

    .PARAMETER EndpointCredential
    An optional hashtable that contains the needed properties to set the credential. See the examples.

    .PARAMETER Quiet
    Optional switch to suppress the return of the modified object

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWEndpoint] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWEndpoint] object will be returned

    .EXAMPLE
    Changes the description, tags and folder of an Endpoint named 'Endpoint1'

    $Endpoint = Get-AutomateNOWEndpoint -Id 'Endpoint1'
    Set-AutomateNOWEndpoint -Endpoint $Endpoint -Description 'My New Description' -Tags 'Tag1', 'Tag2' -Folder 'Folder1' -Force

    .EXAMPLE
    Removes the Description, folder and tags from an Endpoint named 'Endpoint1'

    Set-AutomateNOWEndpoint -Endpoint (Get-AutomateNOWEndpoint -Id 'Endoint1') -UnsetDescription -UnsetTags -UnsetFolder

    .EXAMPLE
    Sets the credential using Read-Host to securely receive the password on an Endpoint object of type USER

    $Endpoint = Get-AutomateNOWEndpoint -Id 'Endpoint1'
    [securestring]$secure_string = Read-Host -AsSecureString
    [string]$encrypted_string = Protect-AutomateNOWEncryptedString -SecureString $secure_string -IncludePrefix
    Set-AutomateNOWEndpoint -Endpoint $Endpoint -EndpointCredential (@{password = $encrypted_string; domain = "Domain"; user = "Username";})

    .EXAMPLE
    Forcefully and quietly sets the credential on an Endpoint object of type POSTGRESQL named 'Endpoint1' that includes a password 'MyCoolPassword'

    [securestring]$secure_string = 'MyCoolPassword' | ConvertTo-SecureString -AsPlainText -Force
    [string]$protected_string = Protect-AutomateNOWEncryptedString -SecureString $secure_string -IncludePrefix
    Set-AutomateNOWEndpoint -Endpoint $endpoint -EndpointCredential @{ url = 'jdbc:postgresql://anow-database.contoso.com:5432/anow'; oauthGrantType = 'CLIENT_CREDENTIALS'; connectionPoolSize = 10; maxLifeTime = 30; user = 'user'; password = $protected_string; closeConnectionPoolIfNotUsed = 'true' } -Quiet -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Setting the credential is currently in PREVIEW mode. You must supply the endpoint properties in a hashtable. See the examples in the help!

    #>
    [OutputType([ANOWEndpoint])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWEndpoint]$Endpoint,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetCodeRepository,
        [Parameter(Mandatory = $false)]
        [hashtable]$EndpointCredential,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot set the Tags and unset them at the same time. Please choose one or the other. Tags from the source object will be carried over to the new object if you do not specify any tag-related parameters."
            Break
        }
        If ($UnsetCodeRepository -eq $true -and $CodeRepository.Id.Length -gt 0) {
            Write-Warning -Message "You cannot unset the Code Repository and set it at the same time. Please choose one or the other."
            Break
        }
        [string]$command = '/endpoint/update'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWEndpoint]$Endpoint = $_
        }
        [string]$Endpoint_id = $Endpoint.id
        [string]$Endpoint_type = $Endpoint.endpointType
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Endpoint_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$Endpoint_exists = ($null -eq (Get-AutomateNOWEndpoint -Id $Endpoint_id))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWEndpoint failed to check if the Endpoint [$Endpoint_id] already existed due to [$Message]."
                Break
            }
            If ($Endpoint_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not a Result Mapping named [$Endpoint_id] in the [$current_domain] domain. Please check into this."
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $Endpoint_id
            If ($Description.Length -gt 0) {
                $BodyMetaData.'description' = $Description
            }
            ElseIf ($UnsetDescription -eq $true) {
                $BodyMetaData.'description' = $Null
            }
            Else {
                If ($Endpoint.description.Length -gt 0) {
                    $BodyMetaData.'description' = $Endpoint.description
                }
            }
            If ($UnsetFolder -eq $True) {
                $BodyMetaData.'folder' = $Null
            }
            ElseIf ($Folder.Length -gt 0) {
                $BodyMetaData.'folder' = $Folder
            }
            Else {
                If ($Endpoint.folder.Length -gt 0) {
                    $BodyMetaData.'folder' = $Endpoint.folder
                }
            }
            If ($Tags.Count -gt 0) {
                [int32]$tag_count = 1
                ForEach ($tag in $Tags) {
                    $BodyMetaData.('tags' + $tag_count ) = $tag
                    $tag_count++
                }
            }
            ElseIf ($UnsetTags -eq $true) {
                $BodyMetaData.'tags' = $Null
            }
            Else {
                If ($Endpoint.Tags -gt 0) {
                    [int32]$tag_count = 1
                    ForEach ($tag in $Endpoint.tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
            }
            If ($CodeRepository.Id.Length -gt 0) {
                [string]$CodeRepository_Id = $CodeRepository.Id
                $Error.Clear()
                Try {
                    [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository_Id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository_Id] actually existed under Set-AutomateNOWEndpoint due to [$Message]"
                    Break
                }
                If ($code_repository_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository_Id] under Set-AutomateNOWEndpoint. Please check again."
                    Break
                }
                $BodyMetaData.'codeRepository' = $CodeRepository_Id
            }
            ElseIf ($UnsetCodeRepository -eq $true) {
                $BodyMetaData.'codeRepository' = $null
            }
            If ($null -ne $EndpointCredential) {
                $Error.Clear()
                Try {
                    [string]$EndpointCredentialString = $EndpointCredential | ConvertTo-Json -Compress
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "ConvertFrom-Json failed when to convert the provided credential object under Set-AutomateNOWEndpoint to JSON format due to [$Message]."
                    Break
                }
                $BodyMetaData.endpointProperties = $EndpointCredentialString
            }
            [string]$old_values = $Endpoint.CreateOldValues()
            $BodyMetaData.'_oldValues' = $old_values
            $BodyMetaData.'_componentId' = 'EndpointVM'
            $BodyMetaData.'_operationType' = 'update'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_dataSource' = 'EndpointDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Endpoint_id] of type [$Endpoint_type] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Else {
                Write-Verbose -Message "Endpoint object [$Endpoint_id] of type [$Endpoint_type] was successfully updated"
            }
            $Error.Clear()
            Try {
                [ANOWEndpoint]$UpdatedEndpoint = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the response into an [ANOWEndpoint] object under Set-AutomateNOWEndpoint due to [$Message]."
                Break
            }
            If ($Quiet -ne $true) {
                Return $UpdatedEndpoint
            }
        }
    }
    End {
    }
}

Function Copy-AutomateNOWEndpoint {
    <#
    .SYNOPSIS
    Copies an Endpoint from an AutomateNOW! instance

    .DESCRIPTION
    Copies an Endpoint from an AutomateNOW! instance. AutomateNOW object id can never be changed, but we can copy the object to a new id and it will include all of the items therein.

    .PARAMETER Endpoint
    Mandatory [ANOWEndpoint] object to be copied.

    .PARAMETER NewId
    The name (Id) of the new Endpoint. The new Id must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    .PARAMETER UnsetDescription
    Optional switch that will ensure that the newly created Endpoint will not have a description set.

    .PARAMETER Description
    Optional description to set on the new Endpoint object. If you do not set this, the new Endpoint object will copy the Description of the source object.

    .PARAMETER UnsetFolder
    Optional switch that will ensure that the newly created Endpoint will not have a Folder set.

    .PARAMETER Folder
    Optional description to set a different folder on the new Endpoint object. If you do not set this, the new Endpoint object will use the same Folder of the source object.

    .PARAMETER UnsetTags
    Optional switch that will ensure that the newly created Endpoint will not have any Tags set.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the new Endpoint object. If you do not set this, the new Endpoint object will apply the same Tags of the source object.

    .PARAMETER Force
    Force the copy without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    ONLY [ANOWEndpoint] object is accepted. Pipeline support is intentionally unavailable.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Creates a copy of an Endpoint and changes the description (multi-line format)
    $Endpoint01 = Get-AutomateNOWEndpoint -Id 'endpoint_01'
    Copy-AutomateNOWEndpoint -Endpoint $Endpoint01 -NewId 'endpoint_01_production' -Description 'Endpoint 01 Production'

    .EXAMPLE
    Creates a copy of an Endpoint that omits the description (one-liner format)
    Copy-AutomateNOWEndpoint -Endpoint (Get-AutomateNOWEndpoint -Id 'endpoint_01') -NewId 'Endpoint_01_production' -UnsetDescription -Tags 'Tag1', 'Tag2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWEndpoint]$Endpoint,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot set the Tags and unset them at the same time. Please choose one or the other. Tags from the source object will be carried over to the new object if you do not specify any tag-related parameters."
            Break
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$Endpoint_exists = ($null -ne (Get-AutomateNOWEndpoint -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWEndpoint failed to check if the Endpoint [$NewId] already existed due to [$Message]."
            Break
        }
        If ($Endpoint_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already an Endpoint named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End warning ##
        [string]$command = '/endpoint/copy'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            [string]$Endpoint_oldId = $Endpoint.id
            [string]$Endpoint_simpleId = $Endpoint.simpleId
            If ($Endpoint_oldId -eq $NewId) {
                Write-Warning -Message "The new id cannot be the same as the old id."
                Break
            }
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Copy the Endpoint $($Endpoint_simpleId) to $($NewId)?")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                If ($UnsetFolder -eq $True) {
                    $BodyMetaData.'folder' = $Null
                }
                ElseIf ($Folder.Length -gt 0) {
                    $BodyMetaData.'folder' = $Folder
                }
                Else {
                    If ($Endpoint.folder.Length -gt 0) {
                        $BodyMetaData.'folder' = $Endpoint.folder
                    }
                }
                If ($Tags.Count -gt 0) {
                    [int32]$tag_count = 1
                    ForEach ($tag in $Tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
                ElseIf ($UnsetTags -eq $true) {
                    $BodyMetaData.'tags' = $Null
                }
                Else {
                    If ($Endpoint.Tags -gt 0) {
                        [int32]$tag_count = 1
                        ForEach ($tag in $Endpoint.tags) {
                            $BodyMetaData.('tags' + $tag_count ) = $tag
                            $tag_count++
                        }
                    }
                }
                $BodyMetaData.'oldId' = $Endpoint_oldId
                $BodyMetaData.'domain' = $Endpoint.domain
                $BodyMetaData.'id' = $NewId
                If ($UnsetDescription -ne $true) {
                    If ($Description.Length -gt 0) {
                        $BodyMetaData.'description' = $Description
                    }
                    Else {
                        $BodyMetaData.'description' = $Endpoint.description
                    }
                }
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_operationId' = 'copy'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_dataSource' = 'EndpointDataSource'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties oldId, domain, NewId, description, folder, tags
                $parameters.Body = $Body
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Endpoint_id] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                $Error.Clear()
                Try {
                    [ANOWEndpoint]$Endpoint = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to create copied [ANOWEndpoint] object $NewId due to [$Message]."
                    Break
                }
                If ($Endpoint.id.Length -eq 0) {
                    Write-Warning -Message "Somehow the newly created (copied) [ANOWEndpoint] object is empty!"
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $Endpoint
                }
            }
        }
    }
    End {

    }
}

Function Rename-AutomateNOWEndpoint {
    <#
    .SYNOPSIS
    Renames an Endpoint on an AutomateNOW! instance

    .DESCRIPTION
    Performs a psuedo-rename operations of an Endpoint from an AutomateNOW! instance by copying it first and then deleting the source. This function merely combines Copy-AutomateNOWEndpoint and Remove-AutomateNOWEndpoint therefore it is to be considered destructive.

    .PARAMETER Endpoint
    An [ANOWEndpoint] object representing the Endpoint to be renamed.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the Endpoint. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER Force
    Force the renaming without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly renamed object.

    .INPUTS
    ONLY [ANOWEndpoint] objects are accepted. There is intentionally no support for the pipeline.

    .OUTPUTS
    The newly renamed [ANOWEndpoint] object will be returned.

    .EXAMPLE
    $Endpoint = Get-AutomateNOWEndpoint -Id 'Endpoint01'
    Rename-AutomateNOWEndpoint -Endpoint $Endpoint -NewId 'Endpoint_01'

    .EXAMPLE
    Rename-AutomateNOWEndpoint -Endpoint (Get-AutomateNOWEndpoint -Id 'Endpoint01') -NewId 'Endpoint_01'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    When renaming, you may only specify a different Id (name).

    This action will be blocked if any existing referrals are found on the object.
    #>
    [OutputType([ANOWEndpoint])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWEndpoint]$Endpoint,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin standard warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$new_Endpoint_exists = ($null -ne (Get-AutomateNOWEndpoint -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWEndpoint failed to check if the Endpoint [$NewId] already existed due to [$Message]."
            Break
        }
        If ($new_Endpoint_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Endpoint named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        #[string]$Endpoint_id = $Endpoint.id
        [string]$Endpoint_id = $Endpoint.simpleId
        $Error.Clear()
        Try {
            [boolean]$old_Endpoint_exists = ($null -ne (Get-AutomateNOWEndpoint -Id $Endpoint_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWEndpoint failed to check if the Endpoint [$Endpoint_id] already existed due to [$Message]."
            Break
        }
        If ($old_Endpoint_exists -eq $false) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not a Endpoint named [$Endpoint_id] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End standard warning ##
        ## Begin referrals warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [int32]$referrals_count = Find-AutomateNOWObjectReferral -Endpoint $Endpoint -Count | Select-Object -Expandproperty referrals
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Find-AutomateNOWObjectReferral failed to extract the referrals on Endpoint [$Endpoint_id] due to [$Message]."
            Break
        }
        If ($referrals_count -gt 0) {
            Write-Warning -Message "Unfortunately, you cannot rename a Endpoint that has referrals. This is because the rename is not actually renaming but copying anew and deleting the old. Please, use the Find-AutomateNOWObjectReferral function to identify referrals and remove them."
            Break
        }
        Else {
            Write-Verbose -Message "The Endpoint [$Endpoint_id] does not have any referrals. It is safe to proceed."
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Endpoint_id)")) -eq $true) {
                $Error.Clear()
                Try {
                    [ANOWEndpoint]$new_Endpoint = Copy-AutomateNOWEndpoint -Endpoint $Endpoint -NewId $NewId -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Copy-AutomateNOWEndpoint failed to create a new Endpoint [$NewId] as Part 1 of the renaming process due to [$Message]."
                    Break
                }
                If ($new_Endpoint.simpleId -eq $NewId) {
                    Write-Verbose -Message "Part 1: Endpoint [$Endpoint_id] successfully copied to [$NewId]"
                }
                Else {
                    Write-Warning -Message "Somehow the first phase (Copy-AutomateNOWEndpoint) failed. Please look into this."
                    Break
                }
                $Error.Clear()
                Try {
                    Remove-AutomateNOWEndpoint -Endpoint $Endpoint -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Remove-AutomateNOWEndpoint failed to remove [$Endpoint_id] as Part 2 of the renaming process due to [$Message]."
                    Break
                }
                Write-Verbose -Message "Part 2: Endpoint [$Endpoint_id] removed"
                Write-Verbose -Message "Task [$Endpoint_id] successfully renamed to [$NewId]"
                If ($Quiet -ne $true) {
                    Return $new_Endpoint
                }
            }
        }
        Else {
            Write-Warning -Message "No action was taken because either the source object didn't exist or the new object already existed"
        }
    }
    End {
    }
}

Function Remove-AutomateNOWEndpoint {
    <#
    .SYNOPSIS
    Removes an Endpoint from an AutomateNOW! instance

    .DESCRIPTION
    Removes an Endpoint from an AutomateNOW! instance

    .PARAMETER Endpoint
    An [ANOWEndpoint] object representing the Endpoint to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWEndpoint] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Remove a single endpoint based on its name.
    Get-AutomateNOWEndpoint -Id 'Endpoint01' | Remove-AutomateNOWEndpoint

    .EXAMPLE
    Remove a series of endpoints based on the pipeline
    @( 'Endpoint1', 'Endpoint2', 'Endpoint3') | Get-AutomateNOWEndpoint | Remove-AutomateNOWEndpoint

    .EXAMPLE
    Forcibly remove all Azure Blob endpoints
    Get-AutomateNOWEndpoint -endpointType 'AZURE_BLOB' | Remove-AutomateNOWEndpoint -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWEndpoint]$Endpoint,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/endpoint/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWEndpoint]$Endpoint = $_
        }
        [string]$Endpoint_id = $Endpoint.id
        If ($Endpoint_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Endpoint_id)")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            [string]$old_values = $Endpoint.CreateOldValues()
            $BodyMetaData.'id' = $Endpoint_id
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_oldValues' = $old_values
            $BodyMetaData.'_componentId' = 'EndpointList'
            $BodyMetaData.'_dataSource' = 'EndpointDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$BodyMetaDataString = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $BodyMetaDataString)
            }
            Else {
                $parameters.Body = $BodyMetaDataString
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Endpoint_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Endpoint $Endpoint_id successfully removed"
        }
    }
    End {

    }
}

Function Show-AutomateNOWEndpointType {
    <#
    .SYNOPSIS
    Shows all of the available Endpoint types for AutomateNOW! in human readable format

    .DESCRIPTION
    Shows all of the available Endpoint types for AutomateNOW! in human readable format (this was statically coded and will become outdated!)

    .INPUTS
    None. You cannot pipe objects to Show-AutomateNOWEndpointType.

    .OUTPUTS
    An array of PSCustomObjects

    .EXAMPLE
    Show-AutomateNOWEndpointType | Where-Object { $_.name -match 'SQL'} | Select-Object Id, Name

    .NOTES
    This is a stand-alone function which does not require connectivity to the AutomateNOW! console

    There are no parameters yet for this function
    #>
    [PSCustomObject]$TaskTypesJson = '[{"id":"REMOTE_CONNECTION","icon":"[SKINIMG]/skin/terminal.gif","name":"Remote Connection","folder":true},{"id":"SSH","parent":"REMOTE_CONNECTION","icon":"[SKINIMG]/skin/terminal.gif","name":"SSH"},{"id":"WINRM","parent":"REMOTE_CONNECTION","name":"Windows RM","icon":"[SKINIMG]/skin/win.png"},{"id":"FILE_MANAGER","folder":true,"icon":"[SKINIMG]/skin/network_folder.png","name":"File Manager"},{"id":"FTP","parent":"FILE_MANAGER","name":"FTP","icon":"[SKINIMG]/skin/ftp.png"},{"id":"MAINFRAME_FTPS","parent":"FILE_MANAGER","name":"Mainframe FTPS","icon":"[SKINIMG]/skin/folder.png"},{"id":"MAINFRAME_FTP","parent":"FILE_MANAGER","name":"Mainframe FTP","icon":"[SKINIMG]/skin/ftp.png"},{"id":"FTPS","parent":"FILE_MANAGER","name":"FTPS","icon":"[SKINIMG]/skin/folder.png"},{"id":"SFTP","name":"SFTP","parent":"FILE_MANAGER","icon":"[SKINIMG]/skin/gnome.png"},{"id":"HDFS","name":"HDFS","parent":"HADOOP","icon":"[SKINIMG]/skin/hadoop.png"},{"id":"S3","name":"Amazon S3","parent":"FILE_MANAGER","icon":"[SKINIMG]/skin/amazon.png"},{"id":"AZURE_BLOB","parent":"FILE_MANAGER","name":"Azure Blob","icon":"[SKINIMG]/skin/azure.png"},{"id":"AZURE_FILE","parent":"FILE_MANAGER","name":"Azure File","icon":"[SKINIMG]/skin/azure.png"},{"id":"GOOGLE_COULD_STORAGE_BUCKET","parent":"FILE_MANAGER","name":"Google Cloud Storage Bucket","icon":"[SKINIMG]/skin/googleCloud.png"},{"id":"USER","name":"User","icon":"[SKINIMG]/skin/user.png"},{"id":"ENCRYPTION","icon":"[SKINIMG]/skin/pgp.png","name":"Encryption","folder":true},{"id":"PGP","parent":"ENCRYPTION","icon":"[SKINIMG]/skin/pgp.png","name":"PGP"},{"id":"IBM_SERIES","folder":true,"icon":"[SKINIMG]/skin/ibm.png","name":"IBM Series"},{"id":"AS400","parent":"IBM_SERIES","icon":"[SKINIMG]/skin/ibm_as400.gif","name":"IBM AS/400"},{"id":"Z_OS","parent":"IBM_SERIES","icon":"[SKINIMG]/skin/zos.png","name":"IBM z/OS Mainframe"},{"id":"Z_OS_REST","parent":"IBM_SERIES","icon":"[SKINIMG]/skin/zos.png","name":"IBM z/OS Mainframe - REST"},{"id":"RAINCODE","parent":"IBM_SERIES","icon":"[SKINIMG]/skin/raincode.ico","name":"Raincode"},{"id":"OPENTEXT","parent":"IBM_SERIES","icon":"[SKINIMG]/skin/microfocus.png","name":"OpenText"},{"id":"SQL_DATABASE","folder":true,"icon":"[SKINIMG]/skin/oracle.png","name":"SQL Database"},{"id":"ORACLE","parent":"SQL_DATABASE","icon":"[SKINIMG]/skin/oracle.png","name":"Oracle"},{"id":"TERADATA","parent":"SQL_DATABASE","icon":"[SKINIMG]/skin/teradata.png","name":"Teradata"},{"id":"SINGLESTORE","parent":"SQL_DATABASE","icon":"[SKINIMG]/skin/singlestore.jpg","name":"SingleStore"},{"id":"SQL_SERVER","parent":"SQL_DATABASE","icon":"[SKINIMG]/skin/sql_server.png","name":"MS SQL Server"},{"id":"SQL_SERVER_JTDS","parent":"SQL_DATABASE","icon":"[SKINIMG]/skin/sql_server.png","name":"MS SQL Server - JTDS"},{"id":"POSTGRESQL","parent":"SQL_DATABASE","icon":"[SKINIMG]/skin/postgres.png","name":"PostgreSQL"},{"id":"MYSQL","parent":"SQL_DATABASE","icon":"[SKINIMG]/skin/mysql.png","name":"MySQL"},{"id":"DB2","parent":"SQL_DATABASE","icon":"[SKINIMG]/skin/db2.png","name":"IBM DB2"},{"id":"NETEZZA","parent":"SQL_DATABASE","icon":"[SKINIMG]/skin/netezza.png","name":"Netezza"},{"id":"DASHDB","parent":"SQL_DATABASE","icon":"[SKINIMG]/skin/dashDB.png","name":"IBM DB2 on Cloud"},{"id":"SNOWFLAKE","parent":"SQL_DATABASE","icon":"[SKINIMG]/skin/snowflake.png","name":"Snowflake"},{"id":"VERTICA","parent":"SQL_DATABASE","icon":"[SKINIMG]/skin/vertica.png","name":"Vertica"},{"id":"PRESTO_DB","parent":"SQL_DATABASE","icon":"[SKINIMG]/skin/prestodb.png","name":"Presto DB"},{"id":"INFORMIX","parent":"SQL_DATABASE","icon":"[SKINIMG]/skin/informix.png","name":"Informix"},{"id":"H2","parent":"SQL_DATABASE","icon":"[SKINIMG]/skin/h2.png","name":"H2"},{"id":"SYBASE","parent":"SQL_DATABASE","icon":"[SKINIMG]/skin/sybase.png","name":"Sybase"},{"id":"AZURE_SQL_DATABASE","parent":"SQL_DATABASE","icon":"[SKINIMG]/skin/azure-sql.png","name":"Azure SQL Database"},{"id":"AZURE_SQL_DATA_WAREHOUSE","parent":"SQL_DATABASE","icon":"[SKINIMG]/skin/azure-warehouse.png","name":"Azure Synapse Analytics"},{"id":"HIVE_QL","parent":"SQL_DATABASE","icon":"[SKINIMG]/skin/hive.png","name":"Hive QL Database"},{"id":"GOOGLE_BIG_QUERY","parent":"SQL_DATABASE","icon":"[SKINIMG]/skin/bigquery.png","name":"Google BigQuery"},{"id":"SAP_HANA","parent":"SQL_DATABASE","icon":"[SKINIMG]/skin/sap.png","name":"SAP Hana"},{"id":"BIG_DATA","folder":true,"icon":"[SKINIMG]/skin/database.png","name":"Big Data"},{"id":"HADOOP","parent":"BIG_DATA","folder":true,"icon":"[SKINIMG]/skin/hadoop.png","name":"Hadoop"},{"id":"SPARK","parent":"HADOOP","icon":"[SKINIMG]/skin/spark.png","name":"Spark"},{"id":"FLINK","parent":"HADOOP","icon":"[SKINIMG]/skin/flink.jpg","name":"Flink"},{"id":"REDIS","parent":"BIG_DATA","icon":"[SKINIMG]/skin/redis.png","name":"Redis"},{"id":"NOSQL_DATABASE","folder":true,"icon":"[SKINIMG]/skin/mongodb.gif","name":"NoSQL Database"},{"id":"MONGO_DB","parent":"NOSQL_DATABASE","icon":"[SKINIMG]/skin/mongodb.gif","name":"Mongo DB"},{"id":"TITAN","parent":"NOSQL_DATABASE","icon":"[SKINIMG]/skin/titan.png","name":"Titan"},{"id":"MQ","folder":true,"icon":"[SKINIMG]/skin/queue.png","name":"Message Queues"},{"id":"IBM_MQ","parent":"MQ","icon":"[SKINIMG]/skin/ibm_mq.png","name":"IBM MQ"},{"id":"ACTIVE_MQ","parent":"MQ","icon":"[SKINIMG]/skin/activemq.png","name":"Active MQ"},{"id":"RABBIT_MQ","parent":"MQ","icon":"[SKINIMG]/skin/rabbitmq.png","name":"Rabbit MQ"},{"id":"KAFKA","parent":"MQ","icon":"[SKINIMG]/skin/kafka.png","name":"Kafka"},{"id":"HORNETQ","parent":"MQ","icon":"[SKINIMG]/skin/hornetq.png","name":"HornetQ"},{"id":"AMQP","parent":"MQ","icon":"[SKINIMG]/skin/amqp.png","name":"AMQP"},{"id":"XMPP","parent":"MQ","icon":"[SKINIMG]/skin/xmpp.png","name":"XMPP"},{"id":"STOMP","parent":"MQ","icon":"[SKINIMG]/skin/shoe.png","name":"STOMP"},{"id":"SOLACE","parent":"MQ","icon":"[SKINIMG]/skin/solace.png","name":"Solace"},{"id":"ETL","folder":true,"icon":"[SKINIMG]/skin/etl.png","name":"ETL Systems"},{"id":"INFORMATICA","parent":"ETL","icon":"[SKINIMG]/skin/informatica.ico","name":"Informatica Power Center"},{"id":"INFORMATICA_WS","parent":"ETL","icon":"[SKINIMG]/skin/informatica.ico","name":"Informatica WS Power Center"},{"id":"IBM_DATASTAGE","parent":"ETL","icon":"[SKINIMG]/skin/ibminfosphere.png","name":"IBM Infosphere DataStage"},{"id":"SAS","parent":"ETL","icon":"[SKINIMG]/skin/sas.png","name":"SAS"},{"id":"SAS_VIYA","parent":"ETL","icon":"[SKINIMG]/skin/sas_viya.png","name":"SAS Viya"},{"id":"MS_SSIS","parent":"ETL","icon":"[SKINIMG]/skin/ssis.png","name":"MS SQL Server Integration Services"},{"id":"ODI","parent":"ETL","icon":"[SKINIMG]/skin/odi.png","name":"Oracle Data Integrator"},{"id":"TALEND","parent":"ETL","icon":"[SKINIMG]/skin/talend.png","name":"Talend"},{"id":"DBT","parent":"ETL","icon":"[SKINIMG]/skin/dbt.ico","name":"dbt"},{"id":"ERP","folder":true,"icon":"[SKINIMG]/skin/erp.png","name":"ERP Systems"},{"id":"SAP","parent":"ERP","icon":"[SKINIMG]/skin/sap.png","name":"SAP R/3"},{"id":"SAP_S4_HANA","parent":"ERP","icon":"[SKINIMG]/skin/sap.png","name":"SAP S/4HANA"},{"id":"SAP_S4_HANA_CLOUD","parent":"ERP","icon":"[SKINIMG]/skin/sap.png","name":"SAP S/4HANA Cloud"},{"id":"ORACLE_EBS","parent":"ERP","icon":"[SKINIMG]/skin/oracle.png","name":"Oracle EBS"},{"id":"PEOPLESOFT","parent":"ERP","icon":"[SKINIMG]/skin/oracle.png","name":"Peoplesoft"},{"id":"WEB","folder":true,"icon":"[SKINIMG]/skin/globe_network.png","name":"Web Service"},{"id":"HTTP","parent":"WEB","icon":"[SKINIMG]/skin/world.png","name":"Http"},{"id":"REST_WEB_SERVICE","parent":"WEB","icon":"[SKINIMG]/skin/rest.png","name":"REST Web Service"},{"id":"SOAP_WEB_SERVICE","parent":"WEB","icon":"[SKINIMG]/skin/soap.png","name":"SOAP Web Service"},{"id":"EMAIL","parent":"WEB","icon":"[SKINIMG]/skin/mail.png","name":"Email"},{"id":"EMAIL_EWS","parent":"WEB","icon":"[SKINIMG]/skin/mail.png","name":"Email Exchange Web Service"},{"id":"ITSM","folder":true,"icon":"skin/compress_repair.png","name":"ITSM"},{"id":"SERVICE_NOW","parent":"ITSM","icon":"skin/servicenow.png","name":"ServiceNow"},{"id":"JIRA","parent":"ITSM","icon":"skin/jira.png","name":"Jira"},{"id":"BMC_REMEDY","parent":"ITSM","icon":"skin/bmc.ico","name":"BMC Remedy"},{"id":"BI","folder":true,"icon":"[SKINIMG]/skin/table_chart.png","name":"Business Intelligence"},{"id":"TABLEAU","parent":"BI","icon":"[SKINIMG]/skin/tableau.ico","name":"Tableau"},{"id":"MICROSOFT_POWER_BI","parent":"BI","icon":"[SKINIMG]/skin/powerBi.ico","name":"Microsoft Power BI"},{"id":"CLOUD","folder":true,"icon":"[SKINIMG]/skin/cloud.png","name":"Cloud"},{"id":"AWS","parent":"CLOUD","icon":"[SKINIMG]/skin/aws.png","name":"Amazon Web Services"},{"id":"AWS_COMMON","parent":"CLOUD","icon":"[SKINIMG]/skin/aws.png","name":"Amazon Web Services Common"},{"id":"AZURE","parent":"CLOUD","icon":"[SKINIMG]/skin/azure.png","name":"Azure"},{"id":"AZURE_DATABRICKS","parent":"CLOUD","icon":"[SKINIMG]/skin/azure.png","name":"Azure DataBricks"},{"id":"INFORMATICA_CLOUD","parent":"CLOUD","icon":"[SKINIMG]/skin/informatica.ico","name":"Informatica Cloud"},{"id":"INSTANT_MESSAGING","name":"Instant Messaging","icon":"[SKINIMG]/skin/comment_edit.png","folder":true},{"id":"TELEGRAM","name":"Telegram","icon":"[SKINIMG]/skin/telegram.png","parent":"INSTANT_MESSAGING"},{"id":"WHATSAPP","name":"WhatsApp","icon":"[SKINIMG]/skin/whatsapp.png","parent":"INSTANT_MESSAGING"},{"id":"RPA","folder":true,"icon":"[SKINIMG]/skin/robot.png","name":"Robotic Process Automation"},{"id":"BLUE_PRISM","parent":"RPA","icon":"[SKINIMG]/skin/blueprism.ico","name":"Blue Prism"},{"id":"UI_PATH","parent":"RPA","icon":"[SKINIMG]/skin/uipath.ico","name":"UI Path"},{"id":"ROBOT_FRAMEWORK","parent":"RPA","icon":"[SKINIMG]/skin/robotFramework.png","name":"Robot Framework"},{"id":"WLA","folder":true,"icon":"[SKINIMG]/skin/gears.png","name":"Workload Automation"},{"id":"AUTOMATE_NOW","parent":"WLA","icon":"[SKINIMG]/skin/favicon.png","name":"AutomateNOW!"},{"id":"APACHE_AIRFLOW","parent":"WLA","icon":"skin/airflow.png","name":"Apache Airflow"},{"id":"VC","folder":true,"icon":"skin/vcs.png","name":"Version Control"},{"id":"GIT","parent":"VC","icon":"skin/git.png","name":"Git"},{"id":"ANSIBLE","parent":"WLA","icon":"skin/ansible.png","name":"Ansible"},{"id":"CTRL_M","parent":"WLA","icon":"skin/bmc.png","name":"Ctrl-M"}]' | ConvertFrom-Json
    [array]$EndpointTypesArray = $TaskTypesJson | ForEach-Object { [PSCustomObject]@{ Parent = $_.parent; Id = $_.id; Name = $_.name; Icon = $_.icon } }
    Return $EndpointTypesArray
}

#endregion

#Region - Events (RESOURCE)

Function Get-AutomateNOWEvent {
    <#
    .SYNOPSIS
    Gets the Event objects from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Event objects from an AutomateNOW! instance

    .PARAMETER Id
    Optional string containing the simple id of the Event to fetch or you can pipeline a series of simple id strings. You may not enter an array here.

    .PARAMETER Detailed
    Switch parameter to provide the detailed properties of the [ANOWEvent] object. This may only be used in conjunction with -Id. Use this option to see the fully populated object.

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100. The console default hard limit is 10,000.

    .PARAMETER sortBy
    Optional string parameter to sort the results by (may not be used with the Id parameter). Valid choices are: {To be continued...}

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .PARAMETER Folder
    Optional string to filter by a particular Folder

    .PARAMETER Tags
    Optional string array of Tags to filter by. Note that the 'containsAny' operator will be used.

    .INPUTS
    Accepts a string representing the simple id of the Event from the pipeline or individually (but not an array).

    .OUTPUTS
    Either one or more [ANOWEvent] objects

    .EXAMPLE
    Gets the first page of Event objects

    Get-AutomateNOWEvent

    .EXAMPLE
    Gets the first 500 Event objects

    Get-AutomateNOWEvent -startRow 0 -endRow 500

    .EXAMPLE
    Gets a single non-detailed Event named 'Event1'

    Get-AutomateNOWEvent -Id 'Event1'

    .EXAMPLE
    Gets the detailed version of an Event object named 'Event1'

    Get-AutomateNOWEvent -Id 'Event1' -Detailed

    .EXAMPLE
    Gets a series of Event objects through the pipeline

    'Event1', 'Event2' | Get-AutomateNOWEvent

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(DefaultParameterSetName = 'Id')]
    Param(
        [Parameter(Mandatory = $False, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [Parameter(Mandatory = $False, ParameterSetName = 'Detailed', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'Detailed')]
        [switch]$Detailed,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [string]$sortBy = 'id',
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [switch]$Descending,
        [Parameter(Mandatory = $False)]
        [string]$Folder,
        [Parameter(Mandatory = $False)]
        [string[]]$Tags
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 ) {
            [string]$Event_Id = $_
        }
        Else {
            [string]$Event_Id = $Id
        }
        If ($Detailed -eq $true) {
            $Body.'id' = $Event_Id
            [string]$textMatchStyle = 'exactCase'
            $Body.'_operationId' = 'readDetailed'
            [string]$Method = 'POST'
        }
        Else {
            $Body.'_constructor' = 'AdvancedCriteria'
            $Body.'operator' = 'and'
            $Body.'criteria1' = '{"fieldName":"resourceType","operator":"equals","value":"EVENT"}'
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
            If ($Event_Id.Length -gt 0) {
                $Body.'criteria2' = ('{"fieldName":"simpleId","operator":"equals","value":"' + $Event_Id + '"}')
                [string]$textMatchStyle = 'exact'
            }
            Else {
                [string]$textMatchStyle = 'substring'
            }
            If ($Folder.Length -gt 0) {
                $Body.'criteria3' = ('{"fieldName":"folder","operator":"equals","value":"' + $Folder + '"}')
            }
            If ($Tags.Count -gt 0) {
                If ($Tags.Count -gt 1) {
                    $Error.Clear()
                    Try {
                        [string]$TagString = $Tags | ConvertTo-Json -Compress
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "ConvertTo-Json failed to convert the provided tag names under Get-AutomateNOWEvent due to [$Message]."
                        Break
                    }
                }
                Else {
                    [string]$TagString = $Tags
                }
                $Body.'criteria4' = ('{"fieldName":"tags","operator":"containsAny","value":' + $TagString + '}')
            }
            $Body.'_componentId' = 'ResourceList'
            If ($Descending -eq $true) {
                $Body.'_sortBy' = '-' + $sortBy
            }
            Else {
                $Body.'_sortBy' = $sortBy
            }
            [string]$Method = 'GET'
        }
        $Body.'_operationType' = 'fetch'
        $Body.'_textMatchStyle' = $textMatchStyle
        $Body.'_dataSource' = 'ResourceDataSource'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        If ($Detailed -eq $true) {
            [string]$command = ('/resource/readDetailed')
            If ($Null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            If ($null -eq $parameters["Command"]) {
                $parameters.Add('Command', $command)
            }
            Else {
                $parameters.Command = $command
            }
        }
        Else {
            [string]$command = ('/resource/read?' + $Body)
            $parameters.Command = $command
        }
        If ($null -eq $parameters.Method) {
            $parameters.Add('Method', $Method)
        }
        Else {
            $parameters.Method = $Method
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWEvent[]]$Events = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWEvent failed to parse the results into [ANOWEvent] objects due to [$Message]."
            Break
        }
        If ($Events.Count -gt 0) {
            Return $Events
        }
    }
    End {

    }
}

Function Set-AutomateNOWEvent {
    <#
    .SYNOPSIS
    Changes the settings of an Event on an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of an Event on an AutomateNOW! instance

    .PARAMETER Event
    An [ANOWEvent] object representing the Event to be modified.

    .PARAMETER Value
    Optional string to set the value of the Event to.

    .PARAMETER UnsetDescription
    Optional switch that will remove the Description from the Event object.

    .PARAMETER Description
    Optional string to set the description on the new Event object.

    .PARAMETER UnsetFolder
    Optional switch that will remove the Folder assignment from the Event object.

    .PARAMETER Folder
    Optional string to set a different folder on the Event object.

    .PARAMETER UnsetTags
    Optional switch that will remove the Tags from the Event object.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the new Event object.

    .PARAMETER CodeRepository
    Optional Code Repository to place the Event into. Use Get-AutomateNOWCodeRepository to fetch this object.

    .PARAMETER UnsetCodeRepository
    Switch parameter that will remove the the Event from its Code Repository.

    .PARAMETER Quiet
    Switch parameter that silences the output of the updated object.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWEvent] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWEvent] object will be returned

    .EXAMPLE
    Changes the description and folder, along with setting 2 tags on an Event

    $Event = Get-AutomateNOWEvent -Id 'Event1'
    Set-AutomateNOWEvent -Description 'Awesome description!' -Tags 'Tag1', 'Tag2' -Folder 'Folder1'

    .EXAMPLE
    Forcibly changes the total permits of an Event to 1000

    $Event = Get-AutomateNOWEvent -Id 'Event1'
    Set-AutomateNOWEvent -Event $Event -TotalPermits 1000 -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Events do not have a settings or attributes tab like most objects do. Therefore, this particular function is very limited in what it can do. See the other related functions.

    Adding actions and parameters are not supported yet. Use Get-AutomateNOWEventEvent to see the related processing events for a particular Event Resource object.

    #>
    [OutputType([ANOWEvent])]
    [Cmdletbinding(SupportsShouldProcess, DefaultParameterSetName = 'Default', ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'Default', ValueFromPipeline = $True)]
        [Parameter(Mandatory = $true, ParameterSetName = 'SetValue', ValueFromPipeline = $True)]
        [ANOWEvent]$Event,
        [Parameter(Mandatory = $false, ParameterSetName = 'SetValue')]
        [string]$Value,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [string[]]$Tags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [string]$Folder,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetCodeRepository,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$Quiet,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot set the Tags and unset them at the same time. Please choose one or the other. Tags from the source object will be carried over to the new object if you do not specify any tag-related parameters."
            Break
        }
        If ($UnsetCodeRepository -eq $true -and $CodeRepository.Id.Length -gt 0) {
            Write-Warning -Message "You cannot unset the Code Repository and set it at the same time. Please choose one or the other."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWEvent]$Event = $_
        }
        [string]$Event_id = $Event.id
        [string]$Event_simpleId = $Event.simpleId
        [string]$current_Event_value = $Event.value
        If ($current_Event_value.Length -eq 0) {
            Write-Verbose -Message "Detected the value of Event object [$Event_simpleId] is empty"
        }
        Else {
            Write-Verbose -Message "Detected the value of Event object [$Event_simpleId] to be [$current_Event_value]"
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Event_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$Event_exists = ($null -eq (Get-AutomateNOWEvent -Id $Event_simpleId))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWEvent failed to check if the Event [$Event_simpleId] already existed due to [$Message]."
                Break
            }
            If ($Event_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not an Event named [$Event_simpleId] in the [$current_domain] domain. Please check into this."
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $Event_id
            If ($Value.Length -gt 0) {
                If ($Value -eq $current_Event_value) {
                    Write-Warning -Message "No action is required. The Event [$Event_simpleId] is already set to [$Value]"
                    Break
                }
                Else {
                    Write-Verbose -Message "Changing the value of [$Event_simpleId] from [$current_Event_value] to [$Value]"
                }
                $BodyMetaData.'newValue' = $Value
                [string]$operationId = 'setValue'
                [string]$operationType = 'custom'
                $BodyMetaData.'_operationId' = $operationId
                [string]$command = "/resource/$operationId"
            }
            ElseIf ($TotalPermits -gt 0 -and ($Event_total_permits -eq $TotalPermits)) {
                Write-Warning -Message "No action is required. $Event_id already has $Event_total_permits total permits."
                Break
            }
            Else {
                [string]$command = '/resource/update'
                [string]$operationType = 'update'
                If ($Description.Length -gt 0) {
                    $BodyMetaData.'description' = $Description
                }
                ElseIf ($UnsetDescription -eq $true) {
                    $BodyMetaData.'description' = $Null
                }
                Else {
                    If ($Event.description.Length -gt 0) {
                        $BodyMetaData.'description' = $Event.description
                    }
                }
                If ($UnsetFolder -eq $True) {
                    $BodyMetaData.'folder' = $Null
                }
                ElseIf ($Folder.Length -gt 0) {
                    $BodyMetaData.'folder' = $Folder
                }
                Else {
                    If ($Event.folder.Length -gt 0) {
                        $BodyMetaData.'folder' = $Event.folder
                    }
                }
                If ($Tags.Count -gt 0) {
                    [int32]$tag_count = 1
                    ForEach ($tag in $Tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
                ElseIf ($UnsetTags -eq $true) {
                    $BodyMetaData.'tags' = $Null
                }
                Else {
                    If ($Event.Tags -gt 0) {
                        [int32]$tag_count = 1
                        ForEach ($tag in $Event.tags) {
                            $BodyMetaData.('tags' + $tag_count ) = $tag
                            $tag_count++
                        }
                    }
                }
            }
            If ($CodeRepository.Id.Length -gt 0) {
                [string]$CodeRepository_Id = $CodeRepository.Id
                $Error.Clear()
                Try {
                    [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository_Id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository_Id] actually existed under Set-AutomateNOWEvent due to [$Message]"
                    Break
                }
                If ($code_repository_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository_Id] under Set-AutomateNOWEvent. Please check again."
                    Break
                }
                $BodyMetaData.'codeRepository' = $CodeRepository_Id
            }
            ElseIf ($UnsetCodeRepository -eq $true) {
                $BodyMetaData.'codeRepository' = $null
            }
            $BodyMetaData.'_operationType' = $operationType
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_dataSource' = 'ResourceDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $parameters.Add('Command', $command)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Event_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Event object [$Event_id] was successfully updated"
            $Error.Clear()
            Try {
                [ANOWEvent]$UpdatedEvent = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the returned updated object to an [ANOWEvent] object due to [$Message]. The object was still updated though."
                Break
            }
            If ($Quiet -ne $true) {
                Return $UpdatedEvent
            }
        }
    }
    End {
    }
}

Function Export-AutomateNOWEvent {
    <#
    .SYNOPSIS
    Exports the Event objects from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Event objects from an instance of AutomateNOW! to a local .csv file

    .PARAMETER Event
    Mandatory [ANOWEvent] object (Use Get-AutomateNOWEvent to retrieve them)

    .INPUTS
    ONLY [ANOWEvent] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWEvent] objects are exported to the local disk in CSV format

    .EXAMPLE
    Exports all of the Event objects (up to 100 by default)

    Get-AutomateNOWEvent | Export-AutomateNOWEvent

    .EXAMPLE
    Exports 1 Event by name

    Get-AutomateNOWEvent -Id 'Event01' | Export-AutomateNOWEvent

    .EXAMPLE
    Exports a series of Event objects by the pipeline

    @( 'Event01', 'Event02' ) | Get-AutomateNOWEvent | Export-AutomateNOWEvent

    .NOTES
	You must present [ANOWEvent] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWEvent]$Event
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-Events-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWEvent]$Event = $_
        }
        $Error.Clear()
        Try {
            $Event | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWEvent] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function New-AutomateNOWEvent {
    <#
    .SYNOPSIS
    Creates an Event within an AutomateNOW! instance

    .DESCRIPTION
    Creates an Event within an AutomateNOW! instance and returns back the newly created [ANOWEvent] object

    .PARAMETER Id
    The intended name of the Event. For example: 'Event1'. This value may not contain the domain in brackets.

    .PARAMETER Description
    Optional description of the Event (may not exceed 255 characters).

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new Event. Do not pass [ANOWTag] objects here.

    .PARAMETER Folder
    Optional name of the folder to place the Event into.

    .PARAMETER CodeRepository
    Optional name of the code repository to place the Event into.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWEvent.

    .OUTPUTS
    An [ANOWEvent] object representing the newly created Event

    .EXAMPLE
    New-AutomateNOWEvent -Id 'Event01' -Description 'Description01' -Tags 'Tag01' -Folder 'Folder01' -CodeRepository 'Repository01'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The name (id) of the Event must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    #>
    [OutputType([ANOWEvent])]
    [Cmdletbinding()]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $true)]
        [string]$Id,
        [ValidateScript({ $_.Length -le 255 })]
        [Parameter(Mandatory = $false, HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [string]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [boolean]$Event_exists = ($null -ne (Get-AutomateNOWEvent -Id $Id))
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWEvent failed to check if the Event [$Id] already existed due to [$Message]."
        Break
    }
    If ($Event_exists -eq $true) {
        [string]$current_domain = $anow_session.header.domain
        Write-Warning -Message "There is already an Event named [$Id] in [$current_domain]. Please check into this."
        Break
    }
    ## End warning ##
    [System.Collections.Specialized.OrderedDictionary]$ANOWEvent = [System.Collections.Specialized.OrderedDictionary]@{}
    $ANOWEvent.Add('id', $Id)
    If ($Description.Length -gt 0) {
        $ANOWEvent.Add('description', $Description)
    }
    If ($Tags.Count -gt 0) {
        [int32]$total_tags = $Tags.Count
        [int32]$current_tag = 1
        ForEach ($tag_id in $Tags) {
            $Error.Clear()
            Try {
                [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] running under New-AutomateNOWEvent due to [$message]"
                Break
            }
            If ($tag_object.simpleId.length -eq 0) {
                Throw "New-AutomateNOWEvent has detected that the tag [$tag_id] does not appear to exist. Please check again."
                Break
            }
            ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                [string]$tag_object_simpleId = $tag_object.simpleId
                Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                Break
            }
            [string]$tag_display = $tag_object | ConvertTo-Json -Compress
            Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
            [string]$tag_name_sequence = ('tags' + $current_tag)
            $ANOWEvent.Add($tag_name_sequence, $tag_id)
            $include_properties += $tag_name_sequence
            $current_tag++
        }
    }
    If ($Folder.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] existed under New-AutomateNOWEvent due to [$Message]"
            Break
        }
        If ($folder_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] under New-AutomateNOWEvent. Please check again."
            Break
        }
        [string]$folder_display = $folder_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding folder $folder_display to [ANOWEvent] [$Id]"
        $ANOWEvent.Add('folder', $Folder)
        $include_properties += 'folder'
    }
    If ($CodeRepository.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository] existed under New-AutomateNOWEvent due to [$Message]"
            Break
        }
        If ($code_repository_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository] under New-AutomateNOWEvent. Please check again."
            Break
        }
        [string]$code_repository_display = $code_repository_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding code repository $code_repository_display to [ANOWEvent] [$Id]"
        $ANOWEvent.Add('codeRepository', $CodeRepository)
        $include_properties += 'codeRepository'
    }
    $ANOWEvent.Add('title', 'Event')
    $ANOWEvent.Add('icon', '[SKINIMG]/skin/arrow-out.png')
    $oldvalues = ('{"title":"Event","resourceType":"EVENT","icon":"[SKINIMG]/skin/arrow-out.png"}')
    [string]$BodyObject = ConvertTo-QueryString -InputObject $ANOWEvent -IncludeProperties id, description, title, icon, tags, folder, codeRepository
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    $BodyMetaData.'resourceType' = 'EVENT'
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_operationType' = 'add'
    $BodyMetaData.'_oldValues' = $oldvalues
    $BodyMetaData.'_componentId' = 'ResourceCreateWindow_form'
    $BodyMetaData.'_dataSource' = 'ResourceDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$BodyMetaDataString = ConvertTo-QueryString -InputObject $BodyMetaData
    [string]$Body = ($BodyObject + '&' + $BodyMetaDataString)
    [string]$command = '/resource/create'
    [hashtable]$parameters = @{}
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('Body', $Body)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWEvent]$Event = $results.response.data | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to parse the result of New-AutomateNOWEvent into an [ANOWEvent] object due to [$Message]."
        Break
    }
    If ($Event.id.Length -eq 0) {
        Write-Warning -Message "Somehow the newly created [ANOWEvent] object is empty!"
        Break
    }
    If ($Quiet -ne $true) {
        Return $Event
    }
}

Function Remove-AutomateNOWEvent {
    <#
    .SYNOPSIS
    Removes an Event from an AutomateNOW! instance

    .DESCRIPTION
    Removes an Event from an AutomateNOW! instance

    .PARAMETER Event
    An [ANOWEvent] object representing the Event to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWEvent] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Remove a single Event by name

    Get-AutomateNOWEvent -Id 'Event01' | Remove-AutomateNOWEvent

    .EXAMPLE
    Removes a series of Event objects via input from the pipeline

    @( 'Event01', 'Event02', 'Event03') | Get-AutomateNOWEvent | Remove-AutomateNOWEvent

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWEvent]$Event,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/resource/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWEvent]$Event = $_
        }
        [string]$Event_id = $Event.id
        If ($Event_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Event_id)")) -eq $true) {
            [string]$oldvalues = $Event.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $Event.id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'ResourceList'
            $BodyMetaData.'_dataSource' = 'ResourceDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Event_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Event [$Event_id] successfully removed"
        }
    }
    End {

    }
}

Function Copy-AutomateNOWEvent {
    <#
    .SYNOPSIS
    Copies an Event from an AutomateNOW! instance

    .DESCRIPTION
    Copies an Event from an AutomateNOW! instance. AutomateNOW object id can never be changed, but we can copy the object to a new id and it will include all of the items therein.

    .PARAMETER Event
    Mandatory [ANOWEvent] object to be copied.

    .PARAMETER NewId
    The name (Id) of the new Event. The new Id must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    .PARAMETER UnsetDescription
    Optional switch that will ensure that the newly created Event will not have a description set.

    .PARAMETER Description
    Optional description to set on the new Event object. If you do not set this, the new Event object will copy the Description of the source object.

    .PARAMETER UnsetFolder
    Optional switch that will ensure that the newly created Event will not have a Folder set.

    .PARAMETER Folder
    Optional description to set a different folder on the new Event object. If you do not set this, the new Event object will use the same Folder of the source object.

    .PARAMETER UnsetTags
    Optional switch that will ensure that the newly created Event will not have any Tags set.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the new Event object. If you do not set this, the new Event object will apply the same Tags of the source object.

    .PARAMETER Force
    Force the copy without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    ONLY [ANOWEvent] object is accepted. Pipeline support is intentionally unavailable.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Creates a copy of an Event and changes the description (multi-line format)
    $Event01 = Get-AutomateNOWEvent -Id 'Event_01'
    Copy-AutomateNOWEvent -Event $Event01 -NewId 'Event_01_production' -Description 'Event 01 Production'

    .EXAMPLE
    Creates a copy of an Event that omits the description (one-liner format)
    Copy-AutomateNOWEvent -Event (Get-AutomateNOWEvent -Id 'Event_01') -NewId 'Event_01_production' -UnsetDescription -Tags 'Tag1', 'Tag2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWEvent]$Event,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot set the Tags and unset them at the same time. Please choose one or the other. Tags from the source object will be carried over to the new object if you do not specify any tag-related parameters."
            Break
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$Event_exists = ($null -ne (Get-AutomateNOWEvent -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWEvent failed to check if the Event [$NewId] already existed due to [$Message]."
            Break
        }
        If ($Event_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already an Event named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End warning ##
        [string]$command = '/resource/copy'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            [string]$Event_oldId = $Event.id
            [string]$Event_simpleId = $Event.simpleId
            If ($Event_oldId -eq $NewId) {
                Write-Warning -Message "The new id cannot be the same as the old id."
                Break
            }
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Copy the Event $($Event_simpleId) to $($NewId)?")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                If ($UnsetFolder -eq $True) {
                    $BodyMetaData.'folder' = $Null
                }
                ElseIf ($Folder.Length -gt 0) {
                    $BodyMetaData.'folder' = $Folder
                }
                Else {
                    If ($Event.folder.Length -gt 0) {
                        $BodyMetaData.'folder' = $Event.folder
                    }
                }
                If ($Tags.Count -gt 0) {
                    [int32]$tag_count = 1
                    ForEach ($tag in $Tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
                ElseIf ($UnsetTags -eq $true) {
                    $BodyMetaData.'tags' = $Null
                }
                Else {
                    If ($Event.Tags -gt 0) {
                        [int32]$tag_count = 1
                        ForEach ($tag in $Event.tags) {
                            $BodyMetaData.('tags' + $tag_count ) = $tag
                            $tag_count++
                        }
                    }
                }
                $BodyMetaData.'oldId' = $Event_oldId
                $BodyMetaData.'domain' = $Event.domain
                $BodyMetaData.'id' = $NewId
                If ($UnsetDescription -ne $true) {
                    If ($Description.Length -gt 0) {
                        $BodyMetaData.'description' = $Description
                    }
                    Else {
                        $BodyMetaData.'description' = $Event.description
                    }
                }
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_operationId' = 'copy'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_dataSource' = 'ResourceDataSource'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties oldId, domain, NewId, description, folder, tags
                $parameters.Body = $Body
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Event_oldId] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                $Error.Clear()
                Try {
                    [ANOWEvent]$NewEvent = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to create copied [ANOWEvent] object [$NewId] due to [$Message]."
                    Break
                }
                If ($NewEvent.id.Length -eq 0) {
                    Write-Warning -Message "Somehow the newly created (copied) [ANOWEvent] object [$NewId] is empty!"
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $NewEvent
                }
            }
        }
    }
    End {

    }
}

Function Rename-AutomateNOWEvent {
    <#
    .SYNOPSIS
    Renames an Event on an AutomateNOW! instance

    .DESCRIPTION
    Performs a psuedo-rename operations of an Event from an AutomateNOW! instance by copying it first and then deleting the source. This function merely combines Copy-AutomateNOWEvent and Remove-AutomateNOWEvent therefore it is to be considered destructive.

    .PARAMETER Event
    An [ANOWEvent] object representing the Event to be renamed.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the Event. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER Force
    Force the renaming without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly renamed object.

    .INPUTS
    ONLY [ANOWEvent] objects are accepted. There is intentionally no support for the pipeline.

    .OUTPUTS
    The newly renamed [ANOWEvent] object will be returned.

    .EXAMPLE
    $Event = Get-AutomateNOWEvent -Id 'Event01'
    Rename-AutomateNOWEvent -Event $Event -NewId 'Event_01'

    .EXAMPLE
    Rename-AutomateNOWEvent -Event (Get-AutomateNOWEvent -Id 'Event01') -NewId 'Event_01'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    When renaming, you may only specify a different Id (name).

    This action will be blocked if any existing referrals are found on the object.
    #>
    [OutputType([ANOWEvent])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWEvent]$Event,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin standard warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$new_Event_exists = ($null -ne (Get-AutomateNOWEvent -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWEvent failed to check if the Event [$NewId] already existed due to [$Message]."
            Break
        }
        If ($new_Event_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already an Event named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        #[string]$Event_id = $Event.id
        [string]$Event_id = $Event.simpleId
        $Error.Clear()
        Try {
            [boolean]$old_Event_exists = ($null -ne (Get-AutomateNOWEvent -Id $Event_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWEvent failed to check if the Event [$Event_id] already existed due to [$Message]."
            Break
        }
        If ($old_Event_exists -eq $false) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not an Event named [$Event_id] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End standard warning ##
        ## Begin referrals warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [int32]$referrals_count = Find-AutomateNOWObjectReferral -Event $Event -Count | Select-Object -Expandproperty referrals
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Find-AutomateNOWObjectReferral failed to extract the referrals on Event [$Event_id] due to [$Message]."
            Break
        }
        If ($referrals_count -gt 0) {
            Write-Warning -Message "Unfortunately, you cannot rename an Event that has referrals. This is because the rename is not actually renaming but copying anew and deleting the old. Please, use the Find-AutomateNOWObjectReferral function to identify referrals and remove them."
            Break
        }
        Else {
            Write-Verbose -Message "The Event [$Event_id] does not have any referrals. It is safe to proceed."
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Event_id)")) -eq $true) {
                $Error.Clear()
                Try {
                    [ANOWEvent]$new_Event = Copy-AutomateNOWEvent -Event $Event -NewId $NewId -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Copy-AutomateNOWEvent failed to create a new Event [$NewId] as Part 1 of the renaming process due to [$Message]."
                    Break
                }
                If ($new_Event.simpleId -eq $NewId) {
                    Write-Verbose -Message "Part 1: Event [$Event_id] successfully copied to [$NewId]"
                }
                Else {
                    Write-Warning -Message "Somehow the first phase (Copy-AutomateNOWEvent) failed. Please look into this."
                    Break
                }
                $Error.Clear()
                Try {
                    Remove-AutomateNOWEvent -Event $Event -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Remove-AutomateNOWEvent failed to remove [$Event_id] as Part 2 of the renaming process due to [$Message]."
                    Break
                }
                Write-Verbose -Message "Part 2: Event [$Event_id] removed"
                Write-Verbose -Message "Task [$Event_id] successfully renamed to [$NewId]"
                If ($Quiet -ne $true) {
                    Return $Event
                }
            }
        }
        Else {
            Write-Warning -Message "No action was taken because either the source object didn't exist or the new object already existed"
        }
    }
    End {
    }
}

Function Start-AutomateNOWEvent {
    <#
    .SYNOPSIS
    Starts (triggers) an Event on an AutomateNOW! instance

    .DESCRIPTION
    Starts (triggers) an Event on an AutomateNOW! instance

    .PARAMETER Event
    Mandatory [ANOWEvent] object to be triggered.

    .PARAMETER EventParameters
    An optional [hashtable] containing the parameters to start the Event with. Example: @{"parameter1"="ABC";"parameter2"="123";}

    .PARAMETER ProcessingTimestamp
    Optional processing timestamp. You should not use this unless you really need to. Leave this blank for the value to be populated automatically (same as the UI). The format is a UTC datestamp string: 08383/1019 03:14:07

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    [ANOWEvent] objects are accepted individually or via the pipeline

    .OUTPUTS
    The latest related [ANOWProcessingEvent] object will be returned

    .EXAMPLE

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This function is equivalent to pressing the Trigger on an Event object in the UI.

    #>
    [OutputType([ANOWProcessingEvent])]
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWEvent]$Event,
        [Parameter(Mandatory = $false)]
        [hashtable]$EventParameters,
        [ValidateScript({ $_ -match '[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}.[0-9]{3}' })]
        [Parameter(Mandatory = $false)]
        [string]$ProcessingTimestamp,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to trigger it.
        $Error.Clear()
        Try {
            [boolean]$Event_exists = ($null -ne (Get-AutomateNOWEvent -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWEvent failed to check if the Event [$NewId] already existed due to [$Message]."
            Break
        }
        If ($Event_exists -eq $false) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not an Event named [$NewId] in the [$current_domain] domain. Please check your parameters."
            Break
        }
        ## End warning ##
        [string]$command = '/resource/triggerEvent'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.Id.Length -gt 0) {
            [ANOWEvent]$Event = $_
        }
        [string]$Event_Id = $Event.Id
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($ProcessingTimestamp.Length -eq 0) {
            [string]$ProcessingTimeStamp = Microsoft.PowerShell.Utility\Get-Date -Date (Microsoft.PowerShell.Utility\Get-Date).ToUniversalTime() -Format 'yyyy-MM-ddTHH:mm:ss.fff'
        }
        $BodyMetaData.'processingTimestamp' = $ProcessingTimeStamp
        $BodyMetaData.'id' = $Event_Id
        If ($Parameters.Keys.Count -gt 0) {
            $Error.Clear()
            Try {
                [string]$EventParameters_json = $EventParameters | ConvertTo-Json -Compress
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "ConvertTo-Json failed to convert the supplied parameter hashtable due to [$Message]."
                Break
            }
            $BodyMetaData.'parameters' = $EventParameters_json
        }
        Else {
            $BodyMetaData.'parameters' = '{}'
        }
        $BodyMetaData.'_operationType' = 'custom'
        $BodyMetaData.'_operationId' = 'triggerEvent'
        $BodyMetaData.'_textMatchStyle' = 'exact'
        $BodyMetaData.'_dataSource' = 'ResourceDataSource'
        $BodyMetaData.'isc_metaDataPrefix' = '_'
        $BodyMetaData.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties parameters
        $parameters.Body = $Body
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Event_oldId] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWEvent]$StartedEvent = $results.response.data | Select-Object -First 1
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to start (trigger) [ANOWEvent] object [$Event_Id] due to [$Message]."
            Break
        }
        If ($StartedEvent.id.Length -eq 0) {
            Write-Warning -Message "Somehow the newly started (triggered) [ANOWEvent] object [$Event_Id] is empty!"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWProcessingEvent]$ProcessingEvent = Read-AutomateNOWProcessingEventLog -Resource $StartedEvent -category 'RESOURCE' -eventType 'RESOURCE_EVENT_TRIGGERED' -startRow 0 -endRow 1 | Select-Object -First 1
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Read-AutomateNOWProcessingEventLog failed due to retrieve the latest Processing Event Log entry after starting Event $Event_Id due to [$Message]."
            Break
        }
        If ($ProcessingEvent.Id.Length -eq 0) {
            Write-Warning -Message "Somehow there Processing Event Log entry for Event $Event_Id was returned empty"
            Break
        }
        Else {
            [string]$ProcessingEventId = $ProcessingEvent.Id
            Write-Verbose -Message "Received back Event Log Id $ProcessingEventId after starting $Event_Id"
        }
        $Error.Clear()
        If ($Quiet -ne $true) {
            Return $ProcessingEvent
        }
    }
    End {

    }
}

#endregion

#Region - Event Log (Processing)

Function Read-AutomateNOWProcessingEventLog {
    <#
    .SYNOPSIS
    Gets the Processing Event Log entries from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Processing Event Log entries from an AutomateNOW! instance

    .PARAMETER Category
    Optional type of Event Log. Use this if you are not providing an object to filter against. Valid choices are: PROCESSING; SERVER_NODE; RESOURCE; AGENT; DOMAIN;

    .PARAMETER eventType
    Optional filter by specifying the eventType. Valid options are: APPLICATION_BROADCAST_MESSAGE; PROCESSING_EVALUATED; PROCESSING_LOADED; PROCESSING_QUEUED; PROCESSING_TRIGGERED; PROCESSING_SENSOR_ITEM_FOUND; PROCESSING_WARNING; PROCESSING_WAITING; PROCESSING_READY; PROCESSING_RECEIVED; PROCESSING_STARTED; PROCESSING_FINISHED; PROCESSING_HANDLE_FINAL_FINISHED_STATUS; PROCESSING_FAILED; PROCESSING_COMPLETED; PROCESSING_ARCHIVED; PROCESSING_ARCHIVED_CLEANUP; PROCESSING_SKIP_ON; PROCESSING_SKIP_OFF; PROCESSING_SKIPPED; PROCESSING_HOLD; PROCESSING_RESUME; PROCESSING_ABORT; PROCESSING_KILL; PROCESSING_ABORTING; PROCESSING_ABORTED; PROCESSING_KILLED; PROCESSING_ABORT_FAILED; PROCESSING_FORCE_COMPLETED; PROCESSING_FORCE_FAILED; PROCESSING_FORCE_READY; PROCESSING_RESTART; PROCESSING_RETRY; PROCESSING_RESTATE; PROCESSING_RELOAD; PROCESSING_CONTEXT_VARIABLE_SET; PROCESSING_INTERNAL_ITEM_ACTION; PROCESSING_ITEM_NOT_LOADED; PROCESSING_CHILDREN_LOADED; PROCESSING_LOAD_LAZY_ITEMS; PROCESSING_FORCE_LAZY_LOAD_ITEMS; PROCESSING_DEPENDENCY_CREATED; PROCESSING_DEPENDENCY_DELETED; PROCESSING_DEPENDENCY_UPDATED; PROCESSING_SUCCESSOR_ADDED; PROCESSING_ACTION_CREATED; PROCESSING_ACTION_DELETED; PROCESSING_ACTION_UPDATED; NOTE_ADDED; NOTE_CLOSED; PROCESSING_ACTION_APPROVAL_PENDING; PROCESSING_ACTION_APPROVE; PROCESSING_ACTION_REJECT; PROCESSING_ACTION_APPROVED; PROCESSING_ACTION_REJECTED; PROCESSING_ACTION_FUTILE_ATTEMPT; PROCESSING_ACTION_FAILED_ATTEMPT; PROCESSING_ACTION_FINISHED; PROCESSING_SET_DELAYED_START_TIME; TRIGGER_ITEM_EXECUTION; SET_PRIORITY; SET_WEIGHT; SET_STATUS_CODE; SET_FOLDER; ADD_TAG; REMOVE_TAG; UPDATE_TASK_COMMAND; UPDATE_PROCESSING_FORCE_COMPLETED_CONDITION; UPDATE_PROCESSING_FORCE_FAILED_CONDITION; UPDATE_PROCESSING_CUSTOM_FIELD_VALUES; UPDATE_PROCESSING_RESTORE_ORIGINAL_COMMAND_ON_RESTART; UPDATE_PROCESSING_AUTO_ARCHIVE; UPDATE_PROCESSING_OWNER; UPDATE_PROCESSING_OWNER_ROLE; UPDATE_PROCESSING_APPROVAL_CONFIGURATION; UPDATE_PROCESSING_RESULT_MAPPING; UPDATE_PROCESSING_NAME; UPDATE_PROCESSING_DESCRIPTION; UPDATE_PROCESSING_STATUS_CODE; UPDATE_PROCESSING_STATUS_MESSAGE; CONFIRMED; DENIED; DATA_ENTERED; PROCESSING_SERVER_NODE_SET; PROCESSING_SERVER_NODE_ENDPOINT_SET; PROCESSING_SERVER_NODE_DISCONNECTED; PROCESSING_SERVER_NODE_RESTARTED; EXECUTING_LONG; EXECUTING_SHORT; EARLY_START; LATE_START; EARLY_END; LATE_END; NOT_STARTED; CRITICAL_PATH_CHANGED; CRITICAL_PATH_ON; CRITICAL_PATH_OFF; TRANSFORM_PROCESSING_TEMPLATE; PROCESSING_ADD_FORECAST_ITEM; PROCESSING_ADD_ROOT_FORECAST_ITEM; CHILD_ADDED; CHILD_REMOVED; SET_PROCESSING_SERVER_NODE_DISCONNECTED; SET_PROCESSING_SERVER_NODE_RESTARTED; EXECUTE_PRELOADED_PROCESSING; PROCESSING_FINISH_RESTART; RESOURCE_SYNCHRONIZE_QUEUE; CHECK_READY; CHECK_RESOURCES; GET_CACHED_RESOURCE_STATES; ACQUIRE_RESOURCES; ENQUEUE_RESOURCES; DEQUEUE_RESOURCES; PROCESSING_RESOURCE_ACQUIRED; PROCESSING_RESOURCE_QUEUED; CHECK_SERVER_NODE; ASSIGN_SERVER_NODE; APPLY_SERVER_NODE; RELEASE_SERVER_NODE; ENQUEUE_SERVER_NODE; DEQUEUE_SERVER_NODE; SERVER_NODE_SYNCHRONIZE_QUEUE; SET_SERVER_NODE; READY_TO_ARCHIVE; READY_TO_START; CHILD_STATUS_CHANGE; CHILD_SERVICE_STATUS_CHANGE; INTERNAL_MONITOR_ITERATION; MONITOR_STATUS_RECEIVED; PROCESSING_SET_INTERNAL_STATE; PROCESSING_STATE_UPDATED; UPDATE_OBSERVER_STATE; INITIALIZE_OBSERVER_STATE; SERVICE_STATUS_GREEN; SERVICE_STATUS_YELLOW; SERVICE_STATUS_RED; RESOURCES_RELEASED; SYNCHRONIZED_RESOURCES_RELEASED; DISPATCH_ACTION; SET_SEMAPHORE_STATE; SET_SEMAPHORE_OFF; SET_SEMAPHORE_ON; TIME_INDEXED_RESOURCE_CHANGED; REMOVE_PROCESSING_FROM_RESOURCE_QUEUE; RELEASE_PROCESSING_SYNCHRONIZED_RESOURCES; RESOURCE_SEMAPHORE_ON; RESOURCE_SEMAPHORE_OFF; RESOURCE_TIME_INDEXED_SEMAPHORE_OFF; RESOURCE_TIME_INDEXED_SEMAPHORE_ON; RESOURCE_TIME_INDEXED_SET_VARIABLE_VALUE; RESOURCE_UNLOCKED; RESOURCE_LOCK_SHARED; RESOURCE_LOCK_EXCLUSIVE; RESOURCE_STOCK_ACQUIRED; RESOURCE_STOCK_RELEASED; RESOURCE_BARRIER_ACQUIRED; RESOURCE_BARRIER_RELEASED; RESOURCE_ADJUST_TOTAL_PERMITS; RESOURCE_SET_VALUE; SET_METRIC; SET_PHYSICAL_RESOURCE; RESOURCE_METRIC_SET_VALUE; RESOURCE_EVENT_TRIGGERED; RESOURCE_ANOMALY; RESOURCE_CREATE; AGENT_DISCONNECTED; AGENT_CONNECTED; AGENT_START; AGENT_STOP; AGENT_STARTED; AGENT_STOPPED; AGENT_CENTRAL_MANAGEMENT_ON; AGENT_CONFIGURATION_PUSHED; AGENT_CONFIGURATION_CHANGED; AGENT_UPGRADE_START; AGENT_NODE_CONNECTED; AGENT_NODE_DISCONNECTED; AGENT_NODE_ADDED; AGENT_NODE_REMOVED; LOAD_BALANCER_NODE_CONNECTED; LOAD_BALANCER_NODE_DISCONNECTED; LOAD_BALANCER_NODE_ADDED; LOAD_BALANCER_NODE_REMOVED; SERVER_NODE_HOLD; SERVER_NODE_RESUME; SERVER_NODE_DISCONNECTED; SERVER_NODE_CONNECTED; SERVER_NODE_CONNECTION_CHANGED; SERVER_NODE_ABORTED_ALL; SERVER_NODE_ABORT_ALL; SERVER_NODE_KILLED_ALL; SERVER_NODE_KILL_ALL; SERVER_NODE_STOP; SERVER_NODE_STOPPED; SERVER_NODE_START; SERVER_NODE_STARTED; SERVER_NODE_SKIP_ON; SERVER_NODE_SKIP_OFF; SERVER_NODE_AGENT_IP_CHANGED; SERVER_NODE_CONFIGURATION_PUSHED; SERVER_NODE_CONFIGURATION_CHANGED; SERVER_NODE_BASELINE_DEVIATION_MULTIPLIER_CHANGED; SERVER_NODE_OCCUPIED_WEIGHT_CHANGED; SERVER_NODE_WEIGHT_RELEASED; SERVER_NODE_TOTAL_WEIGHT_CHANGED; APPLY_DESIGN_IMPORT_OPERATION; VALIDATE_DESIGN_IMPORT_OPERATION; EXECUTE_DYNAMIC_PROCESSING; DOMAIN_HOLD; DOMAIN_RESUME; DOMAIN_CLEAR; DOMAIN_CLEAR_MONITORING; DOMAIN_CLEAR_DESIGN; SCHEDULE_CALENDAR; SCHEDULE_PROCESSING_TIME_TRIGGER; SCHEDULE_RESOURCE_TIME_TRIGGER; SCHEDULE_REMOVE_CALENDAR; SCHEDULE_REMOVE_PROCESSING_TIME_TRIGGER; SCHEDULE_REMOVE_RESOURCE_TIME_TRIGGER; SCHEDULE_CLEAR_DOMAIN; SAVE_VERSION_CONTROL_RECORD; PROCESSING_EXECUTE_PRE_SCRIPT; PROCESSING_EXECUTE_POST_SCRIPT; PROCESSING_EXECUTE_SCRIPT; PROCESSING_PRE_SCRIPT_STARTED; PROCESSING_POST_SCRIPT_STARTED; PROCESSING_SCRIPT_STARTED; PROCESSING_PRE_SCRIPT_COMPLETED; PROCESSING_POST_SCRIPT_COMPLETED; PROCESSING_SCRIPT_COMPLETED; PROCESSING_PRE_SCRIPT_FAILED; PROCESSING_POST_SCRIPT_FAILED; PROCESSING_SCRIPT_FAILED;

    .PARAMETER Domain
    Mandatory (ONLY IF DOMAIN CATEGORY IS SELECTED) [ANOWDomain] object that corresponds to the Domain you wish to retrieve the event logs about.

    .PARAMETER Resource
    Mandatory (ONLY IF RESOURCE CATEGORY IS SELECTED) [ANOWResource] object that corresponds to the Resource you wish to retrieve the event logs about.

    .PARAMETER Agent
    Mandatory (ONLY IF AGENT CATEGORY IS SELECTED) [ANOWAgent] object that corresponds to the Agent you wish to retrieve the event logs from.

    .PARAMETER Processing
    Optional (ONLY IF PROCESSING CATEGORY IS SELECTED) [ANOWProcessingTemplate] object that corresponds to the Node you wish to retrieve the event logs about. Use Get-AutomateNOWTaskTemplate, Get-AutomateNOWWorkflowTemplate, Get-AutomateNOWScheduleTemplate or Get-AutomateNOWServiceManagerTemplate to fetch these.

    .PARAMETER ServerNode
    Optional (ONLY IF SERVER_NODE CATEGORY IS SELECTED) [ANOWServerNode] object that corresponds to the Node you wish to retrieve the event logs about.

    .PARAMETER sortBy
    Optional string parameter to sort the results by. Valid choices are: 'dateCreated', 'timestamp', 'parentProcessingId', 'processingId', 'rootProcessingId'

    .PARAMETER Ascending
    Optional switch parameter to sort in ascending order (oldest to newest)

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100. The console default hard limit is 10,000.

    .INPUTS
    You cannot pipe input to `Get-AutomateNOWResourceEventLog`

    .OUTPUTS
    An array of one or more [ANOWProcessingEvent] objects

    .EXAMPLE
    Gets the first 100 Server Node Processing Events (i.e. log entries)

    Read-AutomateNOWProcessingEventLog -Category SERVER_NODE

    .EXAMPLE
    Gets the first 100 Server Node Processing Events (i.e. log entries) for a specific node named ServerNode1

    Read-AutomateNOWProcessingEventLog -ServerNode (Get-AutomateNOWServerNode -Id 'ServerNode1')

    .EXAMPLE
    Gets the first 100 Resource Processing Events (i.e. log entries)

    Read-AutomateNOWProcessingEventLog -Category RESOURCE

    .EXAMPLE
    Gets the first 100 Resource Processing Events (i.e. log entries) for a Metric named 'Metric1'

    Read-AutomateNOWProcessingEventLog -Resource (Get-AutomateNOWMetric -Id 'Metric1')

    .EXAMPLE
    Gets the first 100 Processing Process Events (i.e. log entries)

    Read-AutomateNOWProcessingEventLog -Category PROCESSING

    .EXAMPLE
    Gets the first 100 Processing Process Events (i.e. log entries) for a specified Workflow with a RunId of 1234567. Note that Tasks, Workflows, Service Managers and Schedules (Triggers) are within the PROCESSING category.

    Read-AutomateNOWProcessingEventLog -Processing (Get-AutomateNOWWorkflow -Id 1234567)

    .EXAMPLE
    Gets the first 100 Domain Processing Events (i.e. log entries) for the current domain

    Read-AutomateNOWProcessingEventLog -Category DOMAIN

    .EXAMPLE
    Gets the first 100 Domain Processing Events (i.e. log entries) for a specified domain named 'Domain1'

    Read-AutomateNOWProcessingEventLog -Domain (Get-AutomateNOWDomain -Id 'Domain1')

    .EXAMPLE
    Gets the first 100 Agent Events (i.e. log entries)

    Read-AutomateNOWProcessingEventLog -Category AGENT

    .EXAMPLE
    Gets the first 100 Agent Processing Events (i.e. log entries) for an Agent named Agent1 in the domain

    Read-AutomateNOWProcessingEventLog -Agent (Get-AutomateNOWAgent -Id 'Agent1')

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The PROCESSING category is available in the UI by selecting the Monitor tab followed by Event Log.

    The SERVER_NODE category is available in the UI by selecting the Nodes tab followed by Event Log.

    The RESOURCE category is available in the UI by selecting the Resources tab followed by Event Log.

    The AGENT category is available in the UI when an Agent object has been opened for editing. Click the heartbeat icon in the upper right to view the log. This category is limited to only events from this particular Agent.

    The DOMAIN category is available in the UI when a Domain object has been opened for editing. Click the heartbeat icon in the upper right to view the log. This category is limited to only events from this particular Domain. If you want to retrieve the log from other domains you'll need to switch domains with Switch-AutomateNOWDomain.

    For the DOMAIN log, if you do not provide an [ANOWDomain] object to the -Domain parameter then the current domain will be taken from the global anow_session variable. At the time of this writing, the DOMAIN log does not seem to function correctly and always returns 0 results.

    #>
    [OutputType([ANOWProcessingEvent[]])]
    [Cmdletbinding( DefaultParameterSetName = 'Category')]
    Param(
        [Parameter(Mandatory = $True, ParameterSetName = 'Category')]
        [ANOWProcessingEvent_eventCategory]$category,
        [Parameter(Mandatory = $False)]
        [ANOWProcessingEvent_eventType]$EventType,
        [Parameter(Mandatory = $False, ParameterSetName = 'Agent', ValueFromPipeline = $true)]
        [ANOWAgent]$Agent,
        [Parameter(Mandatory = $False, ParameterSetName = 'Resource', ValueFromPipeline = $true)]
        [ANOWResource]$Resource,
        [Parameter(Mandatory = $False, ParameterSetName = 'Processing', ValueFromPipeline = $true)]
        [ANOWProcessing]$Processing,
        [Parameter(Mandatory = $False, ParameterSetName = 'ServerNode', ValueFromPipeline = $true)]
        [ANOWServerNode]$ServerNode,
        [Parameter(Mandatory = $False, ParameterSetName = 'Domain', ValueFromPipeline = $true)]
        [ANOWDomain]$Domain,
        [ValidateSet('dateCreated', 'timestamp', 'parentProcessingId', 'processingId', 'rootProcessingId', ignoreCase = $false)]
        [Parameter(Mandatory = $False)]
        [string]$sortBy = 'dateCreated',
        [Parameter(Mandatory = $False)]
        [switch]$Ascending,
        [Parameter(Mandatory = $False)]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False)]
        [int32]$endRow = 100
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
    }
    Process {
        If ($_ -is [ANOWAgent]) {
            [ANOWAgent]$Agent = $_
        }
        ElseIf ($_ -is [ANOWResource]) {
            [ANOWResource]$Resource = $_
        }
        ElseIf ($_ -is [ANOWProcessing]) {
            [ANOWProcessing]$Processing = $_
        }
        ElseIf ($_ -is [ANOWServerNode]) {
            [ANOWServerNode]$ServerNode = $_
        }
        ElseIf ($_ -is [ANOWDomain]) {
            [ANOWDomain]$Domain = $_
        }
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        $Body.'operator' = 'and'
        $Body.'_constructor' = 'AdvancedCriteria'
        $Body.'criteria1' = '{"fieldName":"archived","operator":"equals","value":false}'
        If ($Agent.Id.Length -gt 0) {
            [string]$category = 'AGENT'
            [string]$agent_id = $Agent.id
        }
        ElseIf ($ServerNode.Id.Length -gt 0) {
            [string]$category = 'SERVER_NODE'
            [string]$ServerNode_id = $ServerNode.id
            $Body.'criteria3' = ('{"fieldName":"serverNode","operator":"equals","value":"' + $ServerNode_id + '"}')
        }
        ElseIf ($Domain.Id.Length -gt 0) {
            [string]$category = 'DOMAIN'
        }
        ElseIf ($Resource.Id.Length -gt 0) {
            [string]$category = 'RESOURCE'
            [string]$resource_id = $Resource.id
            $Body.'criteria3' = ('{"fieldName":"resource","operator":"equals","value":"' + $resource_id + '"}')
        }
        ElseIf ($Processing.Id -gt 0) {
            [string]$category = 'PROCESSING'
            [string]$processing_runid = $Processing.Id
            $Body.'criteria3' = ('{"fieldName":"processingId","operator":"equals","value":"' + $processing_runid + '"}')
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
        $Body.'criteria2' = ('{"fieldName":"eventCategory","operator":"equals","value":"' + $category + '"}')

        If ($category -eq 'PROCESSING') {
            [string]$componentId = 'ProcessingEventList'
        }
        ElseIf ($category -eq 'SERVER_NODE') {
            [string]$componentId = 'ServerNodeEventList'
        }
        ElseIf ($category -eq 'RESOURCE') {
            [string]$componentId = 'ResourceEventLog'
        }
        ElseIf ($category -eq 'AGENT') {
            [string]$componentId = 'EventListWindow_list'
            If ($agent_id.Length -gt 0) {
                $Body.'criteria3' = ('{"fieldName":"agent","operator":"equals","value":"' + $agent_id + '"}')
            }
        }
        ElseIf ($category -eq 'DOMAIN') {
            [string]$componentId = 'EventListWindow_list'
            If ($Domain.Length -gt 0) {
                [string]$selected_domain = $Domain.id
            }
            Else {
                [string]$selected_domain = $anow_session.current_domain
            }
            If ($selected_domain.Length -eq 0) {
                Write-Warning -Message "Somehow the current domain could not be confirmed. Please look into this."
                Break
            }
            $Body.'criteria3' = ('{"fieldName":"domain","operator":"equals","value":"' + $selected_domain + '"}')
        }
        Else {
            Write-Warning -Message "Somehow the category could not be determined. Please look into this."
            Break
        }
        If ($eventType.Length -gt 0) {
            $Body.'criteria4' = ('{"fieldName":"eventType","operator":"equals","value":"' + $eventType + '"}')
        }
        $Body.'_componentId' = $componentId
        $Body.'_textMatchStyle' = 'exact'
        $Body.'_dataSource' = 'ProcessingEventDataSource'
        $Body.'_startRow' = $startRow
        $Body.'_endRow' = $endRow
        If ($Ascending -eq $true) {
            $Body.'_sortBy' = $sortBy
        }
        Else {
            $Body.'_sortBy' = '-' + $sortBy
        }
        $Body.'_operationType' = 'fetch'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/processingEvent/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWProcessingEvent[]]$ProcessingEvents = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWProcessingEvent] objects due to [$Message]."
            Break
        }
        If ($ProcessingEvents.Count -gt 0) {
            Return $ProcessingEvents
        }
    }
    End {

    }
}

Function Export-AutomateNOWProcessingEventLog {
    <#
    .SYNOPSIS
    Exports the Processing Events (log entries) from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Processing Events (log entries) from an instance of AutomateNOW! to a local .csv file

    .PARAMETER ProcessingEvent
    Mandatory [ANOWProcessingEvent] object (Use Read-AutomateNOWProcessingEventLog to retrieve them)

    .INPUTS
    ONLY [ANOWProcessingEvent] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWProcessingEvent] objects are exported to the local disk in CSV format

    .EXAMPLE
    Get-AutomateNOWProcessingEvent | Export-AutomateNOWProcessingEvent

    .NOTES
	You must present [ANOWProcessingEvent] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWProcessingEvent]$ProcessingEvent
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-ProcessingEvents-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWProcessingEvent]$ProcessingEvent = $_
        }
        $Error.Clear()
        Try {
            $ProcessingEvent | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWProcessingEvent] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

#endregion

#Region - Folders

Function Get-AutomateNOWFolder {
    <#
    .SYNOPSIS
    Gets the folders from an AutomateNOW! instance

    .DESCRIPTION
    Gets the folders from an AutomateNOW! instance

    .PARAMETER Id
    Optional string containing the id (name) of the folder to fetch. Omit this parameter to get the first page of Folders.

    .PARAMETER sortBy
    Optional string parameter to sort the results by (may not be used with the Id parameter). Valid choices are: id*, createdBy, dateCreated, description, codeRepository

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .PARAMETER startRow
    An optional int32 representing what row to start the download from. This is intended for multi-page transfers.

    .PARAMETER endRow
    An optional int32 representing how many rows of data to receive. The default is 100. This is ideal for testing when you only want a few items.

    .INPUTS
    Accepts the id (name) of the folder including in a string array across the pipeline.

    .OUTPUTS
    [ANOWFolder] class objects will be emitted

    .EXAMPLE
    Gets the first page of Folders
    Get-AutomateNOWFolder

    .EXAMPLE
    Gets a single Folder by name
    Get-AutomateNOWFolder -Id 'Folder1'

    .EXAMPLE
    Gets two Folders by sending their names across the pipeline in a string array
    'Folder1', 'Folder2' | Get-AutomateNOWFolder

    .EXAMPLE
    Gets the first page of Folders sorted by dateCreated
    Get-AutomateNOWFolder -sortBy dateCreated

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWFolder[]])]
    [Cmdletbinding( DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $True, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [string]$Id,
        [ValidateSet('id', 'createdBy', 'dateCreated', 'description', 'codeRepository', IgnoreCase = $false)]
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$sortBy = 'id',
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$Descending,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/folder/read?'
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$BodyObject = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 -or $Id.Length -gt 0) {
            If ($_.Length -gt 0 ) {
                [string]$Id = $_
            }
            $BodyObject.'id' = $Id
            [string]$textMatchStyle = 'exactCase'
        }
        Else {
            $BodyObject.'_startRow' = $startRow
            $BodyObject.'_endRow' = $endRow
            [string]$textMatchStyle = 'substring'
            If ($Descending -eq $true) {
                $BodyObject.'_sortBy' = '-' + $sortBy
            }
            Else {
                $BodyObject.'_sortBy' = $sortBy
            }
        }
        $BodyObject.'_operationType' = 'fetch'
        $BodyObject.'_textMatchStyle' = $textMatchStyle
        $BodyObject.'_componentId' = 'FolderSourceList'
        $BodyObject.'_dataSource' = 'FolderDataSource'
        $BodyObject.'isc_metaDataPrefix' = '_'
        $BodyObject.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $BodyObject
        [string]$command = ($command + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWFolder[]]$Folders = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWFolder] objects due to [$Message]."
            Break
        }
        If ($Folders.Count -gt 0) {
            Return $Folders
        }
    }
    End {

    }
}

Function Set-AutomateNOWFolder {
    <#
    .SYNOPSIS
    Changes the settings of a Folder from an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of a Folder from an AutomateNOW! instance

    .PARAMETER Folder
    An [ANOWFolder] object representing the Folder to be changed.

    .PARAMETER Description
    Optional string to set the description on the Folder.

    .PARAMETER UnsetDescription
    Optional switch that will remove the description from the Folder.

    .PARAMETER CodeRepository
    Optional Code Repository to place the Folder into. Use Get-AutomateNOWCodeRepository to fetch this object.

    .PARAMETER UnsetCodeRepository
    Switch parameter that will remove the the Folder from its Code Repository.

    .PARAMETER Quiet
    Switch parameter that silences the output of the updated object.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWFolder] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWFolder] object will be returned

    .EXAMPLE
    Adds a Folder named 'Folder1' to a Code Repository named 'CodeRepository1' and modifies the description (one-liner)

    Get-AutomateNOWFolder -Id 'Folder1' | Set-AutomateNOWFolder -Description 'New Description' -CodeRepository (Get-AutomateNOWCodeRepository -Id 'CodeRepository1')

    .EXAMPLE
    Removes the description from a Folder named 'Folder1' and removes it from its Code Repository (one-liner)

    Get-AutomateNOWFolder -Id 'Folder1' | Set-AutomateNOWFolder -unsetDescription -UnsetCodeRepository

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWFolder])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWFolder]$Folder,
        [Parameter(Mandatory = $false, HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetCodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot unset the Description and set it at the same time."
        }
        If ($UnsetCodeRepository -eq $true -and $CodeRepository.Id.Length -gt 0) {
            Write-Warning -Message "You cannot unset the Code Repository and set it at the same time. Please choose one or the other."
            Break
        }
        [string]$command = '/folder/update'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWFolder]$Folder = $_
        }
        [string]$Folder_id = $Folder.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Folder_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$Folder_exists = ($null -eq (Get-AutomateNOWFolder -Id $Folder_id))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWFolder failed to check if the Folder [$Folder_id] already existed due to [$Message]."
                Break
            }
            If ($Folder_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not a Folder named [$Folder_id] in the current domain [$current_domain]. Please check into this."
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $Folder.id
            $BodyMetaData.'parent' = $Folder.parent
            If ($Description.Length -gt 0) {
                $BodyMetaData.'description' = $Description
            }
            ElseIf ($UnsetDescription -eq $true) {
                $BodyMetaData.'description' = $null
            }
            If ($CodeRepository.Id.Length -gt 0) {
                [string]$CodeRepository_Id = $CodeRepository.Id
                $Error.Clear()
                Try {
                    [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository_Id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository_Id] actually existed under Set-AutomateNOWBusinessView due to [$Message]"
                    Break
                }
                If ($code_repository_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository_Id] under Set-AutomateNOWBusinessView. Please check again."
                    Break
                }
                $BodyMetaData.'codeRepository' = $CodeRepository_Id
            }
            ElseIf ($UnsetCodeRepository -eq $true) {
                $BodyMetaData.'codeRepository' = $null
            }
            $BodyMetaData.'_oldValues' = $Folder.CreateOldValues()
            $BodyMetaData.'_operationType' = 'update'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_componentId' = 'FolderEditForm'
            $BodyMetaData.'_dataSource' = 'FolderDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Folder_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Folder $Folder_id was successfully updated"
            $Error.Clear()
            Try {
                [ANOWFolder]$UpdatedFolder = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the returned updated object to an [ANOWFolder] object due to [$Message]. The object was still updated though."
                Break
            }
            If ($Quiet -ne $true) {
                Return $UpdatedFolder
            }
        }
    }
    End {
    }
}

Function Export-AutomateNOWFolder {
    <#
    .SYNOPSIS
    Exports the folders from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the folders from an instance of AutomateNOW! to a local .csv file

    .PARAMETER Folder
    Mandatory [ANOWFolder] object (Use Get-AutomateNOWFolder to retrieve them)

    .INPUTS
    ONLY [ANOWFolder] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWFolder] objects are exported to the local disk in CSV format

    .EXAMPLE
    Get-AutomateNOWFolder | Export-AutomateNOWFolder

    .EXAMPLE
    Get-AutomateNOWFolder -Id 'Folder01' | Export-AutomateNOWFolder

    .EXAMPLE
    @( 'Folder01', 'Folder02' ) | Get-AutomateNOWFolder | Export-AutomateNOWFolder

    .EXAMPLE
    Get-AutomateNOWFolder | Where-Object { $_.simpleId -eq 'Folder01' } | Export-AutomateNOWFolder

    .NOTES
	You must present [ANOWFolder] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWFolder]$Folder
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-Folders-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWFolder]$Folder = $_
        }
        $Error.Clear()
        Try {
            $Folder | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWFolder] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function New-AutomateNOWFolder {
    <#
    .SYNOPSIS
    Creates a Folder within an AutomateNOW! instance

    .DESCRIPTION
    Creates a Folder within an AutomateNOW! instance and returns back the newly created [ANOWFolder] object

    .PARAMETER Id
    The intended name of the Folder. For example: 'LinuxFolder1'. This value may not contain the domain in brackets.

    .PARAMETER Description
    Optional description of the Folder (may not exceed 255 characters).

    .PARAMETER CodeRepository
    Optional name of the code repository to place the Folder into.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWFolder.

    .OUTPUTS
    An [ANOWFolder] object representing the newly created Folder

    .EXAMPLE
    New-AutomateNOWFolder -Id 'MyFolder' -Description 'Folder description' -codeRepository 'MyRepository'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The name (id) of the folder must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    #>
    [OutputType([ANOWFolder])]
    [Cmdletbinding()]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $true)]
        [string]$Id,
        [Parameter(Mandatory = $false, HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [string]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [boolean]$Folder_exists = ($null -ne (Get-AutomateNOWFolder -Id $Id))
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWFolder failed to check if the Folder [$Id] existed under New-AutomateNOWFolder due to [$Message]."
        Break
    }
    If ($Folder_exists -eq $true) {
        [string]$current_domain = $anow_session.header.domain
        Write-Warning -Message "There is already a Folder named [$Id] in [$current_domain]. Please check into this."
        Break
    }
    ## End warning ##
    [System.Collections.Specialized.OrderedDictionary]$ANOWFolder = [System.Collections.Specialized.OrderedDictionary]@{}
    $ANOWFolder.Add('id', $Id)
    If ($Description.Length -gt 0) {
        $ANOWFolder.Add('description', $Description)
    }
    If ($CodeRepository.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository] existed under New-AutomateNOWFolder due to [$Message]"
            Break
        }
        If ($code_repository_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository] under New-AutomateNOWFolder. Please check again."
            Break
        }
        [string]$code_repository_display = $code_repository_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding code repository $code_repository_display to [ANOWFolder] [$Id]"
        $ANOWFolder.Add('codeRepository', $CodeRepository)
        $include_properties += 'codeRepository'
    }
    [string]$BodyObject = ConvertTo-QueryString -InputObject $ANOWFolder -IncludeProperties id, description, codeRepository
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    $BodyMetaData.'_operationType' = 'add'
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_oldValues' = '{}'
    $BodyMetaData.'_componentId' = 'FolderCreateWindow_form'
    $BodyMetaData.'_dataSource' = 'FolderDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$BodyMetaDataString = ConvertTo-QueryString -InputObject $BodyMetaData
    [string]$Body = ($BodyObject + '&' + $BodyMetaDataString)
    [string]$command = '/folder/create'
    [hashtable]$parameters = @{}
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('Body', $Body)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWFolder]$Folder = $results.response.data | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to create [ANOWFolder] object due to [$Message]."
        Break
    }
    If ($Folder.id.Length -eq 0) {
        Write-Warning -Message "Somehow the newly created [ANOWFolder] object is empty!"
        Break
    }
    If ($Quiet -ne $true) {
        Return $Folder
    }
}

Function Remove-AutomateNOWFolder {
    <#
    .SYNOPSIS
    Removes a folder from an AutomateNOW! instance

    .DESCRIPTION
    Removes a folder from an AutomateNOW! instance

    .PARAMETER Folder
    An [ANOWFolder] object representing the Folder to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWFolder] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Get-AutomateNOWFolder -Id 'Folder01' | Remove-AutomateNOWFolder

    .EXAMPLE
    @( 'Folder1', 'Folder2', 'Folder3') | Remove-AutomateNOWFolder

    .EXAMPLE
    Get-AutomateNOWFolder | ? { $_.simpleId -like 'test*' } | Remove-AutomateNOWFolder

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWFolder]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/folder/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWFolder]$Folder = $_
        }
        [string]$Folder_id = $Folder.id
        If ($Folder_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Folder_id)")) -eq $true) {
            [string]$oldvalues = $Folder.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $Folder_id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'FolderList'
            $BodyMetaData.'_dataSource' = 'FolderDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Folder_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Folder $Folder_id successfully removed"
        }
    }
    End {

    }
}

#endregion

#Region - Icons

Function Export-AutomateNOWIcon {
    If ($anow_assets.icon_library.Count -eq 0) {
        Write-Warning -Message "Please use Import-AutomateNOWIcon or Import-AutomateNOWLocalIcon to import the icon names into your session."
        Break
    }
    [PSCustomObject[]]$ExportTableFatCow = ForEach ($Icon in $anow_assets.icon_library['FAT_COW']) { [PSCustomObject]@{Library = 'FAT_COW'; Icon = $Icon; } }
    [PSCustomObject[]]$ExportTableFugue = ForEach ($Icon in $anow_assets.icon_library['FUGUE']) { [PSCustomObject]@{Library = 'FUGUE'; Icon = $Icon; } }
    [PSCustomObject[]]$ExportTableFontAwesome = ForEach ($Icon in $anow_assets.icon_library['FONT_AWESOME']) { [PSCustomObject]@{Library = 'FONT_AWESOME'; Icon = $Icon; } }
    [PSCustomObject[]]$DataToExport = ($ExportTableFatCow + $ExportTableFugue + $ExportTableFontAwesome)
    [int32]$DataToExportCount = $DataToExport.Count
    If ($DataToExportCount -eq 0) {
        Write-Warning -Message "Somehow there are zero icons to export. Please look into this."
        Break
    }
    [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
    [string]$ExportFileName = 'Export-AutomateNOW-Icons-' + $current_time + '.csv'
    [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
    [hashtable]$parameters = @{}
    $parameters.Add('Path', $ExportFilePath)
    If ($PSVersionTable.PSVersion.Major -eq 5) {
        $parameters.Add('NoTypeInformation', $true)
    }
    $Error.Clear()
    Try {
        $DataToExport | Export-CSV @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Export-CSV failed to export the icon asset data due to [$Message]"
        Break
    }
    $Error.Clear()
    [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
    [int32]$filelength = $fileinfo.Length
    [string]$filelength_display = "{0:N0}" -f $filelength
    Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
}

Function Import-AutomateNOWIcon {
    <#
    .SYNOPSIS
    Imports the icon asset information from an AutomateNOW! instance

    .DESCRIPTION
    The `Import-AutomateNOWIcon` function imports the icon asset information from an AutomateNOW! instance and makes it available for other functions (e.g. Format-AutomateNOWIconList)

    .INPUTS
    None. You cannot pipe objects to Import-AutomateNOWIcon.

    .OUTPUTS
    The output is set into the global variable anow_assets. A .csv file may optionally be created to capture the output.

    .PARAMETER Instance
    Specifies the name of the AutomateNOW! instance. For example: s2.infinitedata.com

    .EXAMPLE
    Import-AutomateNOWIcon -Instance 'z4.infinitedata.com'

    .NOTES
    You DO NOT need to authenticate to the instance to execute this function.

    #>
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory = $false)]
        [string]$Instance
    )
    Function Format-AutomateNOWIconList {
        [CmdletBinding()]
        Param(
            [Parameter(Mandatory = $true)]
            [ValidateSet('FatCow', 'Fugue', 'FontAwesome', IgnoreCase = $false)]
            [string]$Library,
            [Parameter(Mandatory = $true)]
            [array]$assets_content,
            [Parameter(Mandatory = $true)]
            [string]$first_icon_name,
            [Parameter(Mandatory = $true)]
            [string]$last_icon_name
        )
        [int32]$assets_content_count = $assets_content.Count
        If ($assets_content_count -eq 0) {
            Write-Warning -Message "Somehow there was no content..."
            Break
        }
        [string]$icon_index_first_string_id = ('"ID": "' + $Library + 'DataSource",')
        [string]$icon_index_first_string_name = ("{name: '$first_icon_name'")
        [string]$icon_index_last_string_name = ("{name: '$last_icon_name'")
        $Error.Clear()
        Try {
            [int32]$icon_index_first_number1 = $assets_content.IndexOf($($assets_content -match $icon_index_first_string_id | Select-Object -First 1))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to extract the first index position of the first icon from the [$Library] icon library due to [$Message]"
            Break
        }
        $Error.Clear()
        Try {
            [int32]$icon_index_first_number2 = $assets_content[$icon_index_first_number1..$assets_content_count].IndexOf($($assets_content[$icon_index_first_number1..$assets_content_count] -match $icon_index_first_string_name | Select-Object -First 1))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to extract the second index position of the first icon from the [$Library] icon library due to [$Message]"
            Break
        }
        [int32]$icon_index_first_number = ($icon_index_first_number1 + $icon_index_first_number2)
        Write-Verbose "Extracted first index of [$icon_index_first_number] from the [$Library] icon library"
        $Error.Clear()
        Try {
            [int32]$icon_index_last_number = $assets_content[$icon_index_first_number..$assets_content_count].IndexOf($($assets_content[$icon_index_first_number..$assets_content_count] -match $icon_index_last_string_name | Select-Object -First 1))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to extract the index position of the last icon from the [$Library] icon library due to [$Message]"
            Break
        }
        [int32]$icon_index_last_number = ($icon_index_last_number + $icon_index_first_number)
        Write-Verbose "Extracted last index of [$icon_index_last_number] for [$Library]"
        $Error.Clear()
        Try {
            [array]$icon_raw_array = $assets_content[$icon_index_first_number..$icon_index_last_number]
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to extract the icon data from the assets library from position [$icon_index_first_number] to [$icon_index_last_number] from the [$Library] icon library due to [$Message]"
            Break
        }
        [int32]$icon_raw_array_count = $icon_raw_array.Count
        Write-Verbose -Message "Found [$icon_raw_array_count] icons from the [$Library] library"
        [array]$icon_list = $icon_raw_array | ForEach-Object { $_ -replace '\s' -replace 'name:' -replace "{'" -replace "'}," -replace "'}" }
        Return $icon_list
    }
    If ($Instance.Length -eq 0) {
        [string]$Instance = $anow_session.Instance
        If ($Instance.Length -eq 0) {
            Write-Warning -Message 'You need to either supply the instance via -Instance or use Connect-AutomateNOW to define it for you'
            Break
        }
    }
    If ($Instance -match '/' -or $Instance -match 'http') {
        Write-Warning -Message 'Please do not include http or any slashes in the instance name. Following are 2 valid examples: a2.InfiniteData.com, contoso-sbox-anow.region.cloudapp.azure.com:8080'
        Break
    }
    [string]$url_homepage = ('https://' + $Instance + '/automatenow/') # Note the backslash at the end. This is required!
    [hashtable]$parameters = @{}
    $parameters.Add('Uri', $url_homepage)
    If ($anow_session.Proxy.Length -gt 0) {
        $parameters.Add('Proxy', $anow_session.Proxy)
    }
    Write-Verbose -Message "The instance url is set to [$url_homepage]"
    [int32]$ps_version_major = $PSVersionTable.PSVersion.Major
    If ($ps_version_major -gt 5) {
        [Microsoft.PowerShell.Commands.BasicHtmlWebResponseObject]$request_homepage = Invoke-WebRequest @parameters
    }
    ElseIf ($ps_version_major -eq 5) {
        [Microsoft.PowerShell.Commands.HtmlWebResponseObject]$request_homepage = Invoke-WebRequest @parameters
    }
    Else {
        Write-Warning -Message "Only Windows PowerShell 5.1 and PowerShell Core (7+) are supported."
    }
    [int32]$request_statuscode = $request_homepage.StatusCode
    If ($request_statuscode -ne 200) {
        Write-Warning -Message "Somehow the response code was [$request_statuscode] instead of 200. Please look into this."
        Break
    }
    [array]$homepage_content = $request_homepage.Content -split "`n"
    [int32]$homepage_content_line_count = $homepage_content.Count
    Write-Verbose -Message "The homepage content from [$Instance] has [$homepage_content_line_count] lines"
    [string]$asset_url = ($url_homepage + ($homepage_content -match 'assets/application/automateNow-[0-9a-z]{32}.js' -replace '"></script>' -replace '<script type="text/javascript" src="/automatenow/' | Select-Object -First 1))
    Write-Verbose -Message "Fetching assets from [$asset_url]"
    $parameters.Uri = $asset_url
    If ($ps_version_major -gt 5) {
        [Microsoft.PowerShell.Commands.BasicHtmlWebResponseObject]$request_assets = Invoke-WebRequest @parameters
    }
    ElseIf ($ps_version_major -eq 5) {
        [Microsoft.PowerShell.Commands.HtmlWebResponseObject]$request_assets = Invoke-WebRequest @parameters
    }
    Else {
        Write-Warning -Message "Only Windows PowerShell 5.1 and PowerShell Core (7+) are supported."
    }
    [int32]$request_statuscode = $request_assets.StatusCode
    If ($request_statuscode -ne 200) {
        Write-Warning -Message "Somehow the response code was [$request_statuscode] instead of 200. Please look into this."
        Break
    }
    [array]$assets_content = $request_assets.Content -split "`r" -split "`n"
    [int32]$assets_content_line_count = $assets_content.Count
    Write-Verbose -Message "The assets content from [$Instance] has [$assets_content_line_count] lines"
    $Error.Clear()
    Try {
        [array]$IconNames_FatCow = Format-AutomateNOWIconList -assets_content $assets_content -Library 'FatCow' -first_icon_name '32_bit' -last_icon_name 'zootool'
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Format-AutomateNOWIconList failed to extract the FatCow icons due to [$Message]"
        Break
    }
    $Error.Clear()
    Try {
        [array]$IconNames_Fugue = Format-AutomateNOWIconList -assets_content $assets_content -Library 'Fugue' -first_icon_name 'abacus' -last_icon_name 'zones-stack'
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Format-AutomateNOWIconList failed to extract the Fugue icons due to [$Message]"
        Break
    }
    $Error.Clear()
    Try {
        [array]$IconNames_FontAwesome = Format-AutomateNOWIconList -assets_content $assets_content -Library 'FontAwesome' -first_icon_name '500px' -last_icon_name 'youtube-square'
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Format-AutomateNOWIconList failed to extract the FontAwesome icons due to [$Message]"
        Break
    }
    [int32]$IconCount_FatCow = ($IconNames_FatCow.Count)
    [int32]$IconCount_Fugue = ($IconNames_Fugue.Count)
    [int32]$IconCount_FontAwesome = ($IconNames_FontAwesome.Count)
    If ( $IconCount_FatCow -eq 0 -or $IconCount_Fugue -eq 0 -or $IconCount_FontAwesome -eq 0) {
        Write-Warning -Message "Somehow one or more of the icon counts summed to zero. Please look into this. [FatCow = $IconCount_FatCow; Fugue = $IconCount_Fugue; FontAwesome = $IconCount_FontAwesome;]"
        Break
    }
    [int32]$IconCount = ($IconCount_FatCow + $IconCount_Fugue + $IconCount_FontAwesome)
    [hashtable]$icon_sets = @{ 'FAT_COW' = $IconNames_FatCow; 'FUGUE' = $IconNames_Fugue; 'FONT_AWESOME' = $IconNames_FontAwesome; 'FAT_COW_COUNT' = $IconCount_FatCow; 'FUGUE_COUNT' = $IconCount_Fugue; 'FONT_AWESOME_COUNT' = $IconCount_FatCow; 'TOTAL_COUNT' = $iconCount; }
    If ($null -eq $anow_assets) {
        [hashtable]$global:anow_assets = @{}
    }
    If ($null -eq $anow_assets.icon_library) {
        $anow_assets.Add('icon_library', $icon_sets)
    }
    Else {
        $anow_assets.icon_library = $icon_sets
    }
    Write-Verbose "Added $IconCount icons to the assets library of this session"
}

Function Import-AutomateNOWLocalIcon {
    <#
    .SYNOPSIS
    Loads the icon assets from a local file Icons.ps1 instead of from a live AutomateNOW! instance

    #>
    [string]$LocalIconScript = ($PSScriptRoot + '\Icons.ps1')
    If ((Test-Path -Path "$LocalIconScript") -eq $true) {
        $Error.Clear()
        Try {
            . "$LocalIconScript"
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Unable to load the local icon script [$LocalIconScript] due to [$Message]"
            Break
        }
        [int32]$fat_cow_icon_count = $anow_assets.icon_library["FAT_COW"].Count
        [int32]$fugue_icon_count = $anow_assets.icon_library["FUGUE"].Count
        [int32]$font_awesome_icon_count = $anow_assets.icon_library["FONT_AWESOME"].Count
        Write-Verbose -Message "Imported icons:"
        Write-Verbose -Message "Fat Cow [$fat_cow_icon_count]"
        Write-Verbose -Message "Fugue [$fugue_icon_count]"
        Write-Verbose -Message "Font Awesome [$font_awesome_icon_count]"
    }
    Else {
        Write-Warning -Message "The Icons.ps1 file is not available!"
    }
}

Function Read-AutomateNOWIcon {
    <#
    .SYNOPSIS
    Reads the icon assets from the local cache.

    .DESCRIPTION
    Reads the icon assets from the local cache. You must first import the icons with either Import-AutomateNOWIcon or Import-AutomateNOWLocalIcon.

    .PARAMETER iconSet
    Mandatory string representing a choice between three icon sets. Valid choices are: FAT_COW, FUGUE, FONT_AWESOME

    #>
    [OutputType([String[]])]
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWIcon_iconSet]$iconSet
    )
    If ($anow_assets.icon_library.Count -eq 0) {
        Write-Warning -Message "Please use Import-AutomateNOWIcon or Import-AutomateNOWLocalIcon to import the icon names into your session."
        Break
    }
    Return $anow_assets.icon_library."$iconSet"
}

Function Write-AutomateNOWIconData {
    <#
    .SYNOPSIS
    Writes the icons in .png format from an AutomateNOW! instance to disk

    .DESCRIPTION
    Writes the icons in .png format from an AutomateNOW! instance to disk

    .PARAMETER iconSet
    Mandatory name of the icon set to export. Valid choices are FAT_COW and FUGUE

    .PARAMETER filepath
    Mandatory path where the icons will be exported to. Note that a sub-directory will be created based on the name of the iconSet. See the example.

    .PARAMETER pause_delay
    Optional int32 to indicate the delay in milliseconds between each .png file download. The default is 50.

    .INPUTS
    You can pipe the names of the icon library

    .OUTPUTS
    Image files (*.png) will be written to disk

    .EXAMPLE
    Writes the FUGUE icon set to disk in .png format to the folder 'c:\temp\AutomateNOW\Icons\FUGUE'

    Write-AutomateNOWIconData -iconSet 'FUGUE' -filepath 'C:\temp\AutomateNOW\Icons'

    .NOTES
    You do not need to be logged in to the instance to write the icons to disk.

    #>
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWIcon_iconSet]$iconSet,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ (Test-Path -Path "$_") -eq $true })]
        [string]$filepath,
        [Parameter(Mandatory = $false)]
        [string]$Instance,
        [Parameter(Mandatory = $false)]
        [int32]$pause_delay = 50
    )
    Begin {
        If ($Instance.Length -eq 0) {
            [string]$Instance = $anow_session.Instance
            If ($Instance.Length -eq 0) {
                Write-Warning -Message "You needed to either specify the instance with -Instance or use Connect-AutomateNOW to establish a session."
                Break
            }
        }
        If ($anow_assets.icon_library.Count -eq 0) {
            Write-Warning -Message "Please use Import-AutomateNOWIcon or Import-AutomateNOWLocalIcon to import the icon names into your session."
            Break
        }
    }
    Process {
        If ($_.Length -gt 0) {
            [string]$Set = $_
        }
        Else {
            [string]$Set = $iconSet
        }
        If ($Set -eq 'FONT_AWESOME') {
            Write-Warning -Message "The Font Awesome icon set is a font and not a series of images, therefore they cannot be written to disk as imagefiles."
            Break
        }
        Else {
            [string]$current_path = "$filepath\$Set"
            If ((Test-Path -Path $current_path) -eq $false) {
                $Error.Clear()
                Try {
                    New-Item -ItemType Directory -Path "$current_path" -Force | Out-Null
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "New-Item failed to create $current_path due to [$Message]"
                    Break
                }
                Write-Verbose -Message "Created the [$Set] directory in [$filepath]"
            }
            [int32]$current_path_file_count = Get-ChildItem -Path "$current_path\*.png" | Measure-Object | Select-Object -ExpandProperty Count
            If ($current_path_file_count -gt 0) {
                Throw "There are $current_path_file_count .png files in the [$current_path] directory."
            }
            [array]$icon_names = $anow_assets.icon_library["$iconSet"]
            [int32]$current_icons_count = $icon_names.Count
            If ($current_icons_count -eq 0) {
                Write-Warning -Message "Somehow there are 0 icons available for the [$iconSet] icon set. Please look into this."
                Break
            }
            [string]$icon_directory_name = ($iconSet -replace '_').ToLower()
            [string]$base_icon_uri = 'https' + '://' + $instance + "/automatenow/img/$icon_directory_name/"
            [int32]$total_bytes_downloaded = 0
            [int32]$icons_downloaded = 0
            [int32]$current_loop = 1
            $Error.Clear()
            Try {
                [System.Diagnostics.Stopwatch]$stopwatch = New-Object -TypeName System.Diagnostics.Stopwatch
                $stopwatch.Start()
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "A System.Diagnostics.Stopwatch couldn't be started due to [$Message]"
                Break
            }
            ForEach ($current_icon_name in $icon_names) {
                [string]$current_icon_download_url = ($base_icon_uri + $current_icon_name + '.png')
                [string]$current_icon_file_path = "$filepath\$iconSet\$current_icon_name.png"
                [hashtable]$parameters = @{}
                $parameters.Add('Uri', "$current_icon_download_url")
                $parameters.Add('Passthru', $true)
                $parameters.Add('OutFile', "$current_icon_file_path")
                If ($anow_session.Proxy.Length -gt 0) {
                    $parameters.Add('Proxy', $anow_session.Proxy)
                }
                $Error.Clear()
                Try {
                    $ProgressPreference = 'SilentlyContinue'
                    Invoke-WebRequest @parameters | Out-Null
                    $ProgressPreference = 'Continue'
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-WebRequest failed to download the icon file [$current_icon_download_url] due to [$Message]"
                    Break
                }
                $Error.Clear()
                Try {
                    [System.IO.FileSystemInfo]$current_icon_file_info = Get-Item -Path "$current_icon_file_path"
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-Item failed to read the recently downloaded icon file [$current_icon_file_path] due to [$Message]"
                    Break
                }
                [int32]$current_bytes_downloaded = $current_icon_file_info.Length
                [int32]$total_bytes_downloaded = ($total_bytes_downloaded + $current_bytes_downloaded)
                $icons_downloaded++
                [string]$total_bytes_downloaded_display = "{0:N0}" -f $total_bytes_downloaded
                [int32]$elapsed_ms = $stopwatch.ElapsedMilliseconds
                [decimal]$bytes_per_ms = ($total_bytes_downloaded / $elapsed_ms)
                [string]$kbyte_sec_display = [math]::Round(($bytes_per_ms * 1000 / 1024), 2).ToString("0.00")
                [int32]$avg_file_size = ($total_bytes_downloaded / $current_loop)
                [string]$avg_file_size_display = "{0:N0}" -f $avg_file_size
                Write-Progress -PercentComplete ($current_loop / $current_icons_count * 100) -Activity "   Downloading the '$iconSet' icon library (throttle: $pause_delay ms)" -Status "Image $current_loop of $current_icons_count - Average filesize: $avg_file_size_display bytes - Total Downloaded: $total_bytes_downloaded_display bytes" -CurrentOperation "Speed: $kbyte_sec_display KByte/sec - Downloaded $current_icon_name.png"
                Start-Sleep -Milliseconds $pause_delay
                $current_loop++
            }
        }
    }
    End {
        [int32]$current_path_file_count = Get-ChildItem -Path "$current_path\*.png" | Measure-Object | Select-Object -ExpandProperty Count
        If ($current_path_file_count -gt 0) {
            Write-Information -MessageData "Successfully downloaded $current_path_file_count to the $current_path directory"
        }
        Else {
            Throw "There are $current_path_file_count .png files in the [$current_path] directory."
        }
    }
}

#endregion

#Region - Interfaces

Function Get-AutomateNOWInterface {
    <#
    .SYNOPSIS
    Gets the Interfaces from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Interfaces from an AutomateNOW! instance

    .PARAMETER Id
    The Id of the Interface. Use this when you only want to retrieve a single Interace. This parameter cannot be combined with -startRow/-endRow.

    .PARAMETER startRow
    Integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER Folder
    Optional string to filter by a particular Folder

    .PARAMETER Tags
    Optional string array of Tags to filter by. Note that the 'containsAny' operator will be used.

    .INPUTS
    Accepts a string representing the simple id of the Interface from the pipeline or individually (but not an array) or you can specify by start and end rows.

    .OUTPUTS
    An array of one or more [ANOWInterface] class objects

    .EXAMPLE
    Gets the first page of Interfaces
    Get-AutomateNOWInterface

    .EXAMPLE
    Gets a specific Interface named 'Interface1'
    Get-AutomateNOWInterface -Id 'Interface1'

    .EXAMPLE
    Gets a series of Interfaces using the pipeline
    'Interface1', 'Interface2' | Get-AutomateNOWInterface

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWIntegration[]])]
    [Cmdletbinding( DefaultParameterSetName = 'Default' )]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $False, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False)]
        [string]$Folder,
        [Parameter(Mandatory = $False)]
        [string[]]$Tags
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 -or $Id.Length -gt 0) {
            If ($_.Length -gt 0 ) {
                $Body.'id' = $_
            }
            Else {
                $Body.'id' = $Id
            }
            [string]$textMatchStyle = 'exactCase'
            $Body.'_operationId' = 'read'
        }
        Else {
            $Body.'_constructor' = 'AdvancedCriteria'
            $Body.'operator' = 'and'
            If ($Folder.Length -gt 0) {
                $Body.'criteria1' = ('{"fieldName":"folder","operator":"equals","value":"' + $Folder + '"}')
            }
            If ($Tags.Count -gt 0) {
                If ($Tags.Count -gt 1) {
                    $Error.Clear()
                    Try {
                        [string]$TagString = $Tags | ConvertTo-Json -Compress
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "ConvertTo-Json failed to convert the provided tag names under Get-AutomateNOWInterface due to [$Message]."
                        Break
                    }
                }
                Else {
                    [string]$TagString = $Tags
                }
                $Body.'criteria2' = ('{"fieldName":"tags","operator":"containsAny","value":' + $TagString + '}')
            }
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
            [string]$textMatchStyle = 'exact'
            $Body.'_componentId' = 'IntegrationList'
        }
        $Body.'_textMatchStyle' = $textMatchStyle
        $Body.'_dataSource' = 'IntegrationDataSource'
        $Body.'_operationType' = 'fetch'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/integration/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] while running Get-AutomateNOWInterface due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWIntegration[]]$Integrations = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWIntegration] objects due to [$Message]."
            Break
        }
        If ($Integrations.Count -gt 0) {
            Return $Integrations
        }
    }
    End {

    }
}

#endregion

#Region - Locks (RESOURCE)

Function Get-AutomateNOWLock {
    <#
    .SYNOPSIS
    Gets the Lock objects from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Lock objects from an AutomateNOW! instance

    .PARAMETER Id
    Optional string containing the simple id of the Lock to fetch or you can pipeline a series of simple id strings. You may not enter an array here.

    .PARAMETER Detailed
    Switch parameter to provide the detailed properties of the [ANOWLock] object. This may only be used in conjunction with -Id. Use this option to see the fully populated object.

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100. The console default hard limit is 10,000.

    .PARAMETER sortBy
    Optional string parameter to sort the results by (may not be used with the Id parameter). Valid choices are: {To be continued...}

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .PARAMETER Folder
    Optional string to filter by a particular Folder

    .PARAMETER Tags
    Optional string array of Tags to filter by. Note that the 'containsAny' operator will be used.

    .INPUTS
    Accepts a string representing the simple id of the Lock from the pipeline or individually (but not an array).

    .OUTPUTS
    Either one or more [ANOWLock] objects

    .EXAMPLE
    Gets the first page of Lock objects

    Get-AutomateNOWLock

    .EXAMPLE
    Gets the first 500 Lock objects

    Get-AutomateNOWLock -startRow 0 -endRow 500

    .EXAMPLE
    Gets a single non-detailed Lock named 'Lock1'

    Get-AutomateNOWLock -Id 'Lock1'

    .EXAMPLE
    Gets the detailed version of a Lock object named 'Lock1'

    Get-AutomateNOWLock -Id 'Lock1' -Detailed

    .EXAMPLE
    Gets a series of Lock objects through the pipeline

    'Lock_01', 'Lock_02 | Get-AutomateNOWLock

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(DefaultParameterSetName = 'Id')]
    Param(
        [Parameter(Mandatory = $False, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [Parameter(Mandatory = $False, ParameterSetName = 'Detailed', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'Detailed')]
        [switch]$Detailed,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [string]$sortBy = 'id',
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [switch]$Descending,
        [Parameter(Mandatory = $False)]
        [string]$Folder,
        [Parameter(Mandatory = $False)]
        [string[]]$Tags
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 ) {
            [string]$Lock_Id = $_
        }
        Else {
            [string]$Lock_Id = $Id
        }
        If ($Detailed -eq $true) {
            $Body.'id' = $Lock_Id
            [string]$textMatchStyle = 'exactCase'
            $Body.'_operationId' = 'readDetailed'
            [string]$Method = 'POST'
        }
        Else {
            $Body.'_constructor' = 'AdvancedCriteria'
            $Body.'operator' = 'and'
            $Body.'criteria1' = '{"fieldName":"resourceType","operator":"equals","value":"LOCK"}'
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
            If ($Lock_Id.Length -gt 0) {
                $Body.'criteria2' = ('{"fieldName":"simpleId","operator":"equals","value":"' + $Lock_Id + '"}')
                [string]$textMatchStyle = 'exact'
            }
            Else {
                [string]$textMatchStyle = 'substring'
            }
            If ($Folder.Length -gt 0) {
                $Body.'criteria3' = ('{"fieldName":"folder","operator":"equals","value":"' + $Folder + '"}')
            }
            If ($Tags.Count -gt 0) {
                If ($Tags.Count -gt 1) {
                    $Error.Clear()
                    Try {
                        [string]$TagString = $Tags | ConvertTo-Json -Compress
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "ConvertTo-Json failed to convert the provided tag names under Get-AutomateNOWLock due to [$Message]."
                        Break
                    }
                }
                Else {
                    [string]$TagString = $Tags
                }
                $Body.'criteria4' = ('{"fieldName":"tags","operator":"containsAny","value":' + $TagString + '}')
            }
            $Body.'_componentId' = 'ResourceList'
            If ($Descending -eq $true) {
                $Body.'_sortBy' = '-' + $sortBy
            }
            Else {
                $Body.'_sortBy' = $sortBy
            }
            [string]$Method = 'GET'
        }
        $Body.'_operationType' = 'fetch'
        $Body.'_textMatchStyle' = $textMatchStyle
        $Body.'_dataSource' = 'ResourceDataSource'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        If ($Detailed -eq $true) {
            [string]$command = ('/resource/readDetailed')
            If ($Null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            If ($null -eq $parameters["Command"]) {
                $parameters.Add('Command', $command)
            }
            Else {
                $parameters.Command = $command
            }
        }
        Else {
            [string]$command = ('/resource/read?' + $Body)
            $parameters.Command = $command
        }
        If ($null -eq $parameters.Method) {
            $parameters.Add('Method', $Method)
        }
        Else {
            $parameters.Method = $Method
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWLock[]]$Locks = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWLock failed to parse the results into [ANOWLock] objects due to [$Message]."
            Break
        }
        If ($Locks.Count -gt 0) {
            Return $Locks
        }
    }
    End {

    }
}

Function Set-AutomateNOWLock {
    <#
    .SYNOPSIS
    Changes the settings of an Lock on an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of an Lock on an AutomateNOW! instance

    .PARAMETER Lock
    An [ANOWLock] object representing the Lock to be modified.

    .PARAMETER UnsetDescription
    Optional switch that will remove the Description from the Lock object.

    .PARAMETER Description
    Optional string to set the description on the new Lock object.

    .PARAMETER UnsetFolder
    Optional switch that will remove the Folder assignment from the Lock object.

    .PARAMETER Folder
    Optional string to set a different folder on the Lock object.

    .PARAMETER UnsetTags
    Optional switch that will remove the Tags from the Lock object.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the new Lock object.

    .PARAMETER CodeRepository
    Optional Code Repository to place the Lock into. Use Get-AutomateNOWCodeRepository to fetch this object.

    .PARAMETER UnsetCodeRepository
    Switch parameter that will remove the Lock from its Code Repository.

    .PARAMETER Quiet
    Switch parameter that silences the output of the updated object.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWLock] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWLock] object will be returned

    .EXAMPLE
    Changes the description and folder, along with setting 2 tags on a Lock

    $Lock = Get-AutomateNOWLock -Id 'Lock1'
    Set-AutomateNOWLock -Description 'Awesome description!' -Tags 'Tag1', 'Tag2' -Folder 'Folder1'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    There are no unique properties of a Lock that can be changed, hence there are only parameters for Description, Tags, Folder and Code Repository
    #>
    [OutputType([ANOWLock])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWLock]$Lock,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetCodeRepository,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot set the Tags and unset them at the same time. Please choose one or the other. Tags from the source object will be carried over to the new object if you do not specify any tag-related parameters."
            Break
        }
        If ($UnsetCodeRepository -eq $true -and $CodeRepository.Id.Length -gt 0) {
            Write-Warning -Message "You cannot unset the Code Repository and set it at the same time. Please choose one or the other."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWLock]$Lock = $_
        }
        [string]$Lock_id = $Lock.id
        [string]$Lock_simpleId = $Lock.simpleId
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Lock_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$Lock_exists = ($null -eq (Get-AutomateNOWLock -Id $Lock_simpleId))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWLock failed to check if the Lock [$Lock_simpleId] already existed due to [$Message]."
                Break
            }
            If ($Lock_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not an Lock named [$Lock_simpleId] in the [$current_domain] domain. Please check into this."
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $Lock_id
            [string]$command = '/resource/update'
            [string]$operationType = 'update'
            If ($Description.Length -gt 0) {
                $BodyMetaData.'description' = $Description
            }
            ElseIf ($UnsetDescription -eq $true) {
                $BodyMetaData.'description' = $Null
            }
            Else {
                If ($Lock.description.Length -gt 0) {
                    $BodyMetaData.'description' = $Lock.description
                }
            }
            If ($UnsetFolder -eq $True) {
                $BodyMetaData.'folder' = $Null
            }
            ElseIf ($Folder.Length -gt 0) {
                $BodyMetaData.'folder' = $Folder
            }
            Else {
                If ($Lock.folder.Length -gt 0) {
                    $BodyMetaData.'folder' = $Lock.folder
                }
            }
            If ($Tags.Count -gt 0) {
                [int32]$tag_count = 1
                ForEach ($tag in $Tags) {
                    $BodyMetaData.('tags' + $tag_count ) = $tag
                    $tag_count++
                }
            }
            ElseIf ($UnsetTags -eq $true) {
                $BodyMetaData.'tags' = $Null
            }
            Else {
                If ($Lock.Tags -gt 0) {
                    [int32]$tag_count = 1
                    ForEach ($tag in $Lock.tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
            }
            If ($CodeRepository.Id.Length -gt 0) {
                [string]$CodeRepository_Id = $CodeRepository.Id
                $Error.Clear()
                Try {
                    [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository_Id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository_Id] actually existed under Set-AutomateNOWLock due to [$Message]"
                    Break
                }
                If ($code_repository_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository_Id] under Set-AutomateNOWLock. Please check again."
                    Break
                }
                $BodyMetaData.'codeRepository' = $CodeRepository_Id
            }
            ElseIf ($UnsetCodeRepository -eq $true) {
                $BodyMetaData.'codeRepository' = $null
            }
            $BodyMetaData.'_operationType' = $operationType
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_dataSource' = 'ResourceDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $parameters.Add('Command', $command)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Lock_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Lock object [$Lock_id] was successfully updated"
            $Error.Clear()
            Try {
                [ANOWLock]$UpdatedLock = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the returned updated object to an [ANOWLock] object due to [$Message]. The object was still updated though."
                Break
            }
            If ($Quiet -ne $true) {
                Return $UpdatedLock
            }
        }
    }
    End {
    }
}

Function Export-AutomateNOWLock {
    <#
    .SYNOPSIS
    Exports the Lock objects from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Lock objects from an instance of AutomateNOW! to a local .csv file

    .PARAMETER Lock
    Mandatory [ANOWLock] object (Use Get-AutomateNOWLock to retrieve them)

    .INPUTS
    ONLY [ANOWLock] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWLock] objects are exported to the local disk in CSV format

    .EXAMPLE
    Exports all of the Lock objects (up to 100 by default)

    Get-AutomateNOWLock | Export-AutomateNOWLock

    .EXAMPLE
    Exports 1 Lock by name

    Get-AutomateNOWLock -Id 'Lock01' | Export-AutomateNOWLock

    .EXAMPLE
    Exports a series of Lock objects by the pipeline

    @( 'Lock01', 'Lock02' ) | Get-AutomateNOWLock | Export-AutomateNOWLock

    .NOTES
	You must present [ANOWLock] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWLock]$Lock
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-Locks-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWLock]$Lock = $_
        }
        $Error.Clear()
        Try {
            $Lock | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWLock] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function New-AutomateNOWLock {
    <#
    .SYNOPSIS
    Creates a Lock within an AutomateNOW! instance

    .DESCRIPTION
    Creates a Lock within an AutomateNOW! instance and returns back the newly created [ANOWLock] object

    .PARAMETER Id
    The intended name of the Lock. For example: 'Lock1'. This value may not contain the domain in brackets.

    .PARAMETER Description
    Optional description of the Lock (may not exceed 255 characters).

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new Lock. Do not pass [ANOWTag] objects here.

    .PARAMETER Folder
    Optional name of the folder to place the Lock into.

    .PARAMETER CodeRepository
    Optional name of the code repository to place the Lock into.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWLock.

    .OUTPUTS
    An [ANOWLock] object representing the newly created Lock

    .EXAMPLE
    New-AutomateNOWLock -Id 'Lock01' -Description 'Description01' -Tags 'Tag01' -Folder 'Folder01' -CodeRepository 'Repository01'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The name (id) of the Lock must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    #>
    [OutputType([ANOWLock])]
    [Cmdletbinding()]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $true)]
        [string]$Id,
        [ValidateScript({ $_.Length -le 255 })]
        [Parameter(Mandatory = $false, HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [string]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [boolean]$Lock_exists = ($null -ne (Get-AutomateNOWLock -Id $Id))
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWLock failed to check if the Lock [$Id] already existed due to [$Message]."
        Break
    }
    If ($Lock_exists -eq $true) {
        [string]$current_domain = $anow_session.header.domain
        Write-Warning -Message "There is already a Lock named [$Id] in [$current_domain]. Please check into this."
        Break
    }
    ## End warning ##
    [System.Collections.Specialized.OrderedDictionary]$ANOWLock = [System.Collections.Specialized.OrderedDictionary]@{}
    $ANOWLock.Add('id', $Id)
    If ($Description.Length -gt 0) {
        $ANOWLock.Add('description', $Description)
    }
    If ($Tags.Count -gt 0) {
        [int32]$total_tags = $Tags.Count
        [int32]$current_tag = 1
        ForEach ($tag_id in $Tags) {
            $Error.Clear()
            Try {
                [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] running under New-AutomateNOWLock due to [$message]"
                Break
            }
            If ($tag_object.simpleId.length -eq 0) {
                Throw "New-AutomateNOWLock has detected that the tag [$tag_id] does not appear to exist. Please check again."
                Break
            }
            ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                [string]$tag_object_simpleId = $tag_object.simpleId
                Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                Break
            }
            [string]$tag_display = $tag_object | ConvertTo-Json -Compress
            Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
            [string]$tag_name_sequence = ('tags' + $current_tag)
            $ANOWLock.Add($tag_name_sequence, $tag_id)
            $include_properties += $tag_name_sequence
            $current_tag++
        }
    }
    If ($Folder.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] existed under New-AutomateNOWLock due to [$Message]"
            Break
        }
        If ($folder_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] under New-AutomateNOWLock. Please check again."
            Break
        }
        [string]$folder_display = $folder_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding folder $folder_display to [ANOWLock] [$Id]"
        $ANOWLock.Add('folder', $Folder)
        $include_properties += 'folder'
    }
    If ($CodeRepository.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository] existed under New-AutomateNOWLock due to [$Message]"
            Break
        }
        If ($code_repository_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository] under New-AutomateNOWLock. Please check again."
            Break
        }
        [string]$code_repository_display = $code_repository_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding code repository $code_repository_display to [ANOWLock] [$Id]"
        $ANOWLock.Add('codeRepository', $CodeRepository)
        $include_properties += 'codeRepository'
    }
    $ANOWLock.Add('title', 'Lock')
    $ANOWLock.Add('icon', '[SKINIMG]/skin/lock.png')
    $oldvalues = ('{"title":"Lock","resourceType":"LOCK","icon":"[SKINIMG]/skin/lock.png"}')
    [string]$BodyObject = ConvertTo-QueryString -InputObject $ANOWLock -IncludeProperties id, description, title, icon, tags, folder, codeRepository
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    $BodyMetaData.'resourceType' = 'LOCK'
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_operationType' = 'add'
    $BodyMetaData.'_oldValues' = $oldvalues
    $BodyMetaData.'_componentId' = 'ResourceCreateWindow_form'
    $BodyMetaData.'_dataSource' = 'ResourceDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$BodyMetaDataString = ConvertTo-QueryString -InputObject $BodyMetaData
    [string]$Body = ($BodyObject + '&' + $BodyMetaDataString)
    [string]$command = '/resource/create'
    [hashtable]$parameters = @{}
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('Body', $Body)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWLock]$Lock = $results.response.data | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to parse the result of New-AutomateNOWLock into an [ANOWLock] object due to [$Message]."
        Break
    }
    If ($Lock.id.Length -eq 0) {
        Write-Warning -Message "Somehow the newly created [ANOWLock] object is empty!"
        Break
    }
    If ($Quiet -ne $true) {
        Return $Lock
    }
}

Function Remove-AutomateNOWLock {
    <#
    .SYNOPSIS
    Removes a Lock from an AutomateNOW! instance

    .DESCRIPTION
    Removes a Lock from an AutomateNOW! instance

    .PARAMETER Lock
    An [ANOWLock] object representing the Lock to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWLock] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Remove a single Lock by name

    Get-AutomateNOWLock -Id 'Lock01' | Remove-AutomateNOWLock

    .EXAMPLE
    Removes a series of Lock objects via input from the pipeline

    @( 'Lock01', 'Lock02', 'Lock03') | Get-AutomateNOWLock | Remove-AutomateNOWLock

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWLock]$Lock,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/resource/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWLock]$Lock = $_
        }
        [string]$Lock_id = $Lock.id
        If ($Lock_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Lock_id)")) -eq $true) {
            [string]$oldvalues = $Lock.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $Lock.id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'ResourceList'
            $BodyMetaData.'_dataSource' = 'ResourceDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Lock_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Lock [$Lock_id] successfully removed"
        }
    }
    End {

    }
}

Function Copy-AutomateNOWLock {
    <#
    .SYNOPSIS
    Copies an Lock from an AutomateNOW! instance

    .DESCRIPTION
    Copies an Lock from an AutomateNOW! instance. AutomateNOW object id can never be changed, but we can copy the object to a new id and it will include all of the items therein.

    .PARAMETER Lock
    Mandatory [ANOWLock] object to be copied.

    .PARAMETER NewId
    The name (Id) of the new Lock. The new Id must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    .PARAMETER UnsetDescription
    Optional switch that will ensure that the newly created Lock will not have a description set.

    .PARAMETER Description
    Optional description to set on the new Lock object. If you do not set this, the new Lock object will copy the Description of the source object.

    .PARAMETER UnsetFolder
    Optional switch that will ensure that the newly created Lock will not have a Folder set.

    .PARAMETER Folder
    Optional description to set a different folder on the new Lock object. If you do not set this, the new Lock object will use the same Folder of the source object.

    .PARAMETER UnsetTags
    Optional switch that will ensure that the newly created Lock will not have any Tags set.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the new Lock object. If you do not set this, the new Lock object will apply the same Tags of the source object.

    .PARAMETER Force
    Force the copy without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    ONLY [ANOWLock] object is accepted. Pipeline support is intentionally unavailable.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Creates a copy of an Lock and changes the description (multi-line format)
    $Lock01 = Get-AutomateNOWLock -Id 'Lock_01'
    Copy-AutomateNOWLock -Lock $Lock01 -NewId 'Lock_01_production' -Description 'Lock 01 Production'

    .EXAMPLE
    Creates a copy of an Lock that omits the description (one-liner format)
    Copy-AutomateNOWLock -Lock (Get-AutomateNOWLock -Id 'Lock_01') -NewId 'Lock_01_production' -UnsetDescription -Tags 'Tag1', 'Tag2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWLock]$Lock,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot set the Tags and unset them at the same time. Please choose one or the other. Tags from the source object will be carried over to the new object if you do not specify any tag-related parameters."
            Break
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$Lock_exists = ($null -ne (Get-AutomateNOWLock -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWLock failed to check if the Lock [$NewId] already existed due to [$Message]."
            Break
        }
        If ($Lock_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Lock named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End warning ##
        [string]$command = '/resource/copy'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            [string]$Lock_oldId = $Lock.id
            [string]$Lock_simpleId = $Lock.simpleId
            If ($Lock_oldId -eq $NewId) {
                Write-Warning -Message "The new id cannot be the same as the old id."
                Break
            }
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Copy the Lock $($Lock_simpleId) to $($NewId)?")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                If ($UnsetFolder -eq $True) {
                    $BodyMetaData.'folder' = $Null
                }
                ElseIf ($Folder.Length -gt 0) {
                    $BodyMetaData.'folder' = $Folder
                }
                Else {
                    If ($Lock.folder.Length -gt 0) {
                        $BodyMetaData.'folder' = $Lock.folder
                    }
                }
                If ($Tags.Count -gt 0) {
                    [int32]$tag_count = 1
                    ForEach ($tag in $Tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
                ElseIf ($UnsetTags -eq $true) {
                    $BodyMetaData.'tags' = $Null
                }
                Else {
                    If ($Lock.Tags -gt 0) {
                        [int32]$tag_count = 1
                        ForEach ($tag in $Lock.tags) {
                            $BodyMetaData.('tags' + $tag_count ) = $tag
                            $tag_count++
                        }
                    }
                }
                $BodyMetaData.'oldId' = $Lock_oldId
                $BodyMetaData.'domain' = $Lock.domain
                $BodyMetaData.'id' = $NewId
                If ($UnsetDescription -ne $true) {
                    If ($Description.Length -gt 0) {
                        $BodyMetaData.'description' = $Description
                    }
                    Else {
                        $BodyMetaData.'description' = $Lock.description
                    }
                }
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_operationId' = 'copy'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_dataSource' = 'ResourceDataSource'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties oldId, domain, NewId, description, folder, tags
                $parameters.Body = $Body
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Lock_oldId] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                $Error.Clear()
                Try {
                    [ANOWLock]$NewLock = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to create copied [ANOWLock] object [$NewId] due to [$Message]."
                    Break
                }
                If ($NewLock.id.Length -eq 0) {
                    Write-Warning -Message "Somehow the newly created (copied) [ANOWLock] object [$NewId] is empty!"
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $NewLock
                }
            }
        }
    }
    End {

    }
}

Function Rename-AutomateNOWLock {
    <#
    .SYNOPSIS
    Renames a Lock on an AutomateNOW! instance

    .DESCRIPTION
    Performs a psuedo-rename operations of a Lock from an AutomateNOW! instance by copying it first and then deleting the source. This function merely combines Copy-AutomateNOWLock and Remove-AutomateNOWLock therefore it is to be considered destructive.

    .PARAMETER Lock
    An [ANOWLock] object representing the Lock to be renamed.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the Lock. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER Force
    Force the renaming without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly renamed object.

    .INPUTS
    ONLY [ANOWLock] objects are accepted. There is intentionally no support for the pipeline.

    .OUTPUTS
    The newly renamed [ANOWLock] object will be returned.

    .EXAMPLE
    $Lock = Get-AutomateNOWLock -Id 'Lock01'
    Rename-AutomateNOWLock -Lock $Lock -NewId 'Lock_01'

    .EXAMPLE
    Rename-AutomateNOWLock -Lock (Get-AutomateNOWLock -Id 'Lock01') -NewId 'Lock_01'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    When renaming, you may only specify a different Id (name).

    This action will be blocked if any existing referrals are found on the object.
    #>
    [OutputType([ANOWLock])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWLock]$Lock,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin standard warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$new_Lock_exists = ($null -ne (Get-AutomateNOWLock -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWLock failed to check if the Lock [$NewId] already existed due to [$Message]."
            Break
        }
        If ($new_Lock_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Lock named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        [string]$Lock_id = $Lock.simpleId
        $Error.Clear()
        Try {
            [boolean]$old_Lock_exists = ($null -ne (Get-AutomateNOWLock -Id $Lock_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWLock failed to check if the Lock [$Lock_id] already existed due to [$Message]."
            Break
        }
        If ($old_Lock_exists -eq $false) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not a Lock named [$Lock_id] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End standard warning ##
        ## Begin referrals warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [int32]$referrals_count = Find-AutomateNOWObjectReferral -Lock $Lock -Count | Select-Object -Expandproperty referrals
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Find-AutomateNOWObjectReferral failed to extract the referrals on Lock [$Lock_id] due to [$Message]."
            Break
        }
        If ($referrals_count -gt 0) {
            Write-Warning -Message "Unfortunately, you cannot rename a Lock that has referrals. This is because the rename is not actually renaming but copying anew and deleting the old. Please, use the Find-AutomateNOWObjectReferral function to identify referrals and remove them."
            Break
        }
        Else {
            Write-Verbose -Message "The Lock [$Lock_id] does not have any referrals. It is safe to proceed."
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Lock_id)")) -eq $true) {
                $Error.Clear()
                Try {
                    [ANOWLock]$new_Lock = Copy-AutomateNOWLock -Lock $Lock -NewId $NewId -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Copy-AutomateNOWLock failed to create a new Lock [$NewId] as Part 1 of the renaming process due to [$Message]."
                    Break
                }
                If ($new_Lock.simpleId -eq $NewId) {
                    Write-Verbose -Message "Part 1: Lock [$Lock_id] successfully copied to [$NewId]"
                }
                Else {
                    Write-Warning -Message "Somehow the first phase (Copy-AutomateNOWLock) failed. Please look into this."
                    Break
                }
                $Error.Clear()
                Try {
                    Remove-AutomateNOWLock -Lock $Lock -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Remove-AutomateNOWLock failed to remove [$Lock_id] as Part 2 of the renaming process due to [$Message]."
                    Break
                }
                Write-Verbose -Message "Part 2: Lock [$Lock_id] removed"
                Write-Verbose -Message "Task [$Lock_id] successfully renamed to [$NewId]"
                If ($Quiet -ne $true) {
                    Return $new_Lock
                }
            }
        }
        Else {
            Write-Warning -Message "No action was taken because either the source object didn't exist or the new object already existed"
        }
    }
    End {
    }
}

#endregion

#Region - Menu Customizations

Function Get-AutomateNOWMenuCustomization {
    <#
    .SYNOPSIS
    Gets the Menu Customization Objects from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Menu Customization Objects from an AutomateNOW! instance

    .PARAMETER Id
    Optional CASE-SENSITIVE string containing the 36-character GUID (Id) of the Menu Customimzation Object

    .PARAMETER startRow
    Integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER sortBy
    Optional string parameter to sort the results by (may not be used with the Id parameter). Valid choices are: id*, name, iconCode, dateCreated, lastUpdated, createdBy, lastUpdatedBy

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .INPUTS
    A single Id or a string of Id's across the pipeline will be accepted.

    .OUTPUTS
    Either one or more [ANOWMenuCustomization] objects

    .EXAMPLE
    Gets the first page of Menu Customization objects

    Get-AutomateNOWMenuCustomization

    .EXAMPLE
    Gets a single Menu Customization by its Id

    Get-AutomateNOWMenuCustomization -Id '875787b5-37e4-4717-80ef-05967bcc5abb'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWDeletedObject[]])]
    [Cmdletbinding(DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $True, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100,
        [ValidateSet('id', 'name', 'iconCode', 'dateCreated', 'lastUpdated', 'createdBy', 'lastUpdatedBy', IgnoreCase = $false)]
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$sortBy = 'id',
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$Descending
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
        If ($AllLoadBalancers -eq $true -and $AllChildNodes -eq $true) {
            Write-Warning -Message "You can't request only load balancer and then only load balancer nodes in the same request. Please choose one or the other."
            Break
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If (($_.Length -gt 0 -or $Id.Length -gt 0) ) {
            If ($_.Length -gt 0) {
                $Body.'id' = $_
            }
            Else {
                $Body.'id' = $Id
            }
            [string]$textMatchStyle = 'exactCase'
        }
        ElseIf ($itemId.Length -gt 0) {
            $Body.'itemId' = $itemId
            [string]$textMatchStyle = 'exactCase'
        }
        Else {
            $Body.'operator' = 'and'
            $Body.'_componentId' = 'DomainProcessingTypeList'
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
            [string]$textMatchStyle = 'substring'
            If ($Descending -eq $true) {
                $Body.'_sortBy' = '-' + $sortBy
            }
            Else {
                $Body.'_sortBy' = $sortBy
            }
        }
        $Body.'_operationId' = 'read'
        $Body.'_operationType' = 'fetch'
        $Body.'_textMatchStyle' = $textMatchStyle
        $Body.'_dataSource' = 'DomainProcessingTypeDataSource'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/domainProcessingType/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        [ANOWMenuCustomization[]]$MenuCustomizations = ForEach ($result in $results.response.data) {
            If ($result.integration.length -gt 0) {
                [string]$Integration_Id = $result.integration
                Try {
                    $result.integration = Get-AutomateNOWInterface -Id $Integration_Id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWInterface failed to help parse the response into a series of [ANOWMenuCustomization] objects due to [$Message]."
                    Break
                }
            }
            $result
        }
        If ($MenuCustomizations.Count -gt 0) {
            Return $MenuCustomizations
        }
    }
    End {

    }
}

Function Export-AutomateNOWMenuCustomization {
    <#
    .SYNOPSIS
    Exports the Menu Customization objects from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Menu Customization objects from an instance of AutomateNOW! to a local .csv file

    .PARAMETER MenuCustomization
    Mandatory [ANOWMenuCustomization] object (Use Get-AutomateNOWMenuCustomization to retrieve them)

    .INPUTS
    ONLY [ANOWMenuCustomization] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWMenuCustomization] objects are exported to the local disk in CSV format

    .EXAMPLE
    Exports the first page of Menu Customization objects

    Get-AutomateNOWMenuCustomization | Export-AutomateNOWMenuCustomization

    .EXAMPLE
    Exports a single Menu Customization by id

    Get-AutomateNOWMenuCustomization -Id '875787b5-37e4-4717-80ef-05967bcc5abb' | Export-AutomateNOWMenuCustomization

    .EXAMPLE
    Exports a series of Menu Customization objects by Id across the pipeline

    'e0586d27-f20b-436d-9dcd-cda3b06ddc39', 'acd0d418-37af-449f-a3b0-98c8d30bdae7', '875787b5-37e4-4717-80ef-05967bcc5aba' | Get-AutomateNOWMenuCustomization | Export-AutomateNOWMenuCustomization

    .NOTES
	You must present [ANOWMenuCustomization] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWMenuCustomization]$MenuCustomization
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-MenuCustomizations-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWMenuCustomization]$MenuCustomization = $_
        }
        $Error.Clear()
        Try {
            $MenuCustomization | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWMenuCustomization] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function Remove-AutomateNOWMenuCustomization {
    <#
    .SYNOPSIS
    Removes a Menu Customization from an AutomateNOW! instance

    .DESCRIPTION
    Removes a Menu Customization from an AutomateNOW! instance

    .PARAMETER MenuCustomization
    An [ANOWMenuCustomization] object representing the Menu Customization to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWMenuCustomization] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Remove a single MenuCustomization by Id

    Get-AutomateNOWMenuCustomization -Id '375787b5-37e4-4117-80ef-05967bcc5abb' | Remove-AutomateNOWMenuCustomization

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWMenuCustomization]$MenuCustomization,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/domainProcessingType/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWMenuCustomization]$MenuCustomization = $_
        }
        [string]$MenuCustomization_id = $MenuCustomization.id
        If ($MenuCustomization_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($MenuCustomization_id)")) -eq $true) {
            [string]$oldvalues = $MenuCustomization.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $MenuCustomization.id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'DomainProcessingTypeList'
            $BodyMetaData.'_dataSource' = 'DomainProcessingTypeDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$MenuCustomization_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Menu Customization [$MenuCustomization_id] successfully removed"
        }
    }
    End {

    }
}

#endregion

#Region - Metrics (RESOURCE)

Function Get-AutomateNOWMetric {
    <#
    .SYNOPSIS
    Gets the Metric objects from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Metric objects from an AutomateNOW! instance

    .PARAMETER Id
    Optional string containing the simple id of the Metric to fetch or you can pipeline a series of simple id strings. You may not enter an array here.

    .PARAMETER Detailed
    Switch parameter to provide the detailed properties of the [ANOWMetric] object. This may only be used in conjunction with -Id. Use this option to see the fully populated object.

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100. The console default hard limit is 10,000.

    .PARAMETER sortBy
    Optional string parameter to sort the results by (may not be used with the Id parameter). Valid choices are: {To be continued...}

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .PARAMETER Folder
    Optional string to filter by a particular Folder

    .PARAMETER Tags
    Optional string array of Tags to filter by. Note that the 'containsAny' operator will be used.

    .INPUTS
    Accepts a string representing the simple id of the Metric from the pipeline or individually (but not an array).

    .OUTPUTS
    Either one or more [ANOWMetric] objects

    .EXAMPLE
    Gets the first page of Metric objects

    Get-AutomateNOWMetric

    .EXAMPLE
    Gets the first 500 Metric objects

    Get-AutomateNOWMetric -startRow 0 -endRow 500

    .EXAMPLE
    Gets a single non-detailed Metric named 'Metric1'

    Get-AutomateNOWMetric -Id 'Metric1'

    .EXAMPLE
    Gets the detailed version of a Metric object named 'Metric1'

    Get-AutomateNOWMetric -Id 'Metric1' -Detailed

    .EXAMPLE
    Gets a series of Metric objects through the pipeline

    'Metric1', 'Metric2' | Get-AutomateNOWMetric

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(DefaultParameterSetName = 'Id')]
    Param(
        [Parameter(Mandatory = $False, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [Parameter(Mandatory = $False, ParameterSetName = 'Detailed', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'Detailed')]
        [switch]$Detailed,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [string]$sortBy = 'id',
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [switch]$Descending,
        [Parameter(Mandatory = $False)]
        [string]$Folder,
        [Parameter(Mandatory = $False)]
        [string[]]$Tags
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 ) {
            [string]$Metric_Id = $_
        }
        Else {
            [string]$Metric_Id = $Id
        }
        If ($Detailed -eq $true) {
            $Body.'id' = $Metric_Id
            [string]$textMatchStyle = 'exactCase'
            $Body.'_operationId' = 'readDetailed'
            [string]$Method = 'POST'
        }
        Else {
            $Body.'_constructor' = 'AdvancedCriteria'
            $Body.'operator' = 'and'
            $Body.'criteria1' = '{"fieldName":"resourceType","operator":"equals","value":"METRIC"}'
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
            If ($Metric_Id.Length -gt 0) {
                $Body.'criteria2' = ('{"fieldName":"simpleId","operator":"equals","value":"' + $Metric_Id + '"}')
                [string]$textMatchStyle = 'exact'
            }
            Else {
                [string]$textMatchStyle = 'substring'
            }
            If ($Folder.Length -gt 0) {
                $Body.'criteria3' = ('{"fieldName":"folder","operator":"equals","value":"' + $Folder + '"}')
            }
            If ($Tags.Count -gt 0) {
                If ($Tags.Count -gt 1) {
                    $Error.Clear()
                    Try {
                        [string]$TagString = $Tags | ConvertTo-Json -Compress
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "ConvertTo-Json failed to convert the provided tag names under Get-AutomateNOWMetric due to [$Message]."
                        Break
                    }
                }
                Else {
                    [string]$TagString = $Tags
                }
                $Body.'criteria4' = ('{"fieldName":"tags","operator":"containsAny","value":' + $TagString + '}')
            }
            $Body.'_componentId' = 'ResourceList'
            If ($Descending -eq $true) {
                $Body.'_sortBy' = '-' + $sortBy
            }
            Else {
                $Body.'_sortBy' = $sortBy
            }
            [string]$Method = 'GET'
        }
        $Body.'_operationType' = 'fetch'
        $Body.'_textMatchStyle' = $textMatchStyle
        $Body.'_dataSource' = 'ResourceDataSource'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        If ($Detailed -eq $true) {
            [string]$command = ('/resource/readDetailed')
            If ($Null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            If ($null -eq $parameters["Command"]) {
                $parameters.Add('Command', $command)
            }
            Else {
                $parameters.Command = $command
            }
        }
        Else {
            [string]$command = ('/resource/read?' + $Body)
            $parameters.Command = $command
        }
        If ($null -eq $parameters.Method) {
            $parameters.Add('Method', $Method)
        }
        Else {
            $parameters.Method = $Method
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWMetric[]]$Metrics = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWMetric failed to parse the results into [ANOWMetric] objects due to [$Message]."
            Break
        }
        If ($Metrics.Count -gt 0) {
            Return $Metrics
        }
    }
    End {

    }
}

Function Set-AutomateNOWMetric {
    <#
    .SYNOPSIS
    Changes the settings of an Metric on an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of an Metric on an AutomateNOW! instance

    .PARAMETER Metric
    An [ANOWMetric] object representing the Metric to be modified.

    .PARAMETER Value
    Optional int64 to set the value (resource status) on the Metric to.

    .PARAMETER UnsetValue
    Optional switch that will remove (blank out to null) the Value from the Metric object.

    .PARAMETER ValueUnit
    Optional string to set the name of the Value Unit on the Metric to.

    .PARAMETER UnsetValueUnit
    Optional switch that will remove (blank out to null) the Value Unit from the Metric object.

    .PARAMETER minValue
    Optional [int64] to set the minimum value of the Value Unit of the Metric object.

    .PARAMETER UnsetMinValue
    Optional switch that will remove (blank out to null) the Minimum Value from the Metric object. You should try to use this parameter exclusively from other parameters as it is not supported in the UI.

    .PARAMETER maxValue
    Optional [int64] to set the maximum value of the Value Unit of the Metric object.

    .PARAMETER UnsetMaxValue
    Optional switch that will remove (blank out to null) the Maximum Value from the Metric object.  You should try to use this parameter exclusively from other parameters as it is not supported in the UI.

    .PARAMETER valueVeryLowThreshold
    Optional [int64] to set the Very Low Threshold of the Value Unit of the Metric object.

    .PARAMETER valueLowThreshold
    Optional [int64] to set the Low Threshold of the Value Unit of the Metric object.

    .PARAMETER valueHighThreshold
    Optional [int64] to set the High Threshold of the Value Unit of the Metric object.

    .PARAMETER valueVeryHighThreshold
    Optional [int64] to set the Very High Threshold of the Value Unit of the Metric object.

    .PARAMETER Description
    Optional string to set the description on the new Metric object.

    .PARAMETER UnsetDescription
    Optional switch that will remove (blank out to null) the Description from the Metric object.

    .PARAMETER Folder
    Optional string to set a different folder on the Metric object.

    .PARAMETER UnsetFolder
    Optional switch that will remove the Folder assignment from the Metric object.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the new Metric object.

    .PARAMETER UnsetTags
    Optional switch that will remove the Tags from the Metric object.

    .PARAMETER CodeRepository
    Optional Code Repository to place the Metric into. Use Get-AutomateNOWCodeRepository to fetch this object.

    .PARAMETER UnsetCodeRepository
    Switch parameter that will remove the the Metric from its Code Repository.

    .PARAMETER Quiet
    Switch parameter that silences the output of the updated object.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWMetric] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWMetric] object will be returned

    .EXAMPLE
    Changes the description and folder, along with setting 2 tags on a Metric

    $Metric = Get-AutomateNOWMetric -Id 'Metric1'
    Set-AutomateNOWMetric -Description 'Awesome description!' -Tags 'Tag1', 'Tag2' -Folder 'Folder1'

    .EXAMPLE
    Sets all of the unit values for a Metric

    Set-AutomateNOWMetric -Metric (Get-AutomateNOWMetric -Id 'Metric1') -ValueUnit 'MyUnit' -MinValue 0 -VerylowThreshold 1 -LowThreshold 2 -HighThreshold 3 -VeryHighThreshold 4 -MaxValue 5

    .EXAMPLE
    Unsets all of the unit values for a Metric using the pipeline

    Get-AutomateNOWMetric -Id 'Metric1' | Set-AutomateNOWMetric -UnsetValueUnit -UnsetMinValue -UnsetVeryLowThreshold -UnsetLowThreshold -UnsetHighThreshold -UnsetVeryHighThreshold -UnsetMaxValue -Force

    .EXAMPLE
    Forcibly sets the current value (state) of the Metric to 10
    Get-AutomateNOWMetric -Id 'Metric1' | Set-AutomateNOWMetric -Value 10

    .EXAMPLE
    Forcibly unsets the current value for the Metric using the pipeline
    Get-AutomateNOWMetric -Id 'Metric1' | Set-AutomateNOWMetric -UnsetValue -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Be sure to send a valid int64 to the -Value parameter and not a string like 1+e47 :-)

    API Constraint: The maximum value may not exist but if it does then it must be equal or lesser to the minimum value.

    The value of the Metric CANNOT be set to a value lower then the minimum (if minimum is configured) or higher then the maximum (if maximum is configured). The UI does not allow this but the API will ignore it (without warning) if you try to force a value that is out of bounds.

    #>
    [OutputType([ANOWMetric])]
    [Cmdletbinding(SupportsShouldProcess, DefaultParameterSetName = 'Default', ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'Default', ValueFromPipeline = $True)]
        [Parameter(Mandatory = $true, ParameterSetName = 'SetValue', ValueFromPipeline = $True)]
        [Parameter(Mandatory = $true, ParameterSetName = 'ValueUnit', ValueFromPipeline = $True)]
        [ANOWMetric]$Metric,
        [ValidateScript({ $_ -match '^-{0,}[0-9]{1,}$' })]
        [Parameter(Mandatory = $false, ParameterSetName = 'SetValue')]
        [string]$Value, # this needs to be a string even though it is a number since 0 is a possible value
        [Parameter(Mandatory = $false, ParameterSetName = 'SetValue')]
        [switch]$UnsetValue,
        [Parameter(Mandatory = $false, ParameterSetName = 'ValueUnit')]
        [string]$ValueUnit,
        [Parameter(Mandatory = $false, ParameterSetName = 'ValueUnit')]
        [switch]$UnsetValueUnit,
        [ValidateScript({ $_ -match '^-{0,}[0-9]{1,}$' })]
        [Parameter(Mandatory = $false, ParameterSetName = 'ValueUnit')]
        [string]$minValue, # this needs to be a string even though it is a number since 0 is a possible value
        [Parameter(Mandatory = $false, ParameterSetName = 'ValueUnit')]
        [switch]$UnsetMinValue,
        [ValidateScript({ $_ -match '^-{0,}[0-9]{1,}$' })]
        [Parameter(Mandatory = $false, ParameterSetName = 'ValueUnit')]
        [string]$maxValue, # this needs to be a string even though it is a number since 0 is a possible value
        [Parameter(Mandatory = $false, ParameterSetName = 'ValueUnit')]
        [switch]$UnsetMaxValue,
        [ValidateScript({ $_ -match '^-{0,}[0-9]{1,}$' })]
        [Parameter(Mandatory = $false, ParameterSetName = 'ValueUnit')]
        [string]$VeryLowThreshold,
        [Parameter(Mandatory = $false, ParameterSetName = 'ValueUnit')]
        [switch]$UnsetVeryLowThreshold,
        [ValidateScript({ $_ -match '^-{0,}[0-9]{1,}$' })]
        [Parameter(Mandatory = $false, ParameterSetName = 'ValueUnit')]
        [string]$LowThreshold,
        [Parameter(Mandatory = $false, ParameterSetName = 'ValueUnit')]
        [switch]$UnsetLowThreshold,
        [ValidateScript({ $_ -match '^-{0,}[0-9]{1,}$' })]
        [Parameter(Mandatory = $false, ParameterSetName = 'ValueUnit')]
        [string]$HighThreshold,
        [Parameter(Mandatory = $false, ParameterSetName = 'ValueUnit')]
        [switch]$UnsetHighThreshold,
        [ValidateScript({ $_ -match '^-{0,}[0-9]{1,}$' })]
        [Parameter(Mandatory = $false, ParameterSetName = 'ValueUnit')]
        [string]$VeryHighThreshold,
        [Parameter(Mandatory = $false, ParameterSetName = 'ValueUnit')]
        [switch]$UnsetVeryHighThreshold,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [string[]]$Tags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [string]$Folder,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetCodeRepository,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'SetValue')]
        [Parameter(Mandatory = $false, ParameterSetName = 'ValueUnit')]
        [switch]$Quiet,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'SetValue')]
        [Parameter(Mandatory = $false, ParameterSetName = 'ValueUnit')]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot set the Tags and unset them at the same time. Please choose one or the other. Tags from the source object will be carried over to the new object if you do not specify any tag-related parameters."
            Break
        }
        If ($UnsetCodeRepository -eq $true -and $CodeRepository.Id.Length -gt 0) {
            Write-Warning -Message "You cannot unset the Code Repository and set it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetValue -eq $true -and $Value.Length -gt 0) {
            Write-Warning -Message "You cannot set the Value and unset the Value at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetValueUnit -eq $true -and $ValueUnit.Length -gt 0) {
            Write-Warning -Message "You cannot set the Value Unit and unset the Value Unit at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetMinValue -eq $true -and $minValue.Length -gt 0) {
            Write-Warning -Message "You cannot set the Minimum Value and unset the Minimum Value at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetMaxValue -eq $true -and $maxValue.Length -gt 0) {
            Write-Warning -Message "You cannot set the Maximum Value and unset the Maximum Value at the same time. Please choose one or the other."
            Break
        }
        If ( $UnsetVeryLowThreshold -eq $true -and $VeryLowThreshold.Length -gt 0) {
            Write-Warning -Message "You cannot set the Very Low Threshold Value and unset the it at the same time. Please choose one or the other."
            Break
        }
        If ( $UnsetLowThreshold -eq $true -and $LowThreshold.Length -gt 0) {
            Write-Warning -Message "You cannot set the Low Threshold Value and unset the it at the same time. Please choose one or the other."
            Break
        }
        If ( $UnsetHighThreshold -eq $true -and $HighThreshold.Length -gt 0) {
            Write-Warning -Message "You cannot set the High Threshold Value and unset the it at the same time. Please choose one or the other."
            Break
        }
        If ( $UnsetVeryHighThreshold -eq $true -and $VeryHighThreshold.Length -gt 0) {
            Write-Warning -Message "You cannot set the Very High Threshold Value and unset the it at the same time. Please choose one or the other."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWMetric]$Metric = $_
        }
        [string]$Metric_id = $Metric.id
        [string]$Metric_simpleId = $Metric.simpleId
        [string]$current_Metric_value = $Metric.resourceStatus
        If ($current_Metric_value.Length -eq 0) {
            Write-Verbose -Message "Detected the current value (resource status) of Metric object [$Metric_simpleId] is empty"
        }
        Else {
            Write-Verbose -Message "Detected the current value (resource status) of Metric object [$Metric_simpleId] to be [$current_Metric_value]"
        }
        [string]$current_Metric_valueUnit = $Metric.valueUnit
        [string]$current_Metric_minValue = $Metric.minValue
        [string]$current_Metric_maxValue = $Metric.maxValue
        [string]$current_Metric_lowValue = $Metric.valueLowThreshold
        [string]$current_Metric_veryLowValue = $Metric.valueVeryLowThreshold
        [string]$current_Metric_highValue = $Metric.valueHighThreshold
        [string]$current_Metric_veryHighValue = $Metric.valueVeryHighThreshold
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Metric_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$Metric_exists = ($null -eq (Get-AutomateNOWMetric -Id $Metric_simpleId))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWMetric failed to check if the Metric [$Metric_simpleId] already existed due to [$Message]."
                Break
            }
            If ($Metric_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not a Metric named [$Metric_simpleId] in the [$current_domain] domain. Please check into this."
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            [System.Collections.ArrayList]$IncludeProperties = New-Object -TypeName System.Collections.ArrayList
            $BodyMetaData.'id' = $Metric_id
            If ($Value.Length -gt 0) {
                If ($Value -eq $current_Metric_value) {
                    Write-Warning -Message "No action is required. The Metric [$Metric_simpleId] is already set to [$Value]"
                    Break
                }
                Else {
                    Write-Verbose -Message "Changing the value of [$Metric_simpleId] from [$current_Metric_value] to [$Value]"
                    $BodyMetaData.'newValue' = [int64]$Value # Cast this as an int64 at the last second to ensure this is a valid number being sent
                }
                If ($current_Metric_minValue.Length -gt 0) {
                    [int64]$effective_minValue = $current_Metric_minValue
                    If ($Value -lt $effective_minValue) {
                        Write-Warning -Message "You may not set the value to $Value which is lower then the configured minimum value of $effective_minValue."
                        Break
                    }
                }
                If ($current_Metric_maxValue.Length -gt 0) {
                    [int64]$effective_maxValue = $current_Metric_maxValue
                    If ($Value -gt $effective_maxValue) {
                        Write-Warning -Message "You may not set the value to $Value which is greater then the configured maximum value of $effective_maxValue."
                        Break
                    }
                }
                [string]$operationId = 'setValue'
                [string]$operationType = 'custom'
                $BodyMetaData.'_operationId' = $operationId
                [string]$command = "/resource/$operationId"
            }
            ElseIf ($unsetValue -eq $true) {
                If ($current_Metric_value.Length -eq 0 ) {
                    Write-Warning -Message "The Metric [$Metric_simpleId] value is already unset. No action is required."
                    Break
                }
                [string]$operationId = 'setValue'
                [string]$operationType = 'custom'
                $BodyMetaData.'_operationId' = $operationId
                [string]$command = "/resource/$operationId"
            }
            Else {
                [string]$command = '/resource/update'
                [string]$operationType = 'update'
                If ($Description.Length -gt 0) {
                    $BodyMetaData.'description' = $Description
                }
                ElseIf ($UnsetDescription -eq $true) {
                    $BodyMetaData.'description' = $Null
                }
                If ($UnsetFolder -eq $True) {
                    $BodyMetaData.'folder' = $Null
                }
                ElseIf ($Folder.Length -gt 0) {
                    $BodyMetaData.'folder' = $Folder
                }
                If ($Tags.Count -gt 0) {
                    [int32]$tag_count = 1
                    ForEach ($tag in $Tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
                ElseIf ($UnsetTags -eq $true) {
                    $BodyMetaData.'tags' = $Null
                }
                If ($CodeRepository.Id.Length -gt 0) {
                    [string]$CodeRepository_Id = $CodeRepository.Id
                    $Error.Clear()
                    Try {
                        [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository_Id
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository_Id] actually existed under Set-AutomateNOWMetric due to [$Message]"
                        Break
                    }
                    If ($code_repository_object.simpleId.Length -eq 0) {
                        Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository_Id] under Set-AutomateNOWMetric. Please check again."
                        Break
                    }
                    $BodyMetaData.'codeRepository' = $CodeRepository_Id
                }
                ElseIf ($UnsetCodeRepository -eq $true) {
                    $BodyMetaData.'codeRepository' = $null
                }
                If ($valueUnit.Length -gt 0) {
                    If ($valueUnit -eq $current_Metric_valueUnit) {
                        Write-Warning -Message "The value unit is already named $valueUnit. There is no action required."
                        Break
                    }
                    $BodyMetaData.'valueUnit' = $valueUnit
                }
                ElseIf ($UnsetValueUnit -eq $true) {
                    If ($current_Metric_valueUnit.Length -eq 0) {
                        Write-Warning -Message "The value unit is already unset. There is no action required."
                        Break
                    }
                    $BodyMetaData.'valueUnit' = $null
                }
                If (($minValue.Length -gt 0) -or ($unsetMinValue -eq $true) -or ($VeryLowThreshold.Length -gt 0) -or ($unsetVeryLowThreshold -eq $true) -or ($LowThreshold.Length -gt 0) -or ($unsetLowThreshold -eq $true) -or ($HighThreshold.Length -gt 0) -or ($unsetHighThreshold -eq $true) -or ($VeryHighThreshold.Length -gt 0) -or ($unsetVeryHighThreshold -eq $true) -or ($maxValue.Length -gt 0) -or ($unsetmaxValue -eq $true)) {
                    $BodyMetaData.'_componentId' = 'ResourceVM'
                    If ($minValue.Length -gt 0) {
                        [int64]$effective_minValue = $minValue
                        $BodyMetaData.'minValue' = $effective_minValue
                    }
                    ElseIf ($current_Metric_minValue.Length -gt 0 -and $UnsetMinValue -ne $true) {
                        [int64]$effective_minValue = $current_Metric_minValue
                    }
                    ElseIf ($UnsetMinValue -eq $true) {
                        $BodyMetaData.'minValue' = $null
                        $IncludeProperties += 'minValue'
                    }
                    If ($VeryLowThreshold.Length -gt 0 -and $UnsetVeryLowThreshold -ne $true) {
                        [int64]$effective_VeryLowThreshold = $VeryLowThreshold
                        $BodyMetaData.'valueVeryLowThreshold' = $effective_VeryLowThreshold
                    }
                    ElseIf ($current_Metric_veryLowValue.Length -gt 0 -and $UnsetVeryLowThreshold -ne $true) {
                        [int64]$effective_VeryLowThreshold = $current_Metric_veryLowValue
                    }
                    ElseIf ($UnsetVeryLowThreshold -eq $true) {
                        $BodyMetaData.'valueVeryLowThreshold' = $null
                        $IncludeProperties += 'valueVeryLowThreshold'
                    }
                    If ($LowThreshold.Length -gt 0 -and $UnsetLowThreshold -ne $true) {
                        [int64]$effective_LowThreshold = $LowThreshold
                        $BodyMetaData.'valueLowThreshold' = $effective_LowThreshold
                    }
                    ElseIf ($current_Metric_LowValue.Length -gt 0 -and $UnsetLowThreshold -ne $true) {
                        [int64]$effective_LowThreshold = $current_Metric_LowValue
                    }
                    ElseIf ($UnsetLowThreshold -eq $true) {
                        $BodyMetaData.'valueLowThreshold' = $null
                        $IncludeProperties += 'valueLowThreshold'
                    }
                    If ($HighThreshold.Length -gt 0 -and $UnsetHighThreshold -ne $true) {
                        [int64]$effective_HighThreshold = $HighThreshold
                        $BodyMetaData.'valueHighThreshold' = $effective_HighThreshold
                    }
                    ElseIf ($current_Metric_HighValue.Length -gt 0 -and $UnsetHighThreshold -ne $true) {
                        [int64]$effective_HighThreshold = $current_Metric_highValue
                    }
                    ElseIf ($UnsetHighThreshold -eq $true) {
                        $BodyMetaData.'valueHighThreshold' = $null
                        $IncludeProperties += 'valueHighThreshold'
                    }
                    If ($VeryHighThreshold.Length -gt 0 -and $UnsetVeryHighThreshold -ne $true) {
                        [int64]$effective_VeryHighThreshold = $VeryHighThreshold
                        $BodyMetaData.'valueVeryHighThreshold' = $effective_VeryHighThreshold
                    }
                    ElseIf ($current_Metric_veryHighValue.Length -gt 0 -and $UnsetVeryHighThreshold -ne $true) {
                        [int64]$effective_VeryHighThreshold = $current_Metric_veryHighValue
                    }
                    ElseIf ($UnsetVeryHighThreshold -eq $true) {
                        $BodyMetaData.'valueVeryHighThreshold' = $null
                        $IncludeProperties += 'valueVeryHighThreshold'
                    }
                    If ($maxValue.Length -gt 0 -and $UnsetMaxValue -ne $true) {
                        [int64]$effective_maxValue = $maxValue
                        $BodyMetaData.'maxValue' = $effective_maxValue
                    }
                    ElseIf ($current_Metric_maxValue.Length -gt 0 -and $UnsetMaxValue -ne $true) {
                        [int64]$effective_maxValue = $current_Metric_maxValue
                    }
                    ElseIf ($UnsetMaxValue -eq $true) {
                        $BodyMetaData.'maxValue' = $null
                        $IncludeProperties += 'maxValue'
                    }
                }
                # Testing the constraints around the "Very Low threshold value"
                If ($constraint_violated -ne $true -and $VeryLowThreshold.Length -gt 0) {
                    If ($effective_VeryLowThreshold -lt $effective_minValue) {
                        [boolean]$constraint_violated = $true
                        [string]$constaint_reason = 'Very Low Threshold value is too low in comparison to the other values.'
                    }
                    If ($effective_VeryLowThreshold -gt $effective_LowThreshold -or $effective_VeryLowThreshold -gt $effective_HighThreshold -or $effective_VeryLowThreshold -gt $effective_VeryHighThreshold -or $effective_VeryLowThreshold -gt $effective_maxValue) {
                        [boolean]$constraint_violated = $true
                        [string]$constaint_reason = 'Very Low Threshold value is too high in comparison to the other values.'
                    }
                }
                # Testing the constraints around the "Low threshold value"
                If ($constraint_violated -ne $true -and $LowThreshold.Length -gt 0) {
                    If ($effective_LowThreshold -lt $effective_minValue -or $effective_LowThreshold -lt $effective_VeryLowThreshold) {
                        [boolean]$constraint_violated = $true
                        [string]$constaint_reason = 'Low Threshold value is too low in comparison to the other values.'
                    }
                    If ($effective_LowThreshold -gt $effective_HighThreshold -or $effective_LowThreshold -gt $effective_VeryHighThreshold -or $effective_LowThreshold -gt $effective_maxValue) {
                        [boolean]$constraint_violated = $true
                        [string]$constaint_reason = 'Very Low Threshold value is too high in comparison to the other values.'
                    }
                }
                # Testing the constraints around the "High threshold value"
                If ($constraint_violated -ne $true -and $HighThreshold.Length -gt 0) {
                    If ($effective_HighThreshold -lt $effective_minValue -or $effective_HighThreshold -lt $effective_VeryLowThreshold -or $effective_HighThreshold -lt $effective_LowThreshold) {
                        [boolean]$constraint_violated = $true
                        [string]$constaint_reason = 'High Threshold value is too low in comparison to the other values.'
                    }
                    If ($effective_HighThreshold -gt $effective_VeryHighThreshold -or $effective_HighThreshold -gt $effective_maxValue) {
                        [boolean]$constraint_violated = $true
                        [string]$constaint_reason = 'Very High Threshold value is too high in comparison to the other values.'
                    }
                }
                # Testing the constraints around the "Very High threshold value"
                If ($constraint_violated -ne $true -and $VeryHighThreshold.Length -gt 0) {
                    If ($effective_VeryHighThreshold -lt $effective_minValue -or $effective_VeryHighThreshold -lt $effective_VeryLowThreshold -or $effective_VeryHighThreshold -lt $effective_LowThreshold -or $effective_VeryHighThreshold -lt $effective_HighThreshold) {
                        [boolean]$constraint_violated = $true
                        [string]$constaint_reason = 'Very High Threshold value is too low in comparison to the other values.'
                    }
                    If ($effective_VeryHighThreshold -gt $effective_maxValue) {
                        [boolean]$constraint_violated = $true
                        [string]$constaint_reason = "Very High Threshold value is too high ($effective_VeryHighThreshold) in comparison to the Maximum Value ($effective_maxValue)."
                    }
                }
                # Testing the constraints around the "Minimum value"
                If ($constraint_violated -ne $true -and $effective_minValue.Length -gt 0 -and ($effective_minValue -gt $effective_VeryLowThreshold -or $effective_minValue -gt $effective_LowThreshold -or $effective_minValue -gt $effective_HighThreshold -or $effective_minValue -gt $effective_VeryHighThreshold -or $effective_minValue -gt $effective_maxValue)) {
                    [boolean]$constraint_violated = $true
                    [string]$constaint_reason = "Minimum value too high. Set the other values to anything equal or higher to the minimum value."
                }
                # Testing the constraints around the "Maximum value"
                If ($constraint_violated -ne $true -and $effective_maxValue.Length -gt 0 -and ($effective_maxValue -lt $effective_VeryLowThreshold -or $effective_maxValue -lt $effective_LowThreshold -or $effective_maxValue -lt $effective_HighThreshold -or $effective_maxValue -lt $effective_VeryHighThreshold -or $effective_maxValue -lt $effective_maxValue)) {
                    [boolean]$constraint_violated = $true
                    [string]$constaint_reason = "Maximum value too low. Set the other values to anything equal or lower to the maximum value."
                }
                # Break if any constraints were violated. Note that this measurement is identical to the javascript within the ANOW UI.
                If ($constraint_violated -eq $true) {
                    Write-Warning -Message "You are violating the constraints of the values within this Metric object. Reason: $constaint_reason"
                    Break
                }
            }
            $BodyMetaData.'_operationType' = $operationType
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_dataSource' = 'ResourceDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties $IncludeProperties
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $parameters.Add('Command', $command)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Metric_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Metric object $Metric_id was successfully updated"
            $Error.Clear()
            Try {
                [ANOWMetric]$UpdatedMetric = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the returned updated object to an [ANOWMetric] object due to [$Message]. The object was still updated though."
                Break
            }
            If ($Quiet -ne $true) {
                Return $UpdatedMetric
            }
        }
    }
    End {
    }
}

Function Export-AutomateNOWMetric {
    <#
    .SYNOPSIS
    Exports the Metric objects from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Metric objects from an instance of AutomateNOW! to a local .csv file

    .PARAMETER Metric
    Mandatory [ANOWMetric] object (Use Get-AutomateNOWMetric to retrieve them)

    .INPUTS
    ONLY [ANOWMetric] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWMetric] objects are exported to the local disk in CSV format

    .EXAMPLE
    Exports all of the Metric objects (up to 100 by default)

    Get-AutomateNOWMetric | Export-AutomateNOWMetric

    .EXAMPLE
    Exports 1 Metric by name

    Get-AutomateNOWMetric -Id 'Metric01' | Export-AutomateNOWMetric

    .EXAMPLE
    Exports a series of Metric objects by the pipeline

    @( 'Metric01', 'Metric02' ) | Get-AutomateNOWMetric | Export-AutomateNOWMetric

    .NOTES
	You must present [ANOWMetric] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWMetric]$Metric
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-Metrics-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWMetric]$Metric = $_
        }
        $Error.Clear()
        Try {
            $Metric | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWMetric] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function New-AutomateNOWMetric {
    <#
    .SYNOPSIS
    Creates a Metric within an AutomateNOW! instance

    .DESCRIPTION
    Creates a Metric within an AutomateNOW! instance and returns back the newly created [ANOWMetric] object

    .PARAMETER Id
    The intended name of the Metric. For example: 'Metric1'. This value may not contain the domain in brackets.

    .PARAMETER CompositeFunction
    Optional string to add a Composite Function to the Metric. Valid choices are: CURRENT_VALUE; AVERAGE; MEDIAN; FIRST_QUARTILE; SECOND_QUARTILE; THIRD_QUARTILE; FOURTH_QUARTILE; MIN; MAX; COUNT; MEAN; GEOMETRIC_MEAN; POPULATION_VARIANCE; PRODUCT; SUM_LOG; SUM_SQ; VARIANCE; KURTOSIS; SKEWNESS; STANDARD_DEVIATION;

    .PARAMETER Description
    Optional description of the Metric (may not exceed 255 characters).

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new Metric. Do not pass [ANOWTag] objects here.

    .PARAMETER Folder
    Optional name of the folder to place the Metric into.

    .PARAMETER CodeRepository
    Optional name of the code repository to place the Metric into.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWMetric.

    .OUTPUTS
    An [ANOWMetric] object representing the newly created Metric

    .EXAMPLE
    New-AutomateNOWMetric -Id 'Metric01' -Description 'Description01' -Tags 'Tag01' -Folder 'Folder01' -CodeRepository 'Repository01'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The name (id) of the Metric must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    #>
    [OutputType([ANOWMetric])]
    [Cmdletbinding()]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $true)]
        [string]$Id,
        [Parameter(Mandatory = $false)]
        [ANOWResource_statisticFunction]$CompositeFunction,
        [ValidateScript({ $_.Length -le 255 })]
        [Parameter(Mandatory = $false, HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [string]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [boolean]$Metric_exists = ($null -ne (Get-AutomateNOWMetric -Id $Id))
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWMetric failed to check if the Metric [$Id] already existed due to [$Message]."
        Break
    }
    If ($Metric_exists -eq $true) {
        [string]$current_domain = $anow_session.header.domain
        Write-Warning -Message "There is already a Metric named [$Id] in [$current_domain]. Please check into this."
        Break
    }
    ## End warning ##
    [System.Collections.Specialized.OrderedDictionary]$ANOWMetric = [System.Collections.Specialized.OrderedDictionary]@{}
    $ANOWMetric.Add('id', $Id)
    If ($CompositeFunction.Length -gt 0) {
        $ANOWMetric.Add('composite', 'true')
        $ANOWMetric.Add('statisticFunction', $CompositeFunction)
    }
    If ($Description.Length -gt 0) {
        $ANOWMetric.Add('description', $Description)
    }
    If ($Tags.Count -gt 0) {
        [int32]$total_tags = $Tags.Count
        [int32]$current_tag = 1
        ForEach ($tag_id in $Tags) {
            $Error.Clear()
            Try {
                [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] running under New-AutomateNOWMetric due to [$message]"
                Break
            }
            If ($tag_object.simpleId.length -eq 0) {
                Throw "New-AutomateNOWMetric has detected that the tag [$tag_id] does not appear to exist. Please check again."
                Break
            }
            ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                [string]$tag_object_simpleId = $tag_object.simpleId
                Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                Break
            }
            [string]$tag_display = $tag_object | ConvertTo-Json -Compress
            Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
            [string]$tag_name_sequence = ('tags' + $current_tag)
            $ANOWMetric.Add($tag_name_sequence, $tag_id)
            $include_properties += $tag_name_sequence
            $current_tag++
        }
    }
    If ($Folder.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] existed under New-AutomateNOWMetric due to [$Message]"
            Break
        }
        If ($folder_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] under New-AutomateNOWMetric. Please check again."
            Break
        }
        [string]$folder_display = $folder_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding folder $folder_display to [ANOWMetric] [$Id]"
        $ANOWMetric.Add('folder', $Folder)
        $include_properties += 'folder'
    }
    If ($CodeRepository.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository] existed under New-AutomateNOWMetric due to [$Message]"
            Break
        }
        If ($code_repository_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository] under New-AutomateNOWMetric. Please check again."
            Break
        }
        [string]$code_repository_display = $code_repository_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding code repository $code_repository_display to [ANOWMetric] [$Id]"
        $ANOWMetric.Add('codeRepository', $CodeRepository)
        $include_properties += 'codeRepository'
    }
    $ANOWMetric.Add('title', 'Metric')
    $ANOWMetric.Add('icon', '[SKINIMG]/skin/guage.png')
    $oldvalues = ('{"title":"Metric","resourceType":"METRIC","icon":"[SKINIMG]/skin/guage.png"}')
    [string]$BodyObject = ConvertTo-QueryString -InputObject $ANOWMetric -IncludeProperties id, description, title, icon, tags, folder, codeRepository
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    $BodyMetaData.'resourceType' = 'METRIC'
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_operationType' = 'add'
    $BodyMetaData.'_oldValues' = $oldvalues
    $BodyMetaData.'_componentId' = 'ResourceCreateWindow_form'
    $BodyMetaData.'_dataSource' = 'ResourceDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$BodyMetaDataString = ConvertTo-QueryString -InputObject $BodyMetaData
    [string]$Body = ($BodyObject + '&' + $BodyMetaDataString)
    [string]$command = '/resource/create'
    [hashtable]$parameters = @{}
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('Body', $Body)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWMetric]$Metric = $results.response.data | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to parse the result of New-AutomateNOWMetric into an [ANOWMetric] object due to [$Message]."
        Break
    }
    If ($Metric.id.Length -eq 0) {
        Write-Warning -Message "Somehow the newly created [ANOWMetric] object is empty!"
        Break
    }
    If ($Quiet -ne $true) {
        Return $Metric
    }
}

Function Remove-AutomateNOWMetric {
    <#
    .SYNOPSIS
    Removes a Metric from an AutomateNOW! instance

    .DESCRIPTION
    Removes a Metric from an AutomateNOW! instance

    .PARAMETER Metric
    An [ANOWMetric] object representing the Metric to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWMetric] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Remove a single Metric by name

    Get-AutomateNOWMetric -Id 'Metric01' | Remove-AutomateNOWMetric

    .EXAMPLE
    Removes a series of Metric objects via input from the pipeline

    @( 'Metric01', 'Metric02', 'Metric03') | Get-AutomateNOWMetric | Remove-AutomateNOWMetric

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWMetric]$Metric,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/resource/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWMetric]$Metric = $_
        }
        [string]$Metric_id = $Metric.id
        If ($Metric_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Metric_id)")) -eq $true) {
            [string]$oldvalues = $Metric.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $Metric.id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'ResourceList'
            $BodyMetaData.'_dataSource' = 'ResourceDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Metric_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Metric [$Metric_id] successfully removed"
        }
    }
    End {

    }
}

Function Copy-AutomateNOWMetric {
    <#
    .SYNOPSIS
    Copies an Metric from an AutomateNOW! instance

    .DESCRIPTION
    Copies an Metric from an AutomateNOW! instance. AutomateNOW object id can never be changed, but we can copy the object to a new id and it will include all of the items therein.

    .PARAMETER Metric
    Mandatory [ANOWMetric] object to be copied.

    .PARAMETER NewId
    The name (Id) of the new Metric. The new Id must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    .PARAMETER UnsetDescription
    Optional switch that will ensure that the newly created Metric will not have a description set.

    .PARAMETER Description
    Optional description to set on the new Metric object. If you do not set this, the new Metric object will copy the Description of the source object.

    .PARAMETER UnsetFolder
    Optional switch that will ensure that the newly created Metric will not have a Folder set.

    .PARAMETER Folder
    Optional description to set a different folder on the new Metric object. If you do not set this, the new Metric object will use the same Folder of the source object.

    .PARAMETER UnsetTags
    Optional switch that will ensure that the newly created Metric will not have any Tags set.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the new Metric object. If you do not set this, the new Metric object will apply the same Tags of the source object.

    .PARAMETER Force
    Force the copy without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    ONLY [ANOWMetric] object is accepted. Pipeline support is intentionally unavailable.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Creates a copy of an Metric and changes the description (multi-line format)
    $Metric01 = Get-AutomateNOWMetric -Id 'Metric_01'
    Copy-AutomateNOWMetric -Metric $Metric01 -NewId 'Metric_01_production' -Description 'Metric 01 Production'

    .EXAMPLE
    Creates a copy of an Metric that omits the description (one-liner format)
    Copy-AutomateNOWMetric -Metric (Get-AutomateNOWMetric -Id 'Metric_01') -NewId 'Metric_01_production' -UnsetDescription -Tags 'Tag1', 'Tag2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWMetric]$Metric,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot set the Tags and unset them at the same time. Please choose one or the other. Tags from the source object will be carried over to the new object if you do not specify any tag-related parameters."
            Break
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$Metric_exists = ($null -ne (Get-AutomateNOWMetric -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWMetric failed to check if the Metric [$NewId] already existed due to [$Message]."
            Break
        }
        If ($Metric_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Metric named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End warning ##
        [string]$command = '/resource/copy'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            [string]$Metric_oldId = $Metric.id
            [string]$Metric_simpleId = $Metric.simpleId
            If ($Metric_oldId -eq $NewId) {
                Write-Warning -Message "The new id cannot be the same as the old id."
                Break
            }
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Copy the Metric $($Metric_simpleId) to $($NewId)?")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                If ($UnsetFolder -eq $True) {
                    $BodyMetaData.'folder' = $Null
                }
                ElseIf ($Folder.Length -gt 0) {
                    $BodyMetaData.'folder' = $Folder
                }
                Else {
                    If ($Metric.folder.Length -gt 0) {
                        $BodyMetaData.'folder' = $Metric.folder
                    }
                }
                If ($Tags.Count -gt 0) {
                    [int32]$tag_count = 1
                    ForEach ($tag in $Tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
                ElseIf ($UnsetTags -eq $true) {
                    $BodyMetaData.'tags' = $Null
                }
                Else {
                    If ($Metric.Tags -gt 0) {
                        [int32]$tag_count = 1
                        ForEach ($tag in $Metric.tags) {
                            $BodyMetaData.('tags' + $tag_count ) = $tag
                            $tag_count++
                        }
                    }
                }
                $BodyMetaData.'oldId' = $Metric_oldId
                $BodyMetaData.'domain' = $Metric.domain
                $BodyMetaData.'id' = $NewId
                If ($UnsetDescription -ne $true) {
                    If ($Description.Length -gt 0) {
                        $BodyMetaData.'description' = $Description
                    }
                    Else {
                        $BodyMetaData.'description' = $Metric.description
                    }
                }
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_operationId' = 'copy'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_dataSource' = 'ResourceDataSource'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties oldId, domain, NewId, description, folder, tags
                $parameters.Body = $Body
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Metric_oldId] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                $Error.Clear()
                Try {
                    [ANOWMetric]$NewMetric = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to create copied [ANOWMetric] object [$NewId] due to [$Message]."
                    Break
                }
                If ($NewMetric.id.Length -eq 0) {
                    Write-Warning -Message "Somehow the newly created (copied) [ANOWMetric] object [$NewId] is empty!"
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $NewMetric
                }
            }
        }
    }
    End {

    }
}

Function Rename-AutomateNOWMetric {
    <#
    .SYNOPSIS
    Renames a Metric on an AutomateNOW! instance

    .DESCRIPTION
    Performs a psuedo-rename operations of a Metric from an AutomateNOW! instance by copying it first and then deleting the source. This function merely combines Copy-AutomateNOWMetric and Remove-AutomateNOWMetric therefore it is to be considered destructive.

    .PARAMETER Metric
    An [ANOWMetric] object representing the Metric to be renamed.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the Metric. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER Force
    Force the renaming without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly renamed object.

    .INPUTS
    ONLY [ANOWMetric] objects are accepted. There is intentionally no support for the pipeline.

    .OUTPUTS
    The newly renamed [ANOWMetric] object will be returned.

    .EXAMPLE
    $Metric = Get-AutomateNOWMetric -Id 'Metric01'
    Rename-AutomateNOWMetric -Metric $Metric -NewId 'Metric_01'

    .EXAMPLE
    Rename-AutomateNOWMetric -Metric (Get-AutomateNOWMetric -Id 'Metric01') -NewId 'Metric_01'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    When renaming, you may only specify a different Id (name).

    This action will be blocked if any existing referrals are found on the object.
    #>
    [OutputType([ANOWMetric])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWMetric]$Metric,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin standard warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$new_Metric_exists = ($null -ne (Get-AutomateNOWMetric -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWMetric failed to check if the Metric [$NewId] already existed due to [$Message]."
            Break
        }
        If ($new_Metric_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Metric named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        #[string]$Metric_id = $Metric.id
        [string]$Metric_id = $Metric.simpleId
        $Error.Clear()
        Try {
            [boolean]$old_Metric_exists = ($null -ne (Get-AutomateNOWMetric -Id $Metric_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWMetric failed to check if the Metric [$Metric_id] already existed due to [$Message]."
            Break
        }
        If ($old_Metric_exists -eq $false) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not a Metric named [$Metric_id] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End standard warning ##
        ## Begin referrals warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [int32]$referrals_count = Find-AutomateNOWObjectReferral -Metric $Metric -Count | Select-Object -Expandproperty referrals
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Find-AutomateNOWObjectReferral failed to extract the referrals on Metric [$Metric_id] due to [$Message]."
            Break
        }
        If ($referrals_count -gt 0) {
            Write-Warning -Message "Unfortunately, you cannot rename a Metric that has referrals. This is because the rename is not actually renaming but copying anew and deleting the old. Please, use the Find-AutomateNOWObjectReferral function to identify referrals and remove them."
            Break
        }
        Else {
            Write-Verbose -Message "The Metric [$Metric_id] does not have any referrals. It is safe to proceed."
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Metric_id)")) -eq $true) {
                $Error.Clear()
                Try {
                    [ANOWMetric]$new_Metric = Copy-AutomateNOWMetric -Metric $Metric -NewId $NewId -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Copy-AutomateNOWMetric failed to create a new Metric [$NewId] as Part 1 of the renaming process due to [$Message]."
                    Break
                }
                If ($new_Metric.simpleId -eq $NewId) {
                    Write-Verbose -Message "Part 1: Metric [$Metric_id] successfully copied to [$NewId]"
                }
                Else {
                    Write-Warning -Message "Somehow the first phase (Copy-AutomateNOWMetric) failed. Please look into this."
                    Break
                }
                $Error.Clear()
                Try {
                    Remove-AutomateNOWMetric -Metric $Metric -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Remove-AutomateNOWMetric failed to remove [$Metric_id] as Part 2 of the renaming process due to [$Message]."
                    Break
                }
                Write-Verbose -Message "Part 2: Metric [$Metric_id] removed"
                Write-Verbose -Message "Task [$Metric_id] successfully renamed to [$NewId]"
                If ($Quiet -ne $true) {
                    Return $Metric
                }
            }
        }
        Else {
            Write-Warning -Message "No action was taken because either the source object didn't exist or the new object already existed"
        }
    }
    End {
    }
}

#endregion

#Region - Migrations (Exports)

Function Export-AutomateNOWMigration {
    <#
    .SYNOPSIS
    Exports an object using the Migration feature on an AutomateNOW! instance

    .DESCRIPTION
    Exports an object using the Migration feature on an AutomateNOW! instance

    .PARAMETER ScheduleTemplate
    [ANOWScheduleTemplate] object to export. Use Get-AutomateNOWScheduleTemplate to obtain these objects. This is an ALIAS parameter for the ProcessingTemplate parameter.

    .PARAMETER ProcessingTemplate
    [ANOWProcessingTemplate] object to export. Do not send a Schedule Template to this parameter. Use Get-AutomateNOWProcessingTemplate (or Get-AutomateNOWTaskTemplate, Get-AutomateNOWWorkflowTemplate, Get-AutomateNOWServiceManagerTemplate) to obtain these objects.

    .PARAMETER BusinessView
    [ANOWBusinessView] object to export. Use Get-AutomateNOWBusinessview to obtain these objects.

    .PARAMETER ResultMapping
    [ANOWResultMapping] object to export. Use Get-AutomateNOWResultMapping to obtain these objects.

    .PARAMETER Interface
    [ANOWIntegration] object to export. Use Get-AutomateNOWIntegration to obtain these objects.

    .PARAMETER ServerNode
    [ANOWServerNode] object to export. Use Get-AutomateNOWServerNode to obtain these objects.

    .PARAMETER ServerNodeGroup
    [ANOWServerNodeGroup] object to export. Use Get-AutomateNOWServerNodeGroup to obtain these objects.

    .PARAMETER Agent
    [ANOWAgent] object to export. Use Get-AutomateNOWAgent to obtain these objects.

    .PARAMETER Endpoint
    [ANOWEndpoint] object to export. Use Get-AutomateNOWEndpoint to obtain these objects.

    .PARAMETER Resource
    [ANOWResource] object to export. There are 9 types of resources (Calendar, Event, Lock, Metric, PhysicalResource, Semaphore, Stock, TimeWindow, Variable). Use the respective Get function to obtain the object. For example, use Get-AutomateNOWStock to obtain a Stock.

    .PARAMETER DataSource
    [ANOWDataSource] object to export. Use Get-AutomateNOWDataSource to obtain these objects.

    .PARAMETER Anomaly
    [ANOWAnomaly] object to export. Use Get-AutomateNOWAnomaly to obtain these objects.

    .PARAMETER Workspace
    [ANOWWorkspace] object to export. Use Get-AutomateNOWWorkspace to obtain these objects.

    .PARAMETER CodeRepository
    [ANOWcodeRepository] object to export. Use Get-AutomateNOWCodeRepository to obtain these objects.

    .PARAMETER Approval
    [ANOWApproval] object to export. Use Get-AutomateNOWApproval to obtain these objects.

    .PARAMETER NotificationGroup
    [ANOWNotificationGroup] object to export. Use Get-AutomateNOWNotificationGroup to obtain these objects.

    .PARAMETER NotificationChannel
    [ANOWNotificationChannel] object to export. Use Get-AutomateNOWNotificationChannel to obtain these objects.

    .PARAMETER NotificationMessageTemplate
    [ANOWNotificationMessageTemplate] object to export. Use Get-AutomateNOWNotificationMessageTemplate to obtain these objects.

    .PARAMETER Dashboard
    [ANOWDashboard] object to export. Use Get-AutomateNOWDashboard to obtain these objects.

    .PARAMETER AdhocReport
    [ANOWAdhocReport] object to export. Use Get-AutomateNOWAdhocReport to obtain these objects.

    .PARAMETER UserReport
    [ANOWUserReport] object to export. Use Get-AutomateNOWUserReport to obtain these objects.

    .PARAMETER RuntimeAction
    [ANOWProcessingAction] object to export. Use Get-AutomateNOWRuntimeAction to obtain these objects.

    .PARAMETER Tag
    [ANOWTag] object to export. Use Get-AutomateNOWTag to obtain these objects.

    .PARAMETER Folder
    [ANOWFolder] object to export. Use Get-AutomateNOWFolder to obtain these objects.

    .PARAMETER DesignTemplate
    [ANOWDesignTemplate] object to export. Use Get-AutomateNOWDesignTemplate to obtain these objects.

    .PARAMETER MenuCustomization
    [ANOWMenuCustomization] object to export. Use Get-AutomateNOWMenuCustomization to obtain these objects.

    .PARAMETER ViewSetup
    [ANOWViewSetup] object to export. Use Get-AutomateNOWViewSetup to obtain these objects.

    .PARAMETER SecUser
    [ANOWSecUser] object to export. Use Get-AutomateNOWSecUser to obtain these objects.

    .PARAMETER SecRole
    [ANOWSecRole] object to export. Use Get-AutomateNOWSecRole to obtain these objects.

    .PARAMETER ProcessingFunction
    [ANOWProcessingFunction] object to export. Use Get-AutomateNOWProcessingFunction to obtain these objects.

    .PARAMETER Domain
    [ANOWDomain] object to export. Use Get-AutomateNOWDomain to obtain these objects.

    .PARAMETER deepProcessingTemplateExport
    Switch parameter to enable 'Deep Processing Export' which provides 'Recursively include workflows' subitems definitions'

    .PARAMETER includeProcessingServerNodes
    Switch parameter to enable 'Include Processing Server Nodes' which provides 'Include items Server Nodes definitions'

    .PARAMETER includeProcessingResultMapping
    Switch parameter to enable 'Include Processing Result Mapping' which provides 'Include items Result Mapping definitions'

    .PARAMETER includeVersionControlHistory
    Switch parameter to enable 'Include Version Control' which provides 'Include version control history data'

    .PARAMETER includeDocumentation
    Switch parameter to enable 'Include Documentation' which provides 'Include items' documentation'

    .PARAMETER deepWorkspaceExport
    Switch parameter to enable 'Deep Workspace Export' which provides 'Include all processing templates belonging to selected workspaces'

    .PARAMETER deepBusinessViewExport
    Switch parameter to enable 'Deep Business View Export' which provides 'Include all items belonging to selected business views'

    .PARAMETER deepServerNodeExport
    Switch parameter to enable 'Deep Server Node Export' which provides 'Export Agents, Nodes and Load Balancers with all their subitems'

    .PARAMETER deepResourceExport
    Switch parameter to enable 'Deep Resource Export' which provides 'Include values and time-index states'

    .PARAMETER ManualFilename
    Optional manual filename for the export. Only use this if you do not want to use the automatically generated filename provided by the ANOW API. Do not combine this parameter with -DoNotIncludeObjectTypeInFileName.

    .PARAMETER DestinationFilepath
    Optional path for the outgoing exported file to be written to. Use this if you want the exported JSON file to be written somewhere other than the current path.

    .PARAMETER OverwriteExportFile
    Switch parameter that will force the exported file to be overwritten if it exists

    .PARAMETER DoNotIncludeObjectTypeInFileName
    Switch parameter that will prevent the type of object from being included in the automatically generated filename. Use this switch when you want the filename to appear exactly the same as it would from the console. This parameter may not be combined with -ManualFilename.

    .INPUTS
    Accepts the following types of ANOW objects: Anomaly, Approval, BusinessView, Calendar, Dashboard, Endpoint, Event, Interface, Lock, Metric, NotificationMessageTemplate, PhysicalResource, ResultMapping, ScheduleTemplate, Semaphore, ServerNode, ServiceManagerTemplate, Stock, TaskTemplate, TimeWindow, UserReport, Variable, WorkflowTemplate, Workspace

    .OUTPUTS
    A .json file will be written to disk. This is byte-for-byte identical the output received from the ANOW console.

    .EXAMPLE
    Exports the first page of Schedule Templates (one-liner format)

    Get-AutomateNOWScheduleTemplate | Export-AutomateNOWMigration

    .EXAMPLE
    Exports the first page of Processing Templates. That means Task Templates, Workflow Templates and ServiceManager Templates. (one-liner format)

    Get-AutomateNOWProcessingTemplate | Export-AutomateNOWMigration

    .EXAMPLE
    Exports the first page of Resource objects that have a Tag named 'Tag1' (one-liner format)

    Get-AutomateNOWResourceList -Tags 'Tag1' | Export-AutomateNOWMigration

    .EXAMPLE
    Exports three resources (a Metric, a Stock and a Lock) named 'Metric1', 'Stock1', 'Lock1' (one-liner format)

    'Metric1', 'Stock1', 'Lock1' | Get-AutomateNOWResourceList | Export-AutomateNOWMigration

    .EXAMPLE
    Exports a Workspace named 'Workspace1' (multi-line format)

    $workspace = Get-AutomateNOWWorkspace -Id 'Workspace1'
    Export-AutomateNOWMigration -Workspace $workspace

    .EXAMPLE
    Exports a Workspace named 'Workspace1' (one-liner format)

    Get-AutomateNOWWorkspace -Id 'Workspace1' | Export-AutomateNOWMigration

    .EXAMPLE
    Exports two Runtime Actions by their Id (one-liner format)
    '823fd7ea-3106-40f7-acd3-f33cdd26b7e4','c7558d17-34ee-47a0-9737-648bb6912356' | Get-AutomateNOWRuntimeAction | Export-AutomateNOWMigration

    .EXAMPLE
    Exports a single Runtime Action by its simpleId (multi-line format)

    $runtime_action = Get-AutomateNOWRuntimeAction -simpleId 'RuntimeAction1'
    $runtime_action | Export-AutomateNOWMigration

    .EXAMPLE
    Exports the first page for all 31 types of objects. Note that Schedule Templates are included with Processing Templates

    Get-AutomateNOWAdhocReport | Export-AutomateNOWMigration
    Get-AutomateNOWAgent | Export-AutomateNOWMigration
    Get-AutomateNOWAnomaly | Export-AutomateNOWMigration
    Get-AutomateNOWApproval | Export-AutomateNOWMigration
    Get-AutomateNOWBusinessView | Export-AutomateNOWMigration
    Get-AutomateNOWCodeRepository | Export-AutomateNOWMigration
    Get-AutomateNOWDashboard | Export-AutomateNOWMigration
    Get-AutomateNOWDataSource | Export-AutomateNOWMigration
    Get-AutomateNOWDesignTemplate | Export-AutomateNOWMigration
    Get-AutomateNOWDomain | Export-AutomateNOWMigration                      # --> requires full admin
    Get-AutomateNOWEndpoint | Export-AutomateNOWMigration
    Get-AutomateNOWFolder | Export-AutomateNOWMigration
    Get-AutomateNOWInterface | Export-AutomateNOWMigration
    Get-AutomateNOWMenuCustomization | Export-AutomateNOWMigration
    Get-AutomateNOWNotificationChannel | Export-AutomateNOWMigration
    Get-AutomateNOWNotificationGroup | Export-AutomateNOWMigration
    Get-AutomateNOWNotificationMessageTemplate | Export-AutomateNOWMigration
    Get-AutomateNOWRuntimeAction | Export-AutomateNOWMigration
    Get-AutomateNOWProcessingFunction | Export-AutomateNOWMigration          # --> requires full admin
    Get-AutomateNOWProcessingTemplate | Export-AutomateNOWMigration
    Get-AutomateNOWCalendar | Export-AutomateNOWMigration
    Get-AutomateNOWResultMapping | Export-AutomateNOWMigration
    Get-AutomateNOWScheduleTemplate | Export-AutomateNOWMigration
    Get-AutomateNOWSecUser | Export-AutomateNOWMigration                     # --> requires full admin
    Get-AutomateNOWSecurityRole | Export-AutomateNOWMigration                # --> requires full admin
    Get-AutomateNOWServerNode | Export-AutomateNOWMigration
    Get-AutomateNOWServerNodeGroup | Export-AutomateNOWMigration
    Get-AutomateNOWTag | Export-AutomateNOWMigration
    Get-AutomateNOWUserReport | Export-AutomateNOWMigration
    Get-AutomateNOWWorkspace | Export-AutomateNOWMigration
    Get-AutomateNOWViewSetup | Export-AutomateNOWMigration

    .EXAMPLE
    Exports a Workflow Template named 'WorkflowTemplate1' with version control history.

    Get-AutomateNOWWorkflowTemplate -Id 'WorkflowTemplate1' | Export-AutomateNOWMigration -includeVersionControlHistory

    .EXAMPLE
    Exports a Workflow Template named 'WorkflowTemplate1' with all extra options enabled (not recommended)

    Get-AutomateNOWWorkflowTemplate -Id 'WorkflowTemplate1' | Export-AutomateNOWMigration -deepProcessingTemplateExport -includeProcessingServerNodes -includeProcessingResultMapping -includeVersionControlHistory -includeDocumentation -deepWorkspaceExport -deepBusinessViewExport -deepServerNodeExport -deepResourceExport

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The -ScheduleTemplate parameter is an alias for the -ProcessingTemplate parameter.

    Verbose mode will include a one-line message containing the names of all exported objects.

    Some object types require full admin rights to export (domain admin rights will not be sufficient).

    This is the only function needed to handle Exports in the Migration tab.

    #>
    [Cmdletbinding()]
    Param(
        [Alias('ScheduleTemplate')]
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'ProcessingTemplate')] # Processing Templates
        [ANOWProcessingTemplate]$ProcessingTemplate,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'BusinessView')] # Business Views
        [ANOWBusinessView]$BusinessView,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'ResultMapping')] # Result Mappings
        [ANOWResultMapping]$ResultMapping,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Integration')] # Integrations
        [ANOWIntegration]$Integration,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'ServerNode')] # Server Nodes
        [ANOWServerNode]$ServerNode,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'ServerNodeGroup')] # Server Node Groups
        [ANOWServerNodeGroup]$ServerNodeGroup,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Agent')] # Agents
        [ANOWAgent]$Agent,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Endpoint')] # Endpoints
        [ANOWEndpoint]$Endpoint,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Resource')] # Resources
        [ANOWResource]$Resource,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'DataSource')] # DataSources
        [ANOWDataSource]$DataSource,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Anomaly')] # Anomalies
        [ANOWAnomaly]$Anomaly,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Workspace')] # Workspaces
        [ANOWWorkspace]$Workspace,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'CodeRepository')] # Code Repositories
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Approval')] # Approvals
        [ANOWApproval]$Approval,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'NotificationGroup')] # Notification Groups
        [ANOWNotificationGroup]$NotificationGroup,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'NotificationChannel')] # Notification Channels
        [ANOWNotificationChannel]$NotificationChannel,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'NotificationMessageTemplate')] # Notification Templates
        [ANOWNotificationMessageTemplate]$NotificationMessageTemplate,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Dashboard')] # Dashboards
        [ANOWDashboard]$Dashboard,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'AdhocReport')] # Adhoc Reports
        [ANOWAdhocReport]$AdhocReport,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'UserReport')] # User Reports
        [ANOWUserReport]$UserReport,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'RuntimeAction')] # Runtime Actions
        [ANOWProcessingAction]$RuntimeAction,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Tag')] # Tags
        [ANOWTag]$Tag,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Folder')] # Folders
        [ANOWFolder]$Folder,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'DesignTemplate')] # Design Templates
        [ANOWDesignTemplate]$DesignTemplate,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'MenuCustomization')] # Menu Customizations
        [ANOWMenuCustomization]$MenuCustomization,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'ViewSetup')] # View Setups
        [ANOWViewSetup]$ViewSetup,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'SecUser')] # Sec Users
        [ANOWSecUser]$SecUser,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'SecRole')] # Sec Roles
        [ANOWSecRole]$SecRole,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'ProcessingFunction')] # Processing Functions
        [ANOWProcessingFunction]$ProcessingFunction,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Domain')] # Domains
        [ANOWDomain]$Domain,
        [Parameter(Mandatory = $false)]
        [switch]$deepProcessingTemplateExport,
        [Parameter(Mandatory = $false)]
        [switch]$includeProcessingServerNodes,
        [Parameter(Mandatory = $false)]
        [switch]$includeProcessingResultMapping,
        [Parameter(Mandatory = $false)]
        [switch]$includeVersionControlHistory,
        [Parameter(Mandatory = $false)]
        [switch]$includeDocumentation,
        [Parameter(Mandatory = $false)]
        [switch]$deepWorkspaceExport,
        [Parameter(Mandatory = $false)]
        [switch]$deepBusinessViewExport,
        [Parameter(Mandatory = $false)]
        [switch]$deepServerNodeExport,
        [Parameter(Mandatory = $false)]
        [switch]$deepResourceExport,
        [Parameter(Mandatory = $false)]
        [string]$ManualFilename,
        [ValidateScript({ (Test-Path -Path "$_") -eq $true })]
        [Parameter(Mandatory = $false)]
        [string]$DestinationPath,
        [Parameter(Mandatory = $false)]
        [boolean]$OverwriteExportFile,
        [Parameter(Mandatory = $false)]
        [switch]$DoNotIncludeObjectTypeInFileName
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($DoNotIncludeObjectTypeInFileName -eq $true -and $ManualFilename.Length -gt 0) {
            Write-Warning -Message "Please do not combine with -DoNotIncludeObjectTypeInFileName with -ManualFilename"
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        [string]$ContentType = 'application/x-www-form-urlencoded; charset=UTF-8'
        $parameters.Add('ContentType', $ContentType)
        $parameters.Add('NoHeaders', $true)
        $parameters.Add('JustGiveMeJSON', $true)
        If ($ManualFilename.Length -eq 0) {
            $parameters.Add('IncludeAttachmentFilename', $true)
        }
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
        If ($anow_session.current_domain.Length -eq 0) {
            Write-Warning -Message "Somehow the current ANOW domain could not be determined."
            Break
        }
        If ($anow_session.AccessToken.Length -eq 0) {
            Write-Warning -Message 'Somehow the current ANOW access token could not be determined. Unlike other functions, Export-AutomateNOWMigration requires the access token to be included in the body payload as well.'
            Break
        }
        If ($DestinationPath.Length -gt 0) {
            If ($DestinationPath[-1] -in @('/', '\')) {
                Write-Warning -Message "Please do not include any trailing slashes in the destination path."
                Break
            }
        }
        [System.Collections.ArrayList]$ObjectList = New-Object -TypeName System.Collections.ArrayList
    }
    Process {
        If ($_ -is [ANOWScheduleTemplate] -or $ProcessingTemplate.processingType -eq 'TRIGGER') {
            [string]$ObjectType = 'ProcessingTemplate'
            [boolean]$IsScheduleTemplate = $true
            If ($ProcessingTemplate.id.Length -gt 0) {
                [string]$ObjectId = $ProcessingTemplate.id
            }
            Else {
                [string]$ObjectId = $_.id
            }
            [void]$ObjectList.Add($ObjectId)
        }
        ElseIf ($_ -is [ANOWProcessingTemplate] -or $ProcessingTemplate.Id.Length -gt 0) {
            [string]$ObjectType = 'ProcessingTemplate'
            If ($ProcessingTemplate.id.Length -gt 0) {
                [string]$ObjectId = $ProcessingTemplate.id
            }
            Else {
                [string]$ObjectId = $_.id
            }
            [void]$ObjectList.Add($ObjectId)
        }
        ElseIf ($_ -is [ANOWBusinessView] -or $BusinessView.Id.Length -gt 0) {
            [string]$ObjectType = 'BusinessView'
            If ($ResultMapping.id.Length -gt 0) {
                [string]$ObjectId = $BusinessView.id
            }
            Else {
                [string]$ObjectId = $_.id
            }
            [void]$ObjectList.Add($ObjectId)
        }
        ElseIf ($_ -is [ANOWResultMapping] -or $ResultMapping.Id.Length -gt 0) {
            [string]$ObjectType = 'ResultMapping'
            If ($ResultMapping.id.Length -gt 0) {
                [string]$ObjectId = $ResultMapping.id
            }
            Else {
                [string]$ObjectId = $_.id
            }
            [void]$ObjectList.Add($ObjectId)
        }
        ElseIf ($_ -is [ANOWIntegration] -or $Integration.Id.Length -gt 0) {
            [string]$ObjectType = 'Integration'
            If ($Integration.id.Length -gt 0) {
                [string]$ObjectId = $Integration.id
            }
            Else {
                [string]$ObjectId = $_.id
            }
            [void]$ObjectList.Add($ObjectId)
        }
        ElseIf ($_ -is [ANOWServerNode] -or $ServerNode.Id.Length -gt 0) {
            [string]$ObjectType = 'ServerNode'
            If ($ServerNode.id.Length -gt 0) {
                [string]$ObjectId = $ServerNode.id
            }
            Else {
                [string]$ObjectId = $_.id
            }
            [void]$ObjectList.Add($ObjectId)
        }
        ElseIf ($_ -is [ANOWServerNodeGroup] -or $?.Id.Length -gt 0) {
            [string]$ObjectType = 'ServerNodeGroup'
            If ($ServerNodeGroup.id.Length -gt 0) {
                [string]$ObjectId = $ServerNodeGroup.id
            }
            Else {
                [string]$ObjectId = $_.id
            }
            [void]$ObjectList.Add($ObjectId)
        }
        ElseIf ($_ -is [ANOWAgent] -or $Agent.Id.Length -gt 0) {
            [string]$ObjectType = 'Agent'
            If ($Agent.id.Length -gt 0) {
                [string]$ObjectId = $Agent.id
            }
            Else {
                [string]$ObjectId = $_.id
            }
            [void]$ObjectList.Add($ObjectId)
        }
        ElseIf ($_ -is [ANOWEndpoint] -or $Endpoint.Id.Length -gt 0) {
            [string]$ObjectType = 'Endpoint'
            If ($Endpoint.id.Length -gt 0) {
                [string]$ObjectId = $Endpoint.id
            }
            Else {
                [string]$ObjectId = $_.id
            }
            [void]$ObjectList.Add($ObjectId)
        }
        ElseIf ($_ -is [ANOWResource] -or $Resource.Id.Length -gt 0) {
            [string]$ObjectType = 'Resource'
            If ($Resource.id.Length -gt 0) {
                [string]$ObjectId = $Resource.id
            }
            Else {
                [string]$ObjectId = $_.id
            }
            [void]$ObjectList.Add($ObjectId)
        }
        ElseIf ($_ -is [ANOWDataSource] -or $DataSource.Id.Length -gt 0) {
            [string]$ObjectType = 'DataSource'
            If ($DataSource.id.Length -gt 0) {
                [string]$ObjectId = $DataSource.id
            }
            Else {
                [string]$ObjectId = $_.id
            }
            [void]$ObjectList.Add($ObjectId)
        }
        ElseIf ($_ -is [ANOWAnomaly] -or $Anomaly.Id.Length -gt 0) {
            [string]$ObjectType = 'Anomaly'
            If ($Anomaly.id.Length -gt 0) {
                [string]$ObjectId = $Anomaly.id
            }
            Else {
                [string]$ObjectId = $_.id
            }
            [void]$ObjectList.Add($ObjectId)
        }
        ElseIf ($_ -is [ANOWWorkspace] -or $Workspace.Id.Length -gt 0) {
            [string]$ObjectType = 'Workspace'
            If ($Workspace.id.Length -gt 0) {
                [string]$ObjectId = $Workspace.id
            }
            Else {
                [string]$ObjectId = $_.id
            }
            [void]$ObjectList.Add($ObjectId)
        }
        ElseIf ($_ -is [ANOWCodeRepository] -or $CodeRepository.Id.Length -gt 0) {
            [string]$ObjectType = 'CodeRepository'
            If ($CodeRepository.id.Length -gt 0) {
                [string]$ObjectId = $CodeRepository.id
            }
            Else {
                [string]$ObjectId = $_.id
            }
            [void]$ObjectList.Add($ObjectId)
        }
        ElseIf ($_ -is [ANOWApproval] -or $Approval.Id.Length -gt 0) {
            [string]$ObjectType = 'ApprovalConfiguration'
            If ($Approval.id.Length -gt 0) {
                [string]$ObjectId = $Approval.id
            }
            Else {
                [string]$ObjectId = $_.id
            }
            [void]$ObjectList.Add($ObjectId)
        }
        ElseIf ($_ -is [ANOWNotificationGroup] -or $NotificationGroup.Id.Length -gt 0) {
            [string]$ObjectType = 'NotificationGroup'
            If ($NotificationGroup.id.Length -gt 0) {
                [string]$ObjectId = $NotificationGroup.id
            }
            Else {
                [string]$ObjectId = $_.id
            }
            [void]$ObjectList.Add($ObjectId)
        }
        ElseIf ($_ -is [ANOWNotificationChannel] -or $NotificationChannel.Id.Length -gt 0) {
            [string]$ObjectType = 'NotificationChannel'
            If ($NotificationChannel.id.Length -gt 0) {
                [string]$ObjectId = $NotificationChannel.id
            }
            Else {
                [string]$ObjectId = $_.id
            }
            [void]$ObjectList.Add($ObjectId)
        }
        ElseIf ($_ -is [ANOWNotificationMessageTemplate] -or $NotificationMessageTemplate.Id.Length -gt 0) {
            [string]$ObjectType = 'NotificationMessageTemplate'
            If ($NotificationMessageTemplate.id.Length -gt 0) {
                [string]$ObjectId = $NotificationMessageTemplate.id
            }
            Else {
                [string]$ObjectId = $_.id
            }
            [void]$ObjectList.Add($ObjectId)
        }
        ElseIf ($_ -is [ANOWDashboard] -or $Dashboard.Id.Length -gt 0) {
            [string]$ObjectType = 'Dashboard'
            If ($Dashboard.id.Length -gt 0) {
                [string]$ObjectId = $Dashboard.id
            }
            Else {
                [string]$ObjectId = $_.id
            }
            [void]$ObjectList.Add($ObjectId)
        }
        ElseIf ($_ -is [ANOWAdhocReport] -or $AdhocReport.Id.Length -gt 0) {
            [string]$ObjectType = 'AdhocReport'
            If ($AdhocReport.id.Length -gt 0) {
                [string]$ObjectId = $AdhocReport.id
            }
            Else {
                [string]$ObjectId = $_.id
            }
            [void]$ObjectList.Add($ObjectId)
        }
        ElseIf ($_ -is [ANOWUserReport] -or $UserReport.Id.Length -gt 0) {
            [string]$ObjectType = 'UserReport'
            If ($UserReport.id.Length -gt 0) {
                [string]$ObjectId = $UserReport.id
            }
            Else {
                [string]$ObjectId = $_.id
            }
            [void]$ObjectList.Add($ObjectId)
        }
        ElseIf ($_ -is [ANOWProcessingAction] -or $RuntimeAction.Id.Length -gt 0) {
            [string]$ObjectType = 'ProcessingAction'
            If ($RuntimeAction.id.Length -gt 0) {
                [string]$ObjectId = $RuntimeAction.id
            }
            Else {
                [string]$ObjectId = $_.id
            }
            [void]$ObjectList.Add($ObjectId)
        }
        ElseIf ($_ -is [ANOWTag] -or $Tag.Id.Length -gt 0) {
            [string]$ObjectType = 'Tag'
            If ($Tag.id.Length -gt 0) {
                [string]$ObjectId = $Tag.id
            }
            Else {
                [string]$ObjectId = $_.id
            }
            [void]$ObjectList.Add($ObjectId)
        }
        ElseIf ($_ -is [ANOWFolder] -or $Folder.Id.Length -gt 0) {
            [string]$ObjectType = 'Folder'
            If ($Folder.id.Length -gt 0) {
                [string]$ObjectId = $Folder.id
            }
            Else {
                [string]$ObjectId = $_.id
            }
            [void]$ObjectList.Add($ObjectId)
        }
        ElseIf ($_ -is [ANOWDesignTemplate] -or $DesignTemplate.Id.Length -gt 0) {
            [string]$ObjectType = 'DesignTemplate'
            If ($DesignTemplate.id.Length -gt 0) {
                [string]$ObjectId = $DesignTemplate.id
            }
            Else {
                [string]$ObjectId = $_.id
            }
            [void]$ObjectList.Add($ObjectId)
        }
        ElseIf ($_ -is [ANOWMenuCustomization] -or $MenuCustomization.Id.Length -gt 0) {
            [string]$ObjectType = 'DomainProcessingType'
            If ($MenuCustomization.id.Length -gt 0) {
                [string]$ObjectId = $MenuCustomization.id
            }
            Else {
                [string]$ObjectId = $_.id
            }
            [void]$ObjectList.Add($ObjectId)
        }
        ElseIf ($_ -is [ANOWViewSetup] -or $ViewSetup.Id.Length -gt 0) {
            [string]$ObjectType = 'ViewSetup'
            If ($ViewSetup.id.Length -gt 0) {
                [string]$ObjectId = $ViewSetup.id
            }
            Else {
                [string]$ObjectId = $_.id
            }
            [void]$ObjectList.Add($ObjectId)
        }
        ElseIf ($_ -is [ANOWSecUser] -or $SecUser.Id.Length -gt 0) {
            [string]$ObjectType = 'SecUser'
            If ($SecUser.id.Length -gt 0) {
                [string]$ObjectId = $SecUser.id
            }
            Else {
                [string]$ObjectId = $_.id
            }
            [void]$ObjectList.Add($ObjectId)
        }
        ElseIf ($_ -is [ANOWSecRole] -or $SecRole.Id.Length -gt 0) {
            [string]$ObjectType = 'SecRole'
            If ($SecRole.id.Length -gt 0) {
                [string]$ObjectId = $SecRole.id
            }
            Else {
                [string]$ObjectId = $_.id
            }
            [void]$ObjectList.Add($ObjectId)
        }
        ElseIf ($_ -is [ANOWProcessingFunction] -or $ProcessingFunction.Id.Length -gt 0) {
            [string]$ObjectType = 'ProcessingFunction'
            If ($ProcessingFunction.id.Length -gt 0) {
                [string]$ObjectId = $ProcessingFunction.id
            }
            Else {
                [string]$ObjectId = $_.id
            }
            [void]$ObjectList.Add($ObjectId)
        }
        ElseIf ($_ -is [ANOWDomain] -or $Domain.Id.Length -gt 0) {
            [string]$ObjectType = 'Domain'
            If ($Domain.id.Length -gt 0) {
                [string]$ObjectId = $Domain.id
            }
            Else {
                [string]$ObjectId = $_.id
            }
            [void]$ObjectList.Add($ObjectId)
        }
        Else {
            Write-Warning -Message "Unable to determine input object. Please specify a supported object type. See the in-line help for more information."
            Break
        }
    }
    End {
        [int32]$ObjectListCount = $ObjectList.Count
        If ($ObjectListCount -eq 0) {
            Write-Warning -Message "There are zero objects to export. Please check what happened."
            Break
        }
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        [string]$ObjectListString = $ObjectList -join ','
        $Body.$ObjectType = $ObjectListString
        $Body.'domain' = $anow_session.current_domain
        $Body.'access_token' = $anow_session.AccessToken
        If ($deepProcessingTemplateExport -eq $true) {
            $Body.'deepProcessingTemplateExport' = 'true'
        }
        If ($includeProcessingServerNodes -eq $true) {
            $Body.'includeProcessingServerNodes' = 'true'
        }
        If ($includeProcessingResultMapping -eq $true) {
            $Body.'includeProcessingResultMapping' = 'true'
        }
        If ($includeVersionControlHistory -eq $true) {
            $Body.'includeVersionControlHistory' = 'true'
        }
        If ($includeDocumentation -eq $true) {
            $Body.'includeDocumentation' = 'true'
        }
        If ($deepWorkspaceExport -eq $true) {
            $Body.'deepWorkspaceExport' = 'true'
        }
        If ($deepBusinessViewExport -eq $true) {
            $Body.'deepBusinessViewExport' = 'true'
        }
        If ($deepServerNodeExport -eq $true) {
            $Body.'deepServerNodeExport' = 'true'
        }
        If ($deepResourceExport -eq $true) {
            $Body.'deepResourceExport' = 'true'
        }
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/migration/exportSelected')
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        If ($null -eq $parameters["Body"]) {
            $parameters.Add('Body', $Body)
        }
        Else {
            $parameters.Body = $Body
        }
        $Error.Clear()
        Try {
            If ($ManualFilename.Length -gt 0) {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                If ($results -match '^\{.{1,}\}$') {
                    Write-Warning -Message "Exporting $ObjectType ($ObjectListString) failed due to $results"
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
            }
            Else {
                [PSCustomObject[]]$initial_results = Invoke-AutomateNOWAPI @parameters
                [PSCustomObject]$results = $initial_results | Select-Object -Skip 0 -First 1
                If ($results -match '^\{.{1,}\}$') {
                    Write-Warning -Message "Exporting $ObjectType ($ObjectListString) failed due to $results"
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                [string]$outgoing_filename = $initial_results | Select-Object -Skip 1 -First 1
                If ($DoNotIncludeObjectTypeInFileName -ne $true) {
                    [array]$underscore_matches = $outgoing_filename | Select-String '_' -AllMatches | ForEach-Object { $_.matches }
                    If ($underscore_matches.count -ne 8) {
                        Write-Warning -Message "Somehow the automatic filename generation failed (under Export-AutomateNOWMigration)"
                        Break
                    }
                    [int32]$index_location = $underscore_matches | Select-Object -First 1 -Skip 2 | Select-Object -ExpandProperty index
                    If ($ObjectType -eq 'ProcessingTemplate' -and $IsScheduleTemplate -eq $true) {
                        [string]$ObjectType = 'ScheduleTemplate'
                    }
                    [string]$outgoing_filename = $outgoing_filename.Insert(($index_location + 1), ( $ObjectType + '_'))
                    [string]$random_string = (Get-Random -Minimum 0 -Maximum 1000).ToString("000")
                    [string]$outgoing_filename = $outgoing_filename -replace '\.json', "_$random_string.json"
                }
            }
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] while running Export-AutomateNOWMigration due to [$Message]."
            Break
        }
        If ($ManualFilename.Length -gt 0) {
            [string]$outgoing_filename = $ManualFilename
        }
        If ($outgoing_filename.Length -eq 0) {
            Write-Warning -Message "Somehow the outgoing filename is empty. Please look into how this happened."
            Break
        }
        Else {
            Write-Verbose -Message "Received filename from the ANOW API for the export: $outgoing_filename"
        }
        If ($DestinationPath.Length -eq 0) {
            $DestinationPath = '.'
        }
        [string]$ExportFilePath = Join-Path -Path $DestinationPath -ChildPath $outgoing_filename
        [boolean]$outgoing_file_exists = Test-Path -Path "$ExportFilePath"
        If ($outgoing_file_exists -eq $true -and $OverwriteExportFile -ne $true) {
            Write-Warning -Message "The export file $outgoing_filename already exists at $DestinationPath. Use the -OverwriteExportFile switch parameter to bypass this exception and overwrite the file."
            Break
        }
        $Error.Clear()
        $parameters = @{}
        $parameters.Add('InputObject', $results)
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('NoNewLine', $true)
        If ($OverwriteExportFile -eq $true) {
            $parameters.Add('Force', $true)
        }
        Try {
            Out-File @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Out-File failed to write the outgoing file [$outgoing_filename] to disk under Export-AutomateNOWMigration due to [$Message]."
            Break
        }
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "[$ObjectListCount] objects of type [$ObjectType] were exported to: $outgoing_filename ($filelength_display bytes)"
            Write-Verbose -Message "The list of object names that were exported: $ObjectListString"
        }
    }
}

#endregion

#Region - Migrations (Imports)

Function Get-AutomateNOWMigrationImport {
    <#
    .SYNOPSIS
    Gets the Migration Import requests within an AutomateNOW! instance

    .DESCRIPTION
    Gets the Migration Import requests within an AutomateNOW! instance. This is the list of previous Migration Import requests.

    .PARAMETER Id
    Optional string to retrieve a specific Migration Import by its specific 36-character GUID. This is the ONLY way to retrieve the "Import Summary" of the operation.

    .PARAMETER startRow
    Integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .INPUTS
    You can specify the 36-character GUID of the Migration Import with the -Id parameter or you can supply -startRow and -endRow.

    .OUTPUTS
    An array of one or more [ANOWMigrationImport] class objects

    .EXAMPLE
    Fetches the first page of Migration Import requests

    Get-AutomateNOWMigrationImport

    .EXAMPLE
    Fetches the first page of Migration Import requests WITH their Import Summary

    Get-AutomateNOWMigrationImport | Select-Object -ExpandProperty Id | ForEach-Object { Get-AutomateNOWMigrationImport -Id $_ }

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    To receive the full "Import Summary" of each Import request, you must fetch them individually with the -Id parameters. See the Examples.

    #>
    #[OutputType([ANOWMigrationImport[]])]
    [Cmdletbinding(DefaultParameterSetName = 'Default')]
    Param(
        [ValidateScript({ $_ -match '[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}' })]
        [Parameter(Mandatory = $False, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 -or $Id.Length -gt 0) {
            If ($_.Length -gt 0 ) {
                $Body.'id' = $_
            }
            Else {
                $Body.'id' = $Id
            }
            [string]$textMatchStyle = 'exactCase'
            $Body.'_operationId' = 'get'
            [string]$api_command = 'get'
        }
        Else {
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
            [string]$textMatchStyle = 'exact'
            $Body.'_componentId' = 'DesignImportOperationList'
            [string]$api_command = 'read'
        }
        $Body.'_textMatchStyle' = $textMatchStyle
        $Body.'_dataSource' = 'DesignImportOperationDataSource'
        $Body.'_operationType' = 'fetch'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/designImportOperation/' + $api_command + '?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] while running Get-AutomateNOWApproval due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWMigrationImport[]]$import_requests = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWMigrationImport] objects due to [$Message]."
            Break
        }
        If ($import_requests.Count -gt 0) {
            Return $import_requests
        }
    }
    End {

    }
}

Function New-AutomateNOWMigrationImport {
    <#
    .SYNOPSIS
    Creates a Migration Import within an AutomateNOW! instance

    .DESCRIPTION
    Creates a Migration Import within an AutomateNOW! instance and returns back the newly created [ANOWMigrationImport] object

    .PARAMETER File
    Mandatory [System.IO.FileSystemInfo] object of the file to import. Use Get-Item to fetch this object. See examples.

    .PARAMETER OverwriteDomain
    Optional switch parameter to enable the 'Overwrite domain items in file with current domain' checkbox

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new Migration Import.

    .PARAMETER Folder
    Optional name of the folder to place the Migration Import into.

    .PARAMETER CodeRepository
    Optional name of the code repository to place the Migration Import into.

    .PARAMETER Comment
    Optional string array to include with the Migration Import object. Note, that this is a string array.

    .PARAMETER ApplyImmediately
    Optional switch parameter to enable the 'Apply Immediately' checkbox which skips the validation/approval steps (requires full admin)

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWMigrationImport.

    .OUTPUTS
    An [ANOWMigrationImport] object representing the newly created Migration Import

    .EXAMPLE
    Imports an exported Migration json file named 'C:\temp\AutomateNOW!_Test_Test_2025_04_26_08_24_13.json' while assigning tags, a folder and a code repository while also including a comment, applying immediately (that means without validation or approval) and overwriting the domain within the migrated objects (one-liner format)

    New-AutomateNOWMigrationImport -File (Get-Item -Path 'C:\temp\AutomateNOW!_Test_Test_2025_04_26_08_24_13.json') -Tags 'MJS', '123' -Folder 'MJS' -CodeRepository 'ValidateANOWNode' -Comment 'This', 'is', 'a', 'comment' -ApplyImmediately -OverwriteDomain

    .NOTES

    This function does not produce an object when successful. You will need to use Get-AutomateNOWMigrationImport if you want the newly created object returned.

    #>
    [OutputType([ANOWMigrationImport])]
    [Cmdletbinding()]
    Param(
        [ValidateScript({ ((Test-Path -LiteralPath $_ ) -eq $true) })]
        [Parameter(Mandatory = $true)]
        [System.IO.FileSystemInfo]$File,
        [Parameter(Mandatory = $false)]
        [switch]$OverwriteDomain,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [string]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [string[]]$Comment,
        [Parameter(Mandatory = $false)]
        [switch]$ApplyImmediately
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    [string]$file_name = $File.name
    [string]$formatted_full_file_path = $File.FullName -replace '\[', '`[' -replace ']', '`]'
    $Error.Clear()
    Try {
        [string]$file_content_string = (Get-Content -Path "$formatted_full_file_path") -join "`n"
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-Content failed to read the contents of $file_name under New-AutomateNOWMigrationImport due to [$Message]"
        Break
    }
    If ($file_content_string.Length -eq 0) {
        Write-Warning -Message "Somehow the file $file_name appears to be empty. Please check into this."
        Break
    }
    $Error.Clear()
    Try {
        $file_content_string | ConvertFrom-Json | Out-Null
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "ConvertFrom-Json failed to confirm the validity of the JSON content within $file_name under New-AutomateNOWMigrationImport due to [$Message]"
        Break
    }
    $Error.Clear()
    [hashtable]$get_file_parameters = @{}
    If ($PSVersionTable.PSVersion.Major -eq 5) {
        $get_file_parameters.Add('Encoding', 'Byte')
        $get_file_parameters.Add('Raw', $true)
    }
    Else {
        $get_file_parameters.Add('AsByteStream', $true)
    }
    $get_file_parameters.Add('Path', "$formatted_full_file_path")
    $Error.Clear()
    Try {
        [byte[]]$file_bytes = Get-Content @get_file_parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-Content failed to read (as bytes) the contents of $file_name under New-AutomateNOWMigrationImport due to [$Message]"
        Break
    }
    If (($file_bytes | Select-Object -First 1) -ne 10) {
        Write-Warning -Message "Warning: the first byte of $file_name is not an empty line (0A). This means the file was probably changed somewhere after being exported from the ANOW console."
    }
    [hashtable]$parameters = @{}
    $parameters.Add('Method', 'POST')
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$cr = "`r`n"
    [string]$boundary_string = New-WebkitBoundaryString -Length 32
    [System.Collections.ArrayList]$form_prefix = New-Object -TypeName System.Collections.ArrayList
    [void]$form_prefix.Add("------geckoformboundary$boundary_string")
    [void]$form_prefix.Add("Content-Disposition: form-data; name=`"access_token`"" + $cr)
    [void]$form_prefix.Add($anow_session.AccessToken)
    [void]$form_prefix.Add("------geckoformboundary$boundary_string")
    [void]$form_prefix.Add("Content-Disposition: form-data; name=`"file`"; filename=`"$file_name`"")
    [void]$form_prefix.Add('Content-Type: application/json' + $cr )
    [void]$form_prefix.Add($file_content_string )
    [void]$form_prefix.Add("------geckoformboundary$boundary_string")
    [void]$form_prefix.Add("Content-Disposition: form-data; name=`"overwriteDomain`"" + $cr)
    If ($OverwriteDomain -eq $true) {
        [void]$form_prefix.Add('true')
    }
    Else {
        [void]$form_prefix.Add('undefined')
    }
    [void]$form_prefix.Add("------geckoformboundary$boundary_string")
    [void]$form_prefix.Add("Content-Disposition: form-data; name=`"tags`"" + $cr)
    If ($Tags.Count -gt 0) {
        [int32]$total_tags = $Tags.Count
        ForEach ($tag_id in $Tags) {
            $Error.Clear()
            Try {
                [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] under New-AutomateNOWMigrationImport due to [$message]"
                Break
            }
            If ($tag_object.simpleId.length -eq 0) {
                Throw "New-AutomateNOWMigrationImport has detected that the tag [$tag_id] does not appear to exist. Please check again."
                Break
            }
            ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                [string]$tag_object_simpleId = $tag_object.simpleId
                Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                Break
            }
        }
        [string]$tag_name_sequence = $Tags -join ','
        If ($total_tags -gt 1) {
            Write-Verbose -Message "Joined $total_tags tags together into $tag_name_sequence"
        }
        [void]$form_prefix.Add($tag_name_sequence)
    }
    Else {
        [void]$form_prefix.Add('undefined')
    }
    [void]$form_prefix.Add("------geckoformboundary$boundary_string")
    [void]$form_prefix.Add("Content-Disposition: form-data; name=`"folder`"" + $cr)
    If ($Folder.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] actually existed under New-AutomateNOWMigrationImport due to [$Message]"
            Break
        }
        If ($folder_object.Id.Length -eq 0) {
            Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] under New-AutomateNOWMigrationImport. Please check again."
            Break
        }
        [void]$form_prefix.Add($Folder)
    }
    Else {
        [void]$form_prefix.Add('undefined')
    }
    [void]$form_prefix.Add("------geckoformboundary$boundary_string")
    [void]$form_prefix.Add("Content-Disposition: form-data; name=`"codeRepository`"" + $cr)
    If ($CodeRepository.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository] actually existed under New-AutomateNOWMigrationImport due to [$Message]"
            Break
        }
        If ($code_repository_object.Id.Length -eq 0) {
            Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository] under New-AutomateNOWMigrationImport. Please check again."
            Break
        }
        [void]$form_prefix.Add($CodeRepository)
    }
    Else {
        [void]$form_prefix.Add('')
    }
    [void]$form_prefix.Add("------geckoformboundary$boundary_string")
    [void]$form_prefix.Add("Content-Disposition: form-data; name=`"comment`"" + $cr)
    If ($Comment.Count -gt 0) {
        [string]$Comment_String = $Comment -join "`r`n"
        [void]$form_prefix.Add($Comment_String)
    }
    Else {
        [void]$form_prefix.Add('')
    }
    [void]$form_prefix.Add("------geckoformboundary$boundary_string")
    [void]$form_prefix.Add("Content-Disposition: form-data; name=`"applyImmediately`"" + $cr)
    If ($ApplyImmediately -eq $true) {
        [void]$form_prefix.Add('true')
    }
    Else {
        [void]$form_prefix.Add('false')
    }
    [void]$form_prefix.Add("------geckoformboundary$boundary_string--" + $cr)
    [string]$body_prefix = $form_prefix -join $cr
    [byte[]]$body_prefix_bytes = [System.Text.Encoding]::UTF8.GetBytes($body_prefix)
    [byte[]]$Body = $body_prefix_bytes
    [int32]$content_length = $Body.count
    [string]$domain = $anow_session.header.domain
    [string]$command = "/designImportOperation/create?ui=true&domain=$domain"
    $parameters.Add('ContentType', "multipart/form-data; boundary=----geckoformboundary$boundary_string")
    $parameters.Add('BinaryBody', $Body)
    $parameters.Add('Headers', [hashtable]@{"Content-Length" = $content_length; "Upgrade-Insecure-Requests" = 1; }) # is this header really needed?
    $parameters.Add('Command', $command)
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    Write-Information -Message "$file_name was imported successfully"
}

Function Export-AutomateNOWMigrationImport {
    <#
    .SYNOPSIS
    Exports the Migration Import objects from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Migration Import objects from an instance of AutomateNOW! to a local .csv file

    .PARAMETER MigrationImport
    Mandatory [ANOWMigrationImport] object (Use Get-AutomateNOWMigrationImport to retrieve them)

    .INPUTS
    ONLY [ANOWMigrationImport] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWMigrationImport] objects are exported to the local disk in CSV format

    .EXAMPLE
    Exports the first page of Migration Import objects

    Get-AutomateNOWMigrationImport | Export-AutomateNOWMigrationImport

    .EXAMPLE
    Exports a Migration Import object named 'MigrationImport1'

    Get-AutomateNOWMigrationImport -Id 'MigrationImport1' | Export-AutomateNOWMigrationImport

    .EXAMPLE
    Exports a series of MigrationImport objects by the pipeline

    'MigrationImport1', 'MigrationImport2' | Get-AutomateNOWMigrationImport | Export-AutomateNOWMigrationImport

    .NOTES
	You must present [ANOWMigrationImport] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWMigrationImport]$MigrationImport
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-MigrationImports-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWMigrationImport]$MigrationImport = $_
        }
        $Error.Clear()
        Try {
            $MigrationImport | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWMigrationImport] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function Save-AutomateNOWMigrationImport {
    <#
    .SYNOPSIS
    Downloads (Saves) a Migration Import object from an AutomateNOW! instance and writes it to .json file.

    .DESCRIPTION
    Downloads (Saves) a Migration Import object from an AutomateNOW! instance and writes it to .json file.

    .PARAMETER MigrationImport
    An [ANOWMigrationImport] object representing the Migration Import object to be downloaded to .json file.

    .PARAMETER DestinationFilepath
    Optional path for the .json export file to be written to. Use this if you want the exported JSON file to be written somewhere other than the current path.

    .PARAMETER OverwriteExportFile
    Switch parameter that will force the exported file to be overwritten if it exists

    .INPUTS
    ONLY [ANOWMigrationImport] objects are accepted (including from the pipeline)

    .OUTPUTS
    A verbose information message will be sent indicating success

    .EXAMPLE
    Saves a Migration Import object with an Id of '5cb7046c-cd26-45bf-9c2b-8d0fb9f91ecb' to disk

    Get-AutomateNOWMigrationImport -Id '5cb7046c-cd26-45bf-9c2b-8d0fb9f91ecb' | Save-AutomateNOWMigrationImport

    .EXAMPLE
    Saves the first page of Migration Import objects to disk while overwriting the exported file if it exists

    Get-AutomateNOWMigrationImport | Save-AutomateNOWMigrationImport -OverwriteExportFile

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The UI's calculation of the filesize will not always match what is saved to disk due to possible encoding differences.

    This function is equivalent to the 'Download' button for Migration Import objects (after opening one)

    #>
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWMigrationImport]$MigrationImport,
        [ValidateScript({ (Test-Path -Path "$_") -eq $true })]
        [Parameter(Mandatory = $false)]
        [string]$DestinationPath,
        [Parameter(Mandatory = $false)]
        [switch]$OverwriteExportFile
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWMigrationImport]$MigrationImport = $_
        }
        [int64]$MigrationImport_FileSize = $MigrationImport.fileSize
        [string]$MigrationImport_FileName = $MigrationImport.fileName
        [string]$MigrationImport_id = $MigrationImport.id
        [string]$MigrationImport_domain = $anow_session.current_domain
        If ($MigrationImport_FileName.Length -eq 0) {
            Write-Warning -Message "Somehow this Migration Import has an empty filename. Something is wrong..."
            Break
        }
        If ($MigrationImport_FileSize -eq 0) {
            Write-Warning -Message "Somehow this Migration Import has a datasize of 0? Something is wrong..."
            Break
        }
        If ($MigrationImport_FileSize -lt 1024) {
            [string]$MigrationImport_DisplaySize = ("$MigrationImport_FileSize" + ' B')
        }
        ElseIf ($MigrationImport_FileSize -lt 1048576) {
            [string]$MigrationImport_FileSize = [math]::Round(($MigrationImport_FileSize / 1024), 2, 'ToZero')
            [string]$MigrationImport_DisplaySize = ("$MigrationImport_FileSize" + ' kB')
        }
        Else {
            [string]$MigrationImport_FileSize = [math]::Round(($MigrationImport_FileSize / 1048576), 2, 'ToZero')
            [string]$MigrationImport_DisplaySize = ("$MigrationImport_FileSize" + ' MB')
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [ANOWMigrationImport]$current_MigrationImport = Get-AutomateNOWMigrationImport -Id $MigrationImport_id
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWMigrationImport failed to check if the Migration Import $MigrationImport_FileName ($MigrationImport_id) existed under Save-AutomateNOWMigrationImport due to [$Message]."
            Break
        }
        If ($current_MigrationImport.id.length -eq 0) {
            Write-Warning -Message "The Migration Import you specified does not seem to exist (under Save-AutomateNOWMigrationImport)"
            Break
        }
        ## End warning ##
        Write-Information -MessageData "Downloading Migration Import $MigrationImport_FileName ($MigrationImport_id) $MigrationImport_DisplaySize"
        [string]$command = ('/designImportOperation/downloadFile?id=' + $MigrationImport_id + '&domain=' + $MigrationImport_domain)
        If ($null -ne $parameters["Command"]) {
            $parameters.'command' = $command
        }
        Else {
            $parameters.Add('Command', $command)
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$MigrationImport_id] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [string]$MigrationImport_JSON = $results | ConvertTo-Json -Depth 100
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "ConvertTo-Json failed to convert the download of [$MigrationImport_id] to JSON due to [$Message]."
            Break
        }
        If ($DestinationPath.Length -eq 0) {
            [string]$DestinationPath = '.'
        }
        [string]$outgoing_filename = $MigrationImport.fileName -replace '/', '_'
        [string]$ExportFilePath = Join-Path -Path $DestinationPath -ChildPath $outgoing_filename
        [boolean]$outgoing_file_exists = Test-Path -Path "$ExportFilePath"
        If ($outgoing_file_exists -eq $true -and $OverwriteExportFile -ne $true) {
            Write-Warning -Message "The saved file $outgoing_filename already exists at $DestinationPath. Use the -OverwriteExportFile switch parameter to bypass this exception and overwrite the file."
            Break
        }
        $Error.Clear()
        [hashtable]$parameters2 = @{}
        $parameters2.Add('InputObject', $MigrationImport_JSON)
        $parameters2.Add('Path', $ExportFilePath)
        $parameters2.Add('NoNewLine', $true)
        If ($OverwriteExportFile -eq $true) {
            $parameters2.Add('Force', $true)
        }
        $Error.Clear()
        Try {
            Out-File @parameters2
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Out-File failed to write the outgoing file [$outgoing_filename] to disk (under Save-AutomateNOWMigrationImport) due to [$Message]."
            Break
        }
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Successfully saved Migration Import [$MigrationImport_id] to disk as: $outgoing_filename - $filelength_display bytes"
        }
    }
    End {

    }
}

Function Confirm-AutomateNOWMigrationImport {
    <#
    .SYNOPSIS
    Confirms that a Migration Import object on an AutomateNOW! instance is valid and ready to be applied.

    .DESCRIPTION
    Confirms that a Migration Import object on an AutomateNOW! instance is valid and ready to be applied.

    .PARAMETER MigrationImport
    An [ANOWMigrationImport] object representing the object to be validated.

    .PARAMETER Quiet
    Switch parameter that silences the output of the updated object.

    .INPUTS
    ONLY [ANOWMigrationImport] objects are accepted (including from the pipeline)

    .OUTPUTS
    The validated [ANOWMigrationImport] object will be returned

    .EXAMPLE
    Confirms (validates) a Migration Import object with an Id of '5cb7046c-cd26-45bf-9c2b-8d0fb9f91ecb' to disk

    Get-AutomateNOWMigrationImport -Id '5cb7046c-cd26-45bf-9c2b-8d0fb9f91ecb' | Confirm-AutomateNOWMigrationImport

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This command is not like other Validate/Confirm commands. This endpoint actually updates the object with properties like "ValidatedDate"

    #>
    [OutputType([ANOWMigrationImport])]
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWMigrationImport]$MigrationImport,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/designImportOperation/validate'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWMigrationImport]$MigrationImport = $_
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$MigrationImport_exists = ($null -eq (Get-AutomateNOWMigrationImport -Id $MigrationImport_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWMigrationImport failed to check if the Migration Import [$MigrationImport_id] already existed due to [$Message]."
            Break
        }
        If ($MigrationImport_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not a Migration Import with an Id of [$MigrationImport_id] in the current domain [$current_domain]. Please check into this."
            Break
        }
        ## End warning ##
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        $BodyMetaData.'id' = $MigrationImport_id
        $BodyMetaData.'_operationType' = 'update'
        $BodyMetaData.'_operationId' = 'validate'
        $BodyMetaData.'_textMatchStyle' = 'exact'
        $BodyMetaData.'_dataSource' = 'DesignImportOperationDataSource'
        $BodyMetaData.'isc_metaDataPrefix' = '_'
        $BodyMetaData.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        If ($null -eq $parameters.Body) {
            $parameters.Add('Body', $Body)
        }
        Else {
            $parameters.Body = $Body
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$MigrationImport_id] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        Write-Verbose -Message "Migration Import [$MigrationImport_id] was successfully confirmed (validated)"
        $Error.Clear()
        Try {
            [ANOWMigrationImport]$UpdatedMigrationImport = Get-AutomateNOWMigrationImport -Id $MigrationImport_id
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWMigrationImport failed to confirm that the [ANOWMigrationImport] object was updated due to [$Message]. The object was still validated though."
            Break
        }
        If ($Quiet -ne $true) {
            Return $UpdatedMigrationImport
        }
    }
    End {
    }
}

#endregion

#Region - Notifications

Function Get-AutomateNOWNotification {
    <#
    .SYNOPSIS
    Gets the Notifications (a.k.a. Notification Logs) from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Notifications (a.k.a. Notification Logs) from an AutomateNOW! instance

    .PARAMETER Id
    Optional int64 Id of the specific Notification that you want to retrieve. Note that this parameter is not required.

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER sortBy
    Optional string parameter to sort the results by. Valid choices are: dateSent, id, dateQueued, dateEscalated, confirmationDate, confirmationDeadline (default is dateQueued)

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .INPUTS
    Accepts a string representing the simple id of the Notification Group from the pipeline or individually (but not an array).

    .OUTPUTS
    An array of one or more [ANOWNotificationGroup] class objects

    .EXAMPLE
    Gets the first 100 Notifications

    Get-AutomateNOWNotification

    .EXAMPLE
    Gets a single Notification based on its Id

    Get-AutomateNOWNotification -Id 1

    .EXAMPLE
    Gets a series of Notifications from an array of Id's sent across the pipeline

    @( 1, 2, 3, 10033, 10034 ) | Get-AutomateNOWNotification

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Run this function without parameters to retrieve the first 100 Notification Groups.

    #>
    [OutputType([ANOWNotificationGroup[]])]
    [Cmdletbinding(DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $True, ParameterSetName = 'Id', ValueFromPipeline = $True)]
        [int64]$id,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100,
        [ValidateSet('dateQueued', 'dateSent', 'dateEscalated', 'confirmationDate', 'confirmationDeadline', 'id', ignoreCase = $false)]
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$sortBy = 'dateQueued',
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$Descending
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_ -gt 0) {
            [int64]$Id = $_
        }
        If ($Id -gt 0) {
            $Body.'id' = $Id
            $Body.'_operationId' = 'read'
            [string]$textMatchStyle = 'exactCase'
        }
        Else {
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
            $Body.'_componentId' = 'NotificationList'
            [string]$textMatchStyle = 'subString'
        }
        $Body.'_operationType' = 'fetch'
        $Body.'_textMatchStyle' = $textMatchStyle
        $Body.'_dataSource' = 'NotificationDataSource'
        If ($Descending -eq $true) {
            $Body.'_sortBy' = '-' + $sortBy
        }
        Else {
            $Body.'_sortBy' = $sortBy
        }
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/notification/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('command', $command)
        }
        Else {
            $parameters.'command' = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWNotification[]]$Notifications = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWNotification] objects due to [$Message]."
            Break
        }
        If ($Notifications.Count -gt 0) {
            Return $Notifications
        }
    }
    End {

    }
}

Function Export-AutomateNOWNotification {
    <#
    .SYNOPSIS
    Exports the Notifications (a.k.a. Notification Logs) from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Notifications (a.k.a. Notification Logs) from an instance of AutomateNOW! to a local .csv file

    .PARAMETER NotificationGroup
    Mandatory [ANOWNotification] object (Use Get-AutomateNOWNotification to retrieve them)

    .INPUTS
    ONLY [ANOWNotification] objects individually or from the pipeline are accepted

    .OUTPUTS
    The [ANOWNotificationGroup] objects are exported to the local disk in CSV format

    .EXAMPLE
    Exports the first 100 Notifications

    Get-AutomateNOWNotification | Export-AutomateNOWNotification

    .EXAMPLE
    Exports a series of Notifications from an array of Id's sent across the pipeline

    1, 2, 3, 10033, 10034 | Get-AutomateNOWNotification | Export-AutomateNOWNotification

    .NOTES
	
    #>

    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWNotification]$Notification
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-Notifications-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWNotification]$Notification = $_
        }
        $Error.Clear()
        Try {
            $Notification | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWNotification] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function Remove-AutomateNOWNotification {
    <#
    .SYNOPSIS
    Removes a Notification (a.k.a. Notification Logs) from an AutomateNOW! instance

    .DESCRIPTION
    Removes a Notification (a.k.a. Notification Logs) from an AutomateNOW! instance

    .PARAMETER Notification
    An [ANOWNotification] object representing the Notification to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    [ANOWNotification] objects are accepted individually or across the pipeline

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Removes the first 100 Notifications

    Get-AutomateNOWNotification | Remove-AutomateNOWNotification

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWNotification]$Notification,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/notification/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWNotification]$Notification = $_
        }
        [int64]$Notification_id = $Notification.id
        If ($Notification_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Notification_id)")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            [string]$old_values = $Notification.CreateOldValues()
            $BodyMetaData.'id' = $Notification_id
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_oldValues' = $old_values
            $BodyMetaData.'_componentId' = 'NotificationList'
            $BodyMetaData.'_dataSource' = 'NotificationDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$NotificationGroup_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Notification $Notification_id was removed"
        }
    }
    End {

    }
}

#endregion

#Region - Notification Channel

Function Get-AutomateNOWNotificationChannel {
    <#
    .SYNOPSIS
    Gets the Notification Channels from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Notification Channels from an AutomateNOW! instance

    .PARAMETER Id
    Optional string containing the simple id of the Notification Channel to fetch or you can pipeline a series of simple id strings. You may not enter an array here.

    .PARAMETER sortBy
    Optional string parameter to sort the results by. Valid choices are: id {To be continued...}

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER Folder
    Optional string to filter by a particular Folder

    .PARAMETER Tags
    Optional string array of Tags to filter by. Note that the 'containsAny' operator will be used.

    .INPUTS
    Accepts a string representing the simple id of the Notification Channel from the pipeline or individually (but not an array).

    .OUTPUTS
    An array of one or more [ANOWNotificationChannel] class objects

    .EXAMPLE
    Gets all the first page of Notification Channel objects

    Get-AutomateNOWNotificationChannel

    .EXAMPLE
    Gets a single Notification Channel object named 'NotificationChannel1'

    Get-AutomateNOWNotificationChannel -Id 'NotificationChannel1'

    .EXAMPLE
    Gets a series of Notification Channels from an array of strings sent across the pipeline

    'NotificationChannel1', 'NotificationChannel2' | Get-AutomateNOWNotificationChannel

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWNotificationChannel[]])]
    [Cmdletbinding(DefaultParameterSetName = 'Default')]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $False, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$sortBy = 'id',
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$Descending,
        [Parameter(Mandatory = $False)]
        [string]$Folder,
        [Parameter(Mandatory = $False)]
        [string[]]$Tags
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 -or $Id.Length -gt 0) {
            If ($_.Length -gt 0 ) {
                [string]$NotificationChannel_name = $_
            }
            Else {
                [string]$NotificationChannel_name = $Id
            }
            $Body.'id' = $NotificationChannel_name
            [string]$textMatchStyle = 'exactCase'
            $Body.'_operationId' = 'read'
        }
        Else {
            $Body.'operator' = 'and'
            $Body.'_constructor' = 'AdvancedCriteria'
            If ($Folder.Length -gt 0) {
                $Body.'criteria1' = ('{"fieldName":"folder","operator":"equals","value":"' + $Folder + '"}')
            }
            If ($Tags.Count -gt 0) {
                If ($Tags.Count -gt 1) {
                    $Error.Clear()
                    Try {
                        [string]$TagString = $Tags | ConvertTo-Json -Compress
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "ConvertTo-Json failed to convert the provided tag names under Get-AutomateNOWNotificationChannel due to [$Message]."
                        Break
                    }
                }
                Else {
                    [string]$TagString = $Tags
                }
                $Body.'criteria2' = ('{"fieldName":"tags","operator":"containsAny","value":' + $TagString + '}')
            }
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
            $Body.'_componentId' = 'NotificationChannelList'
            [string]$textMatchStyle = 'substring'
        }
        $Body.'_textMatchStyle' = $textMatchStyle
        $Body.'_operationType' = 'fetch'
        $Body.'_dataSource' = 'NotificationChannelDataSource'
        If ($Descending -eq $true) {
            $Body.'_sortBy' = '-' + $sortBy
        }
        Else {
            $Body.'_sortBy' = $sortBy
        }
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/notificationChannel/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        [PSCustomObject[]]$response_data = ForEach ($response in $results.response.data) {
            If ($response.endpoint.Length -gt 0) {
                $Error.Clear()
                Try {
                    $response.endpoint = Get-AutomateNOWEndpoint -Id ($response.endpoint)
                }
                Catch {
                    [string]$response_endpoint = $response.endpoint
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWEndpoint failed to retrieve [$response_endpoint] under Get-AutomateNOWNotificationChannel due to [$Message]."
                    Break
                }
            }
            $response
        }
        $Error.Clear()
        Try {
            [ANOWNotificationChannel[]]$NotificationChannels = $response_data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWNotificationChannel] objects due to [$Message]."
            Break
        }
        If ($NotificationChannels.Count -gt 0) {
            Return $NotificationChannels
        }
    }
    End {

    }
}

Function Set-AutomateNOWNotificationChannel {
    <#
    .SYNOPSIS
    Changes the settings of a Notification Channel on an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of a Notification Channel on an AutomateNOW! instance

    .PARAMETER NotificationChannel
    An [ANOWNotificationChannel] object representing the Notification Channel to be changed.

    .PARAMETER CodeRepository
    Optional Code Repository to place the Notification Channel into. Use Get-AutomateNOWCodeRepository to fetch this object.

    .PARAMETER UnsetCodeRepository
    Switch parameter that will remove the the Notification Channel from its Code Repository.

    .PARAMETER Endpoint
    An optional [ANOWEndpoint] object representing the endpoint to attach to this Notification Channel.

    .PARAMETER UnsetEndpoint
    A switch parameter that unsets (removes) the Endpoint on the Notification Channel.

    .PARAMETER ConnectionCode
    An optional string containing the code for the Notification Channel. Note that this only applies to CUSTOM_FUNCTION, SCRIPT, WEB_SERVICE types.

    .PARAMETER UnsetConnectioncode
    A switch parameter that unsets (removes) the Connection Code on the Notification Channel.

    .PARAMETER Description
    A text description of at least 1 character.

    .PARAMETER UnsetDescription
    Unsets (removes) the description of the Notification Channel.

    .PARAMETER UnsetFolder
    Switch parameter that will remove the Notification Channel from its current folder.

    .PARAMETER Folder
    String that specifies the name of the folder object to place the Notification Channel into.

    .PARAMETER UnsetTags
    Switch parameter that will remove all tags from the Notification Channel.

    .PARAMETER Tag
    String array that specifies the name(s) of the Tag to apply to the Notification Channel.

    .PARAMETER Quiet
    Switch parameter that silences the output of the updated object.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWNotificationChannel] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWNotificationChannel] object will be returned

    .EXAMPLE
    Forcibly Sets the description on a Notification Channel
    Set-AutomateNOWNotificationChannel -NotificationChannel $NotificationChannel -Description 'My Description' -Force

    .EXAMPLE
    Unsets the description on a Notification Channel
    Set-AutomateNOWNotificationChannel -NotificationChannel $NotificationChannel -UnsetDescription

    .EXAMPLE
    Sets the tags and folder for a Notification Channel
    Set-AutomateNOWNotificationChannel -NotificationChannel $NotificationChannel -Tags 'Tag1', 'Tag2' -Folder 'Folder1'

    .EXAMPLE
    Forcibly unsets the tags for a Notification Channel
    Set-AutomateNOWNotificationChannel -NotificationChannel $NotificationChannel -UnsetTags -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Modifying certain other properties of the Jira channel type is currently broken in ANOW.

    #>
    [OutputType([ANOWNotificationChannel])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWNotificationChannel]$NotificationChannel,
        [Parameter(Mandatory = $false)]
        [ANOWEndpoint]$Endpoint,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetEndpoint,
        [Parameter(Mandatory = $false)]
        [string]$ConnectionCode,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetconnectionCode,
        [ValidateScript({ $_.Length -le 255 })]
        [Parameter(Mandatory = $false, HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetCodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($Endpoint.Id.Length -gt 0 -and $UnsetEndpoint -eq $true) {
            Write-Warning -Message 'You cannot set the Endpoint and unset it at the same time. Please choose one or the other.'
            Break
        }
        If ($ConnectionCode.Length -gt 0 -and $UnsetConnectionCode -eq $true) {
            Write-Warning -Message 'You cannot set the Connection Code and unset it at the same time. Please choose one or the other.'
            Break
        }
        If ($Description.Length -gt 0 -and $UnsetDescription -eq $true) {
            Write-Warning -Message 'You cannot set the Description and unset it at the same time. Please choose one or the other.'
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Exit
        }
        If ($Tags.count -gt 0 -and $UnsetTags -eq $true) {
            Write-Warning -Message "You cannot set the tags and unset them at the same time. Please choose one or the other."
        }
        If ($UnsetCodeRepository -eq $true -and $CodeRepository.Id.Length -gt 0) {
            Write-Warning -Message "You cannot unset the Code Repository and set it at the same time. Please choose one or the other."
            Break
        }
        [string]$command = '/notificationChannel/update'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWNotificationChannel]$NotificationChannel = $_
        }
        [string]$NotificationChannel_id = $NotificationChannel.Id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($NotificationChannel_id)")) -eq $true) {
            [string]$NotificationChannel_notificationChannelType = $NotificationChannel.notificationChannelType
            If ($ConnectionCode.Length -gt 0 -and $NotificationChannel_notificationChannelType -notin @('CUSTOM_FUNCTION', 'SCRIPT', 'WEB_SERVICE')) {
                Write-Warning -Message "The Notification Channel type [$NotificationChannel_notificationChannelType] does not accept Connection Code!"
                Break
            }
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$NotificationChannel_exists = ($null -eq (Get-AutomateNOWNotificationChannel -Id $NotificationChannel_id))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWNotificationChannel failed to check if the Notification Channel [$NotificationChannel_id] already existed due to [$Message]."
                Break
            }
            If ($NotificationChannel_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not a Notification Channel named [$NotificationChannel_id] in the current domain [$current_domain]. Please check into this."
                Break
            }
            ## End warning ##
            [System.Collections.ArrayList]$include_properties = [System.Collections.ArrayList]@()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $NotificationChannel_id
            If ($ConnectionCode.Length -gt 0) {
                $BodyMetaData.'connectionCode' = $ConnectionCode
            }
            If ($Endpoint.Id.Length -gt 0) {
                $BodyMetaData.'endpoint' = ($Endpoint.Id)
            }
            If ($Description.Length -gt 0) {
                $BodyMetaData.'description' = $Description
            }
            ElseIf ($UnsetDescription -eq $true) {
                $BodyMetaData.'description' = $null
                $include_properties += 'description'
            }
            ElseIf ($DataSource.description.length -gt 0) {
                $BodyMetaData.'description' = $DataSource.description
                $include_properties += 'description'
            }
            If ($Folder.Length -gt 0) {
                $Error.Clear()
                Try {
                    [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the Folder [$Folder] actually existed while running under Set-AutomateNOWNotificationChannel due to [$Message]"
                    Break
                }
                If ($folder_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] running under Set-AutomateNOWNotificationChannel. Please check again."
                    Break
                }
                [string]$folder_display = $folder_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Adding Notification Channel [$NotificationChannel_id] to Folder $folder_display"
                $BodyMetaData.'folder' = $Folder
                $include_properties += 'folder'
            }
            ElseIf ($UnsetFolder -eq $true) {
                [string]$folder_display = $folder_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Removing Notification Channel [$NotificationChannel_id] from Folder $folder_display"
                $BodyMetaData.'folder' = $null
                $include_properties += 'folder'
            }
            If ($Tags.Count -gt 0) {
                [int32]$total_tags = $Tags.Count
                [int32]$current_tag = 1
                ForEach ($tag_id in $Tags) {
                    $Error.Clear()
                    Try {
                        [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] running under Set-AutomateNOWNotificationChannel due to [$message]"
                        Break
                    }
                    If ($tag_object.simpleId.length -eq 0) {
                        Write-Warning -Message "Set-AutomateNOWNotificationChannel has detected that the tag [$tag_id] does not appear to exist. Please check again."
                        Break
                    }
                    ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                        [string]$tag_object_simpleId = $tag_object.simpleId
                        Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                        Break
                    }
                    [string]$tag_display = $tag_object | ConvertTo-Json -Compress
                    Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
                    [string]$tag_name_sequence = ('tags' + $current_tag)
                    $BodyMetaData.Add($tag_name_sequence, $tag_id)
                    $include_properties += $tag_name_sequence
                    $current_tag++
                }
            }
            ElseIf ($UnsetTags -eq $true) {
                [string]$tags_display = ($NotificationChannel.tags) | ConvertTo-Json -Compress
                Write-Verbose -Message "Removing tags [$tags_display] from $NotificationChannel_id"
                $BodyMetaData.'tags' = $null
                $include_properties += 'tags'
            }
            If ($CodeRepository.Id.Length -gt 0) {
                [string]$CodeRepository_Id = $CodeRepository.Id
                $Error.Clear()
                Try {
                    [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository_Id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository_Id] actually existed under Set-AutomateNOWNotificationChannel due to [$Message]"
                    Break
                }
                If ($code_repository_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository_Id] under Set-AutomateNOWNotificationChannel. Please check again."
                    Break
                }
                $BodyMetaData.'codeRepository' = $CodeRepository_Id
            }
            ElseIf ($UnsetCodeRepository -eq $true) {
                $BodyMetaData.'codeRepository' = $null
            }
            $include_properties += 'endpointType'
            $BodyMetaData.'_oldValues' = $NotificationChannel.CreateOldValues()
            $BodyMetaData.'_operationType' = 'update'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_dataSource' = 'NotificationChannelDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$DataSource_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Notification Channel [$NotificationChannel_id] was successfully updated"
            $Error.Clear()
            Try {
                [ANOWNotificationChannel]$UpdatedNotificationChannel = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the returned updated object to an [ANOWNotificationChannel] object due to [$Message]. The object was still updated though."
                Break
            }
            If ($Quiet -ne $true) {
                Return $UpdatedNotificationChannel
            }
        }
    }
    End {
    }
}

Function Export-AutomateNOWNotificationChannel {
    <#
    .SYNOPSIS
    Exports the Notification Channels from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Notification Channels from an instance of AutomateNOW! to a local .csv file

    .PARAMETER NotificationChannel
    Mandatory [ANOWNotificationChannel] object (Use Get-AutomateNOWNotificationChannel to retrieve them)

    .INPUTS
    ONLY [ANOWNotificationChannel] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWNotificationChannel] objects are exported to the local disk in CSV format

    .EXAMPLE
    Get-AutomateNOWNotificationChannel | Export-AutomateNOWNotificationChannel

    .EXAMPLE
    Get-AutomateNOWNotificationChannel -Id 'NotificationChannel01' | Export-AutomateNOWNotificationChannel

    .EXAMPLE
    @( 'NotificationChannel01', 'NotificationChannel02' ) | Get-AutomateNOWNotificationChannel | Export-AutomateNOWNotificationChannel

    .EXAMPLE
    Get-AutomateNOWNotificationChannel | Where-Object { $_.simpleId -eq 'NotificationChannel01' } | Export-AutomateNOWNotificationChannel

    .NOTES
	You must present [ANOWNotificationChannel] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWNotificationChannel]$NotificationChannel
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-NotificationChannels-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWNotificationChannel]$NotificationChannel = $_
        }
        $Error.Clear()
        Try {
            $NotificationChannel | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWNotificationChannel] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function New-AutomateNOWNotificationChannel {
    <#
    .SYNOPSIS
    Creates a Notification Channel within an AutomateNOW! instance

    .DESCRIPTION
    Creates a Notification Channel within an AutomateNOW! instance and returns back the newly created [ANOWNotificationChannel] object

    .PARAMETER Id
    The intended name of the Notification Channel. For example: 'LinuxNotificationChannel1'. This value may not contain the domain in brackets.

    .PARAMETER notificationChannelType
    The mandatory type of Notification Channel. Valid options are: CUSTOM_FUNCTION, SCRIPT, WEB_SERVICE, JIRA, SERVICE_NOW

    .PARAMETER Description
    Optional description of the Notification Channel (may not exceed 255 characters).

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new Notification Channel.

    .PARAMETER Folder
    Optional name of the folder to place the DataSource into.

    .PARAMETER CodeRepository
    Optional name of the code repository to place the Notification Channel into.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWNotificationChannel.

    .OUTPUTS
    An [ANOWNotificationChannel] object representing the newly created Notification Channel

    .EXAMPLE
    New-AutomateNOWNotificationChannel -Id 'NotificationChannel1' -notificationChannel SCRIPT Type -Description 'NotificationChannel1 description' -Tags 'Tag1', 'Tag2' -Folder 'Folder1' -codeRepository 'Repository1'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The name (id) of the Notification Channel must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    #>
    [OutputType([ANOWNotificationChannel])]
    [Cmdletbinding()]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $true)]
        [string]$Id,
        [Parameter(Mandatory = $true)]
        [ANOWNotificationChannel_notificationChannelType]$notificationChannelType,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [string]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [boolean]$NotificationChannel_exists = ($null -ne (Get-AutomateNOWNotificationChannel -Id $Id))
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWNotificationChannel failed to check if the Notification Channel [$Id] already existed due to [$Message]."
        Break
    }
    If ($NotificationChannel_exists -eq $true) {
        [string]$current_domain = $anow_session.header.domain
        Write-Warning -Message "There is already a Notification Channel named [$Id] in [$current_domain]. Please check into this."
        Break
    }
    ## End warning ##
    [System.Collections.Specialized.OrderedDictionary]$ANOWNotificationChannel = [System.Collections.Specialized.OrderedDictionary]@{}
    $ANOWNotificationChannel.Add('id', $Id)
    $ANOWNotificationChannel.Add('notificationChannelType', $notificationChannelType)
    If ($Description.Length -gt 0) {
        $ANOWNotificationChannel.Add('description', $Description)
    }
    If ($Tags.Count -gt 0) {
        [int32]$total_tags = $Tags.Count
        [int32]$current_tag = 1
        ForEach ($tag_id in $Tags) {
            $Error.Clear()
            Try {
                [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] under New-AutomateNOWNotificationChannel due to [$message]"
                Break
            }
            If ($tag_object.simpleId.length -eq 0) {
                Throw "New-AutomateNOWNotificationChannel has detected that the tag [$tag_id] does not appear to exist. Please check again."
                Break
            }
            ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                [string]$tag_object_simpleId = $tag_object.simpleId
                Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                Break
            }
            [string]$tag_display = $tag_object | ConvertTo-Json -Compress
            Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
            [string]$tag_name_sequence = ('tags' + $current_tag)
            $ANOWNotificationChannel.Add($tag_name_sequence, $tag_id)
            $include_properties += $tag_name_sequence
            $current_tag++
        }
    }
    If ($Folder.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] actually existed under New-AutomateNOWNotificationChannel due to [$Message]"
            Break
        }
        If ($folder_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] under New-AutomateNOWNotificationChannel. Please check again."
            Break
        }
        [string]$folder_display = $folder_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding folder $folder_display to Notification Channel [$Id]"
        $ANOWNotificationChannel.Add('folder', $Folder)
        $include_properties += 'folder'
    }
    If ($CodeRepository.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository] actually existed under New-AutomateNOWNotificationChannel due to [$Message]"
            Break
        }
        If ($code_repository_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository] under New-AutomateNOWNotificationChannel. Please check again."
            Break
        }
        [string]$code_repository_display = $code_repository_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding code repository $code_repository_display to Notification Channel [$Id]"
        $ANOWNotificationChannel.Add('codeRepository', $CodeRepository)
        $include_properties += 'codeRepository'
    }
    [string]$BodyObject = ConvertTo-QueryString -InputObject $ANOWNotificationChannel -IncludeProperties id, description, tags, folder, codeRepository
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    $BodyMetaData.'_operationType' = 'add'
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_oldValues' = '{}'
    $BodyMetaData.'_componentId' = 'NotificationChannelCreateWindow_form'
    $BodyMetaData.'_dataSource' = 'NotificationChannelDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$BodyMetaDataString = ConvertTo-QueryString -InputObject $BodyMetaData
    [string]$Body = ($BodyObject + '&' + $BodyMetaDataString)
    [string]$command = '/notificationChannel/create'
    [hashtable]$parameters = @{}
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('Body', $Body)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWNotificationChannel]$NotificationChannel = $results.response.data | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to parse the response into a valid [ANOWNotificationChannel] object due to [$Message]."
        Break
    }
    If ($NotificationChannel.id.Length -eq 0) {
        Write-Warning -Message "Somehow the newly created [ANOWNotificationChannel] object is empty!"
        Break
    }
    If ($Quiet -ne $true) {
        Return $NotificationChannel
    }
}

Function Remove-AutomateNOWNotificationChannel {
    <#
    .SYNOPSIS
    Removes a Notification Channel from an AutomateNOW! instance

    .DESCRIPTION
    Removes a Notification Channel from an AutomateNOW! instance

    .PARAMETER NotificationChannel
    An [ANOWNotificationChannel] object representing the Notification Channel to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWNotificationChannel] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Get-AutomateNOWNotificationChannel -Id 'NotificationChannel01' | Remove-AutomateNOWNotificationChannel

    .EXAMPLE
    @( 'NotificationChannel1', 'NotificationChannel2', 'NotificationChannel3') | Remove-AutomateNOWNotificationChannel

    .EXAMPLE
    Get-AutomateNOWNotificationChannel | ? { $_.simpleId -like 'test*' } | Remove-AutomateNOWNotificationChannel

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWNotificationChannel]$NotificationChannel,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/notificationChannel/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWNotificationChannel]$NotificationChannel = $_
        }
        [string]$NotificationChannel_id = $NotificationChannel.id
        If ($NotificationChannel_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($NotificationChannel_id)")) -eq $true) {
            [string]$oldvalues = $NotificationChannel.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $NotificationChannel_id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'NotificationChannelList'
            $BodyMetaData.'_dataSource' = 'NotificationChannelDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$NotificationChannel_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Notification Channel $NotificationChannel_id successfully removed"
        }
    }
    End {

    }
}

Function Copy-AutomateNOWNotificationChannel {
    <#
    .SYNOPSIS
    Copies a Notification Channel from an AutomateNOW! instance

    .DESCRIPTION
    Copies a Notification Channel from an AutomateNOW! instance.

    .PARAMETER NotificationChannel
    Mandatory [ANOWNotificationChannel] object to be copied.

    .PARAMETER NewId
    The name (Id) of the new Notification Channel. The new Id must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    .PARAMETER UnsetDescription
    Optional switch that will ensure that the newly created Notification Channel will not have a description set.

    .PARAMETER Description
    Optional description to set on the new Notification Channel object. If you do not set this, the new Notification Channel object will copy the Description of the source object.

    .PARAMETER UnsetFolder
    Optional switch that will ensure that the newly created Notification Channel will not have a Folder set.

    .PARAMETER Folder
    Optional description to set a different folder on the new Notification Channel object. If you do not set this, the new Notification Channel object will use the same Folder of the source object.

    .PARAMETER UnsetTags
    Optional switch that will ensure that the newly created Notification Channel will not have any Tags set.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the new Notification Channel object. If you do not set this, the new Notification Channel object will apply the same Tags of the source object.

    .PARAMETER Force
    Force the copy without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    ONLY [ANOWNotificationChannel] object is accepted. Pipeline support is intentionally unavailable.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Creates a copy of a Notification Channel and changes the description (multi-line format)
    $NotificationChannel01 = Get-AutomateNOWNotificationChannel -Id 'NotificationChannel_01'
    Copy-AutomateNOWNotificationChannel -NotificationChannel $NotificationChannel01 -NewId 'NotificationChannel_01_production' -Description 'NotificationChannel 01 Production'

    .EXAMPLE
    Creates a copy of a Notification Channel that omits the description (one-liner format)
    Copy-AutomateNOWNotificationChannel -NotificationChannel (Get-AutomateNOWNotificationChannel -Id 'NotificationChannel_01') -NewId 'NotificationChannel_01_production' -UnsetDescription -Tags 'Tag1', 'Tag2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWNotificationChannel]$NotificationChannel,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot set the Tags and unset them at the same time. Please choose one or the other. Tags from the source object will be carried over to the new object if you do not specify any tag-related parameters."
            Break
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$NotificationChannel_exists = ($null -ne (Get-AutomateNOWNotificationChannel -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWNotificationChannel failed to check if the Notification Channel [$NewId] already existed due to [$Message]."
            Break
        }
        If ($NotificationChannel_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Notification Channel named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End warning ##
        [string]$command = '/notificationChannel/copy'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            [string]$NotificationChannel_oldId = $NotificationChannel.id
            [string]$NotificationChannel_simpleId = $NotificationChannel.simpleId
            If ($NotificationChannel_oldId -eq $NewId) {
                Write-Warning -Message "The new id cannot be the same as the old id."
                Break
            }
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Copy the Notification Channel $($NotificationChannel_simpleId) to $($NewId)?")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                If ($UnsetFolder -eq $True) {
                    $BodyMetaData.'folder' = $Null
                }
                ElseIf ($Folder.Length -gt 0) {
                    $BodyMetaData.'folder' = $Folder
                }
                Else {
                    If ($NotificationChannel.folder.Length -gt 0) {
                        $BodyMetaData.'folder' = $NotificationChannel.folder
                    }
                }
                If ($Tags.Count -gt 0) {
                    [int32]$tag_count = 1
                    ForEach ($tag in $Tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
                ElseIf ($UnsetTags -eq $true) {
                    $BodyMetaData.'tags' = $Null
                }
                Else {
                    If ($NotificationChannel.Tags -gt 0) {
                        [int32]$tag_count = 1
                        ForEach ($tag in $NotificationChannel.tags) {
                            $BodyMetaData.('tags' + $tag_count ) = $tag
                            $tag_count++
                        }
                    }
                }
                $BodyMetaData.'oldId' = $NotificationChannel_oldId
                $BodyMetaData.'domain' = $NotificationChannel.domain
                $BodyMetaData.'id' = $NewId
                If ($UnsetDescription -ne $true) {
                    If ($Description.Length -gt 0) {
                        $BodyMetaData.'description' = $Description
                    }
                    Else {
                        $BodyMetaData.'description' = $NotificationChannel.description
                    }
                }
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_operationId' = 'copy'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_dataSource' = 'NotificationChannelDataSource'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties oldId, domain, NewId, description, folder, tags
                $parameters.Body = $Body
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$NotificationChannel_oldId] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                $Error.Clear()
                Try {
                    [ANOWNotificationChannel]$NewNotificationChannel = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to create copied [ANOWNotificationChannel] object [$NewId] due to [$Message]."
                    Break
                }
                If ($NewNotificationChannel.id.Length -eq 0) {
                    Write-Warning -Message "Somehow the newly created (copied) [ANOWNotificationChannel] object [$NewId] is empty!"
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $NewNotificationChannel
                }
            }
        }
    }
    End {

    }
}

Function Rename-AutomateNOWNotificationChannel {
    <#
    .SYNOPSIS
    Renames a Notification Channel on an AutomateNOW! instance

    .DESCRIPTION
    Performs a psuedo-rename operations of a NotificationG roup from an AutomateNOW! instance by copying it first and then deleting the source. This function merely combines Copy-AutomateNOWNotificationChannel and Remove-AutomateNOWNotificationChannel therefore it is to be considered destructive.

    .PARAMETER NotificationChannel
    An [ANOWNotificationChannel] object representing the Notification Channel to be renamed.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the Notification Channel. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER Force
    Force the renaming without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly renamed object.

    .INPUTS
    ONLY [ANOWNotificationChannel] objects are accepted. There is intentionally no support for the pipeline.

    .OUTPUTS
    The newly renamed [ANOWNotificationChannel] object will be returned.

    .EXAMPLE
    $NotificationChannel = Get-AutomateNOWNotificationChannel -Id 'NotificationChannel01'
    Rename-AutomateNOWNotificationChannel -NotificationChannel $NotificationChannel -NewId 'NotificationChannel_01'

    .EXAMPLE
    Rename-AutomateNOWNotificationChannel -NotificationChannel (Get-AutomateNOWNotificationChannel -Id 'NotificationChannel01') -NewId 'NotificationChannel_01'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    When renaming, you may only specify a different Id (name).

    This action will be blocked if any existing referrals are found on the object.
    #>
    [OutputType([ANOWNotificationChannel])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWNotificationChannel]$NotificationChannel,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin standard warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$new_NotificationChannel_exists = ($null -ne (Get-AutomateNOWNotificationChannel -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWNotificationChannel failed to check if the Notification Channel [$NewId] already existed due to [$Message]."
            Break
        }
        If ($new_NotificationChannel_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Notification Channel named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        #[string]$NotificationChannel_id = $NotificationChannel.id
        [string]$NotificationChannel_id = $NotificationChannel.simpleId
        $Error.Clear()
        Try {
            [boolean]$old_NotificationChannel_exists = ($null -ne (Get-AutomateNOWNotificationChannel -Id $NotificationChannel_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWNotificationChannel failed to check if the Notification Channel [$NotificationChannel_id] already existed due to [$Message]."
            Break
        }
        If ($old_NotificationChannel_exists -eq $false) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not a Notification Channel named [$NotificationChannel_id] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End standard warning ##
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($NotificationChannel_id)")) -eq $true) {
                $Error.Clear()
                Try {
                    [ANOWNotificationChannel]$new_NotificationChannel = Copy-AutomateNOWNotificationChannel -NotificationChannel $NotificationChannel -NewId $NewId -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Copy-AutomateNOWNotificationChannel failed to create a new Notification Channel [$NewId] as Part 1 of the renaming process due to [$Message]."
                    Break
                }
                If ($new_NotificationChannel.simpleId -eq $NewId) {
                    Write-Verbose -Message "Part 1: Notification Channel [$NotificationChannel_id] successfully copied to [$NewId]"
                }
                Else {
                    Write-Warning -Message "Somehow the first phase (Copy-AutomateNOWNotificationChannel) failed. Please look into this."
                    Break
                }
                $Error.Clear()
                Try {
                    Remove-AutomateNOWNotificationChannel -NotificationChannel $NotificationChannel -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Remove-AutomateNOWNotificationChannel failed to remove [$NotificationChannel_id] as Part 2 of the renaming process due to [$Message]."
                    Break
                }
                Write-Verbose -Message "Part 2: Notification Channel [$NotificationChannel_id] removed"
                Write-Verbose -Message "Task [$NotificationChannel_id] successfully renamed to [$NewId]"
                If ($Quiet -ne $true) {
                    Return $new_NotificationChannel
                }
            }
        }
        Else {
            Write-Warning -Message "No action was taken because either the source object didn't exist or the new object already existed"
        }
    }
    End {
    }
}

#endregion

#Region - Notification Group

Function Get-AutomateNOWNotificationGroup {
    <#
    .SYNOPSIS
    Gets the Notification Groups from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Notification Groups from an AutomateNOW! instance

    .PARAMETER Id
    Optional string containing the simple id of the Notification Group to fetch or you can pipeline a series of simple id strings. You may not enter an array here.

    .PARAMETER sortBy
    Optional string parameter to sort the results by. Valid choices are: id {To be continued...}

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER Folder
    Optional string to filter by a particular Folder

    .PARAMETER Tags
    Optional string array of Tags to filter by. Note that the 'containsAny' operator will be used.

    .INPUTS
    Accepts a string representing the simple id of the Notification Group from the pipeline or individually (but not an array).

    .OUTPUTS
    An array of one or more [ANOWNotificationGroup] class objects

    .EXAMPLE
    Gets the first page of Notification Group objects

    Get-AutomateNOWNotificationGroup

    .EXAMPLE
    Gets a single Notification Group object named 'NotificationGroup1'

    Get-AutomateNOWNotificationGroup -Id 'NotificationGroup1'

    .EXAMPLE
    Gets a series of Notification Groups from an array of strings sent across the pipeline

    'NotificationGroup1', 'NotificationGroup2' | Get-AutomateNOWNotificationGroup

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWNotificationGroup[]])]
    [Cmdletbinding(DefaultParameterSetName = 'Default')]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $False, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$sortBy = 'id',
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$Descending,
        [Parameter(Mandatory = $False)]
        [string]$Folder,
        [Parameter(Mandatory = $False)]
        [string[]]$Tags
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 -or $Id.Length -gt 0) {
            If ($_.Length -gt 0 ) {
                [string]$NotificationGroup_name = $_
            }
            Else {
                [string]$NotificationGroup_name = $Id
            }
            $Body.'id' = $NotificationGroup_name
        }
        Else {
            $Body.'operator' = 'and'
            $Body.'_constructor' = 'AdvancedCriteria'
            If ($Folder.Length -gt 0) {
                $Body.'criteria1' = ('{"fieldName":"folder","operator":"equals","value":"' + $Folder + '"}')
            }
            If ($Tags.Count -gt 0) {
                If ($Tags.Count -gt 1) {
                    $Error.Clear()
                    Try {
                        [string]$TagString = $Tags | ConvertTo-Json -Compress
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "ConvertTo-Json failed to convert the provided tag names under Get-AutomateNOWNotificationGroup due to [$Message]."
                        Break
                    }
                }
                Else {
                    [string]$TagString = $Tags
                }
                $Body.'criteria2' = ('{"fieldName":"tags","operator":"containsAny","value":' + $TagString + '}')
            }
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
        }
        $Body.'_operationType' = 'fetch'
        $Body.'_textMatchStyle' = 'exactCase'
        $Body.'_operationId' = 'Read'
        $Body.'_dataSource' = 'NotificationGroupDataSource'
        If ($Descending -eq $true) {
            $Body.'_sortBy' = '-' + $sortBy
        }
        Else {
            $Body.'_sortBy' = $sortBy
        }
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/notificationGroup/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWNotificationGroup[]]$NotificationGroups = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWNotificationGroup] objects due to [$Message]."
            Break
        }
        If ($NotificationGroups.Count -gt 0) {
            Return $NotificationGroups
        }
    }
    End {

    }
}

Function Set-AutomateNOWNotificationGroup {
    <#
    .SYNOPSIS
    Changes the settings of a Notification Group on an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of a Notification Group on an AutomateNOW! instance

    .PARAMETER NotificationGroup
    An [ANOWNotificationGroup] object representing the Notification Group to be changed.

    .PARAMETER Description
    A text description of at least 1 character.

    .PARAMETER UnsetDescription
    Unsets (removes) the description of the Notification Group.

    .PARAMETER UnsetFolder
    Switch parameter that will remove the Notification Group from its current folder.

    .PARAMETER Folder
    String that specifies the name of the folder object to place the Notification Group into.

    .PARAMETER UnsetTags
    Switch parameter that will remove all tags from the Notification Group.

    .PARAMETER Tag
    String array that specifies the name(s) of the Tag to apply to the Notification Group.

    .PARAMETER CodeRepository
    Optional Code Repository to place the Notification Group into. Use Get-AutomateNOWCodeRepository to fetch this object.

    .PARAMETER UnsetCodeRepository
    Switch parameter that will remove the the Notification Group from its Code Repository.

    .PARAMETER Quiet
    Switch parameter that silences the output of the updated object.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWNotificationGroup] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWNotificationGroup] object will be returned

    .EXAMPLE
    Forcibly Sets the description on a Notification Group
    Set-AutomateNOWNotificationGroup -NotificationGroup $NotificationGroup -Description 'My Description' -Force

    .EXAMPLE
    Unsets the description on a Notification Group
    Set-AutomateNOWNotificationGroup -NotificationGroup $NotificationGroup -UnsetDescription

    .EXAMPLE
    Sets the tags and folder for a Notification Group
    Set-AutomateNOWNotificationGroup -NotificationGroup $NotificationGroup -Tags 'Tag1', 'Tag2' -Folder 'Folder1'

    .EXAMPLE
    Forcibly unsets the tags for a Notification Group
    Set-AutomateNOWNotificationGroup -NotificationGroup $NotificationGroup -UnsetTags -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWNotificationGroup])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWNotificationGroup]$NotificationGroup,
        [ValidateScript({ $_.Length -le 255 })]
        [Parameter(Mandatory = $false, HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetCodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }

        If ($Description.Length -gt 0 -and $UnsetDescription -eq $true) {
            Write-Warning -Message 'You cannot set the Description and unset it at the same time. Please choose one or the other.'
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Exit
        }
        If ($Tags.count -gt 0 -and $UnsetTags -eq $true) {
            Write-Warning -Message "You cannot set the tags and unset them at the same time. Please choose one or the other."
        }
        If ($UnsetCodeRepository -eq $true -and $CodeRepository.Id.Length -gt 0) {
            Write-Warning -Message "You cannot unset the Code Repository and set it at the same time. Please choose one or the other."
            Break
        }
        [string]$command = '/notificationGroup/update'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWNotificationGroup]$NotificationGroup = $_
        }
        [string]$NotificationGroup_id = $NotificationGroup.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($NotificationGroup_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$NotificationGroup_exists = ($null -eq (Get-AutomateNOWNotificationGroup -Id $NotificationGroup_id))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWNotificationGroup failed to check if the Notification Group [$NotificationGroup_id] already existed due to [$Message]."
                Break
            }
            If ($NotificationGroup_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not a Notification Group named [$NotificationGroup_id] in the current domain [$current_domain]. Please check into this."
                Break
            }
            ## End warning ##
            [System.Collections.ArrayList]$include_properties = [System.Collections.ArrayList]@()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $NotificationGroup_id
            If ($Description.Length -gt 0) {
                $BodyMetaData.'description' = $Description
            }
            ElseIf ($UnsetDescription -eq $true) {
                $BodyMetaData.'description' = $null
                $include_properties += 'description'
            }
            ElseIf ($DataSource.description.length -gt 0) {
                $BodyMetaData.'description' = $DataSource.description
                $include_properties += 'description'
            }
            If ($Folder.Length -gt 0) {
                $Error.Clear()
                Try {
                    [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the Folder [$Folder] actually existed while running under Set-AutomateNOWNotificationGroup due to [$Message]"
                    Break
                }
                If ($folder_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] running under Set-AutomateNOWNotificationGroup. Please check again."
                    Break
                }
                [string]$folder_display = $folder_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Adding Notification Group [$NotificationGroup_id] to Folder $folder_display"
                $BodyMetaData.'folder' = $Folder
                $include_properties += 'folder'
            }
            ElseIf ($UnsetFolder -eq $true) {
                [string]$folder_display = $folder_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Removing Notification Group [$NotificationGroup_id] from Folder $folder_display"
                $BodyMetaData.'folder' = $null
                $include_properties += 'folder'
            }
            If ($Tags.Count -gt 0) {
                [int32]$total_tags = $Tags.Count
                [int32]$current_tag = 1
                ForEach ($tag_id in $Tags) {
                    $Error.Clear()
                    Try {
                        [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] running under Set-AutomateNOWNotificationGroup due to [$message]"
                        Break
                    }
                    If ($tag_object.simpleId.length -eq 0) {
                        Write-Warning -Message "Set-AutomateNOWNotificationGroup has detected that the tag [$tag_id] does not appear to exist. Please check again."
                        Break
                    }
                    ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                        [string]$tag_object_simpleId = $tag_object.simpleId
                        Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                        Break
                    }
                    [string]$tag_display = $tag_object | ConvertTo-Json -Compress
                    Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
                    [string]$tag_name_sequence = ('tags' + $current_tag)
                    $BodyMetaData.Add($tag_name_sequence, $tag_id)
                    $include_properties += $tag_name_sequence
                    $current_tag++
                }
            }
            ElseIf ($UnsetTags -eq $true) {
                [string]$tags_display = ($NotificationGroup.tags) | ConvertTo-Json -Compress
                Write-Verbose -Message "Removing tags [$tags_display] from $NotificationGroup_id"
                $BodyMetaData.'tags' = $null
                $include_properties += 'tags'
            }
            If ($CodeRepository.Id.Length -gt 0) {
                [string]$CodeRepository_Id = $CodeRepository.Id
                $Error.Clear()
                Try {
                    [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository_Id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository_Id] actually existed under Set-AutomateNOWNotificationGroup due to [$Message]"
                    Break
                }
                If ($code_repository_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository_Id] under Set-AutomateNOWNotificationGroup. Please check again."
                    Break
                }
                $BodyMetaData.'codeRepository' = $CodeRepository_Id
            }
            ElseIf ($UnsetCodeRepository -eq $true) {
                $BodyMetaData.'codeRepository' = $null
            }
            $BodyMetaData.'_oldValues' = $NotificationGroup.CreateOldValues()
            $BodyMetaData.'_operationType' = 'update'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_dataSource' = 'NotificationGroupDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$DataSource_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Notification Group [$NotificationGroup_id] was successfully updated"
            $Error.Clear()
            Try {
                [ANOWNotificationGroup]$UpdatedNotificationGroup = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the returned updated object to an [ANOWNotificationGroup] object due to [$Message]. The object was still updated though."
                Break
            }
            If ($Quiet -ne $true) {
                Return $UpdatedNotificationGroup
            }
        }
    }
    End {
    }
}

Function Export-AutomateNOWNotificationGroup {
    <#
    .SYNOPSIS
    Exports the Notification Groups from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Notification Groups from an instance of AutomateNOW! to a local .csv file

    .PARAMETER NotificationGroup
    Mandatory [ANOWNotificationGroup] object (Use Get-AutomateNOWNotificationGroup to retrieve them)

    .INPUTS
    ONLY [ANOWNotificationGroup] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWNotificationGroup] objects are exported to the local disk in CSV format

    .EXAMPLE
    Get-AutomateNOWNotificationGroup | Export-AutomateNOWNotificationGroup

    .EXAMPLE
    Get-AutomateNOWNotificationGroup -Id 'NotificationGroup01' | Export-AutomateNOWNotificationGroup

    .EXAMPLE
    @( 'NotificationGroup01', 'NotificationGroup02' ) | Get-AutomateNOWNotificationGroup | Export-AutomateNOWNotificationGroup

    .EXAMPLE
    Get-AutomateNOWNotificationGroup | Where-Object { $_.simpleId -eq 'NotificationGroup01' } | Export-AutomateNOWNotificationGroup

    .NOTES
	You must present [ANOWNotificationGroup] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWNotificationGroup]$NotificationGroup
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-NotificationGroups-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWNotificationGroup]$NotificationGroup = $_
        }
        $Error.Clear()
        Try {
            $NotificationGroup | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWNotificationGroup] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function New-AutomateNOWNotificationGroup {
    <#
    .SYNOPSIS
    Creates a Notification Group within an AutomateNOW! instance

    .DESCRIPTION
    Creates a Notification Group within an AutomateNOW! instance and returns back the newly created [ANOWNotificationGroup] object

    .PARAMETER Id
    The intended name of the Notification Group. For example: 'LinuxNotificationGroup1'. This value may not contain the domain in brackets.

    .PARAMETER Description
    Optional description of the Notification Group (may not exceed 255 characters).

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new Notification Group.

    .PARAMETER Folder
    Optional name of the folder to place the DataSource into.

    .PARAMETER CodeRepository
    Optional name of the code repository to place the Notification Group into.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWNotificationGroup.

    .OUTPUTS
    An [ANOWNotificationGroup] object representing the newly created Notification Group

    .EXAMPLE
    New-AutomateNOWNotificationGroup -Id 'NotificationGroup1' -Description 'NotificationGroup1 description' -Tags 'Tag1', 'Tag2' -Folder 'Folder1' -codeRepository 'Repository1'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The name (id) of the Notification Group must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    #>
    [OutputType([ANOWNotificationGroup])]
    [Cmdletbinding()]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $true)]
        [string]$Id,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [string]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [boolean]$NotificationGroup_exists = ($null -ne (Get-AutomateNOWNotificationGroup -Id $Id))
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWNotificationGroup failed to check if the Notification Group [$Id] already existed due to [$Message]."
        Break
    }
    If ($NotificationGroup_exists -eq $true) {
        [string]$current_domain = $anow_session.header.domain
        Write-Warning -Message "There is already a Notification Group named [$Id] in [$current_domain]. Please check into this."
        Break
    }
    ## End warning ##
    [System.Collections.Specialized.OrderedDictionary]$ANOWNotificationGroup = [System.Collections.Specialized.OrderedDictionary]@{}
    $ANOWNotificationGroup.Add('id', $Id)
    If ($Description.Length -gt 0) {
        $ANOWNotificationGroup.Add('description', $Description)
    }
    If ($Tags.Count -gt 0) {
        [int32]$total_tags = $Tags.Count
        [int32]$current_tag = 1
        ForEach ($tag_id in $Tags) {
            $Error.Clear()
            Try {
                [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] under New-AutomateNOWNotificationGroup due to [$message]"
                Break
            }
            If ($tag_object.simpleId.length -eq 0) {
                Throw "New-AutomateNOWNotificationGroup has detected that the tag [$tag_id] does not appear to exist. Please check again."
                Break
            }
            ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                [string]$tag_object_simpleId = $tag_object.simpleId
                Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                Break
            }
            [string]$tag_display = $tag_object | ConvertTo-Json -Compress
            Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
            [string]$tag_name_sequence = ('tags' + $current_tag)
            $ANOWNotificationGroup.Add($tag_name_sequence, $tag_id)
            $include_properties += $tag_name_sequence
            $current_tag++
        }
    }
    If ($Folder.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] actually existed under New-AutomateNOWNotificationGroup due to [$Message]"
            Break
        }
        If ($folder_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] under New-AutomateNOWNotificationGroup. Please check again."
            Break
        }
        [string]$folder_display = $folder_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding folder $folder_display to Notification Group [$Id]"
        $ANOWNotificationGroup.Add('folder', $Folder)
        $include_properties += 'folder'
    }
    If ($CodeRepository.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository] actually existed under New-AutomateNOWNotificationGroup due to [$Message]"
            Break
        }
        If ($code_repository_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository] under New-AutomateNOWNotificationGroup. Please check again."
            Break
        }
        [string]$code_repository_display = $code_repository_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding code repository $code_repository_display to Notification Group [$Id]"
        $ANOWNotificationGroup.Add('codeRepository', $CodeRepository)
        $include_properties += 'codeRepository'
    }
    [string]$BodyObject = ConvertTo-QueryString -InputObject $ANOWNotificationGroup -IncludeProperties id, description, tags, folder, codeRepository
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    $BodyMetaData.'_operationType' = 'add'
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_oldValues' = '{}'
    $BodyMetaData.'_componentId' = 'NotificationGroupCreateWindow_form'
    $BodyMetaData.'_dataSource' = 'NotificationGroupDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$BodyMetaDataString = ConvertTo-QueryString -InputObject $BodyMetaData
    [string]$Body = ($BodyObject + '&' + $BodyMetaDataString)
    [string]$command = '/notificationGroup/create'
    [hashtable]$parameters = @{}
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('Body', $Body)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWNotificationGroup]$NotificationGroup = $results.response.data | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to parse the response into a valid [ANOWNotificationGroup] object due to [$Message]."
        Break
    }
    If ($NotificationGroup.id.Length -eq 0) {
        Write-Warning -Message "Somehow the newly created [ANOWNotificationGroup] object is empty!"
        Break
    }
    Return $NotificationGroup
}

Function Remove-AutomateNOWNotificationGroup {
    <#
    .SYNOPSIS
    Removes a Notification Group from an AutomateNOW! instance

    .DESCRIPTION
    Removes a Notification Group from an AutomateNOW! instance

    .PARAMETER NotificationGroup
    An [ANOWNotificationGroup] object representing the Notification Group to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWNotificationGroup] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Get-AutomateNOWNotificationGroup -Id 'NotificationGroup01' | Remove-AutomateNOWNotificationGroup

    .EXAMPLE
    @( 'NotificationGroup1', 'NotificationGroup2', 'NotificationGroup3') | Remove-AutomateNOWNotificationGroup

    .EXAMPLE
    Get-AutomateNOWNotificationGroup | ? { $_.simpleId -like 'test*' } | Remove-AutomateNOWNotificationGroup

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWNotificationGroup]$NotificationGroup,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/notificationGroup/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWNotificationGroup]$NotificationGroup = $_
        }
        [string]$NotificationGroup_id = $NotificationGroup.id
        If ($NotificationGroup_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($NotificationGroup_id)")) -eq $true) {
            [string]$oldvalues = $NotificationGroup.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $NotificationGroup_id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'NotificationGroupList'
            $BodyMetaData.'_dataSource' = 'NotificationGroupDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$NotificationGroup_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Notification Group $NotificationGroup_id successfully removed"
        }
    }
    End {

    }
}

Function Copy-AutomateNOWNotificationGroup {
    <#
    .SYNOPSIS
    Copies a Notification Group from an AutomateNOW! instance

    .DESCRIPTION
    Copies a Notification Group from an AutomateNOW! instance.

    .PARAMETER NotificationGroup
    Mandatory [ANOWNotificationGroup] object to be copied.

    .PARAMETER NewId
    The name (Id) of the new Notification Group. The new Id must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    .PARAMETER UnsetDescription
    Optional switch that will ensure that the newly created Notificatio nGroup will not have a description set.

    .PARAMETER Description
    Optional description to set on the new Notification Group object. If you do not set this, the new Notificatio nGroup object will copy the Description of the source object.

    .PARAMETER UnsetFolder
    Optional switch that will ensure that the newly created Notification Group will not have a Folder set.

    .PARAMETER Folder
    Optional description to set a different folder on the new Notification Group object. If you do not set this, the new Notification Group object will use the same Folder of the source object.

    .PARAMETER UnsetTags
    Optional switch that will ensure that the newly created Notification Group will not have any Tags set.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the new Notification Group object. If you do not set this, the new Notification Group object will apply the same Tags of the source object.

    .PARAMETER Force
    Force the copy without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    ONLY [ANOWNotificationGroup] object is accepted. Pipeline support is intentionally unavailable.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Creates a copy of a Notification Group and changes the description (multi-line format)
    $NotificationGroup01 = Get-AutomateNOWNotificationGroup -Id 'NotificationGroup_01'
    Copy-AutomateNOWNotificationGroup -NotificationGroup $NotificationGroup01 -NewId 'NotificationGroup_01_production' -Description 'NotificationGroup 01 Production'

    .EXAMPLE
    Creates a copy of a Notification Group that omits the description (one-liner format)
    Copy-AutomateNOWNotificationGroup -NotificationGroup (Get-AutomateNOWNotificationGroup -Id 'NotificationGroup_01') -NewId 'NotificationGroup_01_production' -UnsetDescription -Tags 'Tag1', 'Tag2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWNotificationGroup]$NotificationGroup,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot set the Tags and unset them at the same time. Please choose one or the other. Tags from the source object will be carried over to the new object if you do not specify any tag-related parameters."
            Break
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$NotificationGroup_exists = ($null -ne (Get-AutomateNOWNotificationGroup -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWNotificationGroup failed to check if the Notification Group [$NewId] already existed due to [$Message]."
            Break
        }
        If ($NotificationGroup_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Notification Group named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End warning ##
        [string]$command = '/notificationGroup/copy'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            [string]$NotificationGroup_oldId = $NotificationGroup.id
            [string]$NotificationGroup_simpleId = $NotificationGroup.simpleId
            If ($NotificationGroup_oldId -eq $NewId) {
                Write-Warning -Message "The new id cannot be the same as the old id."
                Break
            }
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Copy the Notification Group $($NotificationGroup_simpleId) to $($NewId)?")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                If ($UnsetFolder -eq $True) {
                    $BodyMetaData.'folder' = $Null
                }
                ElseIf ($Folder.Length -gt 0) {
                    $BodyMetaData.'folder' = $Folder
                }
                Else {
                    If ($NotificationGroup.folder.Length -gt 0) {
                        $BodyMetaData.'folder' = $NotificationGroup.folder
                    }
                }
                If ($Tags.Count -gt 0) {
                    [int32]$tag_count = 1
                    ForEach ($tag in $Tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
                ElseIf ($UnsetTags -eq $true) {
                    $BodyMetaData.'tags' = $Null
                }
                Else {
                    If ($NotificationGroup.Tags -gt 0) {
                        [int32]$tag_count = 1
                        ForEach ($tag in $NotificationGroup.tags) {
                            $BodyMetaData.('tags' + $tag_count ) = $tag
                            $tag_count++
                        }
                    }
                }
                $BodyMetaData.'oldId' = $NotificationGroup_oldId
                $BodyMetaData.'domain' = $NotificationGroup.domain
                $BodyMetaData.'id' = $NewId
                If ($UnsetDescription -ne $true) {
                    If ($Description.Length -gt 0) {
                        $BodyMetaData.'description' = $Description
                    }
                    Else {
                        $BodyMetaData.'description' = $NotificationGroup.description
                    }
                }
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_operationId' = 'copy'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_dataSource' = 'NotificationGroupDataSource'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties oldId, domain, NewId, description, folder, tags
                $parameters.Body = $Body
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$NotificationGroup_oldId] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                $Error.Clear()
                Try {
                    [ANOWNotificationGroup]$NewNotificationGroup = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to create copied [ANOWNotificationGroup] object [$NewId] due to [$Message]."
                    Break
                }
                If ($NewNotificationGroup.id.Length -eq 0) {
                    Write-Warning -Message "Somehow the newly created (copied) [ANOWNotificationGroup] object [$NewId] is empty!"
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $NewNotificationGroup
                }
            }
        }
    }
    End {

    }
}

Function Rename-AutomateNOWNotificationGroup {
    <#
    .SYNOPSIS
    Renames a Notification Group on an AutomateNOW! instance

    .DESCRIPTION
    Performs a psuedo-rename operations of a NotificationG roup from an AutomateNOW! instance by copying it first and then deleting the source. This function merely combines Copy-AutomateNOWNotificationGroup and Remove-AutomateNOWNotificationGroup therefore it is to be considered destructive.

    .PARAMETER NotificationGroup
    An [ANOWNotificationGroup] object representing the Notification Group to be renamed.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the Notification Group. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER Force
    Force the renaming without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly renamed object.

    .INPUTS
    ONLY [ANOWNotificationGroup] objects are accepted. There is intentionally no support for the pipeline.

    .OUTPUTS
    The newly renamed [ANOWNotificationGroup] object will be returned.

    .EXAMPLE
    $NotificationGroup = Get-AutomateNOWNotificationGroup -Id 'NotificationGroup01'
    Rename-AutomateNOWNotificationGroup -NotificationGroup $NotificationGroup -NewId 'NotificationGroup_01'

    .EXAMPLE
    Rename-AutomateNOWNotificationGroup -NotificationGroup (Get-AutomateNOWNotificationGroup -Id 'NotificationGroup01') -NewId 'NotificationGroup_01'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    When renaming, you may only specify a different Id (name).

    This action will be blocked if any existing referrals are found on the object.
    #>
    [OutputType([ANOWNotificationGroup])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWNotificationGroup]$NotificationGroup,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin standard warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$new_NotificationGroup_exists = ($null -ne (Get-AutomateNOWNotificationGroup -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWNotificationGroup failed to check if the Notification Group [$NewId] already existed due to [$Message]."
            Break
        }
        If ($new_NotificationGroup_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Notification Group named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        #[string]$NotificationGroup_id = $NotificationGroup.id
        [string]$NotificationGroup_id = $NotificationGroup.simpleId
        $Error.Clear()
        Try {
            [boolean]$old_NotificationGroup_exists = ($null -ne (Get-AutomateNOWNotificationGroup -Id $NotificationGroup_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWNotificationGroup failed to check if the Notification Group [$NotificationGroup_id] already existed due to [$Message]."
            Break
        }
        If ($old_NotificationGroup_exists -eq $false) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not a Notification Group named [$NotificationGroup_id] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End standard warning ##
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($NotificationGroup_id)")) -eq $true) {
                $Error.Clear()
                Try {
                    [ANOWNotificationGroup]$new_NotificationGroup = Copy-AutomateNOWNotificationGroup -NotificationGroup $NotificationGroup -NewId $NewId -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Copy-AutomateNOWNotificationGroup failed to create a new Notification Group [$NewId] as Part 1 of the renaming process due to [$Message]."
                    Break
                }
                If ($new_NotificationGroup.simpleId -eq $NewId) {
                    Write-Verbose -Message "Part 1: Notification Group [$NotificationGroup_id] successfully copied to [$NewId]"
                }
                Else {
                    Write-Warning -Message "Somehow the first phase (Copy-AutomateNOWNotificationGroup) failed. Please look into this."
                    Break
                }
                $Error.Clear()
                Try {
                    Remove-AutomateNOWNotificationGroup -NotificationGroup $NotificationGroup -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Remove-AutomateNOWNotificationGroup failed to remove [$NotificationGroup_id] as Part 2 of the renaming process due to [$Message]."
                    Break
                }
                Write-Verbose -Message "Part 2: Notification Group [$NotificationGroup_id] removed"
                Write-Verbose -Message "Task [$NotificationGroup_id] successfully renamed to [$NewId]"
                If ($Quiet -ne $true) {
                    Return $new_NotificationGroup
                }
            }
        }
        Else {
            Write-Warning -Message "No action was taken because either the source object didn't exist or the new object already existed"
        }
    }
    End {
    }
}

#endregion

#Region - Notification Group Member

Function Get-AutomateNOWNotificationGroupMember {
    <#
    .SYNOPSIS
    Gets the members of a Notification Group from an AutomateNOW! instance

    .DESCRIPTION
    Gets the members of a Notification Group from an AutomateNOW! instance

    .PARAMETER NotificationGroup
    Mandatory [ANOWNotificationGroup] object (Use Get-AutomateNOWNotificationGroup to retrieve them)

    .PARAMETER Id
    Optional string containing the literal id of the member (36-character guid)

    .PARAMETER MemberName
    Optional string containing the "name" of the member.

    .PARAMETER sortBy
    Optional string parameter to sort the results by. Valid choices are: id {To be continued...}

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .INPUTS
    Always accepts an [ANOWNotificationGroup] object individually. However [ANOWNotificationGroup] objects can only be sent across the pipeline when the -MemberName is not specified.

    .OUTPUTS
    An array of one or more [ANOWNotificationGroupMember] objects

    .EXAMPLE
    Gets the first 1000 members of a Notification Group

    Get-AutomateNOWNotificationGroup -Id 'Group1' | Get-AutomateNOWNotificationGroupMember

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Specifying the "name" of the user with -MemberName requires that the Notification Group object be included with the -NotificationGroup parameter aswell. Be aware that the member name property is NOT UNIQUE so you should plan for the possibility of getting back more then one result. Use the -Id parameter if you want to precisely specify a single member.

    #>
    [OutputType([ANOWNotificationGroupMember[]])]
    [Cmdletbinding(DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $True, ValueFromPipeline = $true)]
        [ANOWNotificationGroup]$NotificationGroup,
        [ValidateScript({ $_ -match '[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}' })]
        [Parameter(Mandatory = $False, ParameterSetName = 'Id')]
        [string]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'MemberName')]
        [string]$MemberName,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$sortBy = 'member',
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$Descending
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Id.Length -gt 0) {
            [ANOWNotificationGroup]$NotificationGroup = $_
        }
        [string]$NotificationGroup_Id = $NotificationGroup.Id
        $Body.'_constructor' = 'AdvancedCriteria'
        $Body.'operator' = 'and'
        If ($Id.Length -gt 0) {
            $Body.'criteria1' = ('{"fieldName":"id","operator":"equals","value":"' + $Id + '"}')
        }
        Else {
            $Body.'criteria1' = ('{"fieldName":"notificationGroup","operator":"equals","value":"' + $NotificationGroup_Id + '"}')
            If ($MemberName.Length -gt 0) {
                $Body.'criteria2' = ('{"fieldName":"member","operator":"equals","value":"' + $MemberName + '"}')
            }
            Else {
                $Body.'_startRow' = $startRow
                $Body.'_endRow' = $endRow
                If ($Descending -eq $true) {
                    $Body.'_sortBy' = '-' + $sortBy
                }
                Else {
                    $Body.'_sortBy' = $sortBy
                }
            }
        }
        $Body.'_operationType' = 'fetch'
        $Body.'_textMatchStyle' = 'exact'
        $Body.'_componentId' = 'NotificationGroupMemberList'
        $Body.'_dataSource' = 'NotificationGroupMemberDataSource'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/notificationGroupMember/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('command', $command)
        }
        Else {
            $parameters.'command' = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [PSCustomObject[]]$response_objects = $results.response.data | ForEach-Object { $_.NotificationGroup = $NotificationGroup; $_; }
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to add the Notification Group to the individual Notification Group Member objects due to [$Message]."
            Break
        }
        $Error.Clear()
        Try {
            [ANOWNotificationGroupMember[]]$NotificationGroupMembers = $response_objects
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response objects into a series of [ANOWNotificationGroupMember] objects due to [$Message]."
            Break
        }
        If ($NotificationGroupMembers.Count -gt 0) {
            Return $NotificationGroupMembers
        }
    }
    End {

    }
}

Function Set-AutomateNOWNotificationGroupMember {
    <#
    .SYNOPSIS
    Changes the settings of a member of a Notification Group on an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of a member of a Notification Group on an AutomateNOW! instance

    .PARAMETER NotificationGroupMember
    An [ANOWNotificationGroupMember] object representing the Notification Group Member to be changed.

    .PARAMETER sendSms
    An optional boolean parameter that enables notifications by SMS to the Notification Group Member. Set to $false to uncheck this box.

    .PARAMETER observer
    An optional switch parameter that enables the "Observer" role for the Notification Group Member. Set to $false to uncheck this box.

    .PARAMETER sendEmail
    An optional boolean parameter that enables notifications by email to the Notification Group Member. Set to $false to uncheck this box.

    .PARAMETER sendOnScreen
    An optional switch parameter (for Internal users only) that enables the notifications by on screen notification to the Notification Group Member. Set to $false to uncheck this box.

    .PARAMETER escalationManager
    An optional switch parameter that enables the "Escalation Manager" role for the Notification Group Member. Set to $false to uncheck this box.

    .PARAMETER dutyManager
    An optional switch parameter that enables the "Duty Manager" role for the Notification Group Member. Set to $false to uncheck this box.

    .PARAMETER Quiet
    Switch parameter that silences the output of the updated object.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    [ANOWNotificationGroupMember] objects must be submitted individually

    .OUTPUTS
    The updated [ANOWNotificationGroupMember] object will be returned

    .EXAMPLE
    Forcibly disables all notification options for an internal user with an Id of '1f67c767-455d-4f59-8f7c-7f868ca928fc'

    Get-AutomateNOWNotificationGroupMember -Id '1f67c767-455d-4f59-8f7c-7f868ca928fc' | Set-AutomateNOWNotificationGroupMember -sendSms $false -observer $false -sendOnScreen $false -sendEmail $false -escalationManager $false -dutyManager $false -Force

    .EXAMPLE
    Enables all notification options for an internal user with an Id of '1f67c767-455d-4f59-8f7c-7f868ca928fc'

    Get-AutomateNOWNotificationGroupMember -Id '1f67c767-455d-4f59-8f7c-7f868ca928fc' | Set-AutomateNOWNotificationGroupMember -sendSms $true -observer $true -sendOnScreen $true -sendEmail $true -escalationManager $true -dutyManager $true

    .EXAMPLE
    Enables all notification options and sets the email + phone for an external user member named 'ExternalUser1' (who is a member of a Notification Group named 'NotificationGroup1')

    Get-AutomateNOWNotificationGroup -Id 'NotificationGroup1' | Get-AutomateNOWNotificationGroupMember -Member 'ExternalUser1' | Set-AutomateNOWNotificationGroupMember -sendSms $true -observer $true -sendEmail $true -escalationManager $true -dutyManager $true -phone '867-5309' -email 'user@contoso.com'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWNotificationGroupMember])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWNotificationGroupMember]$NotificationGroupMember,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$sendSms,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$observer,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$sendEmail,
        [Parameter(Mandatory = $false, ParameterSetName = 'INTERNAL')]
        [Nullable[boolean]]$sendOnScreen,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$escalationManager,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$dutyManager,
        [ValidateScript({ $_.Length -lt 256 -and $_ -match '^[0-9_+\-\.]{1,}$' })] # not my regex
        [Parameter(Mandatory = $false, ParameterSetName = 'EXTERNAL')]
        [string]$phone,
        [Parameter(Mandatory = $false, ParameterSetName = 'EXTERNAL')]
        [switch]$unsetPhone,
        [ValidateScript({ $_.Length -lt 71 -and $_ -match '^([a-zA-Z0-9_#.\-+])+@([_a-zA-Z0-9\-\.])+$' })] # not my regex
        [Parameter(Mandatory = $false, ParameterSetName = 'EXTERNAL')]
        [string]$email,
        [Parameter(Mandatory = $false, ParameterSetName = 'EXTERNAL')]
        [switch]$unsetEmail,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/notificationGroupMember/update'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
        If ($email.Length -gt 0 -and $unsetEmail -eq $true) {
            Write-Warning -Message "You cannot set the email address and unset it at the same time. Please choose one or the other."
        }
        If ($phone.Length -gt 0 -and $unsetPhone -eq $true) {
            Write-Warning -Message "You cannot set the phone and unset it at the same time. Please choose one or the other."
        }
    }
    Process {
        If ($_.Id.Length -gt 0) {
            [ANOWNotificationGroupMember]$NotificationGroupMember = $_
        }
        If ($NotificationGroupMember.NotificationGroup -isnot [ANOWNotificationGroup]) {
            Write-Warning -Message "Unable to extract the Notification Group object from the Notification Group Member"
            Break
        }
        [ANOWNotificationGroup]$NotificationGroup = $NotificationGroupMember.NotificationGroup
        [string]$NotificationGroupMember_id = $NotificationGroupMember.id
        [string]$memberType = $NotificationGroupMember.groupMemberType
        If ($memberType -eq 'INTERNAL') {
            If ($email.Length -gt 0) {
                Write-Warning -Message "You cannot configure the email for internal users. ANOW users are modified with Set-AutomateNOWSecUser (consult with your admin)"
                Break
            }
            ElseIf ($phone.Length -gt 0) {
                Write-Warning -Message "You cannot configure the phone for internal users. ANOW users are modified with Set-AutomateNOWSecUser (consult with your admin)"
                Break
            }
        }
        ElseIf ($memberType -eq 'EXTERNAL') {
            If ($null -ne $sendOnScreen) {
                Write-Warning -Message "You cannot configure On Screen notifications for external users."
                Break
            }
        }
        Else {
            Write-Warning -Message "Somehow could not determine the type of Notification Group Member"
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($NotificationGroupMember_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$NotificationGroupMember_exists = ($null -eq (Get-AutomateNOWNotificationGroupMember -NotificationGroup $NotificationGroup -Id $NotificationGroupMember_id))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWNotificationGroupMember failed to check if the Notification Group Member [$NotificationGroupMember_id] already existed due to [$Message]."
                Break
            }
            If ($NotificationGroupMember_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not a Notification Group Member with Id [$NotificationGroupMember_id] in the current domain [$current_domain]. Please check into this."
                Break
            }
            ## End warning ##
            [string]$old_values = $NotificationGroupMember.CreateOldValues()
            [System.Collections.ArrayList]$include_properties = [System.Collections.ArrayList]@()
            $include_properties += 'description'
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $NotificationGroupMember_id
            If ($null -ne $sendSMS) {
                If ($sendSMS -eq $true) {
                    $BodyMetaData.'sendSms' = 'true'
                }
                Else {
                    $BodyMetaData.'sendSms' = 'false'
                }
            }
            If ($null -ne $observer) {
                If ($observer -eq $true) {
                    $BodyMetaData.'observer' = 'true'
                }
                Else {
                    $BodyMetaData.'observer' = 'false'
                }
            }
            If ($null -ne $sendEmail) {
                If ($sendEmail -eq $true) {
                    $BodyMetaData.'sendEmail' = 'true'
                }
                Else {
                    $BodyMetaData.'sendEmail' = 'false'
                }
            }
            If ($null -ne $escalationManager) {
                If ($escalationManager -eq $true) {
                    $BodyMetaData.'escalationManager' = 'true'
                }
                Else {
                    $BodyMetaData.'escalationManager' = 'false'
                }
            }
            If ($null -ne $dutyManager) {
                If ($dutyManager -eq $true) {
                    $BodyMetaData.'dutyManager' = 'true'
                }
                Else {
                    $BodyMetaData.'dutyManager' = 'false'
                }
            }
            If ($null -ne $sendOnScreen) {
                If ($sendOnScreen -eq $true -and $memberType -eq 'INTERNAL') {
                    $BodyMetaData.'sendOnScreen' = 'true'
                }
                Else {
                    $BodyMetaData.'sendOnScreen' = 'false'
                }
            }
            If ($phone.Length -gt 0 -and $memberType -eq 'EXTERNAL') {
                $BodyMetaData.'phone' = $phone
            }
            ElseIf ($unsetPhone -eq $true -and $memberType -eq 'EXTERNAL') {
                $BodyMetaData.'phone' = $null
            }
            If ($email.Length -gt 0 -and $memberType -eq 'EXTERNAL') {
                $BodyMetaData.'email' = $email
            }
            ElseIf ($unsetEmail -eq $true -and $memberType -eq 'EXTERNAL') {
                $BodyMetaData.'email' = $null
            }
            $BodyMetaData.'_oldValues' = $old_values
            $BodyMetaData.'_operationType' = 'update'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_componentId' = 'NotificationGroupMemberEditForm'
            $BodyMetaData.'_dataSource' = 'NotificationGroupDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties $include_properties
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$DataSource_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Notification Group Member [$NotificationGroupMember_id] was successfully modified"
            $Error.Clear()
            Try {
                [ANOWNotificationGroupMember]$UpdatedNotificationGroupMember = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the returned updated object to an [ANOWNotificationGroupMember] object due to [$Message]. The object was still updated though."
                Break
            }
            If ($Quiet -ne $true) {
                Return $UpdatedNotificationGroupMember
            }
        }
    }
    End {
    }
}

Function Export-AutomateNOWNotificationGroupMember {
    <#
    .SYNOPSIS
    Exports the members of a Notification Group on an instance of AutomateNOW!

    .DESCRIPTION
    Exports the members of a Notification Group on an instance of AutomateNOW!

    .PARAMETER NotificationGroup
    Mandatory [ANOWNotificationGroupMember] object (Use Get-AutomateNOWNotificationGroupMember to retrieve them)

    .INPUTS
    [ANOWNotificationGroupMember] objects individually or from the pipeline are accepted

    .OUTPUTS
    The [ANOWNotificationGroupMember] objects are exported to the local disk in CSV format

    .EXAMPLE
    Exports the members of a Notification Group named 'NotificationGroup1'

    $group = Get-AutomateNOWNotificationGroup -Id 'NotificationGroup1'
    Get-AutomateNOWNotificationGroupMember -NotificationGroup $group | Export-AutomateNOWNotificationGroupMember

    .NOTES
	
    You must present [ANOWNotificationGroupMember] objects to the pipeline to use this function.

    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWNotificationGroupMember]$NotificationGroupMember
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-NotificationGroupMembers-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWNotificationGroupMember]$NotificationGroupMember = $_
        }
        $Error.Clear()
        Try {
            $NotificationGroupMember | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWNotificationGroupMember] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function Add-AutomateNOWNotificationGroupMember {
    <#
    .SYNOPSIS
    Adds a member to a Notification Group on an AutomateNOW! instance

    .DESCRIPTION
    Adds a member to a Notification Group on an AutomateNOW! instance

    .PARAMETER NotificationGroup
    Mandatory [ANOWNotificationGroup] object representing the Notification Group that will gain a member.

    .PARAMETER MemberType
    Mandatory string indicating the type of user. Valid choices are: INTERNAL, EXTERNAL

    .PARAMETER InternalUser
    Mandatory (IF MemberType IS INTERNAL) [ANOWSecUser] object representing the internal user to be added to the Notification Group.

    .PARAMETER ExternalUserName
    Mandatory (IF MemberType IS EXTERNAL) arbitrary string representing the name of the external user. The limit is 255 characters.

    .PARAMETER ExternalUserPhone
    Optional (IF MemberType IS EXTERNAL) string representing the phone number of the external user. Valid characters to use are: 0-9, _, +, - and . The limit is 255 characters.

    .PARAMETER ExternalUserEmail
    Optional (IF MemberType IS EXTERNAL) string representing the email of the external user. The limit is 70 characters.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly added member object.

    .INPUTS
    ONLY [ANOWNotificationGroup] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWNotificationGroup] object will be returned

    .EXAMPLE
    Quietly adds an internal user to a Notification Group called NotificationGroup1

    Add-AutomateNOWNotificationGroupMember -NotificationGroup (Get-AutomateNOWNotificationGroup -Id 'NotificationGroup1') -MemberType Internal -InternalUser (Get-AutomateNOWSecUser -Id 'User1') -Quiet

    .EXAMPLE
    Adds an external user to a Notification Group called NotificationGroup1 with the optional email and phone number properties included.

    Add-AutomateNOWNotificationGroupMember -NotificationGroup (Get-AutomateNOWNotificationGroup -Id 'NotificationGroup1') -MemberType EXTERNAL -ExternalUserName 'ExternalUser1' -ExternalUserPhone '+867-5309' -ExternalUserEmail 'external-user@contoso.com'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Caution: The current design of ANOW allows the same user to be added more then once to the same Notification Group.

    #>
    [Cmdletbinding(DefaultParameterSetName = 'Internal')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWNotificationGroup]$NotificationGroup,
        [Parameter(Mandatory = $true)]
        [ANOWNotificationGroupMember_groupMemberType]$MemberType,
        [Parameter(Mandatory = $true, ParameterSetName = 'Internal', ValueFromPipeline = $True)]
        [ANOWSecUser]$InternalUser,
        [ValidateScript({ $_.Length -lt 256 })]
        [Parameter(Mandatory = $true, ParameterSetName = 'External')]
        [string]$ExternalUserName,
        [ValidateScript({ $_.Length -lt 256 -and $_ -match '^[0-9_+\-\.]{1,}$' })] # not my regex
        [Parameter(Mandatory = $false, ParameterSetName = 'External')]
        [string]$ExternalUserPhone,
        [ValidateScript({ $_.Length -lt 71 -and $_ -match '^([a-zA-Z0-9_#.\-+])+@([_a-zA-Z0-9\-\.])+$' })] # not my regex
        [Parameter(Mandatory = $false, ParameterSetName = 'External')]
        [string]$ExternalUserEmail,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/notificationGroupMember/create'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.Id.Length -gt 0) {
            [ANOWSecUser]$InternalUser = $_
        }
        [string]$InternalUser_id = $InternalUser.Id
        [string]$NotificationGroup_id = $NotificationGroup.id
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$NotificationGroup_exists = ($null -eq (Get-AutomateNOWNotificationGroup -Id $NotificationGroup_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWNotificationGroup failed to check if the Notification Group [$NotificationGroup_id] already existed due to [$Message]."
            Break
        }
        If ($NotificationGroup_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not a Notification Group named [$NotificationGroup_id] in the current domain [$current_domain]. Please check into this."
            Break
        }
        ## End warning ##
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        If ( $MemberType -eq 'INTERNAL') {
            $BodyMetaData.'groupMemberType' = 'INTERNAL'
            [string]$member_name = $InternalUser.Id
            If ($member_name.Length -eq 0) {
                Write-Warning -Message "Somehow the name of the user could not be determined under "
            }
            $BodyMetaData.'member' = $member_name
        }
        ElseIf ( $MemberType -eq 'EXTERNAL') {
            $BodyMetaData.'groupMemberType' = 'EXTERNAL'
            $BodyMetaData.'member' = $ExternalUserName
            If ($ExternalUserPhone.Length -gt 0) {
                $BodyMetaData.'phone' = $ExternalUserPhone
            }
            If ($ExternalUserEmail.Length -gt 0) {
                $BodyMetaData.'email' = $ExternalUserEmail
            }
        }
        Else {
            Write-Warning -Message 'Somehow could not determine the groupMemberType'
            Break
        }
        $BodyMetaData.'notificationGroup' = $NotificationGroup_id
        $BodyMetaData.'_operationType' = 'add'
        $BodyMetaData.'_textMatchStyle' = 'exact'
        $BodyMetaData.'_dataSource' = 'NotificationGroupMemberDataSource'
        $BodyMetaData.'isc_metaDataPrefix' = '_'
        $BodyMetaData.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        If ($null -eq $parameters.Body) {
            $parameters.Add('Body', $Body)
        }
        Else {
            $parameters.Body = $Body
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$NotificationGroup_id] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        [PSCustomObject]$response_object = $results.response.data | Select-Object -First 1
        $response_object.NotificationGroup = $NotificationGroup
        $Error.Clear()
        Try {
            [ANOWNotificationGroupMember]$group_member = $response_object
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Unable to parse the response from Add-AutomateNOWNotificationGroupMember to an [ANOWNotificationGroupMember] object due to [$Message]."
            Break
        }
        If ($group_member.Id.Length -eq 0) {
            Write-Warning -Message "Somehow the returned [ANOWNotificationGroupMember] object was empty"
            Break
        }
        [string]$group_member_id = $group_member.id
        If ($InternalUser_id.Length -gt 0) {
            Write-Verbose -Message "Internal user $group_member_id was added to Notification Group $NotificationGroup_id"
        }
        If ($Quiet -ne $true) {
            Return $group_member
        }
    }
    End {
    }
}

Function Remove-AutomateNOWNotificationGroupMember {
    <#
    .SYNOPSIS
    Removes a member from a Notification Group on an AutomateNOW! instance

    .DESCRIPTION
    Removes a member from a Notification Group on an AutomateNOW! instance

    .PARAMETER NotificationGroup
    Mandatory [ANOWNotificationGroup] object representing the Notification Group that will lose a member.

    .PARAMETER NotificationGroupMember
    Mandatory [ANOWNotificationGroupMember] object representing the member to be removed.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the updated [ANOWNotificationGroupMember]

    .INPUTS
    A [ANOWNotificationGroup] object along with [ANOWNotificationGroupMember] objects that can be sent across the pipeline

    .OUTPUTS
    A verbose informational message will be sent to the host.

    .EXAMPLE
    Forcibly removes all of the members from a Notification Group named 'NotificationGroup1' in one line

    Get-AutomateNOWNotificationGroupMember -NotificationGroup (Get-AutomateNOWNotificationGroup -Id 'NotificationGroup1') | Remove-AutomateNOWNotificationGroupMember -Force

    .EXAMPLE
    Removes a single member named 'User1' from a Notification Group named 'NotificationGroup1'

    $grp = Get-AutomateNOWNotificationGroup -Id 'NotificationGroup1'
    $member = Get-AutomateNOWNotificationGroupMember -NotificationGroup $grp -MemberName 'User1'
    $member | Remove-AutomateNOWNotificationGroupMember -Force

    .EXAMPLE
    Forcibly removes all members from a Notification Group named 'NotificationGroup1'

    Get-AutomateNOWNotificationGroup -Id 'NotificationGroup1' | Get-AutomateNOWNotificationGroupMember | Remove-AutomateNOWNotificationGroupMember -NotificationGroup (Get-AutomateNOWNotificationGroup -Id 'NotificationGroup1') -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWNotificationGroup]$NotificationGroup,
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWNotificationGroupMember]$NotificationGroupMember,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/notificationGroupMember/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.Id.Length -gt 0) {
            [ANOWNotificationGroupMember]$NotificationGroupMember = $_
        }
        [string]$NotificationGroupMember_id = $NotificationGroupMember.id
        If ($NotificationGroupMember_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$NotificationGroupMember_exists = ($null -eq (Get-AutomateNOWNotificationGroupMember -NotificationGroup $NotificationGroup -MemberName $NotificationGroupMember_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWNotificationGroupMember failed to check if the Notification Group Member [$NotificationGroupMember_id] under Remove-AutomateNOWNotificationGroupMember existed due to [$Message]."
            Break
        }
        If ($NotificationGroupMember_exists -ne $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is no Notification Group Member with id [$NotificationGroupMember_id] in the [$current_domain] domain. Please check into this."
            Break
        }
        [string]$NotificationGroupMember_name = $NotificationGroupMember.member
        ## End warning ##
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($NotificationGroupMember_name)")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            [string]$old_values = $NotificationGroupMember.CreateOldValues()
            $BodyMetaData.'id' = $NotificationGroupMember_id
            $BodyMetaData.'_oldValues' = $old_values
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_componentId' = 'NotificationGroupMemberList'
            $BodyMetaData.'_dataSource' = 'NotificationGroupMemberDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$NotificationGroup_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
        }
    }
    End {
    }
}

#endregion

#Region - Notification Message Template

Function Get-AutomateNOWNotificationMessageTemplate {
    <#
    .SYNOPSIS
    Gets the Notification Message Templates from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Notification Message Templates from an AutomateNOW! instance

    .PARAMETER Id
    Optional string containing the simple id of the Notification Message Template to fetch or you can pipeline a series of simple id strings. You may not enter an array here.

    .PARAMETER sortBy
    Optional string parameter to sort the results by. Valid choices are: id {To be continued...}

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER Folder
    Optional string to filter by a particular Folder

    .PARAMETER Tags
    Optional string array of Tags to filter by. Note that the 'containsAny' operator will be used.

    .INPUTS
    Accepts a string representing the simple id of the Notification Message Template from the pipeline or individually (but not an array).

    .OUTPUTS
    An array of one or more [ANOWNotificationMessageTemplate] class objects

    .EXAMPLE
    Gets all Notification Message Templates

    Get-AutomateNOWNotificationMessageTemplate

    .EXAMPLE
    Gets a single Notification Message Template

    Get-AutomateNOWNotificationMessageTemplate -Id 'NotificationMessageTemplate1'

    .EXAMPLE
    Gets a series of Notification Message Templates from an array of strings sent across the pipeline

    @( 'NotificationMessageTemplate1', 'NotificationMessageTemplate2' ) | Get-AutomateNOWNotificationMessageTemplate

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Run this function without parameters to retrieve the first 100 Notification Message Templates.

    #>
    [OutputType([ANOWNotificationMessageTemplate[]])]
    [Cmdletbinding(DefaultParameterSetName = 'Default')]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $False, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$sortBy = 'id',
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$Descending,
        [Parameter(Mandatory = $False)]
        [string]$Folder,
        [Parameter(Mandatory = $False)]
        [string[]]$Tags
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 -or $Id.Length -gt 0) {
            If ($_.Length -gt 0 ) {
                [string]$NotificationMessageTemplate_name = $_
            }
            Else {
                [string]$NotificationMessageTemplate_name = $Id
            }
            $Body.'id' = $NotificationMessageTemplate_name
            [string]$textMatchStyle = 'exactCase'
            $Body.'_operationId' = 'read'
        }
        Else {
            $Body.'operator' = 'and'
            $Body.'_constructor' = 'AdvancedCriteria'
            If ($Folder.Length -gt 0) {
                $Body.'criteria1' = ('{"fieldName":"folder","operator":"equals","value":"' + $Folder + '"}')
            }
            If ($Tags.Count -gt 0) {
                If ($Tags.Count -gt 1) {
                    $Error.Clear()
                    Try {
                        [string]$TagString = $Tags | ConvertTo-Json -Compress
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "ConvertTo-Json failed to convert the provided tag names under Get-AutomateNOWNotificationMessageTemplate due to [$Message]."
                        Break
                    }
                }
                Else {
                    [string]$TagString = $Tags
                }
                $Body.'criteria2' = ('{"fieldName":"tags","operator":"containsAny","value":' + $TagString + '}')
            }
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
            $Body.'_componentId' = 'NotificationMessageTemplateList'
            [string]$textMatchStyle = 'substring'
        }
        $Body.'_textMatchStyle' = $textMatchStyle
        $Body.'_operationType' = 'fetch'
        $Body.'_dataSource' = 'NotificationMessageTemplateDataSource'
        If ($Descending -eq $true) {
            $Body.'_sortBy' = '-' + $sortBy
        }
        Else {
            $Body.'_sortBy' = $sortBy
        }
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/notificationMessageTemplate/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        [PSCustomObject[]]$response_data = ForEach ($response in $results.response.data) {
            If ($response.endpoint.Length -gt 0) {
                $Error.Clear()
                Try {
                    $response.endpoint = Get-AutomateNOWEndpoint -Id ($response.endpoint)
                }
                Catch {
                    [string]$response_endpoint = $response.endpoint
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWEndpoint failed to retrieve [$response_endpoint] under Get-AutomateNOWNotificationMessageTemplate due to [$Message]."
                    Break
                }
            }
            $response
        }
        $Error.Clear()
        Try {
            [ANOWNotificationMessageTemplate[]]$NotificationMessageTemplates = $response_data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWNotificationMessageTemplate] objects due to [$Message]."
            Break
        }
        If ($NotificationMessageTemplates.Count -gt 0) {
            Return $NotificationMessageTemplates
        }
    }
    End {

    }
}

Function Set-AutomateNOWNotificationMessageTemplate {
    <#
    .SYNOPSIS
    Changes the settings of a Notification Message Template on an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of a Notification Message Template on an AutomateNOW! instance

    .PARAMETER NotificationMessageTemplate
    An [ANOWNotificationMessageTemplate] object representing the Notification Message Template to be changed.

    .PARAMETER subject
    An sometimes mandatory string representing the subject (or title) of the Notification Message Template. There is no length check on this parameter since the ANOW application seems to accept unlimited length strings for this property. This parameter is only required when changing the html status, the body or the headers.

    .PARAMETER headers
    An optional hashtable representing the desired headers to be included. See the examples.

    .PARAMETER html
    An optional boolean representing the 'HTML' checkbox. This indicates whether or not any HTML content within the body should be rendered as HTML.

    .PARAMETER body
    An optional string representing the body of the email.

    .PARAMETER Description
    Optional description of the Notification Message Template (may not exceed 255 characters).

    .PARAMETER unSetDescription
    Optional switch to set the Description to Null (blank)

    .PARAMETER Folder
    String that specifies the name of the folder object to place the Notification Message Template into.

    .PARAMETER UnsetFolder
    Switch parameter that will remove the Notification Message Template from its current folder.

    .PARAMETER Tags
    String array that specifies the name(s) of the Tag to apply to the Notification Message Template.

    .PARAMETER UnsetTags
    Switch parameter that will remove all tags from the Notification Message Template.

    .PARAMETER CodeRepository
    Optional Code Repository to place the Notification Message Template into. Use Get-AutomateNOWCodeRepository to fetch this object.

    .PARAMETER UnsetCodeRepository
    Switch parameter that will remove the the Notification Message Template from its Code Repository.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly modified object

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWNotificationMessageTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWNotificationMessageTemplate] object will be returned

    .EXAMPLE
    Forcibly and quietly enables HTML on a Notification Message Template named 'NotificationTemplate1'

    Get-AutomateNOWNotificationMessageTemplate -Id 'NotificationTemplate1' | Set-AutomateNOWNotificationMessageTemplate -html $true -Force -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWNotificationMessageTemplate])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWNotificationMessageTemplate]$NotificationMessageTemplate,
        [ValidateScript({ $_.Length -le 255 })]
        [Parameter(Mandatory = $false, HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$html,
        [Parameter(Mandatory = $false)]
        [string]$subject,
        [Parameter(Mandatory = $false)]
        [hashtable]$headers,
        [Parameter(Mandatory = $false)]
        [string]$body,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetCodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($Description.Length -gt 0 -and $UnsetDescription -eq $true) {
            Write-Warning -Message 'You cannot set the Description and unset it at the same time. Please choose one or the other.'
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($Tags.count -gt 0 -and $UnsetTags -eq $true) {
            Write-Warning -Message "You cannot set the tags and unset them at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetCodeRepository -eq $true -and $CodeRepository.Id.Length -gt 0) {
            Write-Warning -Message "You cannot unset the Code Repository and set it at the same time. Please choose one or the other."
            Break
        }
        [string]$command = '/notificationMessageTemplate/update'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWNotificationMessageTemplate]$NotificationMessageTemplate = $_
        }
        [string]$NotificationMessageTemplate_id = $NotificationMessageTemplate.Id
        [string]$current_NotificationMessageTemplate_body = $NotificationMessageTemplate.body
        If (($subject.Length -eq 0 -and $current_NotificationMessageTemplate_body.Length -eq 0) -and ($null -ne $html -or $Body.length -gt 0 -or $headers.count -gt 0)) {
            Write-Warning -Message "If the HTML setting, the Body or Headers are set (and the current subject/title is currently empty) then the subject/title of the notification must also be included!"
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($NotificationMessageTemplate_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$NotificationMessageTemplate_exists = ($null -eq (Get-AutomateNOWNotificationMessageTemplate -Id $NotificationMessageTemplate_id))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWNotificationMessageTemplate failed to check if the Notification Message Template [$NotificationMessageTemplate_id] already existed due to [$Message]."
                Break
            }
            If ($NotificationMessageTemplate_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not a Notification Message Template named [$NotificationMessageTemplate_id] in the current domain [$current_domain]. Please check into this."
                Break
            }
            ## End warning ##
            [System.Collections.ArrayList]$include_properties = [System.Collections.ArrayList]@()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $NotificationMessageTemplate_id
            If ($Description.Length -gt 0) {
                $BodyMetaData.'description' = $Description
            }
            ElseIf ($UnsetDescription -eq $true) {
                $BodyMetaData.'description' = $null
                $include_properties += 'description'
            }
            ElseIf ($DataSource.description.length -gt 0) {
                $BodyMetaData.'description' = $DataSource.description
                $include_properties += 'description'
            }
            If ($Folder.Length -gt 0) {
                $Error.Clear()
                Try {
                    [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the Folder [$Folder] actually existed while running under Set-AutomateNOWNotificationMessageTemplate due to [$Message]"
                    Break
                }
                If ($folder_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] running under Set-AutomateNOWNotificationMessageTemplate. Please check again."
                    Break
                }
                [string]$folder_display = $folder_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Adding Notification Message Template [$NotificationMessageTemplate_id] to Folder $folder_display"
                $BodyMetaData.'folder' = $Folder
                $include_properties += 'folder'
            }
            ElseIf ($UnsetFolder -eq $true) {
                [string]$folder_display = $folder_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Removing Notification Message Template [$NotificationMessageTemplate_id] from Folder $folder_display"
                $BodyMetaData.'folder' = $null
                $include_properties += 'folder'
            }
            If ($Tags.Count -gt 0) {
                [int32]$total_tags = $Tags.Count
                [int32]$current_tag = 1
                ForEach ($tag_id in $Tags) {
                    $Error.Clear()
                    Try {
                        [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Throw "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] running under Set-AutomateNOWNotificationMessageTemplate due to [$message]"
                        Break
                    }
                    If ($tag_object.simpleId.length -eq 0) {
                        Throw "Set-AutomateNOWNotificationMessageTemplate has detected that the tag [$tag_id] does not appear to exist. Please check again."
                        Break
                    }
                    ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                        [string]$tag_object_simpleId = $tag_object.simpleId
                        Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                        Break
                    }
                    [string]$tag_display = $tag_object | ConvertTo-Json -Compress
                    Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
                    [string]$tag_name_sequence = ('tags' + $current_tag)
                    $BodyMetaData.Add($tag_name_sequence, $tag_id)
                    $include_properties += $tag_name_sequence
                    $current_tag++
                }
            }
            ElseIf ($UnsetTags -eq $true) {
                [string]$tags_display = ($NotificationMessageTemplate.tags) | ConvertTo-Json -Compress
                Write-Verbose -Message "Removing tags [$tags_display] from $NotificationMessageTemplate_id"
                $BodyMetaData.'tags' = $null
                $include_properties += 'tags'
            }
            If ($CodeRepository.Id.Length -gt 0) {
                [string]$CodeRepository_Id = $CodeRepository.Id
                $Error.Clear()
                Try {
                    [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository_Id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository_Id] actually existed under Set-AutomateNOWNotificationMessageTemplate due to [$Message]"
                    Break
                }
                If ($code_repository_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository_Id] under Set-AutomateNOWNotificationMessageTemplate. Please check again."
                    Break
                }
                $BodyMetaData.'codeRepository' = $CodeRepository_Id
            }
            ElseIf ($UnsetCodeRepository -eq $true) {
                $BodyMetaData.'codeRepository' = $null
            }
            If ($headers.count -gt 0) {
                [string]$headers_string = ($headers.GetEnumerator() | ForEach-Object { ($_.key + '=' + $_.value) }) -join "`n"
                $BodyMetaData.'headers' = $headers_string
            }
            $BodyMetaData.'title' = $subject
            If ($body.Length -gt 0) {
                $BodyMetaData.'body' = $body
            }
            If ($html -eq $true) {
                $BodyMetaData.'html' = 'true'
            }
            ElseIf ($html -eq $false) {
                $BodyMetaData.'html' = 'false'
            }
            $include_properties += 'notificationType', 'confirmationTimeLimit', 'emailTo', 'cc', 'bcc', 'attachLogFile', 'confirmationRequired'
            $BodyMetaData.'_oldValues' = $NotificationMessageTemplate.CreateOldValues()
            $BodyMetaData.'_operationType' = 'update'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_componentId' = 'NotificationMessageTemplateVM'
            $BodyMetaData.'_dataSource' = 'NotificationMessageTemplateDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$DataSource_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Notification Message Template [$NotificationMessageTemplate_id] was successfully updated"
            $Error.Clear()
            Try {
                [ANOWNotificationMessageTemplate]$updated_notification_template = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Unable to parse the response from Set-AutomateNOWNotificationMessageTemplate to an [ANOWNotificationMessageTemplate] object due to [$Message]."
                Break
            }
            If ($Quiet -ne $true) {
                Return $updated_notification_template
            }
        }
    }
    End {
    }
}

Function Export-AutomateNOWNotificationMessageTemplate {
    <#
    .SYNOPSIS
    Exports the Notification Message Templates from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Notification Message Templates from an instance of AutomateNOW! to a local .csv file

    .PARAMETER NotificationMessageTemplate
    Mandatory [ANOWNotificationMessageTemplate] object (Use Get-AutomateNOWNotificationMessageTemplate to retrieve them)

    .INPUTS
    ONLY [ANOWNotificationMessageTemplate] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWNotificationMessageTemplate] objects are exported to the local disk in CSV format

    .EXAMPLE
    Get-AutomateNOWNotificationMessageTemplate | Export-AutomateNOWNotificationMessageTemplate

    .EXAMPLE
    Get-AutomateNOWNotificationMessageTemplate -Id 'NotificationMessageTemplate01' | Export-AutomateNOWNotificationMessageTemplate

    .NOTES
	You must present [ANOWNotificationMessageTemplate] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWNotificationMessageTemplate]$NotificationMessageTemplate
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-NotificationMessageTemplates-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWNotificationMessageTemplate]$NotificationMessageTemplate = $_
        }
        $Error.Clear()
        Try {
            $NotificationMessageTemplate | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWNotificationMessageTemplate] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function New-AutomateNOWNotificationMessageTemplate {
    <#
    .SYNOPSIS
    Creates a Notification Message Template within an AutomateNOW! instance

    .DESCRIPTION
    Creates a Notification Message Template within an AutomateNOW! instance and returns back the newly created [ANOWNotificationMessageTemplate] object

    .PARAMETER Id
    The intended name of the Notification Message Template. For example: 'LinuxNotificationMessageTemplate1'. This value may not contain the domain in brackets.

    .PARAMETER Description
    Optional description of the Notification Message Template (may not exceed 255 characters).

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new Notification Message Template.

    .PARAMETER Folder
    Optional name of the folder to place the DataSource into.

    .PARAMETER CodeRepository
    Optional name of the code repository to place the Notification Message Template into.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWNotificationMessageTemplate.

    .OUTPUTS
    An [ANOWNotificationMessageTemplate] object representing the newly created Notification Message Template

    .EXAMPLE
    New-AutomateNOWNotificationMessageTemplate -Id 'NotificationTemplate1' -Description 'my description' -Tags 'Tag1', 'Tag2' -Folder 'Folder1' -CodeRepository 'CodeRepository1'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The name (id) of the Notification Message Template must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    #>
    [OutputType([ANOWNotificationMessageTemplate])]
    [Cmdletbinding()]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $true)]
        [string]$Id,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [string]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [boolean]$NotificationMessageTemplate_exists = ($null -ne (Get-AutomateNOWNotificationMessageTemplate -Id $Id))
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWNotificationMessageTemplate failed to check if the Notification Message Template [$Id] already existed due to [$Message]."
        Break
    }
    If ($NotificationMessageTemplate_exists -eq $true) {
        [string]$current_domain = $anow_session.header.domain
        Write-Warning -Message "There is already a Notification Message Template named [$Id] in [$current_domain]. Please check into this."
        Break
    }
    ## End warning ##
    [System.Collections.Specialized.OrderedDictionary]$ANOWNotificationMessageTemplate = [System.Collections.Specialized.OrderedDictionary]@{}
    $ANOWNotificationMessageTemplate.Add('id', $Id)
    If ($Description.Length -gt 0) {
        $ANOWNotificationMessageTemplate.Add('description', $Description)
    }
    If ($Tags.Count -gt 0) {
        [int32]$total_tags = $Tags.Count
        [int32]$current_tag = 1
        ForEach ($tag_id in $Tags) {
            $Error.Clear()
            Try {
                [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] under New-AutomateNOWNotificationMessageTemplate due to [$message]"
                Break
            }
            If ($tag_object.simpleId.length -eq 0) {
                Throw "New-AutomateNOWNotificationMessageTemplate has detected that the tag [$tag_id] does not appear to exist. Please check again."
                Break
            }
            ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                [string]$tag_object_simpleId = $tag_object.simpleId
                Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                Break
            }
            [string]$tag_display = $tag_object | ConvertTo-Json -Compress
            Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
            [string]$tag_name_sequence = ('tags' + $current_tag)
            $ANOWNotificationMessageTemplate.Add($tag_name_sequence, $tag_id)
            $include_properties += $tag_name_sequence
            $current_tag++
        }
    }
    If ($Folder.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] actually existed under New-AutomateNOWNotificationMessageTemplate due to [$Message]"
            Break
        }
        If ($folder_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] under New-AutomateNOWNotificationMessageTemplate. Please check again."
            Break
        }
        [string]$folder_display = $folder_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding folder $folder_display to Notification Message Template [$Id]"
        $ANOWNotificationMessageTemplate.Add('folder', $Folder)
        $include_properties += 'folder'
    }
    If ($CodeRepository.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository] actually existed under New-AutomateNOWNotificationMessageTemplate due to [$Message]"
            Break
        }
        If ($code_repository_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository] under New-AutomateNOWNotificationMessageTemplate. Please check again."
            Break
        }
        [string]$code_repository_display = $code_repository_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding code repository $code_repository_display to Notification Message Template [$Id]"
        $ANOWNotificationMessageTemplate.Add('codeRepository', $CodeRepository)
        $include_properties += 'codeRepository'
    }
    [string]$BodyObject = ConvertTo-QueryString -InputObject $ANOWNotificationMessageTemplate -IncludeProperties id, description, tags, folder, codeRepository
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    $BodyMetaData.'_operationType' = 'add'
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_oldValues' = '{}'
    $BodyMetaData.'_componentId' = 'NotificationMessageTemplateCreateWindow_form'
    $BodyMetaData.'_dataSource' = 'NotificationMessageTemplateDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$BodyMetaDataString = ConvertTo-QueryString -InputObject $BodyMetaData
    [string]$Body = ($BodyObject + '&' + $BodyMetaDataString)
    [string]$command = '/NotificationMessageTemplate/create'
    [hashtable]$parameters = @{}
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('Body', $Body)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWNotificationMessageTemplate]$NotificationMessageTemplate = $results.response.data | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to parse the response into a valid [ANOWNotificationMessageTemplate] object due to [$Message]."
        Break
    }
    If ($NotificationMessageTemplate.id.Length -eq 0) {
        Write-Warning -Message "Somehow the newly created [ANOWNotificationMessageTemplate] object is empty!"
        Break
    }
    Return $NotificationMessageTemplate
}

Function Remove-AutomateNOWNotificationMessageTemplate {
    <#
    .SYNOPSIS
    Removes a Notification Message Template from an AutomateNOW! instance

    .DESCRIPTION
    Removes a Notification Message Template from an AutomateNOW! instance

    .PARAMETER NotificationMessageTemplate
    An [ANOWNotificationMessageTemplate] object representing the Notification Message Template to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWNotificationMessageTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Get-AutomateNOWNotificationMessageTemplate -Id 'NotificationMessageTemplate01' | Remove-AutomateNOWNotificationMessageTemplate

    .EXAMPLE
    @( 'NotificationMessageTemplate1', 'NotificationMessageTemplate2', 'NotificationMessageTemplate3') | Remove-AutomateNOWNotificationMessageTemplate

    .EXAMPLE
    Get-AutomateNOWNotificationMessageTemplate | ? { $_.simpleId -like 'test*' } | Remove-AutomateNOWNotificationMessageTemplate

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWNotificationMessageTemplate]$NotificationMessageTemplate,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/NotificationMessageTemplate/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWNotificationMessageTemplate]$NotificationMessageTemplate = $_
        }
        [string]$NotificationMessageTemplate_id = $NotificationMessageTemplate.id
        If ($NotificationMessageTemplate_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($NotificationMessageTemplate_id)")) -eq $true) {
            [string]$oldvalues = $NotificationMessageTemplate.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $NotificationMessageTemplate_id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'NotificationMessageTemplateList'
            $BodyMetaData.'_dataSource' = 'NotificationMessageTemplateDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$NotificationMessageTemplate_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Notification Message Template $NotificationMessageTemplate_id successfully removed"
        }
    }
    End {

    }
}

Function Copy-AutomateNOWNotificationMessageTemplate {
    <#
    .SYNOPSIS
    Copies a Notification Message Template from an AutomateNOW! instance

    .DESCRIPTION
    Copies a Notification Message Template from an AutomateNOW! instance.

    .PARAMETER NotificationMessageTemplate
    Mandatory [ANOWNotificationMessageTemplate] object to be copied.

    .PARAMETER NewId
    The name (Id) of the new Notification Message Template. The new Id must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    .PARAMETER UnsetDescription
    Optional switch that will ensure that the newly created Notification Channel will not have a description set.

    .PARAMETER Description
    Optional description to set on the new Notification Message Template object. If you do not set this, the new Notification Channel object will copy the Description of the source object.

    .PARAMETER UnsetFolder
    Optional switch that will ensure that the newly created Notification Message Template will not have a Folder set.

    .PARAMETER Folder
    Optional description to set a different folder on the new Notification Message Template object. If you do not set this, the new Notification Message Template object will use the same Folder of the source object.

    .PARAMETER UnsetTags
    Optional switch that will ensure that the newly created Notification Message Template will not have any Tags set.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the new Notification Message Template object. If you do not set this, the new Notification Message Template object will apply the same Tags of the source object.

    .PARAMETER Force
    Force the copy without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    ONLY [ANOWNotificationMessageTemplate] object is accepted. Pipeline support is intentionally unavailable.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Creates a copy of a Notification Message Template and changes the description (multi-line format)
    $NotificationMessageTemplate01 = Get-AutomateNOWNotificationMessageTemplate -Id 'NotificationMessageTemplate_01'
    Copy-AutomateNOWNotificationMessageTemplate -NotificationMessageTemplate $NotificationMessageTemplate01 -NewId 'NotificationMessageTemplate_01_production' -Description 'NotificationMessageTemplate 01 Production'

    .EXAMPLE
    Creates a copy of a Notification Message Template that omits the description (one-liner format)
    Copy-AutomateNOWNotificationMessageTemplate -NotificationMessageTemplate (Get-AutomateNOWNotificationMessageTemplate -Id 'NotificationMessageTemplate_01') -NewId 'NotificationMessageTemplate_01_production' -UnsetDescription -Tags 'Tag1', 'Tag2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWNotificationMessageTemplate]$NotificationMessageTemplate,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot set the Tags and unset them at the same time. Please choose one or the other. Tags from the source object will be carried over to the new object if you do not specify any tag-related parameters."
            Break
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$NotificationMessageTemplate_exists = ($null -ne (Get-AutomateNOWNotificationMessageTemplate -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWNotificationMessageTemplate failed to check if the Notification Message Template [$NewId] already existed due to [$Message]."
            Break
        }
        If ($NotificationMessageTemplate_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Notification Message Template named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End warning ##
        [string]$command = '/NotificationMessageTemplate/copy'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            [string]$NotificationMessageTemplate_oldId = $NotificationMessageTemplate.id
            [string]$NotificationMessageTemplate_simpleId = $NotificationMessageTemplate.simpleId
            If ($NotificationMessageTemplate_oldId -eq $NewId) {
                Write-Warning -Message "The new id cannot be the same as the old id."
                Break
            }
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Copy the Notification Message Template $($NotificationMessageTemplate_simpleId) to $($NewId)?")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                If ($UnsetFolder -eq $True) {
                    $BodyMetaData.'folder' = $Null
                }
                ElseIf ($Folder.Length -gt 0) {
                    $BodyMetaData.'folder' = $Folder
                }
                Else {
                    If ($NotificationMessageTemplate.folder.Length -gt 0) {
                        $BodyMetaData.'folder' = $NotificationMessageTemplate.folder
                    }
                }
                If ($Tags.Count -gt 0) {
                    [int32]$tag_count = 1
                    ForEach ($tag in $Tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
                ElseIf ($UnsetTags -eq $true) {
                    $BodyMetaData.'tags' = $Null
                }
                Else {
                    If ($NotificationMessageTemplate.Tags -gt 0) {
                        [int32]$tag_count = 1
                        ForEach ($tag in $NotificationMessageTemplate.tags) {
                            $BodyMetaData.('tags' + $tag_count ) = $tag
                            $tag_count++
                        }
                    }
                }
                $BodyMetaData.'oldId' = $NotificationMessageTemplate_oldId
                $BodyMetaData.'domain' = $NotificationMessageTemplate.domain
                $BodyMetaData.'id' = $NewId
                If ($UnsetDescription -ne $true) {
                    If ($Description.Length -gt 0) {
                        $BodyMetaData.'description' = $Description
                    }
                    Else {
                        $BodyMetaData.'description' = $NotificationMessageTemplate.description
                    }
                }
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_operationId' = 'copy'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_dataSource' = 'NotificationMessageTemplateDataSource'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties oldId, domain, NewId, description, folder, tags
                $parameters.Body = $Body
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$NotificationMessageTemplate_oldId] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                $Error.Clear()
                Try {
                    [ANOWNotificationMessageTemplate]$NewNotificationMessageTemplate = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to create copied [ANOWNotificationMessageTemplate] object [$NewId] due to [$Message]."
                    Break
                }
                If ($NewNotificationMessageTemplate.id.Length -eq 0) {
                    Write-Warning -Message "Somehow the newly created (copied) [ANOWNotificationMessageTemplate] object [$NewId] is empty!"
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $NewNotificationMessageTemplate
                }
            }
        }
    }
    End {

    }
}

Function Rename-AutomateNOWNotificationMessageTemplate {
    <#
    .SYNOPSIS
    Renames a Notification Message Template on an AutomateNOW! instance

    .DESCRIPTION
    Performs a psuedo-rename operations of a NotificationG roup from an AutomateNOW! instance by copying it first and then deleting the source. This function merely combines Copy-AutomateNOWNotificationMessageTemplate and Remove-AutomateNOWNotificationMessageTemplate therefore it is to be considered destructive.

    .PARAMETER NotificationMessageTemplate
    An [ANOWNotificationMessageTemplate] object representing the Notification Message Template to be renamed.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the Notification Message Template. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER Force
    Force the renaming without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly renamed object.

    .INPUTS
    ONLY [ANOWNotificationMessageTemplate] objects are accepted. There is intentionally no support for the pipeline.

    .OUTPUTS
    The newly renamed [ANOWNotificationMessageTemplate] object will be returned.

    .EXAMPLE
    $NotificationMessageTemplate = Get-AutomateNOWNotificationMessageTemplate -Id 'NotificationMessageTemplate01'
    Rename-AutomateNOWNotificationMessageTemplate -NotificationMessageTemplate $NotificationMessageTemplate -NewId 'NotificationMessageTemplate_01'

    .EXAMPLE
    Rename-AutomateNOWNotificationMessageTemplate -NotificationMessageTemplate (Get-AutomateNOWNotificationMessageTemplate -Id 'NotificationMessageTemplate01') -NewId 'NotificationMessageTemplate_01'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    When renaming, you may only specify a different Id (name).

    This action will be blocked if any existing referrals are found on the object.
    #>
    [OutputType([ANOWNotificationMessageTemplate])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWNotificationMessageTemplate]$NotificationMessageTemplate,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin standard warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$new_NotificationMessageTemplate_exists = ($null -ne (Get-AutomateNOWNotificationMessageTemplate -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWNotificationMessageTemplate failed to check if the Notification Message Template [$NewId] already existed due to [$Message]."
            Break
        }
        If ($new_NotificationMessageTemplate_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Notification Message Template named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        #[string]$NotificationMessageTemplate_id = $NotificationMessageTemplate.id
        [string]$NotificationMessageTemplate_id = $NotificationMessageTemplate.simpleId
        $Error.Clear()
        Try {
            [boolean]$old_NotificationMessageTemplate_exists = ($null -ne (Get-AutomateNOWNotificationMessageTemplate -Id $NotificationMessageTemplate_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWNotificationMessageTemplate failed to check if the Notification Message Template [$NotificationMessageTemplate_id] already existed due to [$Message]."
            Break
        }
        If ($old_NotificationMessageTemplate_exists -eq $false) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not a Notification Message Template named [$NotificationMessageTemplate_id] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End standard warning ##
        ## Begin referrals warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [int32]$referrals_count = Find-AutomateNOWObjectReferral -NotificationMessageTemplate $NotificationMessageTemplate -Count | Select-Object -Expandproperty referrals
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Find-AutomateNOWObjectReferral failed to extract the referrals on Notification Message Template [$NotificationMessageTemplate_id] due to [$Message]."
            Break
        }
        If ($referrals_count -gt 0) {
            Write-Warning -Message "Unfortunately, you cannot rename a Notification Message Template that has referrals. This is because the rename is not actually renaming but copying anew and deleting the old. Please, use the Find-AutomateNOWObjectReferral function to identify referrals and remove them."
            Break
        }
        Else {
            Write-Verbose -Message "The Notification Message Template [$NotificationMessageTemplate_id] does not have any referrals. It is safe to proceed."
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($NotificationMessageTemplate_id)")) -eq $true) {
                $Error.Clear()
                Try {
                    [ANOWNotificationMessageTemplate]$new_NotificationMessageTemplate = Copy-AutomateNOWNotificationMessageTemplate -NotificationMessageTemplate $NotificationMessageTemplate -NewId $NewId -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Copy-AutomateNOWNotificationMessageTemplate failed to create a new Notification Message Template [$NewId] as Part 1 of the renaming process due to [$Message]."
                    Break
                }
                If ($new_NotificationMessageTemplate.simpleId -eq $NewId) {
                    Write-Verbose -Message "Part 1: Notification Message Template [$NotificationMessageTemplate_id] successfully copied to [$NewId]"
                }
                Else {
                    Write-Warning -Message "Somehow the first phase (Copy-AutomateNOWNotificationMessageTemplate) failed. Please look into this."
                    Break
                }
                $Error.Clear()
                Try {
                    Remove-AutomateNOWNotificationMessageTemplate -NotificationMessageTemplate $NotificationMessageTemplate -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Remove-AutomateNOWNotificationMessageTemplate failed to remove [$NotificationMessageTemplate_id] as Part 2 of the renaming process due to [$Message]."
                    Break
                }
                Write-Verbose -Message "Part 2: Notification Message Template [$NotificationMessageTemplate_id] removed"
                Write-Verbose -Message "Task [$NotificationMessageTemplate_id] successfully renamed to [$NewId]"
                If ($Quiet -ne $true) {
                    Return $new_NotificationMessageTemplate
                }
            }
        }
        Else {
            Write-Warning -Message "No action was taken because either the source object didn't exist or the new object already existed"
        }
    }
    End {
    }
}

#endregion

#Region - Physical Resources (RESOURCE)

Function Get-AutomateNOWPhysicalResource {
    <#
    .SYNOPSIS
    Gets the Physical Resource objects from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Physical Resource objects from an AutomateNOW! instance

    .PARAMETER Id
    Optional string containing the simple id of the Physical Resource to fetch or you can pipeline a series of simple id strings. You may not enter an array here.

    .PARAMETER Detailed
    Switch parameter to provide the detailed properties of the [ANOWPhysicalResource] object. This may only be used in conjunction with -Id. Use this option to see the fully populated object.

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100. The console default hard limit is 10,000.

    .PARAMETER sortBy
    Optional string parameter to sort the results by (may not be used with the Id parameter). Valid choices are: {To be continued...}

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .PARAMETER Folder
    Optional string to filter by a particular Folder

    .PARAMETER Tags
    Optional string array of Tags to filter by. Note that the 'containsAny' operator will be used.

    .INPUTS
    Accepts a string representing the simple id of the Physical Resource from the pipeline or individually (but not an array).

    .OUTPUTS
    Either one or more [ANOWPhysicalResource] objects

    .EXAMPLE
    Gets the first page of Physical Resource objects

    Get-AutomateNOWPhysicalResource

    .EXAMPLE
    Gets the first 500 Physical Resource objects

    Get-AutomateNOWPhysicalResource -startRow 0 -endRow 500

    .EXAMPLE
    Gets a single non-detailed Physical Resource named 'PhysicalResource1'

    Get-AutomateNOWPhysicalResource -Id 'PhysicalResource1'

    .EXAMPLE
    Gets the detailed version of a Physical Resource object named 'PhysicalResource1'

    Get-AutomateNOWPhysicalResource -Id 'PhysicalResource1' -Detailed

    .EXAMPLE
    Gets a series of Physical Resource objects through the pipeline

    'PhysicalResource1', 'PhysicalResource2' | Get-AutomateNOWPhysicalResource

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(DefaultParameterSetName = 'Id')]
    Param(
        [Parameter(Mandatory = $False, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [Parameter(Mandatory = $False, ParameterSetName = 'Detailed', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'Detailed')]
        [switch]$Detailed,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [string]$sortBy = 'id',
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [switch]$Descending,
        [Parameter(Mandatory = $False)]
        [string]$Folder,
        [Parameter(Mandatory = $False)]
        [string[]]$Tags
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 ) {
            [string]$PhysicalResource_Id = $_
        }
        Else {
            [string]$PhysicalResource_Id = $Id
        }
        If ($Detailed -eq $true) {
            $Body.'id' = $PhysicalResource_Id
            [string]$textMatchStyle = 'exactCase'
            $Body.'_operationId' = 'readDetailed'
            [string]$Method = 'POST'
        }
        Else {
            $Body.'_constructor' = 'AdvancedCriteria'
            $Body.'operator' = 'and'
            $Body.'criteria1' = '{"fieldName":"resourceType","operator":"equals","value":"PHYSICAL_RESOURCE"}'
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
            If ($Descending -eq $true) {
                $Body.'_sortBy' = '-' + $sortBy
            }
            Else {
                $Body.'_sortBy' = $sortBy
            }
            If ($PhysicalResource_Id.Length -gt 0) {
                $Body.'criteria2' = ('{"fieldName":"simpleId","operator":"equals","value":"' + $PhysicalResource_Id + '"}')
                [string]$textMatchStyle = 'exact'
            }
            Else {
                [string]$textMatchStyle = 'substring'
            }
            If ($Folder.Length -gt 0) {
                $Body.'criteria3' = ('{"fieldName":"folder","operator":"equals","value":"' + $Folder + '"}')
            }
            If ($Tags.Count -gt 0) {
                If ($Tags.Count -gt 1) {
                    $Error.Clear()
                    Try {
                        [string]$TagString = $Tags | ConvertTo-Json -Compress
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "ConvertTo-Json failed to convert the provided tag names under Get-AutomateNOWPhysicalResource due to [$Message]."
                        Break
                    }
                }
                Else {
                    [string]$TagString = $Tags
                }
                $Body.'criteria4' = ('{"fieldName":"tags","operator":"containsAny","value":' + $TagString + '}')
            }
            $Body.'_componentId' = 'ResourceList'
            [string]$Method = 'GET'
        }
        $Body.'_operationType' = 'fetch'
        $Body.'_textMatchStyle' = $textMatchStyle
        $Body.'_dataSource' = 'ResourceDataSource'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        If ($Detailed -eq $true) {
            [string]$command = ('/resource/readDetailed')
            If ($Null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            If ($null -eq $parameters["Command"]) {
                $parameters.Add('Command', $command)
            }
            Else {
                $parameters.Command = $command
            }
        }
        Else {
            [string]$command = ('/resource/read?' + $Body)
            $parameters.Command = $command
        }
        If ($null -eq $parameters.Method) {
            $parameters.Add('Method', $Method)
        }
        Else {
            $parameters.Method = $Method
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWPhysicalResource[]]$PhysicalResources = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWPhysicalResource failed to parse the results into [ANOWPhysicalResource] objects due to [$Message]."
            Break
        }
        If ($PhysicalResources.Count -gt 0) {
            Return $PhysicalResources
        }
    }
    End {

    }
}

Function Set-AutomateNOWPhysicalResource {
    <#
    .SYNOPSIS
    Changes the settings of an Physical Resource on an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of an Physical Resource on an AutomateNOW! instance

    .PARAMETER PhysicalResource
    An [ANOWPhysicalResource] object representing the Physical Resource to be modified.

    .PARAMETER Value
    Optional int64 to set the value (resource status) on the Physical Resource to.

    .PARAMETER UnsetValue
    Optional switch that will remove (blank out to null) the Value from the Physical Resource object.

    .PARAMETER ValueUnit
    Optional string to set the name of the Value Unit on the Physical Resource to.

    .PARAMETER UnsetValueUnit
    Optional switch that will remove (blank out to null) the Value Unit from the Physical Resource object.

    .PARAMETER minValue
    Optional [int64] to set the minimum value of the Value Unit of the Physical Resource object.

    .PARAMETER UnsetMinValue
    Optional switch that will remove (blank out to null) the Minimum Value from the Physical Resource object. You should try to use this parameter exclusively from other parameters as it is not supported in the UI.

    .PARAMETER maxValue
    Optional [int64] to set the maximum value of the Value Unit of the Physical Resource object.

    .PARAMETER UnsetMaxValue
    Optional switch that will remove (blank out to null) the Maximum Value from the Physical Resource object.  You should try to use this parameter exclusively from other parameters as it is not supported in the UI.

    .PARAMETER Description
    Optional string to set the description on the new PhysicalResource object.

    .PARAMETER UnsetDescription
    Optional switch that will remove (blank out to null) the Description from the Physical Resource object.

    .PARAMETER Folder
    Optional string to set a different folder on the PhysicalResource object.

    .PARAMETER UnsetFolder
    Optional switch that will remove the Folder assignment from the PhysicalResource object.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the new PhysicalResource object.

    .PARAMETER UnsetTags
    Optional switch that will remove the Tags from the PhysicalResource object.

    .PARAMETER CodeRepository
    Optional Code Repository to place the Physical Resouce into. Use Get-AutomateNOWCodeRepository to fetch this object.

    .PARAMETER UnsetCodeRepository
    Switch parameter that will remove the the Physical Resource from its Code Repository.

    .PARAMETER Quiet
    Switch parameter that silences the output of the updated object.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWPhysicalResource] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWPhysicalResource] object will be returned

    .EXAMPLE
    Changes the description and folder, along with setting 2 tags on a Physical Resource

    $PhysicalResource = Get-AutomateNOWPhysicalResource -Id 'PhysicalResource1'
    Set-AutomateNOWPhysicalResource -Description 'Awesome description!' -Tags 'Tag1', 'Tag2' -Folder 'Folder1'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Be sure to send a valid int64 to the -Value parameter and not a string like 1+e47 :-)

    API Constraint: The maximum value may not exist but if it does then it must be equal or lesser to the minimum value.

    Unsetting the min/max values is actually not supported in the UI but it is supported here. However, these 2 unset switches will be ignored if the opposite value is getting set at the same time.

    #>
    [OutputType([ANOWPhysicalResource])]
    [Cmdletbinding(SupportsShouldProcess, DefaultParameterSetName = 'Default', ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'Default', ValueFromPipeline = $True)]
        [Parameter(Mandatory = $true, ParameterSetName = 'SetValue', ValueFromPipeline = $True)]
        [Parameter(Mandatory = $true, ParameterSetName = 'ValueUnit', ValueFromPipeline = $True)]
        [ANOWPhysicalResource]$PhysicalResource,
        [ValidateScript({ $_ -match '^-{0,}[0-9]{1,}$' })]
        [Parameter(Mandatory = $false, ParameterSetName = 'SetValue')]
        [string]$Value, # this needs to be a string even though it is a number since 0 is a possible value
        [Parameter(Mandatory = $false, ParameterSetName = 'SetValue')]
        [switch]$UnsetValue,
        [Parameter(Mandatory = $false, ParameterSetName = 'ValueUnit')]
        [string]$ValueUnit,
        [Parameter(Mandatory = $false, ParameterSetName = 'ValueUnit')]
        [switch]$UnsetValueUnit,
        [ValidateScript({ $_ -match '^-{0,}[0-9]{1,}$' })]
        [Parameter(Mandatory = $false, ParameterSetName = 'ValueUnit')]
        [string]$minValue, # this needs to be a string even though it is a number since 0 is a possible value
        [Parameter(Mandatory = $false, ParameterSetName = 'ValueUnit')]
        [switch]$UnsetMinValue,
        [ValidateScript({ $_ -match '^-{0,}[0-9]{1,}$' })]
        [Parameter(Mandatory = $false, ParameterSetName = 'ValueUnit')]
        [string]$maxValue, # this needs to be a string even though it is a number since 0 is a possible value
        [Parameter(Mandatory = $false, ParameterSetName = 'ValueUnit')]
        [switch]$UnsetMaxValue,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [string[]]$Tags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [string]$Folder,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetCodeRepository,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'SetValue')]
        [Parameter(Mandatory = $false, ParameterSetName = 'ValueUnit')]
        [switch]$Quiet,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'SetValue')]
        [Parameter(Mandatory = $false, ParameterSetName = 'ValueUnit')]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot set the Tags and unset them at the same time. Please choose one or the other. Tags from the source object will be carried over to the new object if you do not specify any tag-related parameters."
            Break
        }
        If ($UnsetCodeRepository -eq $true -and $CodeRepository.Id.Length -gt 0) {
            Write-Warning -Message "You cannot unset the Code Repository and set it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetValue -eq $true -and $Value.Length -gt 0) {
            Write-Warning -Message "You cannot set the Value and unset the Value at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetValueUnit -eq $true -and $ValueUnit.Length -gt 0) {
            Write-Warning -Message "You cannot set the Value Unit and unset the Value Unit at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetMinValue -eq $true -and $minValue.Length -gt 0) {
            Write-Warning -Message "You cannot set the Minimum Value and unset the Minimum Value at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetMaxValue -eq $true -and $maxValue.Length -gt 0) {
            Write-Warning -Message "You cannot set the Maximum Value and unset the Maximum Value at the same time. Please choose one or the other."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWPhysicalResource]$PhysicalResource = $_
        }
        [string]$PhysicalResource_id = $PhysicalResource.id
        [string]$PhysicalResource_simpleId = $PhysicalResource.simpleId
        [string]$current_PhysicalResource_value = $PhysicalResource.resourceStatus
        If ($current_PhysicalResource_value.Length -eq 0) {
            Write-Verbose -Message "Detected the current value (resource status) of PhysicalResource object [$PhysicalResource_simpleId] is empty"
        }
        Else {
            Write-Verbose -Message "Detected the current value (resource status) of PhysicalResource object [$PhysicalResource_simpleId] to be [$current_PhysicalResource_value]"
        }
        [string]$current_PhysicalResource_valueUnit = $PhysicalResource.valueUnit
        [string]$current_PhysicalResource_minValue = $PhysicalResource.minValue
        [string]$current_PhysicalResource_maxValue = $PhysicalResource.maxValue
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($PhysicalResource_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$PhysicalResource_exists = ($null -eq (Get-AutomateNOWPhysicalResource -Id $PhysicalResource_simpleId))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWPhysicalResource failed to check if the PhysicalResource [$PhysicalResource_simpleId] already existed due to [$Message]."
                Break
            }
            If ($PhysicalResource_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not a PhysicalResource named [$PhysicalResource_simpleId] in the [$current_domain] domain. Please check into this."
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $PhysicalResource_id
            If ($Value.Length -gt 0) {
                If ($Value -eq $current_PhysicalResource_value) {
                    Write-Warning -Message "No action is required. The Physical Resource [$PhysicalResource_simpleId] is already set to [$Value]"
                    Break
                }
                Else {
                    Write-Verbose -Message "Changing the value of [$PhysicalResource_simpleId] from [$current_PhysicalResource_value] to [$Value]"
                    $BodyMetaData.'newValue' = [int64]$Value # Cast this as an int64 at the last second to ensure this is a valid number being sent
                }
                [string]$operationId = 'setValue'
                [string]$operationType = 'custom'
                $BodyMetaData.'_operationId' = $operationId
                [string]$command = "/resource/$operationId"
            }
            ElseIf ($unsetValue -eq $true) {
                If ($current_PhysicalResource_value.Length -eq 0 ) {
                    Write-Warning -Message "The Physical Resource [$PhysicalResource_simpleId] value is already unset. No action is required."
                    Break
                }
                [string]$operationId = 'setValue'
                [string]$operationType = 'custom'
                $BodyMetaData.'_operationId' = $operationId
                [string]$command = "/resource/$operationId"
            }
            Else {
                [string]$command = '/resource/update'
                [string]$operationType = 'update'
                If ($Description.Length -gt 0) {
                    $BodyMetaData.'description' = $Description
                }
                ElseIf ($UnsetDescription -eq $true) {
                    $BodyMetaData.'description' = $Null
                }
                Else {
                    If ($PhysicalResource.description.Length -gt 0) {
                        $BodyMetaData.'description' = $PhysicalResource.description
                    }
                }
                If ($UnsetFolder -eq $True) {
                    $BodyMetaData.'folder' = $Null
                }
                ElseIf ($Folder.Length -gt 0) {
                    $BodyMetaData.'folder' = $Folder
                }
                Else {
                    If ($PhysicalResource.folder.Length -gt 0) {
                        $BodyMetaData.'folder' = $PhysicalResource.folder
                    }
                }
                If ($Tags.Count -gt 0) {
                    [int32]$tag_count = 1
                    ForEach ($tag in $Tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
                ElseIf ($UnsetTags -eq $true) {
                    $BodyMetaData.'tags' = $Null
                }
                Else {
                    If ($PhysicalResource.Tags -gt 0) {
                        [int32]$tag_count = 1
                        ForEach ($tag in $PhysicalResource.tags) {
                            $BodyMetaData.('tags' + $tag_count ) = $tag
                            $tag_count++
                        }
                    }
                }
                If ($CodeRepository.Id.Length -gt 0) {
                    [string]$CodeRepository_Id = $CodeRepository.Id
                    $Error.Clear()
                    Try {
                        [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository_Id
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository_Id] actually existed under Set-AutomateNOWPhysicalResource due to [$Message]"
                        Break
                    }
                    If ($code_repository_object.simpleId.Length -eq 0) {
                        Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository_Id] under Set-AutomateNOWPhysicalResource. Please check again."
                        Break
                    }
                    $BodyMetaData.'codeRepository' = $CodeRepository_Id
                }
                ElseIf ($UnsetCodeRepository -eq $true) {
                    $BodyMetaData.'codeRepository' = $null
                }
                If ($valueUnit.Length -gt 0) {
                    If ($valueUnit -eq $current_PhysicalResource_valueUnit) {
                        Write-Warning -Message "The value unit is already named $valueUnit. There is no action required."
                        Break
                    }
                    $BodyMetaData.'valueUnit' = $valueUnit
                    $BodyMetaData.'_componentId' = 'ResourceVM'
                }
                ElseIf ($UnsetValueUnit -eq $true) {
                    If ($current_PhysicalResource_valueUnit.Length -eq 0) {
                        Write-Warning -Message "The value unit is already unset. There is no action required."
                        Break
                    }
                    $BodyMetaData.'valueUnit' = $null
                    $BodyMetaData.'_componentId' = 'ResourceVM'
                }
                If ($minValue.Length -gt 0 -or $maxValue.Length -gt 0) {
                    If ($minValue.Length -gt 0) {
                        If ($maxValue.Length -gt 0) {
                            If ([int64]$minValue -gt [int64]$maxValue) {
                                Write-Warning -Message "You cannot set the minimum value ($minValue) as a higher value then the maximum value ($maxValue) you are trying to set."
                                Break
                            }
                        }
                        ElseIf ($current_PhysicalResource_maxValue.Length -gt 0) {
                            If ([int64]$minValue -gt [int64]$current_PhysicalResource_maxValue) {
                                Write-Warning -Message "You cannot set the minimum value ($minValue) as a higher value then the existing maximum value ($current_PhysicalResource_maxValue)."
                                Break
                            }
                        }
                        $BodyMetaData.'minValue' = [int64]$minValue # Cast this as an int64 at the last second to ensure this is a valid number being sent
                    }
                    If ($maxValue.Length -gt 0) {
                        If ($minValue.Length -gt 0) {
                            If ([int64]$maxValue -lt [int64]$minValue) {
                                Write-Warning -Message "You cannot set the maximum value ($maxValue) as a lower value then the minimum value ($minValue) you are trying to set."
                                Break
                            }
                        }
                        ElseIf ($current_PhysicalResource_minValue.Length -gt 0) {
                            If ([int64]$maxValue -lt [int64]$current_PhysicalResource_minValue) {
                                Write-Warning -Message "You cannot set the maximum value ($minValue) as a lower value then the existing minimum value ($current_PhysicalResource_minValue)."
                                Break
                            }
                        }
                        $BodyMetaData.'minValue' = [int64]$minValue # Cast this as an int64 at the last second to ensure this is a valid number being sent
                    }
                    $BodyMetaData.'_componentId' = 'ResourceVM'
                }
                ElseIf ($UnsetMinValue -eq $true -or $UnsetMaxValue -eq $true) {
                    If ($UnsetMinValue -eq $true) {
                        $BodyMetaData.'minValue' = $null
                    }
                    If ($UnsetMaxValue -eq $true) {
                        $BodyMetaData.'maxValue' = $null
                    }
                    $BodyMetaData.'_componentId' = 'ResourceVM'
                }
            }
            $BodyMetaData.'_operationType' = $operationType
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_dataSource' = 'ResourceDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $parameters.Add('Command', $command)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$PhysicalResource_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Physical Resource object [$PhysicalResource_id] was successfully updated"
            $Error.Clear()
            Try {
                [ANOWPhysicalResource]$UpdatedPhysicalResource = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the returned updated object to an [ANOWPhysicalResource] object due to [$Message]. The object was still updated though."
                Break
            }
            If ($Quiet -ne $true) {
                Return $UpdatedPhysicalResource
            }
        }
    }
    End {
    }
}

Function Export-AutomateNOWPhysicalResource {
    <#
    .SYNOPSIS
    Exports the Physical Resource objects from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Physical Resource objects from an instance of AutomateNOW! to a local .csv file

    .PARAMETER PhysicalResource
    Mandatory [ANOWPhysicalResource] object (Use Get-AutomateNOWPhysicalResource to retrieve them)

    .INPUTS
    ONLY [ANOWPhysicalResource] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWPhysicalResource] objects are exported to the local disk in CSV format

    .EXAMPLE
    Exports all of the Physical Resource objects (up to 100 by default)

    Get-AutomateNOWPhysicalResource | Export-AutomateNOWPhysicalResource

    .EXAMPLE
    Exports 1 Physical Resource by name

    Get-AutomateNOWPhysicalResource -Id 'PhysicalResource01' | Export-AutomateNOWPhysicalResource

    .EXAMPLE
    Exports a series of Physical Resource objects by the pipeline

    @( 'PhysicalResource01', 'PhysicalResource02' ) | Get-AutomateNOWPhysicalResource | Export-AutomateNOWPhysicalResource

    .NOTES
	You must present [ANOWPhysicalResource] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWPhysicalResource]$PhysicalResource
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-PhysicalResources-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWPhysicalResource]$PhysicalResource = $_
        }
        $Error.Clear()
        Try {
            $PhysicalResource | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWPhysicalResource] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function New-AutomateNOWPhysicalResource {
    <#
    .SYNOPSIS
    Creates a Physical Resource within an AutomateNOW! instance

    .DESCRIPTION
    Creates a Physical Resource within an AutomateNOW! instance and returns back the newly created [ANOWPhysicalResource] object

    .PARAMETER Id
    The intended name of the PhysicalR esource. For example: 'PhysicalResource1'. This value may not contain the domain in brackets.

    .PARAMETER Description
    Optional description of the Physical Resource (may not exceed 255 characters).

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new Physical Resource. Do not pass [ANOWTag] objects here.

    .PARAMETER Folder
    Optional name of the folder to place the Physical Resource into.

    .PARAMETER CodeRepository
    Optional name of the code repository to place the Physical Resource into.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWPhysical Resource.

    .OUTPUTS
    An [ANOWPhysicalResource] object representing the newly created Physical Resource

    .EXAMPLE
    New-AutomateNOWPhysicalResource -Id 'PhysicalResource01' -Description 'Description01' -Tags 'Tag01' -Folder 'Folder01' -CodeRepository 'Repository01'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The name (id) of the Physical Resource must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    #>
    [OutputType([ANOWPhysicalResource])]
    [Cmdletbinding()]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $true)]
        [string]$Id,
        [ValidateScript({ $_.Length -le 255 })]
        [Parameter(Mandatory = $false, HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [string]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [boolean]$PhysicalResource_exists = ($null -ne (Get-AutomateNOWPhysicalResource -Id $Id))
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWPhysicalResource failed to check if the Physical Resource [$Id] already existed due to [$Message]."
        Break
    }
    If ($PhysicalResource_exists -eq $true) {
        [string]$current_domain = $anow_session.header.domain
        Write-Warning -Message "There is already a Physical Resource named [$Id] in [$current_domain]. Please check into this."
        Break
    }
    ## End warning ##
    [System.Collections.Specialized.OrderedDictionary]$ANOWPhysicalResource = [System.Collections.Specialized.OrderedDictionary]@{}
    $ANOWPhysicalResource.Add('id', $Id)
    If ($Description.Length -gt 0) {
        $ANOWPhysicalResource.Add('description', $Description)
    }
    If ($Tags.Count -gt 0) {
        [int32]$total_tags = $Tags.Count
        [int32]$current_tag = 1
        ForEach ($tag_id in $Tags) {
            $Error.Clear()
            Try {
                [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] running under New-AutomateNOWPhysicalResource due to [$message]"
                Break
            }
            If ($tag_object.simpleId.length -eq 0) {
                Throw "New-AutomateNOWPhysicalResource has detected that the tag [$tag_id] does not appear to exist. Please check again."
                Break
            }
            ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                [string]$tag_object_simpleId = $tag_object.simpleId
                Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                Break
            }
            [string]$tag_display = $tag_object | ConvertTo-Json -Compress
            Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
            [string]$tag_name_sequence = ('tags' + $current_tag)
            $ANOWPhysicalResource.Add($tag_name_sequence, $tag_id)
            $include_properties += $tag_name_sequence
            $current_tag++
        }
    }
    If ($Folder.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] existed under New-AutomateNOWPhysicalResource due to [$Message]"
            Break
        }
        If ($folder_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] under New-AutomateNOWPhysicalResource. Please check again."
            Break
        }
        [string]$folder_display = $folder_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding folder $folder_display to [ANOWPhysicalResource] [$Id]"
        $ANOWPhysicalResource.Add('folder', $Folder)
        $include_properties += 'folder'
    }
    If ($CodeRepository.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository] existed under New-AutomateNOWPhysicalResource due to [$Message]"
            Break
        }
        If ($code_repository_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository] under New-AutomateNOWPhysicalResource. Please check again."
            Break
        }
        [string]$code_repository_display = $code_repository_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding code repository $code_repository_display to [ANOWPhysicalResource] [$Id]"
        $ANOWPhysicalResource.Add('codeRepository', $CodeRepository)
        $include_properties += 'codeRepository'
    }
    $ANOWPhysicalResource.Add('title', 'Physical Resource')
    $ANOWPhysicalResource.Add('icon', '[SKINIMG]/skin/wall.png')
    $oldvalues = ('{"title":"Physical Resource","resourceType":"PHYSICAL_RESOURCE","icon":"[SKINIMG]/skin/memory.png"}')
    [string]$BodyObject = ConvertTo-QueryString -InputObject $ANOWPhysicalResource -IncludeProperties id, description, title, icon, tags, folder, codeRepository
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    $BodyMetaData.'resourceType' = 'PHYSICAL_RESOURCE'
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_operationType' = 'add'
    $BodyMetaData.'_oldValues' = $oldvalues
    $BodyMetaData.'_componentId' = 'ResourceCreateWindow_form'
    $BodyMetaData.'_dataSource' = 'ResourceDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$BodyMetaDataString = ConvertTo-QueryString -InputObject $BodyMetaData
    [string]$Body = ($BodyObject + '&' + $BodyMetaDataString)
    [string]$command = '/resource/create'
    [hashtable]$parameters = @{}
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('Body', $Body)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWPhysicalResource]$PhysicalResource = $results.response.data | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to parse the result of New-AutomateNOWPhysicalResource into an [ANOWPhysicalResource] object due to [$Message]."
        Break
    }
    If ($PhysicalResource.id.Length -eq 0) {
        Write-Warning -Message "Somehow the newly created [ANOWPhysicalResource] object is empty!"
        Break
    }
    If ($Quiet -ne $true) {
        Return $PhysicalResource
    }
}

Function Remove-AutomateNOWPhysicalResource {
    <#
    .SYNOPSIS
    Removes a Physical Resource from an AutomateNOW! instance

    .DESCRIPTION
    Removes a Physical Resource from an AutomateNOW! instance

    .PARAMETER PhysicalResource
    An [ANOWPhysicalResource] object representing the Physical Resource to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWPhysicalResource] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Remove a single Physical Resource by name

    Get-AutomateNOWPhysicalResource -Id 'PhysicalResource01' | Remove-AutomateNOWPhysicalResource

    .EXAMPLE
    Removes a series of Physical Resource objects via input from the pipeline

    @( 'PhysicalResource01', 'PhysicalResource02', 'PhysicalResource03') | Get-AutomateNOWPhysicalResource | Remove-AutomateNOWPhysicalResource

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWPhysicalResource]$PhysicalResource,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/resource/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWPhysicalResource]$PhysicalResource = $_
        }
        [string]$PhysicalResource_id = $PhysicalResource.id
        If ($PhysicalResource_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($PhysicalResource_id)")) -eq $true) {
            [string]$oldvalues = $PhysicalResource.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $PhysicalResource.id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'ResourceList'
            $BodyMetaData.'_dataSource' = 'ResourceDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$PhysicalResource_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Physical Resource [$PhysicalResource_id] successfully removed"
        }
    }
    End {

    }
}

Function Copy-AutomateNOWPhysicalResource {
    <#
    .SYNOPSIS
    Copies an Physical Resource from an AutomateNOW! instance

    .DESCRIPTION
    Copies an Physical Resource from an AutomateNOW! instance. AutomateNOW object id can never be changed, but we can copy the object to a new id and it will include all of the items therein.

    .PARAMETER PhysicalResource
    Mandatory [ANOWPhysicalResource] object to be copied.

    .PARAMETER NewId
    The name (Id) of the new Physical Resource. The new Id must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    .PARAMETER UnsetDescription
    Optional switch that will ensure that the newly created Physical Resource will not have a description set.

    .PARAMETER Description
    Optional description to set on the new PhysicalResource object. If you do not set this, the new Physical Resource object will copy the Description of the source object.

    .PARAMETER UnsetFolder
    Optional switch that will ensure that the newly created Physical Resource will not have a Folder set.

    .PARAMETER Folder
    Optional description to set a different folder on the new Physical Resource object. If you do not set this, the new Physical Resource object will use the same Folder of the source object.

    .PARAMETER UnsetTags
    Optional switch that will ensure that the newly created Physical Resource will not have any Tags set.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the new Physical Resource object. If you do not set this, the new Physical Resource object will apply the same Tags of the source object.

    .PARAMETER Force
    Force the copy without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    ONLY [ANOWPhysicalResource] object is accepted. Pipeline support is intentionally unavailable.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Creates a copy of an Physical Resource and changes the description (multi-line format)
    $PhysicalResource01 = Get-AutomateNOWPhysicalResource -Id 'PhysicalResource_01'
    Copy-AutomateNOWPhysicalResource -PhysicalResource $PhysicalResource01 -NewId 'PhysicalResource_01_production' -Description 'PhysicalResource 01 Production'

    .EXAMPLE
    Creates a copy of an Physical Resource that omits the description (one-liner format)
    Copy-AutomateNOWPhysicalResource -PhysicalResource (Get-AutomateNOWPhysicalResource -Id 'PhysicalResource_01') -NewId 'PhysicalResource_01_production' -UnsetDescription -Tags 'Tag1', 'Tag2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWPhysicalResource]$PhysicalResource,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot set the Tags and unset them at the same time. Please choose one or the other. Tags from the source object will be carried over to the new object if you do not specify any tag-related parameters."
            Break
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$PhysicalResource_exists = ($null -ne (Get-AutomateNOWPhysicalResource -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWPhysicalResource failed to check if the Physical Resource [$NewId] already existed due to [$Message]."
            Break
        }
        If ($PhysicalResource_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Physical Resource named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End warning ##
        [string]$command = '/resource/copy'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            [string]$PhysicalResource_oldId = $PhysicalResource.id
            [string]$PhysicalResource_simpleId = $PhysicalResource.simpleId
            If ($PhysicalResource_oldId -eq $NewId) {
                Write-Warning -Message "The new id cannot be the same as the old id."
                Break
            }
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Copy the Physical Resource $($PhysicalResource_simpleId) to $($NewId)?")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                If ($UnsetFolder -eq $True) {
                    $BodyMetaData.'folder' = $Null
                }
                ElseIf ($Folder.Length -gt 0) {
                    $BodyMetaData.'folder' = $Folder
                }
                Else {
                    If ($PhysicalResource.folder.Length -gt 0) {
                        $BodyMetaData.'folder' = $PhysicalResource.folder
                    }
                }
                If ($Tags.Count -gt 0) {
                    [int32]$tag_count = 1
                    ForEach ($tag in $Tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
                ElseIf ($UnsetTags -eq $true) {
                    $BodyMetaData.'tags' = $Null
                }
                Else {
                    If ($PhysicalResource.Tags -gt 0) {
                        [int32]$tag_count = 1
                        ForEach ($tag in $PhysicalResource.tags) {
                            $BodyMetaData.('tags' + $tag_count ) = $tag
                            $tag_count++
                        }
                    }
                }
                $BodyMetaData.'oldId' = $PhysicalResource_oldId
                $BodyMetaData.'domain' = $PhysicalResource.domain
                $BodyMetaData.'id' = $NewId
                If ($UnsetDescription -ne $true) {
                    If ($Description.Length -gt 0) {
                        $BodyMetaData.'description' = $Description
                    }
                    Else {
                        $BodyMetaData.'description' = $PhysicalResource.description
                    }
                }
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_operationId' = 'copy'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_dataSource' = 'ResourceDataSource'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties oldId, domain, NewId, description, folder, tags
                $parameters.Body = $Body
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$PhysicalResource_oldId] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                $Error.Clear()
                Try {
                    [ANOWPhysicalResource]$NewPhysicalResource = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to create copied [ANOWPhysicalResource] object [$NewId] due to [$Message]."
                    Break
                }
                If ($NewPhysicalResource.id.Length -eq 0) {
                    Write-Warning -Message "Somehow the newly created (copied) [ANOWPhysicalResource] object [$NewId] is empty!"
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $NewPhysicalResource
                }
            }
        }
    }
    End {

    }
}

Function Rename-AutomateNOWPhysicalResource {
    <#
    .SYNOPSIS
    Renames a Physical Resource on an AutomateNOW! instance

    .DESCRIPTION
    Performs a psuedo-rename operations of a Physical Resource from an AutomateNOW! instance by copying it first and then deleting the source. This function merely combines Copy-AutomateNOWPhysicalResource and Remove-AutomateNOWPhysicalResource therefore it is to be considered destructive.

    .PARAMETER PhysicalResource
    An [ANOWPhysicalResource] object representing the Physical Resource to be renamed.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the Physical Resource. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER Force
    Force the renaming without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly renamed object.

    .INPUTS
    ONLY [ANOWPhysicalResource] objects are accepted. There is intentionally no support for the pipeline.

    .OUTPUTS
    The newly renamed [ANOWPhysicalResource] object will be returned.

    .EXAMPLE
    $PhysicalResource = Get-AutomateNOWPhysicalResource -Id 'PhysicalResource01'
    Rename-AutomateNOWPhysicalResource -PhysicalResource $PhysicalResource -NewId 'PhysicalResource_01'

    .EXAMPLE
    Rename-AutomateNOWPhysicalResource -PhysicalResource (Get-AutomateNOWPhysicalResource -Id 'PhysicalResource01') -NewId 'PhysicalResource_01'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    When renaming, you may only specify a different Id (name).

    This action will be blocked if any existing referrals are found on the object.
    #>
    [OutputType([ANOWPhysicalResource])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWPhysicalResource]$PhysicalResource,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin standard warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$new_PhysicalResource_exists = ($null -ne (Get-AutomateNOWPhysicalResource -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWPhysicalResource failed to check if the Physical Resource [$NewId] already existed due to [$Message]."
            Break
        }
        If ($new_PhysicalResource_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Physical Resource named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        #[string]$PhysicalResource_id = $PhysicalResource.id
        [string]$PhysicalResource_id = $PhysicalResource.simpleId
        $Error.Clear()
        Try {
            [boolean]$old_PhysicalResource_exists = ($null -ne (Get-AutomateNOWPhysicalResource -Id $PhysicalResource_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWPhysicalResource failed to check if the Physical Resource [$PhysicalResource_id] already existed due to [$Message]."
            Break
        }
        If ($old_PhysicalResource_exists -eq $false) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not a Physical Resource named [$PhysicalResource_id] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End standard warning ##
        ## Begin referrals warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [int32]$referrals_count = Find-AutomateNOWObjectReferral -PhysicalResource $PhysicalResource -Count | Select-Object -Expandproperty referrals
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Find-AutomateNOWObjectReferral failed to extract the referrals on Physical Resource [$PhysicalResource_id] due to [$Message]."
            Break
        }
        If ($referrals_count -gt 0) {
            Write-Warning -Message "Unfortunately, you cannot rename a Physical Resource that has referrals. This is because the rename is not actually renaming but copying anew and deleting the old. Please, use the Find-AutomateNOWObjectReferral function to identify referrals and remove them."
            Break
        }
        Else {
            Write-Verbose -Message "The Physical Resource [$PhysicalResource_id] does not have any referrals. It is safe to proceed."
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($PhysicalResource_id)")) -eq $true) {
                $Error.Clear()
                Try {
                    [ANOWPhysicalResource]$new_PhysicalResource = Copy-AutomateNOWPhysicalResource -PhysicalResource $PhysicalResource -NewId $NewId -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Copy-AutomateNOWPhysicalResource failed to create a new Physical Resource [$NewId] as Part 1 of the renaming process due to [$Message]."
                    Break
                }
                If ($new_PhysicalResource.simpleId -eq $NewId) {
                    Write-Verbose -Message "Part 1: Physical Resource [$PhysicalResource_id] successfully copied to [$NewId]"
                }
                Else {
                    Write-Warning -Message "Somehow the first phase (Copy-AutomateNOWPhysicalResource) failed. Please look into this."
                    Break
                }
                $Error.Clear()
                Try {
                    Remove-AutomateNOWPhysicalResource -PhysicalResource $PhysicalResource -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Remove-AutomateNOWPhysicalResource failed to remove [$PhysicalResource_id] as Part 2 of the renaming process due to [$Message]."
                    Break
                }
                Write-Verbose -Message "Part 2: Physical Resource [$PhysicalResource_id] removed"
                Write-Verbose -Message "Task [$PhysicalResource_id] successfully renamed to [$NewId]"
                If ($Quiet -ne $true) {
                    Return $PhysicalResource
                }
            }
        }
        Else {
            Write-Warning -Message "No action was taken because either the source object didn't exist or the new object already existed"
        }
    }
    End {
    }
}

#endregion

#Region - Processing

Function Wait-AutomateNOWProcessing {
    <#
    .SYNOPSIS
    Waits for a Processing Item (Task, Workflow, Schedule or Service Manager) to complete executing on an AutomateNOW! instance

    .DESCRIPTION
    Waits for a Processing Item (Task, Workflow, Schedule or Service Manager) to complete executing on an AutomateNOW! instance

    .PARAMETER Processing
    An [ANOWProcessing] object representing the Processing Item to wait for. Use Get-AutomateNOWTask, Get-AutomateNOWWorkflow, Get-AutomateNOWSchedule or Get-AutomateNOWServiceManager to fetch these

    .PARAMETER WaitForExecutionInterval
    Optional int32 number of times (intervals) to wait for executing. The default value is 60.

    .PARAMETER WaitForExecutionDuration
    Optional int32 number of seconds to wait for executing between each interval. The default value is 10.

    .PARAMETER Quiet
    Switch parameter to silence the Write-Progress progress meter that appears by default

    .INPUTS
    ONLY [ANOWProcessing] objects are accepted (including from the pipeline) (this means Tasks, Workflows, Schedules and Service Managers)

    .OUTPUTS
    The [ANOWProcessing] will be returned once it is no longer in the EXECUTING state or when the intervals deplete

    .EXAMPLE
    Waits for an already started Workflow with a RunId of 12345678

    Get-AutomateNOWWorkflow -Id 12345678 | Wait-AutomateNOWProcessing

    .EXAMPLE
    Starts a Task Template named 'TaskTemplate1' without parameters and waits for it

    Get-AutomateNOWTaskTemplate -Id 'TaskTemplate1' | Start-AutomateNOWTaskTemplate | Wait-AutomateNOWProcessing

    .EXAMPLE
    Quietly waits for an already started Workflow with a RunId of 12345678 along with specifying a custom interval and delay time

    12345678 | Get-AutomateNOWWorkflow | Wait-AutomateNOWProcessing -WaitForExecutionInterval 23 -WaitForExecutionInterval 5 -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [CmdletBinding()]
    [Alias('Wait-AutomateNOWSchedule', 'Wait-AutomateNOWServiceManager', 'Wait-AutomateNOWTask', 'Wait-AutomateNOWWorkflow')]
    Param(
        [ValidateScript({ $_.processingStatus -eq 'EXECUTING' -or $_.processingStatus -eq 'WAITING' })]
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWProcessing]$Processing,
        [Parameter(Mandatory = $false)]
        [int32]$WaitForExecutionInterval = 60,
        [Parameter(Mandatory = $false)]
        [int32]$WaitForExecutionDuration = 10,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
    }
    Process {
        If ($_.Id.Length -gt 0) {
            [ANOWProcessing]$Processing = $_
        }
        [int64]$Processing_Id = $Processing.Id
        $Error.Clear()
        Try {
            [ANOWProcessing]$Processing = Get-AutomateNOWProcessingList -Id $Processing_Id
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWProcessingList failed to retrieve [$Processing_id] (under Wait-AutomateNOWProcessing) due to [$Message]."
            Break
        }
        If ($Processing.processingStatus -eq 'EXECUTING' -or $Processing.processingStatus -eq 'WAITING') {
            [string]$Processing_Name = $Processing.Name
            [int32]$loop = 1
            While ( ($Processing.processingStatus -eq 'EXECUTING' -or $Processing.processingStatus -eq 'WAITING') -and ($loop -lt $WaitForExecutionInterval)) {
                If ($Quiet -ne $true) {
                    Write-Progress -Activity "Waiting [$WaitForExecutionDuration] seconds for RunId [$Processing_Id] to complete executing" -Status "Loop $loop of $WaitForExecutionInterval" -CurrentOperation "$Processing_Name" -PercentComplete ($loop / $WaitForExecutionInterval * 100)
                }
                Start-Sleep -Seconds $WaitForExecutionDuration
                $Error.Clear()
                Try {
                    [ANOWProcessing]$Processing = Get-AutomateNOWProcessingList -Id $Processing_Id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWProcessingList failed to retrieve [$Processing_id] (under Wait-AutomateProcessing) due to [$Message]."
                    Break
                }
                $loop++
            }
            If ($Quiet -ne $true) {
                Write-Progress -Activity "Waiting has completed for RunId [$Processing_Id]" -Status "$WaitForExecutionInterval loops were completed" -Completed
            }
            [ANOWProcessing_processingStatus]$Processing_processingStatus = $Processing.processingStatus
            If ($loop -ge $WaitForExecutionInterval -and ($Processing.processingStatus -eq 'EXECUTING' -or $Processing.processingStatus -eq 'WAITING')) {
                Write-Warning -Message "After $WaitForExecutionInterval attempts of $WaitForExecutionDuration seconds each, $Processing_Id is still in EXECUTING status"
            }
            Write-Verbose -Message "Returning $Processing_Id which is in the [$Processing_processingStatus] status"
        }
        Return $Processing
    }
    End {

    }
}

Function Trace-AutomateNOWProcessing {
    <#
    .SYNOPSIS
    Traces a Workflow based on its parentage on an AutomateNOW! instance

    .DESCRIPTION
    Traces a Workflow based on its parentage on an AutomateNOW! instance. This function is intended only for Workflows.

    .PARAMETER Id
    Mandatory option of the int64 Run Id of the Workflow that you wish to trace.

    .PARAMETER Workflow
    Mandatory option to supply the [ANOWProcessing] object that you wish to trace. Do not send WorkflowTemplates here!

    .PARAMETER WaitForExecution
    Optional switch parameter to enable 'Waiting for execution...' loops. Use with caution. Default is 60 intervals at 10 seconds each.

    .PARAMETER WorkflowSortBy
    Optional string to supply the property to sort by. Valid values are: dateCreated*, sortOrder, endTime, firstStartTime, startTime, duration

    .PARAMETER DoNotIncludeTriggers
    Optional switch parameter to exclude the trigger items from the final result.

    .PARAMETER PerformDeepSearch
    Optional switch parameter to include searching for Workflows that were launched by one of the Workflows in the trace. Note, this may add a considerable number of items to the output.

    .PARAMETER ReturnContextVariables
    Optional switch parameter to replace the workflows in the output with the context variables instead.

    .PARAMETER DefaultPause
    Optional number of milliseconds to pause between each Workflow lookup. The default is 100. If you want to simulate the behavior of the console exactly then set this to 0 for no delays between Workflow lookups.

    .PARAMETER NoStats
    Optional switch to suppress the showing of stats (time elapsed) for the trace. This parameter is ignored if -Quiet is specified.

    .PARAMETER WaitForExecutionDuration
    Optional int32 number of seconds to wait for executing between each interval. The default value is 10.

    .PARAMETER WaitForExecutionInterval
    Optional int32 number of times (intervals) to wait for executing. The default value is 60.

    .PARAMETER IncludeArchived
    Optional switch parameter removes the filter for archived items thus both archived and non-archived items will be returned.

    .PARAMETER OnlyArchived
    Optional switch parameter filters out non-archived items thus only archived items will be returned.

    .PARAMETER pendingCharacter
    Optional 1-character string to change how the "waiting" status appears. The default character is an asterisk *.

    .PARAMETER Quiet
    .Optional switch that will suppress the Write-Information outputs during the course of the trace.

    .INPUTS
    Accepts either a numeric RunId in the -Id parameter or an [ANOWProcessing] object. Either can be presented via the pipeline.

    .OUTPUTS
    The output will be either an array of whole [ANOWProcessing] objects (formatted or unformatted) or the output will be an array of just the RunId's of the Workflows.

    .EXAMPLE
    Traces a workflow (by Id) with the RunId of 1234567 and a sort order of endTime

    Trace-AutomateNOWProcessing -Id 1234567 -WorkflowSortBy endTime

    .EXAMPLE
    Traces a workflow (by Id) with the RunId of 1234567 and using the pipeline with the default sort order (dateCreated)

    1234567 | Trace-AutomateNOWProcessing

    .EXAMPLE
    Traces a workflow (by object) with the RunId of 1234567 while excluding the trigger items from the output and sorting in the same order that the console uses (sortOrder).

    Get-AutomateNOWWorkflow -Id 1234567 | Trace-AutomateNOWProcessing -DoNotIncludeTriggers -WorkflowSortBy sortOrder

    .EXAMPLE
    Traces (and waits for) a workflow (by object) with the RunId of 1234567 using the pipeline and returns the Context Variables instead of the Workflows

    1234567 | Get-AutomateNOWWorkflow | Trace-AutomateNOWProcessing -ReturnContextVariables -WaitForExecution

    .EXAMPLE
    Quietly starts a Workflow and deep traces it while waiting for execution and ignoring trigger items.

    Get-AutomateNOWWorkflowTemplate -Id 'Worflow1' | Start-AutomateNOWWorkflowTemplate | Trace-AutomateNOWProcessing -WaitForExecution -PerformDeepSearch -DoNotIncludeTriggers -ReturnContextVariables -Quiet

    .EXAMPLE
    Starts a Task Template ('TaskTemplate1') with parameters, waits for execution to complete and returns the context variables (one-liner format)

    Get-AutomateNOWTaskTemplate -Id 'TaskTemplate1' | Start-AutomateNOWTaskTemplate -TaskParameters @{parameter1 = "value1"; parameter2 = "value2";} | Trace-AutomateNOWTask -WaitForExecution -ReturnContextVariables

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This function uses an inner function to ensure that the output does not contain any duplicates. Help to re-write this to be more efficient would be welcomed!

    All sorting has a secondary sort by id. This is most applicable when sorting by sortOrder property while including triggers.The default sort order of the console is sortOrder but the default sort order for this function is dateCreated.

    This function only supports [ANOWProcessing] objects through the pipeline. Id's must be specified individually.

    #>
    [CmdletBinding()]
    [Alias('Trace-AutomateNOWSchedule', 'Trace-AutomateNOWServiceManager', 'Trace-AutomateNOWTask', 'Trace-AutomateNOWWorkflow')]
    Param(
        [Parameter(Mandatory = $True, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [int64]$Id,
        [Parameter(Mandatory = $True, ParameterSetName = 'Processing', ValueFromPipeline = $true)]
        [ANOWProcessing]$Processing,
        [Parameter(Mandatory = $False)]
        [switch]$WaitForExecution,
        [Parameter(Mandatory = $False)]
        [int32]$WaitForExecutionDuration = 10,
        [Parameter(Mandatory = $False)]
        [int32]$WaitForExecutionInterval = 60,
        [ValidateSet('dateCreated', 'sortOrder', 'id', 'endTime', 'firstStartTime', 'startTime', 'duration', IgnoreCase = $false)]
        [Parameter(Mandatory = $False)]
        [string]$ProcessingSortBy = 'dateCreated',
        [Parameter(Mandatory = $False)]
        [switch]$DoNotIncludeTriggers,
        [Parameter(Mandatory = $False)]
        [switch]$PerformDeepSearch,
        [Parameter(Mandatory = $False)]
        [switch]$ReturnContextVariables,
        [Parameter(Mandatory = $False)]
        [switch]$ReturnRunIds,
        [Parameter(Mandatory = $False)]
        [switch]$NoStats,
        [Parameter(Mandatory = $False)]
        [int32]$DefaultPause = 100,
        [Parameter(Mandatory = $False)]
        [switch]$IncludeArchived,
        [Parameter(Mandatory = $False)]
        [switch]$OnlyArchived,
        [ValidateScript({ $_.length -eq 1 })]
        [Parameter(Mandatory = $False)]
        [string]$pendingCharacter = '*',
        [Parameter(Mandatory = $False)]
        [switch]$Quiet
    )
    Begin {
        Function Search-AutomateNOWProcessing {
            [Cmdletbinding()]
            Param(
                [Parameter(Mandatory = $True, ParameterSetName = 'Id', ValueFromPipeline = $true)]
                [int64]$Id,
                [Parameter(Mandatory = $True, ParameterSetName = 'Processing', ValueFromPipeline = $true)]
                [ANOWProcessing]$Processing,
                [Parameter(Mandatory = $False)]
                [array]$items,
                [Parameter(Mandatory = $False)]
                [int32]$DefaultPause = 100,
                [Parameter(Mandatory = $False)]
                [switch]$PerformDeepSearch,
                [Parameter(Mandatory = $False)]
                [switch]$IncludeArchived,
                [Parameter(Mandatory = $False)]
                [switch]$OnlyArchived,
                [ValidateScript({ $_.length -eq 1 })]
                [Parameter(Mandatory = $False)]
                [string]$pendingCharacter = '*'
            )
            Begin {
                If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
                    Write-Warning -Message "Somehow there is not a valid token confirmed."
                    Break
                }
                [hashtable]$parameters = @{}
                $parameters.Add('Method', 'POST')
                $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
                If ($anow_session.NotSecure -eq $true) {
                    $parameters.Add('NotSecure', $true)
                }
                If ($ReturnContextVariables -eq $true -and $ReturnRunIds -eq $true) {
                    Write-Warning -Message "You cannot use -ReturnContextVariables with -ReturnRunIds. Please choose one or the other."
                    Break
                }
            }
            Process {
                [int32]$items_count = $global:items.count
                Write-Verbose -Message "Current items count: $items_count"
                Write-Debug -Message "Current items count: $items_count"
                If ((($_ -is [int64]) -or ($Id -gt 0)) -and ($Id -notin $global:items.id)) {
                    If ($Id -gt 0) {
                        [int64]$current_id = $Id
                    }
                    Else {
                        [int64]$current_id = $_
                    }
                    If ($global:items.Id -notcontains $current_id) {
                        [hashtable]$parameters = @{}
                        $parameters.Add('Id', $current_id)
                        If ($IncludeArchived -eq $true) {
                            $parameters.Add('IncludeArchived', $true)
                        }
                        If ($OnlyArchived -eq $true) {
                            $parameters.Add('OnlyArchived', $true)
                        }
                        #[string]$processingType = $Processing.processingType
                        #If ($processingType -in ('WORKFLOW', 'TASK', 'TRIGGER', 'SERVICE')) {
                        $Error.Clear()
                        Try {
                            [ANOWProcessing]$Processing = Get-AutomateNOWProcessingList @parameters
                        }
                        Catch {
                            [string]$Message = $_.Exception.Message
                            Write-Warning -Message "Get-AutomateNOWTask failed (under Search-AutomateNOWProcessing) due to [$Message]."
                            Break
                        }
                        #}
                        #Else {
                        #    Write-Warning -Message "$current_id has a processingType of $processingType which is not recognized!"
                        #    Break
                        #}
                        If ($Processing.Id.Length -gt 0 -and $global:items.Id -notcontains $Processing.Id) {
                            [string]$item_id = $Processing.Id
                            [int32]$items_count = $global:items.Count
                            If ($items_count -gt 0) {
                                [array]$global:items = @($global:items) + @($Processing)
                            }
                            Else {
                                [array]$global:items = @($Processing)
                            }
                            [int32]$items_count = $global:items.Count
                            Write-Verbose -Message "Adding $item_id ($items_count items accumulated) to the collection (1)"
                            Write-Debug -Message "Adding $item_id ($items_count items accumulated) to the collection (1)"
                        }
                    }
                }
                ElseIf ($_ -is [ANOWProcessing]) {
                    [ANOWProcessing]$Processing = $_
                }
                ElseIf ($Processing.Id.Length -gt 0) {
                    #this space intentionally left blank
                }
                ElseIf ($Id -in $global:items.id) {
                    $Error.Clear()
                    Try {
                        [ANOWProcessing]$Processing = ($global:items | Where-Object { $_.Id -eq $Id })
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Failed to create a single [ANOWProcessing] object from the traced items due to [$Message]. Note, that this function is in experimental status. Please report steps to reproduce to the author."
                        Break
                    }
                }
                Else {
                    Write-Warning -Message "Somehow was unable to determine the object type that was passed to the pipeline of Search-AutomateNOWProcessing"
                    Break
                }
                [int32]$items_count = $global:items.Count
                If ($items_count -eq 0 -and $null -eq $Processing -and $Id -gt 0) {
                    Write-Warning -Message "Apparently the RunId you provided [$Id] does not exist on this instance. Are you sure you are in the correct ANOW domain?"
                    Break
                }
                If ($Processing.Id -gt 0 -and $global:items.Id -notcontains $Processing.Id) {
                    [int64]$item_id = $Processing.Id
                    [array]$global:items = @($global:items) + @($Processing)
                    [int32]$items_count = $global:items.Count
                    Write-Verbose -Message "Adding $item_id ($items_count items accumulated) to the collection (2)"
                    Write-Debug -Message "Adding $item_id ($items_count items accumulated) to the collection (2)"
                }
                [int64]$RunId = $Processing.Id
                If ($null -ne $Processing.processingStatus) {
                    [ANOWProcessing_processingStatus]$Processing_processingStatus = $Processing.processingStatus
                }
                Else {
                    [ANOWProcessing_processingStatus]$Processing_processingStatus = 'WAITING'
                }
                If (($Processing_processingStatus -eq 'EXECUTING' -or $Processing_processingStatus -eq 'WAITING' -or $null -eq $Processing_processingStatus) -and $WaitForExecution -eq $true) {
                    [hashtable]$parameters = @{}
                    $parameters.Add('Processing', $Processing)
                    $parameters.Add('WaitForExecutionInterval', $WaitForExecutionInterval)
                    $parameters.Add('WaitForExecutionDuration', $WaitForExecutionDuration)
                    If ($Quiet -eq $true) {
                        $parameters.Add('Quiet', $true)
                    }
                    Write-Verbose -Message "Initating wait for $RunId"
                    Write-Debug -Message "Initating wait for $RunId"
                    $Error.Clear()
                    Try {
                        [ANOWProcessing]$Processing = Wait-AutomateNOWProcessing @parameters
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Wait-AutomateNOWProcessing failed to wait for RunId $RunId due to [$Message]."
                        Break
                    }
                    [ANOWProcessing_processingStatus]$Processing_processingStatus = $Processing.processingStatus
                    If ($Processing_processingStatus -eq 'EXECUTING' -or $Processing_processingStatus -eq 'WAITING') {
                        Write-Warning -Message "$RunId was still executing (or waiting) after pause intervals were exhausted!"
                    }
                }
                ElseIf (($Processing_processingStatus -eq 'EXECUTING' -or $Processing_processingStatus -eq 'WAITING') -and $WaitForExecution -ne $true -and $ReturnContextVariables -eq $true) {
                    If ($Quiet -ne $true) {
                        Write-Warning -Message "Warning: $RunId is still executing (or waiting) but you requested Context Variables. As a result, you may not receive all of the Context Variables that you were expecting. Use -WaitForExecution or -Quiet to suppress this warning."
                    }
                }
                [hashtable]$parameters = @{}
                $Error.Clear()
                Try {
                    [ANOWProcessing_processingType]$processingType = $Processing.processingType
                    If ($null -ne $Processing.taskType) {
                        [ANOWProcessing_taskType]$taskType = $Processing.taskType
                    }
                    ElseIf ( $null -ne $Processing.triggerType.Length -gt 0) {
                        [ANOWProcessing_triggerType]$triggerType = $Processing.triggerType
                    }
                    Else {
                        [string]$taskType = 'n/a'
                    }
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Somehow failed to extract the processingType from a Processing object due to [$Message]."
                    Break
                }
                If ($Quiet -ne $true) {
                    Write-Host $pendingCharacter -NoNewLine
                }
                [int32]$items_count = $global:items.count
                If ($Processing.triggerType.Length -gt 0) {
                    Write-Verbose -Message "Tracing $RunId ($items_count items accumulated) ($processingType of type $triggerType)"
                    Write-Debug -Message "Tracing $RunId ($items_count items accumulated) ($processingType of type $triggerType)"
                }
                Else {
                    Write-Verbose -Message "Tracing $RunId ($items_count items accumulated) ($processingType of type $taskType)"
                    Write-Debug -Message "Tracing $RunId ($items_count items accumulated) ($processingType of type $taskType)"
                }
                If ($processingType -eq 'TRIGGER' -and (($taskType -eq 'PROCESSING_OBSERVER') -or ($triggerType.length -gt 0))) {
                    If ($taskType -eq 'PROCESSING_OBSERVER') {
                        Write-Verbose -Message "$RunId is the Processing Observer (Trigger)"
                        Write-Debug -Message "$RunId is the Processing Observer (Trigger)"
                    }
                    Else {
                        Write-Verbose -Message "$RunId is the starting trigger ($triggerType type)"
                        Write-Debug -Message "$RunId is the starting trigger ($triggerType type)"
                    }
                    [string]$nextProperty = 'Id'
                    $parameters.Add('Id', $RunId)
                    $parameters.Add('ItemsOnly', $true)
                }
                ElseIf ($processingType -eq 'TASK' -and $taskType -eq 'TRIGGER_ITEM') {
                    Write-Verbose -Message "$RunId is the follow-up Trigger Item Task"
                    Write-Verbose -Message "$RunId is the follow-up Trigger Item Task"
                    [boolean]$isProcessing = $Processing.isProcessing
                    [int64]$exitCode = $Processing.exitCode
                    [ANOWProcessing_processingStatus]$processingStatus = $Processing.processingStatus
                    If ($isProcessing -eq $false -and $exitCode -eq 0) {
                        If ($processingStatus -in @('WAITING', 'READY')) {
                            Write-Verbose -Message "Skipping $RunId because it is in a state of $processingStatus"
                            Write-Debug -Message "Skipping $RunId because it is in a state of $processingStatus"
                            [string]$nextProperty = 'Id'
                            $parameters.Add('Id', $RunId)
                            $parameters.Add('ItemsOnly', $true)
                        }
                        Else {
                            Write-Warning -Message "How can $RunId (a TRIGGER_ITEM) be in a state of isProcessing = false and processingStatus is $processingStatus instead of (WAITING or READY)?"
                            Break
                        }
                    }
                    Else {
                        [string]$nextProperty = 'exitCode'
                        If ($exitCode -eq 0) {
                            Write-Warning -Message "Somehow $RunId (a TRIGGER_ITEM) didn't have an exit code. (processingStatus = $processingStatus) Please look into this..."
                            Break
                        }
                        $parameters.Add('Id', $exitCode)
                    }
                }
                Else {
                    [string]$nextProperty = 'Id'
                    $parameters.Add('Id', $RunId)
                    $parameters.Add('ItemsOnly', $true)
                }
                If ($IncludeArchived -eq $true) {
                    $parameters.Add('IncludeArchived', $true)
                }
                If ($OnlyArchived -eq $true) {
                    $parameters.Add('OnlyArchived', $true)
                }
                [string]$parameters_display = $parameters | ConvertTo-Json -Compress
                Write-Verbose -Message "Sending the following parameters to Get-AutomateNOWProcessingList: $parameters_display"
                Write-Verbose -Message "Pausing for [$DefaultPause] milliseconds before proceeding to trace $RunId..."
                Start-Sleep -Milliseconds $DefaultPause
                $Error.Clear()
                Try {
                    [ANOWProcessing[]]$new_items = Get-AutomateNOWProcessingList @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWProcessingList failed to retrieve $RunId (under Search-AutomateNOWProcessing) due to [$Message]."
                    Break
                }
                [array]$new_items = $new_items | Where-Object { $_.Id -notin $global:items.Id }
                [int32]$new_items_count = $new_items.count
                If ($new_items_count -eq 1 -and (($new_items.processingType -eq 'TRIGGER' -and ($new_items.taskType -eq 'PROCESSING_OBSERVER' -or $new_items.taskType -eq 'n/a' )) -or ($new_items.processingType -eq 'TASK' -and $new_items.taskType -eq 'TRIGGER_ITEM' ))) {
                    [int64]$current_id = $new_items.Id
                    [int64]$NextId = $new_items."$nextProperty"
                    If ($NextId -eq 0) {
                        Write-Warning -Message "Somehow a starting trigger, a trigger_item or a processing_observer ($current_id) has no child exit code!"
                        Break
                    }
                    ElseIf ($NextId -in $global:items.Id) {
                        Write-Verbose -Message "Skipping $NextId because it is already in the collection..." # Note: This check may not be needed
                        Write-Debug -Message "Skipping $NextId because it is already in the collection..." # Note: This check may not be needed
                    }
                    Else {
                        [int32]$items_count = $global:items.count
                        Write-Verbose -Message "Adding $NextId ($items_count items accumulated) to the next trace"
                        Write-Debug -Message "Adding $NextId ($items_count items accumulated) to the next trace"
                        [hashtable]$parameters = @{}
                        $parameters.Add('Id', $NextId)
                        $parameters.Add('Items', $global:items)
                        If ($PerformDeepSearch -eq $true) {
                            $parameters.Add('PerformDeepSearch', $true)
                        }
                        If ($IncludeArchived -eq $true) {
                            $parameters.Add('IncludeArchived', $true)
                        }
                        If ($OnlyArchived -eq $true) {
                            $parameters.Add('OnlyArchived', $true)
                        }
                        $Error.Clear()
                        Try {
                            Search-AutomateNOWProcessing @parameters
                        }
                        Catch {
                            [string]$Message = $_.Exception.Message
                            [string]$parameters_display = $parameters | ConvertTo-Json -Compress
                            Write-Warning -Message "Search-AutomateNOWProcessing failed (#1) regarding `$NextId $NextId due to [$Message]. Full parameters were: $parameters_display"
                            Break
                        }
                    }
                }
                ElseIf ($new_items_count -gt 0 -or $PerformDeepSearch -eq $true) {
                    If ($PerformDeepSearch -eq $true) {
                        Write-Verbose -Message "Pausing for [$DefaultPause] milliseconds before proceeding to deep search $RunId"
                        Write-Debug -Message "Pausing for [$DefaultPause] milliseconds before proceeding to deep search $RunId"
                        Start-Sleep -Milliseconds $DefaultPause
                        [hashtable]$parameters = @{}
                        $parameters.Add('LaunchedById', $RunId)
                        If ($IncludeArchived -eq $true) {
                            $parameters.Add('IncludeArchived', $true)
                        }
                        If ($OnlyArchived -eq $true) {
                            $parameters.Add('OnlyArchived', $true)
                        }
                        $Error.Clear()
                        Try {
                            [array]$new_launched_by_items = Get-AutomateNOWProcessingList @parameters
                        }
                        Catch {
                            [string]$Message = $_.Exception.Message
                            Write-Warning -Message "Get-AutomateNOWProcessingList failed (during deep search for $RunId) due to [$Message]."
                            Break
                        }
                        [array]$new_launched_by_items = $new_launched_by_items | Where-Object { $_.Id -notin $global:items.Id }
                        [int32]$new_launched_by_items_count = $new_launched_by_items.Count
                        If ($new_launched_by_items_count -gt 0) {
                            Write-Verbose -Message "Found $new_launched_by_items_count new Processing items that will be added to the trace"
                            Write-Debug -Message "Found $new_launched_by_items_count new Processing items that will be added to the trace"
                            ForEach ($new_launched_by_item in $new_launched_by_items) {
                                [int64]$new_launchedby_id = $new_launched_by_item.Id
                                If ($global:items.Id -notcontains $new_launchedby_id) {
                                    [int32]$items_count = $global:items.count
                                    Write-Verbose -Message "Adding $new_launchedby_id ($items_count items accumulated) to the trace list (launchedById)"
                                    Write-Debug -Message "Adding $new_launchedby_id ($items_count items accumulated) to the trace list (launchedById)"
                                    [array]$global:items = @($global:items) + @($new_launched_by_item)
                                    [hashtable]$parameters = @{}
                                    $parameters.Add('Id', $new_launchedby_id)
                                    $parameters.Add('Items', $global:items)
                                    If ($PerformDeepSearch -eq $true) {
                                        $parameters.Add('PerformDeepSearch', $true)
                                    }
                                    If ($IncludeArchived -eq $true) {
                                        $parameters.Add('IncludeArchived', $true)
                                    }
                                    If ($OnlyArchived -eq $true) {
                                        $parameters.Add('OnlyArchived', $true)
                                    }
                                    $Error.Clear()
                                    Try {
                                        Search-AutomateNOWProcessing @parameters
                                    }
                                    Catch {
                                        [string]$Message = $_.Exception.Message
                                        Write-Warning -Message "Search-AutomateNOWProcessing failed (#2) due to [$Message]."
                                        Break
                                    }
                                }
                            }
                        }
                    }
                    [array]$new_items = $new_items | Where-Object { $_.Id -notin $global:items.Id }
                    ForEach ($new_item in $new_items) {
                        [int64]$new_item_id = $new_item.id
                        [int32]$items_count = $global:items.count
                        If ($Quiet -ne $true) {
                            Write-Host $pendingCharacter -NoNewLine
                        }
                        Write-Verbose -Message "Adding $new_item_id ($items_count items accumulated) to the trace list (new items)"
                        Write-Debug -Message "Adding $new_item_id ($items_count items accumulated) to the trace list (new items)"
                        [array]$global:items = @($global:items) + @($new_item)
                        [hashtable]$parameters = @{}
                        $parameters.Add('Id', $new_item_id)
                        $parameters.Add('Items', $global:items)
                        If ($PerformDeepSearch -eq $true) {
                            $parameters.Add('PerformDeepSearch', $true)
                        }
                        If ($IncludeArchived -eq $true) {
                            $parameters.Add('IncludeArchived', $true)
                        }
                        If ($OnlyArchived -eq $true) {
                            $parameters.Add('OnlyArchived', $true)
                        }
                        $Error.Clear()
                        Try {
                            Search-AutomateNOWProcessing @parameters
                        }
                        Catch {
                            [string]$Message = $_.Exception.Message
                            Write-Warning -Message "Search-AutomateNOWProcessing failed (#3) due to [$Message]."
                            Break
                        }
                    }
                }
                Else {
                    [int32]$items_count = $global:items.Count
                    If ($items_count -gt 0) {
                        Write-Verbose -Message "$items_count items are in the queue"
                        Write-Debug -Message "$items_count items are in the queue"
                        [int64[]]$unique_item_ids = $global:items.id | Sort-Object -Unique
                        [ANOWProcessing[]]$unique_items = ForEach ($unique_item_id in $unique_item_ids) {
                            $global:items | Where-Object { $_.Id -eq $unique_item_id | Select-Object -First 1 }
                        }
                        [int32]$unique_items_count = $unique_items.Count
                        If ($unique_items_count -lt $items_count) {
                            Write-Verbose -Message "The items account was reduced from $items_count to $unique_items_count"
                            Write-Debug -Message "The items account was reduced from $items_count to $unique_items_count"
                        }
                        Return $unique_items
                    }
                }
            }
            End {
                [int32]$items_count = $global:items.count
                Write-Verbose -Message "End running with $items_count items accrued"
                Write-Debug -Message "End running with $items_count items accrued"
                [int64[]]$unique_item_ids = $global:items.id | Sort-Object -Unique
                [ANOWProcessing[]]$unique_items = ForEach ($unique_item_id in $unique_item_ids) {
                    $global:items | Where-Object { $_.Id -eq $unique_item_id | Select-Object -First 1 }
                }
                [int32]$unique_items_count = $unique_items.Count
                If ($unique_items_count -lt $items_count) {
                    Write-Verbose -Message "Reduced items accrued from $items_count to $unique_items_count"
                    Write-Debug -Message "Reduced items accrued from $items_count to $unique_items_count"
                }
                Return $unique_items
            }
        }
    }
    Process {
        $global:items = @()
        [hashtable]$parameters = @{}
        If (($Id -gt 0) -or ($_ -is [int64] -or $_ -is [int32])) {
            If ($Id -gt 0) {
                [int64]$original_id = $Id
            }
            Else {
                [int64]$original_id = $Id
            }
            $parameters.Add('Id', $original_id)
        }
        ElseIf (($Processing.Id -gt 0) -or ($_.Id -gt 0)) {
            If ($Processing.Id -gt 0) {
                [int64]$original_id = $Processing.Id
                $parameters.Add('Processing', $Processing)
            }
            Else {
                [int64]$original_id = $_.Id
                $parameters.Add('Processing', $_)
            }
        }
        Else {
            Write-Warning -Message "Somehow was unable to determine the starting Id to start this trace from. How can that happen? Are you debugging?"
            Break
        }
        If ($Quiet -ne $true) {
            Write-Host "Tracing $original_id $pendingCharacter" -NoNewLine
        }
        Write-Verbose -Message "Tracing $original_id (1 item accumulated) (first)"
        Write-Debug -Message "Tracing $original_id (1 item accumulated) (first)"
        $parameters.Add('DefaultPause', $DefaultPause)
        If ($PerformDeepSearch -eq $true) {
            $parameters.Add('PerformDeepSearch', $true)
        }
        If ($IncludeArchived -eq $true) {
            $parameters.Add('IncludeArchived', $true)
        }
        If ($OnlyArchived -eq $true) {
            $parameters.Add('OnlyArchived', $true)
        }
        [System.Diagnostics.Stopwatch]$stopwatch = [System.Diagnostics.Stopwatch]::new()
        $stopwatch.Start()
        [array]$returned_items = Search-AutomateNOWProcessing @parameters
        [int32]$returned_items_count = $returned_items.Count
        If ($returned_items_count -gt 0) {
            [int64[]]$unique_ids = @($returned_items.Id | Sort-Object -Unique)
            [array]$formatted_items = ForEach ($Id in $unique_ids) {
                $returned_items | Where-Object { $_.Id -eq $Id } | Select-Object -First 1
            }
            [int32]$formatted_items_count = $formatted_items.count
            [string]$object_label = 'Processing object'
            If ($formatted_items_count -eq 0) {
                Write-Warning -Message "Somehow the returned items were lost after formatting! Please look into this or contact the author with steps to reproduce if you were not debugging."
                Break
            }
            Else {
                If ($DoNotIncludeTriggers -eq $true) {
                    [array]$formatted_items = ($formatted_items | Where-Object { $_.Id -notin ($formatted_items | Where-Object { (($_.processingType -eq 'TRIGGER') -and ($_.taskType -eq 'PROCESSING_OBSERVER' -or $null -eq $_.taskType)) -or (($_.processingType -eq 'TASK') -and ($_.taskType -eq 'TRIGGER_ITEM')) } | Select-Object -ExpandProperty Id) }) #this line of code really needs to be optimized :-)
                }
                [array]$formatted_items = $formatted_items | Sort-Object -Property $ProcessingSortBy, 'id'
                [int32]$formatted_items_count = $formatted_items.count
                If ($formatted_items_count -gt 0) {
                    If ($ReturnContextVariables -ne $true) {
                        If ($ReturnRunIds -eq $true) {
                            [array]$formatted_items = @($formatted_items.Id)
                            [string]$object_label = 'RunId'
                        }
                        Write-Verbose -Message "Returning [$formatted_items_count] [$object_label]'s sorted by [$ProcessingSortBy] (traced from $original_id)"
                        Write-Debug -Message "Returning [$formatted_items_count] [$object_label]'s sorted by [$ProcessingSortBy] (traced from $original_id)"
                    }
                    Else {
                        [int64[]]$IdArray = @($formatted_items.Id)
                        [string]$IdArray_display = $IdArray | ConvertTo-JSON -Compress
                        Write-Verbose -Message "Fetching $formatted_items_count Context Variables (from RunId's: $IdArray_display)"
                        Write-Debug -Message "Fetching $formatted_items_count Context Variables (from RunId's: $IdArray_display)"
                        $Error.Clear()
                        Try {
                            [ANOWProcessingContextVariable[]]$context_variables = Get-AutomateNOWContextVariable -RunId $IdArray -startRow 0 -endRow 10000
                        }
                        Catch {
                            [string]$Message = $_.Exception.Message
                            Write-Warning -Message "Get-AutomateNOWContextVariable failed (under Trace-AutomateNOWProcessing) due to [$Message]."
                            Break
                        }
                        [int64[]]$root_ids = $formatted_items | Where-Object { $_.ancestorpath.count -eq 0 } | Where-Object { $_.Id -gt 0 } | Select-Object -ExpandProperty Id
                        [int32]$context_variables_count = $context_variables.count
                        Write-Verbose -Message "Fetched $context_variables_count Context Variables"
                        Write-Debug -Message "Fetched $context_variables_count Context Variables"
                        If ($context_variables_count -gt 0) {
                            [array]$formatted_variables = ForEach ($variable in $context_variables) {
                                [int64]$current_variable_processingId = $variable.processing
                                [ANOWProcessing]$current_workflow = $formatted_items | Where-Object { $_.Id -eq $current_variable_processingId } | Select-Object -First 1
                                [int64]$rootProcessingId = $current_workflow.rootProcessingId
                                [int64]$parent = $current_workflow.parent
                                [string]$ancestorPath = $current_workflow.ancestorPath
                                [boolean]$isRoot = $current_workflow.isRoot
                                [int32]$ancestorCount = $(If ($ancestorPath.Length -gt 0) { ($ancestorPath -split ',') | Measure-Object | Select-Object -ExpandProperty Count -EA 0 })
                                If ($current_variable_processingId -in $root_ids) {
                                    [string]$scope = 'Root'
                                }
                                ElseIf ($rootProcessingId -eq $parent) {
                                    [string]$scope = 'Parent'
                                }
                                Else {
                                    [string]$scope = 'Self'
                                }
                                [PSCustomObject]@{ scope = $scope; name = $variable.name; value = $variable.value; processing = $variable.processing; id = $variable.id; rootProcessingId = $rootProcessingId; parent = $parent; ancestorPath = $ancestorPath; ancestorCount = $ancestorCount; isRoot = $isRoot; }
                            }
                        }
                    }
                }
            }
        }
        Else {
            Write-Verbose -Message "There were no returned items when tracing from [$original_id]"
            Write-Debug -Message "There were no returned items when tracing from [$original_id]"
        }
        $stopwatch.Stop()
        [decimal]$elapsed_seconds = [math]::Round($stopwatch.elapsed.TotalSeconds, 2)
        If ($Quiet -ne $true) {
            If ($NoStats -ne $true) {
                If ($formatted_items_count -gt 0) {
                    [decimal]$average_time_per_item = [math]::Round(($elapsed_seconds / $formatted_items_count), 2)
                }
                Else {
                    [decimal]$average_time_per_item = 0
                }
                If ($null -eq $context_variables_count) {
                    [int32]$context_variables_count = 0
                }
                If ($elapsed_seconds -lt 60) {
                    If ($Quiet -ne $true) {
                        Write-Information -MessageData "Trace $original_id completed: $formatted_items_count processing items in $elapsed_seconds sec. ($average_time_per_item sec. each). $context_variables_count context variables were returned."
                    }
                    ElseIf ($elapsed_seconds -lt 3600) {
                        [decimal]$elapsed_minutes = [math]::Round(($elapsed_seconds / 60), 2)
                        [int32]$elapsed_seconds = ($elapsed_seconds - ($elapsed_minutes * 60))
                        If ($elapsed_minutes -gt 0) {
                            Write-Information -MessageData "Trace $original_id completed: $formatted_items_count processing items in 1 minute and $elapsed_seconds sec. ($average_time_per_item sec. each). $context_variables_count context variables were returned."
                        }
                        Else {
                            Write-Information -MessageData "Trace $original_id completed: $formatted_items_count processing items in $elapsed_minutes min. ($average_time_per_item sec. each). $context_variables_count context variables were returned."
                        }
                    }
                    Else {
                        [decimal]$elapsed_hours = [math]::Round(($elapsed_seconds / 3600), 2)
                        If ($elapsed_hours -gt 0) {
                            Write-Information -MessageData "Trace $original_id completed: $formatted_items_count workflows in $elapsed_elapsed hour(s) ($average_time_per_item sec. each). $context_variables_count context variables were returned. This trace took entirely too much time. Please look into this."
                        }
                    }
                }
            }
        }
        If ($formatted_items_count -gt 0 -and $ReturnContextVariables -ne $true) {
            Return $formatted_items
        }
        If ($context_variables_count -gt 0 -and $ReturnContextVariables -eq $true) {
            Return $formatted_variables
        }
    }
    End {

    }
}

#endregion

#Region - Processing List (Menu Specialty)

Function Get-AutomateNOWProcessingList {
    <#
    .SYNOPSIS
    Gets the Processing List from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Processing List from an AutomateNOW! instance

    .PARAMETER Id
    Optional int64 parameter to limit the result to a single result by Id. This parameter cannot be combined with other parameters.

    .PARAMETER sortBy
    Optional string parameter to sort the results by (may not be used with the Id parameter). Valid choices are: 'id', 'processingType','template', 'dateCreated', 'firstStartTime', 'lastUpdated', 'launchedByName', 'launchedById', 'exitProcessingStatus', 'rootTemplate', 'endTime', 'processingStatus', 'startTime', 'processingTimestamp', 'processingLaunchType'

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .PARAMETER ItemsOnly
    Optional switch parameter that modifies the -Id parameter set to provide the executed child Items within the Workflow. This switch completely changes the output of this function and may only be used in conjuntion with the -Id parameter.

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100. The console default hard limit is 10,000.

    .PARAMETER IncludeArchived
    Optional switch parameter removes the filter for archived items thus both archived and non-archived items will be returned.

    .PARAMETER OnlyArchived
    Optional switch parameter filters out non-archived items thus only archived items will be returned.

    .PARAMETER Folder
    Optional string to filter by a particular Folder

    .PARAMETER Tags
    Optional string array of Tags to filter by. Note that the 'containsAny' operator will be used.

    .PARAMETER isProcessing
    Optional switch parameter that enables the requirement for the processing items to be considering "isProcessing". Setting this parameter to $true delivers the functionality of the Processing List menu functionality, otherwise this function is equivalent to this function into Get-AutomateNOWProcessing.

    .OUTPUTS
    An array of one or more [ANOWProcessing] class objects

    .EXAMPLE
    Gets the first page of items in the Processing List

    Get-AutomateNOWProcessingList

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This is a "menu specialty" function meaning that its purpose is to mimic one of the UI buttons. This function returns all types of Processing items. You should instead use the respective processing functions (i.e. Get-AutomateNOWTask, GetAutomateNOWWorkflow, Get-AutomateNOWServiceManager, Get-AutomateNOWSchedule).

    Unlike most Get/Read functions, there is no default sort order. The UI probably does this for performance reasons.

    You must include the -isProcessing switch parameter to fully emulate the menu function.

    #>
    [OutputType([ANOWProcessing[]])]
    [Cmdletbinding( DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $True, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [string]$Id,
        [ValidateSet('id', 'processingType', 'template', 'dateCreated', 'firstStartTime', 'lastUpdated', 'launchedByName', 'launchedById', 'exitProcessingStatus', 'rootTemplate', 'endTime', 'processingStatus', 'startTime', 'processingTimestamp', 'processingLaunchType')]
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$sortBy,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$Descending,
        [Parameter(Mandatory = $false, ParameterSetName = 'Id')]
        [switch]$ItemsOnly,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$IncludeArchived,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$OnlyArchived,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$Folder,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string[]]$Tags,
        [Parameter(Mandatory = $False)]
        [switch]$isProcessing
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        If ($Descending -eq $true -and $sortBy.Length -eq 0) {
            Write-Warning -Message "You must include the -sortBy parameter when -Descending is used"
            Break
        }
        [string]$command = ('/processing/read')
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        If (($_.Length -gt 0 -or $Id.Length -gt 0) -and $ItemsOnly -ne $true) {
            If ( $_.Length -gt 0 ) {
                [string]$Id = $_
            }
            $BodyMetaData.'id' = $Id
            $BodyMetaData.'_operationId' = 'read'
            [string]$textMatchStyle = 'exactCase'
        }
        Else {
            $BodyMetaData.'_constructor' = 'AdvancedCriteria'
            $BodyMetaData.'operator' = 'and'
            $BodyMetaData.'_startRow' = $startRow
            $BodyMetaData.'_endRow' = $endRow
            $BodyMetaData.'_operationType' = 'fetch'
            [string]$componentId = 'ProcessingList'
            [string]$textMatchStyle = 'substring'
            If ($sortBy.Length -gt 0) {
                If ($Descending -eq $true) {
                    $BodyMetaData.'_sortBy' = '-' + $sortBy
                }
                Else {
                    $BodyMetaData.'_sortBy' = $sortBy
                }
            }
            If ($isProcessing -eq $true) {
                $BodyMetaData.'criteria1' = '{"fieldName":"isProcessing","operator":"equals","value":true}'
            }
            If ($OnlyArchived -eq $true) {
                $BodyMetaData.'criteria2' = '{"fieldName":"archived","operator":"equals","value":true}'
            }
            ElseIf ($IncludeArchived -ne $true) {
                $BodyMetaData.'criteria2' = '{"fieldName":"archived","operator":"equals","value":false}'
            }
            If ($ItemsOnly -eq $true -and $Id -gt 0) {
                $BodyMetaData.'criteria3' = '{"fieldName":"parent","value":"' + $Id + '","operator":"equals"}'
                [string]$componentId = 'ProcessingItemList'
            }
            If ($Folder.Length -gt 0) {
                $BodyMetaData.'criteria4' = ('{"fieldName":"folder","operator":"equals","value":"' + $Folder + '"}')
            }
            If ($Tags.Count -gt 0) {
                If ($Tags.Count -gt 1) {
                    $Error.Clear()
                    Try {
                        [string]$TagString = $Tags | ConvertTo-Json -Compress
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "ConvertTo-Json failed to convert the provided tag names under Get-AutomateNOWProcessingList due to [$Message]."
                        Break
                    }
                }
                Else {
                    [string]$TagString = $Tags
                }
                $BodyMetaData.'criteria5' = ('{"fieldName":"tags","operator":"containsAny","value":' + $TagString + '}')
            }
        }
        $BodyMetaData.'_componentId' = $componentId
        $BodyMetaData.'_dataSource' = 'ProcessingDataSource'
        $BodyMetaData.'_textMatchStyle' = $textMatchStyle
        $BodyMetaData.'isc_metaDataPrefix' = '_'
        $BodyMetaData.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        If ($null -eq $parameters.Body) {
            $parameters.Add('Body', $Body)
        }
        Else {
            $parameters.Body = $Body
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWProcessing[]]$Processing = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWProcessing] objects due to [$Message]."
            Break
        }
        If ($Processing.Count -gt 0) {
            Return $Processing
        }
    }
    End {

    }
}

#endregion

#Region - Processing Functions

Function Get-AutomateNOWProcessingFunction {
    <#
    .SYNOPSIS
    Gets the Processing Function objects from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Processing Function objects from an AutomateNOW! instance

    .PARAMETER Id
    Optional string of the specific Id of the Processing Function that you want to retrieve. Note that this parameter is not required and is exclusive from all other parameters.

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER sortBy
    Optional string parameter to sort the results by. Valid choices are: 'lastUpdated', 'lastUpdatedBy', 'dateCreated', 'createdBy', 'description', 'id'*, 'functionBody', 'processingFunctionType'

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .INPUTS
    Accepts a string representing the simple id of the Notification Group from the pipeline or individually (but not an array).

    .OUTPUTS
    An array of one or more [ANOWProcessingFunction] class objects

    .EXAMPLE
    Gets the first page of Processing Function objects

    Get-AutomateNOWProcessingFunction

    .EXAMPLE
    Gets the first page of Processing Function objects sorted by 'lastUpdated'

    Get-AutomateNOWProcessingFunction -sortBy 'lastUpdated'

    .EXAMPLE
    Gets a Processing Function object by Id (one-liner)

    Get-AutomateNOWProcessingFunction -Id 'MyProcessingFunction'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Run this function without parameters to retrieve the first page of Processing Function objects.

    #>
    [OutputType([ANOWProcessingFunction[]])]
    [Cmdletbinding(DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $True, ParameterSetName = 'Id', ValueFromPipeline = $True)]
        [string]$id,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100,
        [ValidateSet('lastUpdated', 'lastUpdatedBy', 'dateCreated', 'createdBy', 'description', 'userIp', 'id', 'functionBody', 'processingFunctionType', ignoreCase = $false)]
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$sortBy = 'id',
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$Descending
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 ) {
            [string]$Id = $_
        }
        If ($Id.Length -gt 0) {
            $Body.'id' = $Id
            $Body.'_operationId' = 'read'
            [string]$textMatchStyle = 'exactCase'
        }
        Else {
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
            $Body.'_componentId' = 'ProcessingFunctionList'
            [string]$textMatchStyle = 'subString'
        }
        $Body.'_operationType' = 'fetch'
        $Body.'_textMatchStyle' = $textMatchStyle
        $Body.'_dataSource' = 'ProcessingFunctionDataSource'
        If ($Descending -eq $true) {
            $Body.'_sortBy' = '-' + $sortBy
        }
        Else {
            $Body.'_sortBy' = $sortBy
        }
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/processingFunction/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('command', $command)
        }
        Else {
            $parameters.'command' = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWProcessingFunction[]]$ProcessingFunctions = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWProcessingFunction] objects due to [$Message]."
            Break
        }
        If ($ProcessingFunctions.Count -gt 0) {
            Return $ProcessingFunctions
        }
    }
    End {

    }
}

Function Set-AutomateNOWProcessingFunction {
    <#
    .SYNOPSIS
    Changes the settings of an Processing Function on an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of an Processing Function on an AutomateNOW! instance

    .PARAMETER ProcessingFunction
    Mandatory [ANOWProcessingFunction] object representing the Processing Function to be modified. Use Get-AutomateNOWProcessingFunction to retrieve these.

    .PARAMETER FunctionBody
    Optional string to set as the Function Body of the Processing Function.

    .PARAMETER UnsetFunctionBody
    Optional switch parameter to unset the Function Body on the Processing Function.

    .PARAMETER Description
    Optional string to set the description on the Processing Function.

    .PARAMETER UnsetDescription
    Optional switch parameter to unset the description on the Processing Function.

    .PARAMETER Quiet
    An optional switch parameter that silences the output of this function

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWProcessingFunction] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWProcessingFunction] object will be returned

    .EXAMPLE
    Forcibly and quietly sets the description and the Function Bodyon a Processing Function named 'ProcessingFunction1' (one-liner format)

    Get-AutomateNOWProcessingFunction -Id 'ProcessingFunction1' | Set-AutomateNOWProcessingFunction -Description 'Description!' -FunctionBody 'new Date().format(''yy'')' -Force -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWProcessingFunction])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWProcessingFunction]$ProcessingFunction,
        [Parameter(Mandatory = $false)]
        [string]$FunctionBody,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFunctionBody,
        [Parameter(Mandatory = $false)]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        [string]$command = '/processingFunction/update'
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWProcessingFunction]$ProcessingFunction = $_
        }
        [string]$ProcessingFunction_id = $ProcessingFunction.Id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$ProcessingFunction_id")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$ProcessingFunction_exists = ($null -eq (Get-AutomateNOWProcessingFunction -Id $ProcessingFunction_id))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWProcessingFunction failed to check if the Processing Function [$ProcessingFunction_id] under Set-AutomateNOWProcessingFunction already existed due to [$Message]."
                Break
            }
            If ($ProcessingFunction_exists -eq $true) {
                Write-Warning -Message "There is not a Processing Function named [$ProcessingFunction_id]. Please check into this."
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $ProcessingFunction_id
            If ($FunctionBody.Length -gt 0) {
                $BodyMetaData.'functionBody' = $FunctionBody
            }
            ElseIf ($UnsetFunctionBody -eq $true) {
                $BodyMetaData.'functionBody' = $Null
            }
            If ($Description.Length -gt 0) {
                $BodyMetaData.'description' = $Description
            }
            ElseIf ($UnsetDescription -eq $true) {
                $BodyMetaData.'description' = $Null
            }
            $BodyMetaData.'_operationType' = 'update'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_dataSource' = 'ProcessingFunctionDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ProcessingFunction_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Processing Function object [$ProcessingFunction_id] was successfully updated"
            $Error.Clear()
            Try {
                [ANOWProcessingFunction]$UpdatedProcessingFunction = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the successful result of Set-AutomateNOWProcessingFunction to an [ANOWProcessingFunction] object due to [$Message]."
                Break
            }
            If ($Quiet -ne $true) {
                Return $UpdatedProcessingFunction
            }
        }
    }
    End {
    }
}

Function New-AutomateNOWProcessingFunction {
    <#
    .SYNOPSIS
    Creates a Processing Function within an AutomateNOW! instance

    .DESCRIPTION
    Creates a Processing Function within an AutomateNOW! instance

    .PARAMETER Id
    Mandatory name or Id of the ProcessingFunction. For example: 'ProcessingFunction1'. This value may not contain the domain in brackets.

    .PARAMETER ProcessingFunctionType
    Mandatory type of Processing Function. Valid choices are: DYNAMIC_PROPERTY or DYNAMIC_FUNCTION

    .PARAMETER Description
    Optional description of the ProcessingFunction (may not exceed 255 characters).

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWProcessingFunction.

    .OUTPUTS
    An [ANOWProcessingFunction] object representing the newly created ProcessingFunction

    .EXAMPLE
    Creates a new Processing Function named 'ProcessingFunction1' of type DYNAMIC_PROPERTY

    New-AutomateNOWProcessingFunction -Id 'ProcessingFunction1' -ProcessingFunctionType DYNAMIC_PROPERTY -Description 'Desc'

    .EXAMPLE
    Creates a new Processing Function named 'ProcessingFunction2' of type DYNAMIC_FUNCTION

    New-AutomateNOWProcessingFunction -Id 'ProcessingFunction2' -ProcessingFunctionType DYNAMIC_FUNCTION -Description 'Desc'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The name (id) of the ProcessingFunction must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    Use `Set-AutomateNOWProcessingFunction` to set the Function Body on the newly created object.

    #>
    [OutputType([ANOWProcessingFunction])]
    [Cmdletbinding()]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $true)]
        [string]$Id,
        [Parameter(Mandatory = $true)]
        [ANOWProcessingFunction_processingFunctionType]$ProcessingFunctionType,
        [ValidateScript({ $_.Length -le 255 })]
        [Parameter(Mandatory = $false, HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [boolean]$ProcessingFunction_exists = ($null -ne (Get-AutomateNOWProcessingFunction -Id $Id))
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWProcessingFunction failed to check if the ProcessingFunction [$Id] already existed due to [$Message]."
        Break
    }
    If ($ProcessingFunction_exists -eq $true) {
        [string]$current_domain = $anow_session.header.domain
        Write-Warning -Message "There is already a Processing Function named [$Id] in [$current_domain]. Please check into this."
        Break
    }
    ## End warning ##
    [string]$oldvalues = ('{"processingFunctionType":"' + $Type + '"}')
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    $BodyMetaData.'id' = $Id
    $BodyMetaData.'processingFunctionType' = $ProcessingFunctionType
    If ($Description.Length -gt 0) {
        $BodyMetaData.'description' = $Description
    }
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_operationType' = 'add'
    $BodyMetaData.'_oldValues' = $oldvalues
    $BodyMetaData.'_componentId' = 'ProcessingFunctionCreateWindow_form'
    $BodyMetaData.'_dataSource' = 'ProcessingFunctionDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
    [string]$command = '/processingFunction/create'
    [hashtable]$parameters = @{}
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('Body', $Body)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWProcessingFunction]$ProcessingFunction = $results.response.data | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to parse the result of New-AutomateNOWProcessingFunction into an [ANOWProcessingFunction] object due to [$Message]."
        Break
    }
    If ($ProcessingFunction.id.Length -eq 0) {
        Write-Warning -Message "Somehow the newly created [ANOWProcessingFunction] object is empty!"
        Break
    }
    If ($Quiet -ne $true) {
        Return $ProcessingFunction
    }
}

Function Remove-AutomateNOWProcessingFunction {
    <#
    .SYNOPSIS
    Removes a Processing Function from an AutomateNOW! instance

    .DESCRIPTION
    Removes a Processing Function from an AutomateNOW! instance

    .PARAMETER ProcessingFunction
    An [ANOWProcessingFunction] object representing the Processing Function to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWProcessingFunction] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Removes a Processing Function with an Id of 'ProcessingFunction1'

    Get-AutomateNOWProcessingFunction -Id 'ProcessingFunction1' | Remove-AutomateNOWProcessingFunction

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWProcessingFunction]$ProcessingFunction,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processingFunction/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id -gt 0) {
            [ANOWProcessingFunction]$ProcessingFunction = $_
        }
        [string]$ProcessingFunction_id = $ProcessingFunction.id
        If ($ProcessingFunction_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ProcessingFunction_id)")) -eq $true) {
            [string]$oldvalues = $ProcessingFunction.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $ProcessingFunction_id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'ProcessingFunctionList'
            $BodyMetaData.'_dataSource' = 'ProcessingFunctionDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ProcessingFunction_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Processing Function $ProcessingFunction_id was successfully removed"
        }
    }
    End {

    }
}

Function Export-AutomateNOWProcessingFunction {
    <#
    .SYNOPSIS
    Exports the Processing Functions from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Processing Functions from an instance of AutomateNOW! to a local .csv file

    .PARAMETER ProcessingFunction
    Mandatory [ANOWProcessingFunction] object (Use Get-AutomateNOWProcessingFunction to retrieve them)

    .INPUTS
    ONLY [ANOWProcessingFunction] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWProcessingFunction] objects are exported to the local disk in CSV format

    .EXAMPLE
    Get-AutomateNOWProcessingFunction | Export-AutomateNOWProcessingFunction

    .EXAMPLE
    Get-AutomateNOWProcessingFunction -Id 'ProcessingFunction1' | Export-AutomateNOWProcessingFunction

    .EXAMPLE
    'ProcessingFunction01', 'ProcessingFunction02' | Get-AutomateNOWProcessingFunction | Export-AutomateNOWProcessingFunction

    .NOTES
	You must present [ANOWProcessingFunction] objects to the pipeline to use this function.

    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWProcessingFunction]$ProcessingFunction
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-ProcessingFunctions-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWProcessingFunction]$ProcessingFunction = $_
        }
        $Error.Clear()
        Try {
            $ProcessingFunction | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWProcessingFunction] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function Copy-AutomateNOWProcessingFunction {
    <#
    .SYNOPSIS
    Copies a Processing Function from an AutomateNOW! instance

    .DESCRIPTION
    Copies a Processing Function from an AutomateNOW! instance. AutomateNOW object id can never be changed, but we can copy the object to a new id and it will include all of the items therein.

    .PARAMETER ProcessingFunction
    Mandatory [ANOWProcessingFunction] object to be copied.

    .PARAMETER NewId
    The new "name" (Id) of the new Processing Function. The new Id must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    .PARAMETER UnsetDescription
    Optional switch that will ensure that the newly created Processing Function will not have a description set.

    .PARAMETER Description
    Optional description to set on the new Processing Function object. If you do not set this, the new Processing Function object will copy the Description of the source object.

    .PARAMETER Force
    Force the copy without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    ONLY [ANOWProcessingFunction] object is accepted. Pipeline support is intentionally unavailable.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Forcefully and quietly creates a copy of a Processing Function named 'ProcessingFunction1' to 'ProcessingFunction2'

    Copy-AutomateNOWProcessingFunction -ProcessingFunction (Get-AutomateNOWProcessingFunction -Id 'ProcessingFunction1') -NewId 'ProcessingFunction2' -Force -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWProcessingFunction]$ProcessingFunction,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        [string]$command = '/processingFunction/copy'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$ProcessingFunction_exists = ($null -ne (Get-AutomateNOWProcessingFunction -Id $NewId))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWProcessingFunction failed to check if the Processing Function [$NewId] already existed due to [$Message]."
                Break
            }
            If ($ProcessingFunction_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is already a Processing Function with an Id of [$NewId] in [$current_domain]. You may not proceed. Are you debugging?"
                Break
            }
            ## End warning ##
            [string]$ProcessingFunction_oldId = $ProcessingFunction.id
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Copy the Processing Function $("[$ProcessingFunction_oldId]") to $("[$NewId]")")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                $BodyMetaData.'oldId' = $ProcessingFunction_oldId
                $BodyMetaData.'id' = $NewId
                If ($Description.Length -gt 0) {
                    $BodyMetaData.'description' = $Description
                }
                ElseIf ($UnsetDescription -eq $true) {
                    $BodyMetaData.'description' = $null
                }
                ElseIf ($ProcessingFunction.description.Length -gt 0) {
                    $BodyMetaData.'description' = $ProcessingFunction.description
                }
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_operationId' = 'copy'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_dataSource' = 'ProcessingFunctionDataSource'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
                $parameters.Body = $Body
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ProcessingFunction_oldId] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                $Error.Clear()
                Try {
                    [ANOWProcessingFunction]$NewProcessingFunction = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to create copied [ANOWProcessingFunction] object [$NewSimpleId] due to [$Message]."
                    Break
                }
                If ($NewProcessingFunction.id.Length -eq 0) {
                    Write-Warning -Message "Somehow the newly created (copied) [ANOWProcessingFunction] object [$NewSimpleId] is empty!"
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $NewProcessingFunction
                }
            }
        }
    }
    End {

    }
}

Function Rename-AutomateNOWProcessingFunction {
    <#
    .SYNOPSIS
    Renames a Processing Function on an AutomateNOW! instance

    .DESCRIPTION
    Performs a psuedo-rename operations of a Processing Function from an AutomateNOW! instance by copying it first and then deleting the source. This function merely combines Copy-AutomateNOWProcessingFunction and Remove-AutomateNOWProcessingFunction therefore it is to be considered destructive.

    .PARAMETER ProcessingFunction
    An [ANOWProcessingFunction] object representing the Processing Function to be renamed.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the Processing Function. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER Force
    Force the renaming without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly renamed object.

    .INPUTS
    ONLY [ANOWProcessingFunction] objects are accepted. There is intentionally no support for the pipeline.

    .OUTPUTS
    The newly renamed [ANOWProcessingFunction] object will be returned.

    .EXAMPLE
    Renames a Processing Function from 'ProcessingFunction1' to 'ProcessingFunction2' (multi-line format)

    $ProcessingFunction = Get-AutomateNOWProcessingFunction -Id 'ProcessingFunction1'
    Rename-AutomateNOWProcessingFunction -ProcessingFunction $ProcessingFunction -NewId 'ProcessingFunction2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    When renaming, you may only specify a different Id (name).

    This action will be bProcessingFunctioned if any existing referrals are found on the object.
    #>
    [OutputType([ANOWProcessingFunction])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWProcessingFunction]$ProcessingFunction,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin standard warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$new_ProcessingFunction_exists = ($null -ne (Get-AutomateNOWProcessingFunction -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWProcessingFunction failed to check if the ProcessingFunction [$NewId] already existed due to [$Message]."
            Break
        }
        If ($new_ProcessingFunction_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a ProcessingFunction named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        [string]$ProcessingFunction_id = $ProcessingFunction.Id
        $Error.Clear()
        Try {
            [boolean]$old_ProcessingFunction_exists = ($null -ne (Get-AutomateNOWProcessingFunction -Id $ProcessingFunction_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWProcessingFunction failed to check if the ProcessingFunction [$ProcessingFunction_id] already existed due to [$Message]."
            Break
        }
        If ($old_ProcessingFunction_exists -eq $false) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not a ProcessingFunction named [$ProcessingFunction_id] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End standard warning ##
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ProcessingFunction_id)")) -eq $true) {
                $Error.Clear()
                Try {
                    [ANOWProcessingFunction]$new_ProcessingFunction = Copy-AutomateNOWProcessingFunction -ProcessingFunction $ProcessingFunction -NewId $NewId -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Copy-AutomateNOWProcessingFunction failed to create a new ProcessingFunction [$NewId] as Part 1 of the renaming process due to [$Message]."
                    Break
                }
                If ($new_ProcessingFunction.Id -eq $NewId) {
                    Write-Verbose -Message "Part 1: ProcessingFunction [$ProcessingFunction_id] successfully copied to [$NewId]"
                }
                Else {
                    Write-Warning -Message "Somehow the first phase (Copy-AutomateNOWProcessingFunction) failed. Please look into this."
                    Break
                }
                $Error.Clear()
                Try {
                    Remove-AutomateNOWProcessingFunction -ProcessingFunction $ProcessingFunction -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Remove-AutomateNOWProcessingFunction failed to remove [$ProcessingFunction_id] as Part 2 of the renaming process due to [$Message]."
                    Break
                }
                Write-Verbose -Message "Part 2: ProcessingFunction [$ProcessingFunction_id] removed"
                Write-Verbose -Message "Task [$ProcessingFunction_id] successfully renamed to [$NewId]"
                If ($Quiet -ne $true) {
                    Return $new_ProcessingFunction
                }
            }
        }
        Else {
            Write-Warning -Message "No action was taken because either the source object didn't exist or the new object already existed"
        }
    }
    End {
    }
}

#endregion

#Region - Processing State

Function Get-AutomateNOWProcessingState {
    <#
    .SYNOPSIS
    Gets the Processing State objects from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Processing State objects from an AutomateNOW! instance

    .PARAMETER Id
    Optional int64 Id of the specific Processing State that you want to retrieve. Note that this parameter is not required.

    .PARAMETER ProcessingTemplate
    Optional Processing Template (i.e. Task Template, Workflow Template, Service Manager Template, Schedule Template) to filter the results by

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER sortBy
    Optional string parameter to sort the results by. Valid choices are: 'processingTimestamp'*, 'id', 'dateCreated', 'lastUpdated', 'executingCount', 'failedCount', 'parentTemplate', 'processingTemplate', 'searchKey'

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .INPUTS
    Accepts a string representing the simple id of the Notification Group from the pipeline or individually (but not an array).

    .OUTPUTS
    An array of one or more [ANOWProcessingState] class objects

    .EXAMPLE
    Gets the first page of Processing State objects. You should try to avoid this approach as it is very chatty.

    Get-AutomateNOWProcessingState

    .EXAMPLE
    Gets a Processing State object by Id (one-liner)

    Get-AutomateNOWProcessingState -Id 1234567

    .EXAMPLE
    Gets the first page of Processing State objects for a Task Template named 'TaskTemplate1' (one-liner)

    Get-AutomateNOWTaskTemplate -Id 'TaskTemplate1' | Get-AutomateNOWProcessingState

    .EXAMPLE
    Gets the most recent Processing State for a Task Template named 'TaskTemplate1' (one-liner)
    Get-AutomateNOWTaskTemplate -Id 'TaskTemplate1' | Get-AutomateNOWProcessingState -Descending | Select-Object -First 1

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Run this function without parameters to retrieve the first page of Processing State objects (not recommended)

    From the UI: The blue gear box is executingCount, the green checkmark is completedCount and the red x is failedCount.

    The recommended approach is to include the [ANOWProcessingTemplate] object that you want to filter against.

    #>
    [OutputType([ANOWProcessingState[]])]
    [Cmdletbinding(DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $False, ParameterSetName = 'Id', ValueFromPipeline = $True)]
        [int64]$id,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default', ValueFromPipeline = $True)]
        [ANOWProcessingTemplate]$ProcessingTemplate,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100,
        [ValidateSet('processingTimestamp', 'id', 'dateCreated', 'lastUpdated', 'executingCount', 'failedCount', 'parentTemplate', 'processingTemplate', 'searchKey', ignoreCase = $false)]
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$sortBy = 'processingTimestamp',
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$Descending
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_ -gt 0 -or $Id -gt 0) {
            If ($_ -gt 0) {
                [int64]$Id = $_
            }
            $Body.'id' = $Id
            $Body.'_operationId' = 'read'
            [string]$textMatchStyle = 'exactCase'
        }
        Else {
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
            If ($Descending -eq $true) {
                $Body.'_sortBy' = $sortBy
            }
            Else {
                $Body.'_sortBy' = '-' + $sortBy
            }
            If ($_.Id.Length -gt 0 -or $ProcessingTemplate.Id.Length -gt 0) {
                If ($_.Id.Length -gt 0) {
                    [string]$ProcessingTemplate_Id = $_.Id
                }
                Else {
                    [string]$ProcessingTemplate_Id = $ProcessingTemplate.Id
                }
                $Body.'_constructor' = 'AdvancedCriteria'
                $Body.'operator' = 'and'
                $Body.'criteria' = ('{"fieldName":"processingTemplate","operator":"equals","value":"' + $ProcessingTemplate_Id + '"}')
            }
            $Body.'_componentId' = 'ProcessingStateList'
            $Body.'_operationId' = 'readByDomain'
            [string]$textMatchStyle = 'subString'
        }
        $Body.'_operationType' = 'fetch'
        $Body.'_textMatchStyle' = $textMatchStyle
        $Body.'_dataSource' = 'ProcessingStateDataSource'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/processingState/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('command', $command)
        }
        Else {
            $parameters.'command' = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        If ($ProcessingTemplate.Id.Length -eq 0 -and $_ -is [int64]) {
            $Error.Clear()
            Try {
                [string]$processingTemplate_Id = $results.response.data | Select-Object -First 1.processingTemplate
                [ANOWProcessingTemplate]$ProcessingTemplate = Get-AutomateNOWWorkflowTemplate -Id $processingTemplate_Id -OverrideProcessingType
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWWorkflowTemplate failed to retrieve the Processing Template $processingTemplate_Id (with Override Type) on a single Id under Get-AutomateNOWProcessingState due to [$Message]."
                Break
            }
        }
        [hashtable]$ProcessingTemplateHashTable = @{}
        [int32]$results_count = $results.response.data.count
        [int32]$current_loop = 1
        $Error.Clear()
        Try {
            [ANOWProcessingState[]]$ProcessingStates = ForEach ($result in $results.response.data) {
                If ($ProcessingTemplate.Id.Length -eq 0) {
                    [string]$processingTemplate_Id = $result.processingTemplate -split ']' | Select-Object -Last 1
                    If ($null -eq $ProcessingTemplateHashTable.$processingTemplate_Id) {
                        [ANOWProcessingTemplate]$ProcessingTemplate_object = Get-AutomateNOWWorkflowTemplate -Id $processingTemplate_Id -OverrideProcessingType
                        [string]$processingType = $ProcessingTemplate_object.processingType
                        $Error.Clear()
                        If ($processingType -eq 'WORKFLOW') {
                            Try {
                                [ANOWWorkflowTemplate]$ProcessingTemplate2 = Get-AutomateNOWWorkflowTemplate -Id $processingTemplate_Id
                            }
                            Catch {
                                [string]$Message = $_.Exception.Message
                                Write-Warning -Message "Get-AutomateNOWWorkflowTemplate failed to retrieve the Processing Template $processingTemplate_Id under Get-AutomateNOWProcessingState due to [$Message] (on loop $current_loop/$results_count)."
                                Break
                            }
                        }
                        ElseIf ($processingType -eq 'TASK') {
                            Try {
                                [ANOWTaskTemplate]$ProcessingTemplate2 = Get-AutomateNOWTaskTemplate -Id $processingTemplate_Id
                            }
                            Catch {
                                [string]$Message = $_.Exception.Message
                                Write-Warning -Message "Get-AutomateNOWTaskTemplate failed to retrieve the Processing Template $processingTemplate_Id under Get-AutomateNOWProcessingState due to [$Message] (on loop $current_loop/$results_count)."
                                Break
                            }
                        }
                        ElseIf ($processingType -eq 'TRIGGER') {
                            Try {
                                [ANOWScheduleTemplate]$ProcessingTemplate2 = Get-AutomateNOWScheduleTemplate -Id $processingTemplate_Id
                            }
                            Catch {
                                [string]$Message = $_.Exception.Message
                                Write-Warning -Message "Get-AutomateNOWScheduleTemplate failed to retrieve the Processing Template $processingTemplate_Id under Get-AutomateNOWProcessingState due to [$Message] (on loop $current_loop/$results_count)."
                                Break
                            }
                        }
                        ElseIf ($processingType -eq 'SERVICE') {
                            Try {
                                [ANOWScheduleTemplate]$ProcessingTemplate2 = Get-AutomateNOWServiceManagerTemplate -Id $processingTemplate_Id
                            }
                            Catch {
                                [string]$Message = $_.Exception.Message
                                Write-Warning -Message "Get-AutomateNOWServiceManagerTemplate failed to retrieve the Processing Template $processingTemplate_Id under Get-AutomateNOWProcessingState due to [$Message] (on loop $current_loop/$results_count)."
                                Break
                            }
                        }
                        Else {
                            Write-Warning -Message "Unable to determine the processingType of the Processing Template $processingTemplate_Id (on loop $current_loop/$results_count)"
                            Break
                        }
                        Write-Verbose -Message "Adding $processingTemplate_Id to the Processing Template hashtable"
                        $ProcessingTemplateHashTable.Add($processingTemplate_Id, $ProcessingTemplate2)
                    }
                    Else {
                        Switch ($ProcessingTemplateHashTable.$processingTemplate_Id.processingType) {
                            'WORKFLOW' { [ANOWWorkflowTemplate]$ProcessingTemplate2 = $ProcessingTemplateHashTable.$processingTemplate_Id; Break; }
                            'TASK' { [ANOWTaskTemplate]$ProcessingTemplate2 = $ProcessingTemplateHashTable.$processingTemplate_Id; Break; }
                            'TRIGGER' { [ANOWScheduleTemplate]$ProcessingTemplate2 = $ProcessingTemplateHashTable.$processingTemplate_Id; Break; }
                            'SERVICE' { [ANOWServiceManagerTemplate]$ProcessingTemplate2 = $ProcessingTemplateHashTable.$processingTemplate_Id; Break; }
                        }
                    }
                    If ($result.parentTemplate.Length -gt 0) {
                        [string]$parentTemplate_Id = $result.parentTemplate -split ']' | Select-Object -Last 1
                        If ($null -eq $ProcessingTemplateHashTable.$parentTemplate_Id) {
                            [ANOWProcessingTemplate]$ProcessingTemplate_object = Get-AutomateNOWWorkflowTemplate -Id $parentTemplate_Id -OverrideProcessingType
                            [string]$processingType = $ProcessingTemplate_object.processingType
                            $Error.Clear()
                            If ($processingType -eq 'WORKFLOW') {
                                Try {
                                    [ANOWWorkflowTemplate]$ProcessingTemplate3 = Get-AutomateNOWWorkflowTemplate -Id $parentTemplate_Id
                                }
                                Catch {
                                    [string]$Message = $_.Exception.Message
                                    Write-Warning -Message "Get-AutomateNOWWorkflowTemplate failed to retrieve the Parent Template $parentTemplate_Id under Get-AutomateNOWProcessingState due to [$Message] (on loop $current_loop/$results_count)."
                                    Break
                                }
                            }
                            ElseIf ($processingType -eq 'TASK') {
                                Try {
                                    [ANOWTaskTemplate]$ProcessingTemplate3 = Get-AutomateNOWTaskTemplate -Id $parentTemplate_Id
                                }
                                Catch {
                                    [string]$Message = $_.Exception.Message
                                    Write-Warning -Message "Get-AutomateNOWTaskTemplate failed to retrieve the Parent Template $parentTemplate_Id under Get-AutomateNOWProcessingState due to [$Message] (on loop $current_loop/$results_count)."
                                    Break
                                }
                            }
                            ElseIf ($processingType -eq 'TRIGGER') {
                                Try {
                                    [ANOWScheduleTemplate]$ProcessingTemplate3 = Get-AutomateNOWScheduleTemplate -Id $parentTemplate_Id
                                }
                                Catch {
                                    [string]$Message = $_.Exception.Message
                                    Write-Warning -Message "Get-AutomateNOWScheduleTemplate failed to retrieve the Parent Template $parentTemplate_Id under Get-AutomateNOWProcessingState due to [$Message] (on loop $current_loop/$results_count)."
                                    Break
                                }
                            }
                            ElseIf ($processingType -eq 'SERVICE') {
                                Try {
                                    [ANOWScheduleTemplate]$ProcessingTemplate3 = Get-AutomateNOWServiceManagerTemplate -Id $parentTemplate_Id
                                }
                                Catch {
                                    [string]$Message = $_.Exception.Message
                                    Write-Warning -Message "Get-AutomateNOWServiceManagerTemplate failed to retrieve the Parent Template $parentTemplate_Id under Get-AutomateNOWProcessingState due to [$Message] (on loop $current_loop/$results_count)."
                                    Break
                                }
                            }
                            Else {
                                Write-Warning -Message "Unable to determine the processingType of the Parent Template $parentTemplate_Id (on loop $current_loop/$results_count)"
                                Break
                            }
                            Write-Verbose -Message "Adding $parentTemplate_Id (parent) to the Processing Template hashtable"
                            $ProcessingTemplateHashTable.Add($parentTemplate_Id, $ProcessingTemplate3)
                        }
                        Else {
                            Switch ($ProcessingTemplateHashTable.$parentTemplate_Id.processingType) {
                                'WORKFLOW' { [ANOWWorkflowTemplate]$ProcessingTemplate3 = $ProcessingTemplateHashTable.$parentTemplate_Id; Break; }
                                'TASK' { [ANOWTaskTemplate]$ProcessingTemplate3 = $ProcessingTemplateHashTable.$parentTemplate_Id; Break; }
                                'TRIGGER' { [ANOWScheduleTemplate]$ProcessingTemplate3 = $ProcessingTemplateHashTable.$parentTemplate_Id; Break; }
                                'SERVICE' { [ANOWServiceManagerTemplate]$ProcessingTemplate3 = $ProcessingTemplateHashTable.$parentTemplate_Id; Break; }
                            }
                        }
                    }
                }
                $current_loop++
                $result.processingTemplate = $ProcessingTemplate2
                If ($ProcessingTemplate3.Id.Length -gt 0) {
                    $result.parentTemplate = $ProcessingTemplate3
                    Clear-Variable -Name ProcessingTemplate3
                }
                $result
            }
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response (during $processingTemplate_Id) into a series of [ANOWProcessingState] objects due to [$Message] (on loop $current_loop/$results_count)."
            Break
        }
        If ($ProcessingStates.Count -gt 0) {
            Return $ProcessingStates
        }
    }
    End {

    }
}

Function New-AutomateNOWProcessingState {
    <#
    .SYNOPSIS
    Creates a new Processing State object within the Processing State Registry of an AutomateNOW! instance

    .DESCRIPTION
    Creates a new Processing State object within the Processing State Registry of an AutomateNOW! instance

    .PARAMETER ProcessingTemplate
    Mandatory [ANOWProcessingTemplate] object. Use Get-AutomateNOWTaskTemplate, Get-AutomateNOWWorkflowTemplate, Get-AutomateNOWScheduleTemplate or Get-AutomateNOWServiceManagerTemplate to retrieve these.

    .PARAMETER ParentTemplate
    Optional [ANOWProcessingTemplate] object by which the Processing State object will be configured against. Use Get-AutomateNOWWorkflowTemplate to retrieve one of these.

    .PARAMETER ProcessingTemplateItem
    Optional [ANOWProcessingTemplateItem] object by which the Processing State object will be configured against. Use Read-AutomateNOWWorkflowTemplate to retrieve one of these.

    .PARAMETER ProcessingTimestamp
    Mandatory string representing the Processing Timestamp. The format should be: YYYY-MM-DD or YYYYMMDD

    .PARAMETER ProcessingStatus
    Mandatory string representing the status of the Processing State. Valid choices are: EXECUTING; COMPLETED; FAILED;

    .PARAMETER StatusCode
    Only Mandatory when -ProcessingStatus is set to COMPLETED or FAILED. This is a custom string of your choosing.

    .PARAMETER Quiet
    Suppresses the return of the newly created object.

    .INPUTS
    One [ANOWProcessingState] object along with one or more ProcessingStatus string (pipeline capable)

    .OUTPUTS
    The updated [ANOWProcessingState] object will be returned

    .EXAMPLE
    Quietly creates a Processing State for a Task Template named 'TaskTemplate1' with a Processing Status of COMPLETED, a Status Code of 0 and a processing timestamp of December 31st, 2029 (multi-line format)

    $ProcessingTemplate = Get-AutomateNOWTaskTemplate -Id 'TaskTemplate1'
    New-AutomateNOWProcessingState -ProcessingTemplate $ProcessingTemplate -ProcessingStatus COMPLETED -ProcessingTimeStamp '2029-12-31' -StatusCode 0 -Quiet

    .EXAMPLE
    Creates a Processing State for a Task Template named 'TaskTemplate1' under a Parent Template named 'WorkflowTemplate1' and attached to a Workflow Item with an Id of '12345678-7e1e-4a69-ae7c-bc15e19a0fe2' and a Processing Status of FAILED, a Status Code of 1 and a processing timestamp of December 31st, 2029 (multi-line format)

    $ProcessingTemplate = Get-AutomateNOWTaskTemplate -Id 'TaskTemplate1'
    $ParentTemplate = Get-AutomateNOWWorkflowTemplate -Id 'WorkflowTemplate1'
    $ProcessingTemplateItem = Read-AutomateNOWWorkflowTemplateItem -Id '12345678-7e1e-4a69-ae7c-bc15e19a0fe2'
    New-AutomateNOWProcessingState -ProcessingTemplate $ProcessingTemplate -parentTemplate $ParentTemplate -ProcessingTemplateItem $ProcessingTemplateItem -ProcessingStatus FAILED -ProcessingTimeStamp '2029-12-31' -StatusCode 1

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    If a -ParentTemplate is included, it must be a Workflow.

    #>
    [OutputType([ANOWProcessingState])]
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWProcessingTemplate]$ProcessingTemplate,
        [Parameter(Mandatory = $false)]
        [ANOWProcessingTemplate]$ParentTemplate,
        [Parameter(Mandatory = $false)]
        [ANOWProcessingTemplateItem]$ProcessingTemplateItem,
        [ValidateScript({ $_ -match '^\d{4}-{0,}\d{2}-{0,}\d{2}$' })]
        [Parameter(Mandatory = $true, HelpMessage = 'Example: 2029-01-31 for January 31st, 2029')]
        [string]$ProcessingTimestamp,
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWProcessingState_processingStatus]$ProcessingStatus,
        [Parameter(Mandatory = $false)]
        [string]$StatusCode,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    If ($StatusCode.Length -eq 0 -and $ProcessingStatus -ne 'EXECUTING') {
        Write-Warning -Message 'You must include a -StatusCode if the -ProcessingStatus is anything other than EXECUTING'
        Break
    }
    If ($ParentTemplate.Id.Length -gt 0) {
        If ($ParentTemplate.processingType -ne 'WORKFLOW') {
            [string]$processingType = $ParentTemplate.processingType
            Write-Warning -Message "The parent template must be a Workflow. You submitted a parent template of type [$processingType]. Please look into this."
            Break
        }
        If ($ProcessingTemplateItem.Id.Length -eq 0) {
            Write-Warning -Message "You must include the -ProcessingTemplateItem when a -ParentTemplate is specified."
            Break
        }
    }
    [string]$command = '/processingState/create'
    [hashtable]$parameters = @{}
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$ProcessingTemplate_id = $ProcessingTemplate.id
    [string]$ParentTemplate_id = $ParentTemplate.id
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    $BodyMetaData.'processingTemplate' = $ProcessingTemplate_id
    If ($ParentTemplate_id.Length -gt 0) {
        $BodyMetaData.'parentTemplate' = $ParentTemplate_id
    }
    If ($ProcessingTemplateItem.Id.Length -gt 0) {
        [string]$ProcessingTemplateItem_Name = $ProcessingTemplateItem.Name
        $BodyMetaData.'processingTemplateItemName' = $ProcessingTemplateItem_Name
    }
    If ($StatusCode.Length -gt 0) {
        $BodyMetaData.'statusCode' = $StatusCode
    }
    $BodyMetaData.'processingStatus' = $ProcessingStatus
    $BodyMetaData.'processingTimestamp' = $ProcessingTimestamp
    $BodyMetaData.'_oldValues' = '{}'
    $BodyMetaData.'_operationType' = 'add'
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_componentId' = 'ProcessingStateCreateWindow_form'
    $BodyMetaData.'_dataSource' = 'ProcessingStateDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
    If ($null -eq $parameters.Body) {
        $parameters.Add('Body', $Body)
    }
    Else {
        $parameters.Body = $Body
    }
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ProcessingState_id] due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    Write-Verbose -Message "Processing State $ProcessingState_id was successfully updated"
    $Error.Clear()
    Try {
        [PSCustomObject]$UpdatedProcessingState = $results.response.data | Select-Object -First 1 | Select-Object -ExcludeProperty parentTemplate, processingTemplate
        $UpdatedProcessingState | Add-Member -MemberType NoteProperty -Name processingTemplate -Value $ProcessingTemplate
        If ( $parentTemplate.id.Length -gt 0 ) {
            [PSCustomObject]$UpdatedProcessingState = $UpdatedProcessingState | Add-Member -MemberType NoteProperty -Name parentTemplate -Value $parentTemplate
        }
        [ANOWProcessingState]$UpdatedProcessingState = $UpdatedProcessingState
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to parse the returned updated object to an [ANOWProcessingState] object due to [$Message]. The object was still updated though."
        Break
    }
    If ($Quiet -ne $true) {
        Return $UpdatedProcessingState
    }
}

Function Remove-AutomateNOWProcessingState {
    <#
    .SYNOPSIS
    Removes a Processing State from an AutomateNOW! instance

    .DESCRIPTION
    Removes a Processing State from an AutomateNOW! instance

    .PARAMETER ProcessingState
    An [ANOWProcessingState] object representing the Processing State to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWProcessingState] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Removes a Processing State with an Id of 12345
    Get-AutomateNOWProcessingState -Id 12345 | Remove-AutomateNOWProcessingState

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWProcessingState]$ProcessingState,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processingState/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id -gt 0) {
            [ANOWProcessingState]$ProcessingState = $_
        }
        [int64]$ProcessingState_id = $ProcessingState.id
        If ($ProcessingState_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ProcessingState_id)")) -eq $true) {
            [string]$oldvalues = $ProcessingState.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $ProcessingState_id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'ProcessingStateList'
            $BodyMetaData.'_dataSource' = 'ProcessingStateDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ProcessingState_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Processing State $ProcessingState_id was successfully removed"
        }
    }
    End {

    }
}

Function Export-AutomateNOWProcessingState {
    <#
    .SYNOPSIS
    Exports the Processing States from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Processing States from an instance of AutomateNOW! to a local .csv file

    .PARAMETER ProcessingState
    Mandatory [ANOWProcessingState] object (Use Get-AutomateNOWProcessingState to retrieve them)

    .INPUTS
    ONLY [ANOWProcessingState] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWProcessingState] objects are exported to the local disk in CSV format

    .EXAMPLE
    Get-AutomateNOWProcessingState | Export-AutomateNOWProcessingState

    .EXAMPLE
    Get-AutomateNOWProcessingState -Id 'ProcessingState01' | Export-AutomateNOWProcessingState

    .EXAMPLE
    'ProcessingState01', 'ProcessingState02' | Get-AutomateNOWProcessingState | Export-AutomateNOWProcessingState

    .NOTES
	You must present [ANOWProcessingState] objects to the pipeline to use this function.

    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWProcessingState]$ProcessingState
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-ProcessingStates-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWProcessingState]$ProcessingState = $_
        }
        $Error.Clear()
        Try {
            $ProcessingState | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWProcessingState] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function Read-AutomateNOWProcessingStateItem {
    <#
    .SYNOPSIS
    Reads the items associated with a particular Processing State within the Processing State Registry of an AutomateNOW! instance

    .DESCRIPTION
    Reads the items associated with a particular Processing State within the Processing State Registry of an AutomateNOW! instance

    .PARAMETER ProcessingState
    Mandatory [ANOWProcessingState] from which the items will be read.

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER sortBy
    Optional string parameter to sort the results by. Valid choices are: 'sortOrder'*, 'dateCreated', 'endTime', 'firstStartTime', 'lastUpdated', 'pid', 'processingStatus', 'processingTimestamp', 'startTime', 'statusCode'

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .INPUTS
    One or more [ANOWProcessingState] objects (pipeline capable)

    .OUTPUTS
    [ANOWProcessing] objects that match the Processing State will be returned

    .EXAMPLE
    Gets the Items associated with a known Processing State that has an Id of 123456
    Get-AutomateNOWProcessingState -Id 123456 | Read-AutomateNOWProcessingStateItem

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWProcessing[]])]
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWProcessingState]$ProcessingState,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100,
        [ValidateSet('sortOrder', 'dateCreated', 'endTime', 'firstStartTime', 'lastUpdated', 'pid', 'processingStatus', 'processingTimestamp', 'startTime', 'statusCode', ignoreCase = $false)]
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$sortBy = 'sortOrder',
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$Descending
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processing/read'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id -gt 0) {
            [ANOWProcessingState]$ProcessingState = $_
        }
        [string]$ProcessingState_id = $ProcessingState.id
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$ProcessingState_exists = ($null -eq (Get-AutomateNOWProcessingState -Id $ProcessingState_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWProcessingState failed to check if the Processing State [$ProcessingState_id] already existed due to [$Message]."
            Break
        }
        If ($ProcessingState_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not a Processing State with an Id of [$ProcessingState_id] in the Processing Registry of the [$current_domain]. Please check into this."
            Break
        }
        ## End warning ##
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        [string]$template = $ProcessingState.processingTemplate.Id
        [datetime]$ProcessingTimestamp = $ProcessingState.processingTimestamp
        [string]$processingTimestamp = Get-Date -Date $ProcessingTimestamp -Format 'yyyy-MM-ddTHH:mm:ss.fff'
        [string]$processingTemplateItemName = $ProcessingState.processingTemplateItemName
        [string]$parentTemplate = $ProcessingState.parentTemplate.Id
        $BodyMetaData.'_constructor' = 'AdvancedCriteria'
        $BodyMetaData.'operator' = 'and'
        $BodyMetaData.'criteria1' = ( '{"fieldName":"template","operator":"equals","value":"' + $template + '"}' )
        $BodyMetaData.'criteria2' = ( '{"fieldName":"processingTimestamp","operator":"equals","value":"' + $processingTimestamp + '"}' )
        $BodyMetaData.'criteria3' = ( '{"fieldName":"processingTemplateItemName","operator":"equals","value":"' + $processingTemplateItemName + '"}' )
        If ($parentTemplate.Length -gt 0) {
            $BodyMetaData.'criteria4' = ( '{"fieldName":"parentTemplate","operator":"equals","value":"' + $parentTemplate + '"}' )
        }
        $BodyMetaData.'_operationType' = 'fetch'
        $BodyMetaData.'startRow' = $startRow
        $BodyMetaData.'endRow' = $endRow
        If ($Descending -eq $true) {
            $BodyMetaData.'_sortBy' = '-' + $sortBy
        }
        Else {
            $BodyMetaData.'_sortBy' = $sortBy
        }
        $BodyMetaData.'_textMatchStyle' = 'substring'
        $BodyMetaData.'_componentId' = 'ProcessingStateItemList'
        $BodyMetaData.'_dataSource' = 'ProcessingDataSource'
        $BodyMetaData.'isc_metaDataPrefix' = '_'
        $BodyMetaData.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        If ($null -eq $parameters.Body) {
            $parameters.Add('Body', $Body)
        }
        Else {
            $parameters.Body = $Body
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ProcessingState_id] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWProcessing[]]$ProcessingStateItems = ForEach ($result in $results.response.data) {
                Switch ($result.processingType) {
                    'WORKFLOW' { [ANOWWorkflow]$Processing = $result; Break; }
                    'TASK' { [ANOWTask]$Processing = $result; Break; }
                    'TRIGGER' { [ANOWSchedule]$Processing = $result; Break; }
                    'SERVICE' { [ANOWServiceManager]$Processing = $result; Break; }
                }
                If ($null -ne $Processing) {
                    $Processing
                }
            }
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the returned Processing State item objects (which are actually [ANOWProcessing] objects) due to [$Message]"
            Break
        }
        If ($ProcessingStateItems.Count -gt 0) {
            Return $ProcessingStateItems
        }
    }
    End {
    }
}

Function Register-AutomateNOWProcessingState {
    <#
    .SYNOPSIS
    Registers a Processing State within the Processing State Registry of an AutomateNOW! instance

    .DESCRIPTION
    Registers a Processing State within the Processing State Registry of an AutomateNOW! instance

    .PARAMETER ProcessingState
    Mandatory [ANOWProcessingState] is registering a new Processing State

    .PARAMETER ProcessingStatus
    Mandatory string representing the Processing Status. Valid values are: EXECUTING, COMPLETED, FAILED

    .PARAMETER StatusCode
    This parameter only applies when ProcessingStatus is COMPLETED or FAILED. A string representing the Status Code that is associated with this registration.

    .PARAMETER Force
    Force the registration without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Suppresses the return of the updated object.

    .INPUTS
    One ProcessingStatus string along with one or more [ANOWProcessingState] objects (pipeline capable)

    .OUTPUTS
    The updated [ANOWProcessingState] object will be returned

    .EXAMPLE
    Forcefully registers a Processing State of COMPLETED with a Status Code of 200 to a Processing State with Id of 1234567. In this example, you know the exact Id of the Processing State. (one-liner format)

    Get-AutomateNOWProcessingState -Id 1234567 | Register-AutomateNOWProcessingState -ProcessingStatus COMPLETED -StatusCode 200 -Force

    .EXAMPLE
    Forcefully and quietly registers a Processing State of COMPLETED with a Status Code of 200 to the most current Processing State for a Task Template named 'TaskTemplate1' (one-liner)

    Get-AutomateNOWTaskTemplate -Id 'TaskTemplate1' | Get-AutomateNOWProcessingState -Descending | Select-Object -First 1 | Register-AutomateNOWProcessingState -ProcessingStatus COMPLETED -StatusCode 200 -Force -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWProcessingState]$ProcessingState,
        [Parameter(Mandatory = $true)]
        [ANOWProcessingState_processingStatus]$ProcessingStatus,
        [Parameter(Mandatory = $false)]
        [string]$statusCode,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($ProcessingStatus -eq 'EXECUTING' -and $statusCode.Length -gt 0) {
            Write-Warning -Message "You may not specify a -statusCode when the -ProcessingStatus is EXECUTING"
            Break
        }
        ElseIf ($ProcessingStatus -ne 'EXECUTING' -and $statusCode.Length -eq 0) {
            Write-Warning -Message "You must specify a -statusCode when the -ProcessingStatus is COMPLETED or FAILED"
            Break
        }
        [string]$command = '/processingState/registerProcessingState'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id -gt 0) {
            [ANOWProcessingState]$ProcessingState = $_
        }
        [string]$ProcessingState_id = $ProcessingState.id
        [string]$ProcessingTemplateId = $ProcessingState.processingTemplate
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$ProcessingStatus onto Processing State $($ProcessingState_id)?")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$ProcessingState_exists = ($null -eq (Get-AutomateNOWProcessingState -Id $ProcessingState_id))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWProcessingState failed to check if the Processing State [$ProcessingState_id] already existed due to [$Message]."
                Break
            }
            If ($ProcessingState_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not a Processing State with an Id of [$ProcessingState_id] in the Processing Registry of the [$current_domain]. Please check into this."
                Break
            }
            ## End warning ##
            [string]$processingTimestamp = Get-Date -Date (Get-Date -Date $ProcessingState.processingTimestamp) -format "yyyy-MM-ddTHH:mm:ss.fff"
            If ($processingTimestamp -notmatch '^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}\.[0-9]{3}$') {
                Write-Warning -Message "Somehow the processingTimestamp ($processingTimestamp) within Processing State [$ProcessingState_id] was not in the expected format. Please look into this."
                Break
            }
            [string]$processingTimestamp = $processingTimestamp.SubString(0, 10)
            [string]$old_Values = $ProcessingState.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'processingTemplate' = $ProcessingTemplateId
            $BodyMetaData.'processingTimestamp' = $processingTimestamp
            $BodyMetaData.'processingStatus' = $ProcessingStatus
            If ($null -ne $statusCode) {
                $BodyMetaData.'statusCode' = $statusCode
            }
            $BodyMetaData.'_operationType' = 'update'
            $BodyMetaData.'_operationId' = 'registerProcessingState'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_oldValues' = $old_values
            $BodyMetaData.'_componentId' = 'ProcessingStateUpdateWindow_form'
            $BodyMetaData.'_dataSource' = 'ProcessingStateDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ProcessingState_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Processing State $ProcessingState_id was successfully registered"
            $Error.Clear()
            Try {
                [ANOWProcessingState]$UpdatedProcessingState = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the returned registered object to an [ANOWProcessingState] object due to [$Message]. The object was still updated though."
                Break
            }
            If ($Quiet -ne $true) {
                Return $UpdatedProcessingState
            }
        }
    }
    End {
    }
}

Function Unregister-AutomateNOWProcessingState {
    <#
    .SYNOPSIS
    Unregisters a Processing State within the Processing State Registry of an AutomateNOW! instance

    .DESCRIPTION
    Unregisters a Processing State within the Processing State Registry of an AutomateNOW! instance

    .PARAMETER ProcessingState
    Mandatory [ANOWProcessingState] is unregistering a new Processing State

    .PARAMETER ProcessingStatus
    Mandatory string representing the Processing Status. Valid values are: EXECUTING, COMPLETED, FAILED

    .PARAMETER StatusCode
    This parameter only applies when ProcessingStatus is COMPLETED or FAILED. A string representing the Status Code that is associated with this unregistration.

    .PARAMETER Force
    Force the unregistration without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Suppresses the return of the updated object.

    .INPUTS
    One ProcessingStatus string along with one or more [ANOWProcessingState] objects (pipeline capable)

    .OUTPUTS
    The updated [ANOWProcessingState] object will be returned

    .EXAMPLE
    Forcefully unregisters a Processing State of COMPLETED with a Status Code of 200 to a Processing State with Id of 1234567. In this example, you know the exact Id of the Processing State. (one-liner format)

    Get-AutomateNOWProcessingState -Id 1234567 | Unregister-AutomateNOWProcessingState -ProcessingStatus COMPLETED -StatusCode 200 -Force

    .EXAMPLE
    Forcefully and quietly unregisters a Processing State of COMPLETED with a Status Code of 200 to the most current Processing State for a Task Template named 'TaskTemplate1' (one-liner)

    Get-AutomateNOWTaskTemplate -Id 'TaskTemplate1' | Get-AutomateNOWProcessingState -Descending | Select-Object -First 1 | Unregister-AutomateNOWProcessingState -ProcessingStatus COMPLETED -StatusCode 200 -Force -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(

        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWProcessingState]$ProcessingState,
        [Parameter(Mandatory = $true)]
        [ANOWProcessingState_processingStatus]$ProcessingStatus,
        [Parameter(Mandatory = $false)]
        [string]$statusCode,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($ProcessingStatus -eq 'EXECUTING' -and $statusCode.Length -gt 0) {
            Write-Warning -Message "You may not specify a -statusCode when the -ProcessingStatus is EXECUTING"
            Break
        }
        ElseIf ($ProcessingStatus -ne 'EXECUTING' -and $statusCode.Length -eq 0) {
            Write-Warning -Message "You must specify a -statusCode when the -ProcessingStatus is COMPLETED or FAILED"
            Break
        }
        [string]$command = '/processingState/unregisterProcessingState'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id -gt 0) {
            [ANOWProcessingState]$ProcessingState = $_
        }
        [string]$ProcessingState_id = $ProcessingState.id
        [string]$ProcessingTemplateId = $ProcessingState.processingTemplate
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$ProcessingStatus onto Processing State $($ProcessingState_id)?")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$ProcessingState_exists = ($null -eq (Get-AutomateNOWProcessingState -Id $ProcessingState_id))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWProcessingState failed to check if the Processing State [$ProcessingState_id] already existed due to [$Message]."
                Break
            }
            If ($ProcessingState_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not a Processing State with an Id of [$ProcessingState_id] in the Processing Registry of the [$current_domain]. Please check into this."
                Break
            }
            ## End warning ##
            [string]$processingTimestamp = Get-Date -Date (Get-Date -Date $ProcessingState.processingTimestamp) -format "yyyy-MM-ddTHH:mm:ss.fff"
            If ($processingTimestamp -notmatch '^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}\.[0-9]{3}$') {
                Write-Warning -Message "Somehow the processingTimestamp ($processingTimestamp) within Processing State [$ProcessingState_id] was not in the expected format. Please look into this."
                Break
            }
            [string]$processingTimestamp = $processingTimestamp.SubString(0, 10)
            [string]$old_Values = $ProcessingState.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'processingTemplate' = $ProcessingTemplateId
            $BodyMetaData.'processingTimestamp' = $processingTimestamp
            $BodyMetaData.'processingStatus' = $ProcessingStatus
            If ($null -ne $statusCode) {
                $BodyMetaData.'statusCode' = $statusCode
            }
            $BodyMetaData.'_operationType' = 'update'
            $BodyMetaData.'_operationId' = 'unregisterProcessingState'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_oldValues' = $old_values
            $BodyMetaData.'_componentId' = 'ProcessingStateUpdateWindow_form'
            $BodyMetaData.'_dataSource' = 'ProcessingStateDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ProcessingState_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Processing State $ProcessingState_id was successfully unregistered"
            $Error.Clear()
            Try {
                [ANOWProcessingState]$UpdatedProcessingState = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the returned registered object to an [ANOWProcessingState] object due to [$Message]. The object was still updated though."
                Break
            }
            If ($Quiet -ne $true) {
                Return $UpdatedProcessingState
            }
        }
    }
    End {
    }
}

Function Clear-AutomateNOWProcessingStateRegistry {
    <#
    .SYNOPSIS
    Clears all of the Processing States within the Processing State Registry of an AutomateNOW! instance

    .DESCRIPTION
    Clears all of the Processing States within the Processing State Registry of an AutomateNOW! instance

    .PARAMETER Force
    Switch parameter that forces the clearing without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    This function has no input parameters.

    .OUTPUTS
    A verbose message indicating success.

    .EXAMPLE
    Forcibly clears all of the Processing States

    Clear-AutomateNOWProcessingState -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processingState/clearProcessingStateRegistry'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("?")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'_operationType' = 'custom'
            $BodyMetaData.'_operationId' = 'clearProcessingStateRegistry'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_dataSource' = 'ProcessingStateDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ProcessingState_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Processing State $ProcessingState_id was successfully cleared"
        }
    }
    End {
    }
}

#endregion

#Region - Processing Template (Menu Specialty)

Function Get-AutomateNOWProcessingTemplate {
    <#
    .SYNOPSIS
    Gets the Processing Templates from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Processing Templates from an AutomateNOW! instance (this is a "Menu Speciality" function which means it seeks to emulate a specific list from the API user interface)

    .PARAMETER Id
    Optional string parameter to limit the result to a single result by Id. This parameter cannot be combined with other parameters.

    .PARAMETER sortBy
    Optional string parameter to sort the results by. Valid choices are: id*, processingType, simpleId, dateCreated, node, outOfSync, keepResourcesOnFailure, onHold, lastUpdated, highRisk, weight, taskType, userIp, createdBy, lazyLoad, passBy, lastUpdatedBy, durationSum, serverNodeType, eagerScriptExecution, passResourceDependenciesToChildren, owner, checkedOut, estimatedDuration, passActionsToChildren

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100. The console default hard limit is 10,000.

    .PARAMETER Folder
    Optional string to filter by a particular Folder

    .PARAMETER Tags
    Optional string array of Tags to filter by. Note that the 'containsAny' operator will be used.

    .PARAMETER Workspace
    Optional string to filter by a particular Workspace

    .OUTPUTS
    An array of one or more [ANOWProcessing] class objects

    .EXAMPLE
    Gets the first page of Processing Templates

    Get-AutomateNOWProcessingTemplate

    .EXAMPLE
    Gets a Processing Template named 'ProcessingTemplate1'

    Get-AutomateNOWProcessingTemplate -Id 'ProcessingTemplate1'

    .EXAMPLE
    Gets the first 10,000 Processing Templates within a Folder named 'Folder1'

    Get-AutomateNOWProcessingTemplate -startRow 0 -endRow 10000 -Folder 'Folder1'

    .EXAMPLE
    Gets the first page of Processing Templates within a Workspace named 'Workspace1'

    Get-AutomateNOWProcessingTemplate -Workspace 'Workspace1'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This is a "menu specialty" function meaning that its purpose is to mimic one of the UI buttons. This function returns all types of Processing items. You should try to use the respective processing functions (i.e. Get-AutomateNOWTask, GetAutomateNOWWorkflow, Get-AutomateNOWServiceManager, Get-AutomateNOWSchedule) whenever possible.

    Unlike most Get/Read functions, there is no default sort order. The UI probably does this for performance reasons.

    #>
    [OutputType([ANOWProcessingTemplate[]])]
    [Cmdletbinding( DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $True, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [string]$Id,
        [ValidateSet('id', 'processingType', 'simpleId', 'dateCreated', 'node', 'outOfSync', 'keepResourcesOnFailure', 'onHold', 'lastUpdated', 'highRisk', 'weight', 'taskType', 'userIp', 'createdBy', 'lazyLoad', 'passBy', 'lastUpdatedBy', 'durationSum', 'serverNodeType', 'eagerScriptExecution', 'passResourceDependenciesToChildren', 'owner', 'checkedOut', 'estimatedDuration', 'passActionsToChildren', ignoreCase = $false)]
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$sortBy = 'id',
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$Descending,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$Folder,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string[]]$Tags,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$Workspace
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        If ($Descending -eq $true -and $sortBy.Length -eq 0) {
            Write-Warning -Message "You must include the -sortBy parameter when -Descending is used"
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 -or $Id.Length -gt 0) {
            If ( $_.Length -gt 0 ) {
                [string]$Id = $_
            }
            $BodyMetaData.'id' = $Id
            $BodyMetaData.'_operationId' = 'read'
            [string]$textMatchStyle = 'exactCase'
        }
        Else {
            [string]$componentId = 'ProcessingTemplateList'
            $BodyMetaData.'_constructor' = 'AdvancedCriteria'
            $BodyMetaData.'operator' = 'and'
            $BodyMetaData.'_startRow' = $startRow
            $BodyMetaData.'_endRow' = $endRow
            [string]$textMatchStyle = 'substring'
            If ($sortBy.Length -gt 0) {
                If ($Descending -eq $true) {
                    $BodyMetaData.'_sortBy' = '-' + $sortBy
                }
                Else {
                    $BodyMetaData.'_sortBy' = $sortBy
                }
            }
            $BodyMetaData.'criteria1' = '{"fieldName":"processingType","operator":"inSet","value":["TASK","WORKFLOW","SERVICE"]}'
            If ($Folder.Length -gt 0) {
                $BodyMetaData.'criteria2' = ('{"fieldName":"folder","operator":"equals","value":"' + $Folder + '"}')
            }
            If ($Tags.Count -gt 0) {
                If ($Tags.Count -gt 1) {
                    $Error.Clear()
                    Try {
                        [string]$TagString = $Tags | ConvertTo-Json -Compress
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "ConvertTo-Json failed to convert the provided tag names under Get-AutomateNOWProcessingTemplate due to [$Message]."
                        Break
                    }
                }
                Else {
                    [string]$TagString = $Tags
                }
                $BodyMetaData.'criteria3' = ('{"fieldName":"tags","operator":"containsAny","value":' + $TagString + '}')
            }
            If ($Workspace.Length -gt 0) {
                $Error.Clear()
                Try {
                    [ANOWWorkspace]$Workspace_object = Get-AutomateNOWWorkspace -Id $Workspace
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWWorkspace failed to fetch $Workspace under Get-AutomateNOWProcessingTemplate due to [$Message]."
                    Break
                }
                If ($Workspace_object.Id.Length -eq 0) {
                    Write-Warning -Message "The Workspace $Workspace does not appear to exist. Please check into this."
                    Break
                }
                $BodyMetaData.'criteria4' = ('{"fieldName":"workspace","operator":"equals","value":' + $Workspace + '}')
            }
            $BodyMetaData.'_componentId' = $componentId
        }
        $BodyMetaData.'_textMatchStyle' = $textMatchStyle
        $BodyMetaData.'_operationType' = 'fetch'
        $BodyMetaData.'_dataSource' = 'ProcessingTemplateDataSource'
        $BodyMetaData.'isc_metaDataPrefix' = '_'
        $BodyMetaData.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        [string]$command = ('/processingTemplate/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('command', $command)
        }
        Else {
            $parameters.'command' = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWProcessingTemplate[]]$ProcessingTemplates = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWProcessingTemplate] objects due to [$Message]."
            Break
        }
        If ($ProcessingTemplates.Count -gt 0) {
            Return $ProcessingTemplates
        }
    }
    End {

    }
}

#endregion

#Region - Processing Trigger Logs

Function Get-AutomateNOWProcessingTriggerLog {
    <#
    .SYNOPSIS
    Gets the Processing Trigger Log objects from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Processing Trigger Log objects from an AutomateNOW! instance

    .PARAMETER Id
    Optional string of the specific Id of the Processing Trigger Log that you want to retrieve. Note that this parameter is not required and is exclusive from all other parameters.

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER sortBy
    Optional string parameter to sort the results by. Valid choices are: 'dateCreated'*, 'id', 'scheduledFireTime', 'schedulerInstanceId', 'triggerId', 'fireInstanceId'

    .PARAMETER Ascending
    Optional switch parameter to sort in ascending order

    .INPUTS
    Accepts a string representing the simple id of the Notification Group from the pipeline or individually (but not an array).

    .OUTPUTS
    An array of one or more [ANOWProcessingTriggerLog] class objects

    .EXAMPLE
    Gets the first page of Processing Trigger Log objects

    Get-AutomateNOWProcessingTriggerLog

    .EXAMPLE
    Gets the first 10,000 Processing Trigger Log objects

    Get-AutomateNOWProcessingTriggerLog -startRow 0 -endRow 10000

    .EXAMPLE
    Gets a single Processing Trigger Log entry by its Id

    Get-AutomateNOWProcessingTriggerLog -Id '1f2c7591-2ece-2b95-aac8-63b51a98ad6a_1761432500000'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWProcessingTriggerLog[]])]
    [Cmdletbinding(DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $True, ParameterSetName = 'Id', ValueFromPipeline = $True)]
        [string]$id,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100,
        [ValidateSet('dateCreated', 'id', 'scheduledFireTime', 'schedulerInstanceId', 'triggerId', 'fireInstanceId', ignoreCase = $false)]
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$sortBy = 'dateCreated',
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$Ascending
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 ) {
            [string]$Id = $_
        }
        If ($Id.Length -gt 0) {
            $Body.'id' = $Id
            $Body.'_operationId' = 'read'
            [string]$textMatchStyle = 'exactCase'
        }
        Else {
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
            $Body.'_componentId' = 'ExecuteProcessingTriggerLogList'
            [string]$textMatchStyle = 'subString'
        }
        $Body.'_operationType' = 'fetch'
        $Body.'_textMatchStyle' = $textMatchStyle
        $Body.'_dataSource' = 'ExecuteProcessingTriggerLogDataSource'
        If ($Ascending -ne $true) {
            $Body.'_sortBy' = '-' + $sortBy
        }
        Else {
            $Body.'_sortBy' = $sortBy
        }
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/executeProcessingTriggerLog/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('command', $command)
        }
        Else {
            $parameters.'command' = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWProcessingTriggerLog[]]$ProcessingTriggerLogs = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWProcessingTriggerLog] objects due to [$Message]."
            Break
        }
        If ($ProcessingTriggerLogs.Count -gt 0) {
            Return $ProcessingTriggerLogs
        }
    }
    End {

    }
}

Function Export-AutomateNOWProcessingTriggerLog {
    <#
    .SYNOPSIS
    Exports the Processing Trigger Log entries from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Processing Trigger Log entries from an instance of AutomateNOW! to a local .csv file

    .PARAMETER ProcessingTriggerLog
    Mandatory [ANOWProcessingTriggerLog] object (Use Get-AutomateNOWProcessingTriggerLog to retrieve them)

    .INPUTS
    ONLY [ANOWProcessingTriggerLog] objects are accepted (including from the pipeline)

    .OUTPUTS
    The [ANOWProcessingTriggerLog] objects are exported to the local disk in CSV format

    .EXAMPLE
    Get-AutomateNOWProcessingTriggerLog | Export-AutomateNOWProcessingTriggerLog

    .NOTES
	You must present [ANOWProcessingTriggerLog] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWProcessingTriggerLog]$ProcessingTriggerLog
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-ProcessingTriggerLog-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        $parameters.Add('Delimiter', "`t")
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWProcessingTriggerLog]$ProcessingTriggerLog = $_
        }
        $Error.Clear()
        Try {
            $ProcessingTriggerLog | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWProcessingTriggerLog] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

#endregion

#Region - Referrals

Function Find-AutomateNOWObjectReferral {
    <#
    .SYNOPSIS
    Gets the referrals for an object from an AutomateNOW! instance

    .DESCRIPTION
    Gets the referrals for an object from an AutomateNOW! instance

    .PARAMETER Sum
    Optional switch to return only the sum of total referrals. Returns 0 when no results are found.

    .PARAMETER startRow
    Integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER TaskTemplate
    [ANOWTaskTemplate] object to find referrals to. Use Get-AutomateNOWTaskTemplate to obtain these objects.

    .PARAMETER WorkflowTemplate
    [ANOWWorkflowTemplate] object to find referrals to. Use Get-AutomateNOWWorkflowTemplate to obtain these objects.

    .PARAMETER ServiceManagerTemplate
    [ANOWServiceManagerTemplate] object to find referrals to. Use Get-AutomateNOWServiceManagerTemplate to obtain these objects.

    .PARAMETER ScheduleTemplate
    [ANOWScheduleTemplate] object to find referrals to. Use Get-AutomateNOWScheduleTemplate to obtain these objects. Note: The console refers to these as 'Schedules'.

    .PARAMETER BusinessView
    [ANOWBusinessView] object to find referrals to. Use Get-AutomateNOWBusinessview to obtain these objects.

    .PARAMETER Workspace
    [ANOWWorkspace] object to find referrals to. Use Get-AutomateNOWWorkspace to obtain these objects.

    .PARAMETER ResultMapping
    [ANOWResultMapping] object to find referrals to. Use Get-AutomateNOWResultMapping to obtain these objects.

    .PARAMETER Approval
    [ANOWApproval] object to find referrals to. Use Get-AutomateNOWApproval to obtain these objects.

    .PARAMETER ServerNode
    [ANOWServerNode] object to find referrals to. Use Get-AutomateNOWServerNode to obtain these objects.

    .PARAMETER ServerNodeGroup
    [ANOWServerNodeGroup] object to find referrals to. Use Get-AutomateNOWServerNodeGroup to obtain these objects.

    .PARAMETER Endpoint
    [ANOWEndpoint] object to find referrals to. Use Get-AutomateNOWEndpoint to obtain these objects.

    .PARAMETER Stock
    [ANOWStock] object to find referrals to. Use Get-AutomateNOWStock to obtain these objects.

    .PARAMETER Lock
    [ANOWLock] object to find referrals to. Use Get-AutomateNOWLock to obtain these objects.

    .PARAMETER Semaphore
    [ANOWSemaphore] object to find referrals to. Use Get-AutomateNOWSemaphore to obtain these objects.

    .PARAMETER TimeWindow
    [ANOWTimeWindow] object to find referrals to. Use Get-AutomateNOWTimeWindow to obtain these objects.

    .PARAMETER Variable
    [ANOWVariable] object to find referrals to. Use Get-AutomateNOWVariable to obtain these objects.

    .PARAMETER PhysicalResource
    [ANOWPhysicalResource] object to find referrals to. Use Get-AutomateNOWPhysicalResource to obtain these objects.

    .PARAMETER Metric
    [ANOWMetric] object to find referrals to. Use Get-AutomateNOWMetric to obtain these objects.

    .PARAMETER Event
    [ANOWEvent] object to find referrals to. Use Get-AutomateNOWEvent to obtain these objects.

    .PARAMETER Calendar
    [ANOWCalendar] object to find referrals to. Use Get-AutomateNOWCalendar to obtain these objects.

    .PARAMETER Anomaly
    [ANOWAnomaly] object to find referrals to. Use Get-AutomateNOWAnomaly to obtain these objects.

    .PARAMETER Interface
    [ANOWIntegration] object to find referrals to. Use Get-AutomateNOWIntegration to obtain these objects.

    .PARAMETER NotificationMessageTemplate
    [ANOWNotificationMessageTemplate] object to find referrals to. Use Get-AutomateNOWNotificationMessageTemplate to obtain these objects.

    .PARAMETER Dashboard
    [ANOWDashboard] object to find referrals to. Use Get-AutomateNOWBusinessview to obtain these objects.

    .PARAMETER UserReport
    [ANOWUserReport] object to find referrals to. Use Get-AutomateNOWBusinessview to obtain these objects.

    .INPUTS
    Accepts the following types of ANOW objects: Anomaly, Approval, BusinessView, Calendar, Dashboard, Endpoint, Event, Interface, Lock, Metric, NotificationMessageTemplate, PhysicalResource, ResultMapping, ScheduleTemplate, Semaphore, ServerNode, ServiceManagerTemplate, Stock, TaskTemplate, TimeWindow, UserReport, Variable, WorkflowTemplate, Workspace

    .OUTPUTS
    Raw results by default or a summary with the -Sum parameter

    .EXAMPLE
    $server_node = Get-AutomateNOWServerNode -Id 'ServerNode1'
    Find-AutomateNOWObjectReferral -ServerNode $server_node

    .EXAMPLE
    $workflow_template = Get-AutomateNOWWorkflowTemplate -Id 'WorkflowTemplate1'
    Find-AutomateNOWObjectReferral -WorkflowTemplate $workflow_template -Sum

    .EXAMPLE
    Get-AutomateNOWServerNode -Id 'ServerNode1' | Find-AutomateNOWObjectReferral

    .EXAMPLE
    'Workflow1', 'Workflow2' | Get-AutomateNOWWorkflowTemplate | Find-AutomateNOWObjectReferral

    .EXAMPLE
    Get-AutomateNOWTaskTemplate | Find-AutomateNOWObjectReferral

    .EXAMPLE
    Get-AutomateNOWTaskTemplate -TaskType PYTHON | Find-AutomateNOWObjectReferral -Sum

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Referrals may not actually exist (yet) for the following object types: Approval, Dashboard, ScheduleTemplate, ServerNodeGroup, UserReport, Workspace

    #>
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $False)]
        [switch]$Sum,
        [Parameter(Mandatory = $False)]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False)]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'TaskTemplate')] # Processing Templates
        [ANOWTaskTemplate]$TaskTemplate,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'WorkflowTemplate')] # Processing Templates
        [ANOWWorkflowTemplate]$WorkflowTemplate,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'ServiceManagerTemplate')] # Processing Templates
        [ANOWServiceManagerTemplate]$ServiceManagerTemplate,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'ScheduleTemplate')] # Schedules
        [ANOWScheduleTemplate]$ScheduleTemplate,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'BusinessView')] # Business Views
        [ANOWBusinessView]$BusinessView,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Workspace')] # Workspaces
        [ANOWWorkspace]$Workspace,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'ResultMapping')] # Result Mappings
        [ANOWResultMapping]$ResultMapping,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Approval')] # Approvals
        [ANOWApproval]$Approval,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'ServerNode')] # Server Nodes
        [ANOWServerNode]$ServerNode,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'ServerNodeGroup')] # Server Node Groups
        [ANOWServerNodeGroup]$ServerNodeGroup,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Endpoint')] # Endpoints
        [ANOWEndpoint]$Endpoint,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Stock')] # Resources
        [ANOWStock]$Stock,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Lock')] # Resources
        [ANOWLock]$Lock,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Semaphore')] # Resources
        [ANOWSemaphore]$Semaphore,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'TimeWindow')] # Resources
        [ANOWTimeWindow]$TimeWindow,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Variable')] # Resources
        [ANOWVariable]$Variable,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'PhysicalResource')] # Resources
        [ANOWPhysicalResource]$PhysicalResource,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Metric')] # Resources
        [ANOWMetric]$Metric,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Event')] # Resources
        [ANOWEvent]$Event,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Calendar')] # Resources
        [ANOWCalendar]$Calendar,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Anomaly')] # Anomalies
        [ANOWAnomaly]$Anomaly,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Interface')] # Interfaces
        [ANOWIntegration]$Interface,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'NotificationMessageTemplate')] # Notification Templates
        [ANOWNotificationMessageTemplate]$NotificationMessageTemplate,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Dashboard')] # Dashboards
        [ANOWDashboard]$Dashboard,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'UserReport')] # User Reports
        [ANOWUserReport]$UserReport
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_ -is [ANOWTaskTemplate] -or $TaskTemplate.Id.Length -gt 0) {
            [string]$domainClass = 'ProcessingTemplate'
            If ($TaskTemplate.Id.Length -gt 0) {
                $Body.'id' = $TaskTemplate.Id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWWorkflowTemplate] -or $WorkflowTemplate.Id.Length -gt 0) {
            [string]$domainClass = 'ProcessingTemplate'
            If ($WorkflowTemplate.Id.Length -gt 0) {
                $Body.'id' = $WorkflowTemplate.Id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWServiceManagerTemplate] -or $ServiceManagerTemplate.Id.Length -gt 0) {
            [string]$domainClass = 'ProcessingTemplate'
            If ($ServiceManagerTemplate.Id.Length -gt 0) {
                $Body.'id' = $ServiceManagerTemplate.Id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWScheduleTemplate] -or $ScheduleTemplate.Id.Length -gt 0) {
            [string]$domainClass = 'ProcessingTemplate'
            If ($ScheduleTemplate.Id.Length -gt 0) {
                $Body.'id' = $ScheduleTemplate.Id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWBusinessView] -or $BusinessView.Id.Length -gt 0) {
            [string]$domainClass = 'BusinessView'
            If ($BusinessView.id.Length -gt 0) {
                $Body.'id' = $BusinessView.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWWorkspace] -or $Workspace.Id.Length -gt 0) {
            [string]$domainClass = 'Workspace'
            If ($Workspace.id.Length -gt 0) {
                $Body.'id' = $Workspace.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWResultMapping] -or $ResultMapping.Id.Length -gt 0) {
            [string]$domainClass = 'ResultMapping'
            If ($ResultMapping.id.Length -gt 0) {
                $Body.'id' = $ResultMapping.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWApproval] -or $Approval.Id.Length -gt 0) {
            [string]$domainClass = 'ApprovalConfiguration'
            If ($Approval.id.Length -gt 0) {
                $Body.'id' = $Approval.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWServerNode] -or $ServerNode.Id.Length -gt 0) {
            [string]$domainClass = 'ServerNode'
            If ($ServerNode.id.Length -gt 0) {
                $Body.'id' = $ServerNode.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWServerNodeGroup] -or $ServerNodeGroup.Id.Length -gt 0) {
            [string]$domainClass = 'ServerNodeGroup'
            If ($ServerNodeGroup.id.Length -gt 0) {
                $Body.'id' = $ServerNodeGroup.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWEndpoint] -or $Endpoint.Id.Length -gt 0) {
            [string]$domainClass = 'Endpoint'
            If ($Endpoint.id.Length -gt 0) {
                $Body.'id' = $Endpoint.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWStock] -or $Stock.Id.Length -gt 0) {
            [string]$domainClass = 'Resource'
            If ($Stock.id.Length -gt 0) {
                $Body.'id' = $Stock.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWLock] -or $Lock.Id.Length -gt 0) {
            [string]$domainClass = 'Resource'
            If ($Lock.id.Length -gt 0) {
                $Body.'id' = $Lock.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWSemaphore] -or $Semaphore.Id.Length -gt 0) {
            [string]$domainClass = 'Resource'
            If ($Semaphore.id.Length -gt 0) {
                $Body.'id' = $Semaphore.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWTimeWindow] -or $TimeWindow.Id.Length -gt 0) {
            [string]$domainClass = 'Resource'
            If ($TimeWindow.id.Length -gt 0) {
                $Body.'id' = $TimeWindow.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWVariable] -or $Variable.Id.Length -gt 0) {
            [string]$domainClass = 'Resource'
            If ($Variable.id.Length -gt 0) {
                $Body.'id' = $Variable.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWPhysicalResource] -or $PhysicalResource.Id.Length -gt 0) {
            [string]$domainClass = 'Resource'
            If ($PhysicalResource.id.Length -gt 0) {
                $Body.'id' = $PhysicalResource.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWMetric] -or $Metric.Id.Length -gt 0) {
            [string]$domainClass = 'Resource'
            If ($Metric.id.Length -gt 0) {
                $Body.'id' = $Metric.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWEvent] -or $Event.Id.Length -gt 0) {
            [string]$domainClass = 'Resource'
            If ($Event.id.Length -gt 0) {
                $Body.'id' = $Event.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWCalendar] -or $Calendar.Id.Length -gt 0) {
            [string]$domainClass = 'Resource'
            If ($Calendar.id.Length -gt 0) {
                $Body.'id' = $Calendar.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWAnomaly] -or $Anomaly.Id.Length -gt 0) {
            [string]$domainClass = 'Anomaly'
            If ($Anomaly.id.Length -gt 0) {
                $Body.'id' = $Anomaly.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWIntegration] -or $Integration.Id.Length -gt 0) {
            [string]$domainClass = 'Integration'
            If ($Integration.id.Length -gt 0) {
                $Body.'id' = $Integration.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWNotificationMessageTemplate] -or $NotificationMessageTemplate.Id.Length -gt 0) {
            [string]$domainClass = 'NotificationMessageTemplate'
            If ($NotificationMessageTemplate.id.Length -gt 0) {
                $Body.'id' = $NotificationMessageTemplate.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWDashboard] -or $Dashboard.Id.Length -gt 0) {
            [string]$domainClass = 'Dashboard'
            If ($Dashboard.id.Length -gt 0) {
                $Body.'id' = $Dashboard.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        ElseIf ($_ -is [ANOWUserReport] -or $UserReport.Id.Length -gt 0) {
            [string]$domainClass = 'UserReport'
            If ($UserReport.id.Length -gt 0) {
                $Body.'id' = $UserReport.id
            }
            Else {
                $Body.'id' = $_.'id'
            }
        }
        Else {
            Write-Warning -Message "Unable to determine input object. Please specify a supported object type. See the in-line help for more information."
            Break
        }
        [string]$object_id = $Body.'id'
        $Body.'domainClass' = $domainclass
        $Body.'_operationType' = 'fetch'
        $Body.'_startRow' = $startRow
        $Body.'_endRow' = $endRow
        $Body.'_textMatchStyle' = 'exact'
        $Body.'_componentId' = 'ReferenceListWindow_list'
        $Body.'_dataSource' = 'ReferrersDataSource'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/findReferrers/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] while running Find-AutomateNOWObjectReferral due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWReferrer[]]$referrers = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Unable to parse the response into [ANOWReferrer] objects when querying about $object_id of domainClass [$domainclass] (under Find-AutomateNOWObjectReferral) due to [$Message]."
            Break
        }
        If ($Sum -eq $true) {
            [int32]$results_count = $referrers.count
            [PSCustomObject]$results_summary = [PSCustomObject]@{ object = $object_id; object_class = $domainClass; referrals = $results_count; }
            Return $results_summary
        }
        Else {
            Return $referrers
        }
    }
    End {

    }
}

#endregion

#Region - Resource Anomalies

Function Read-AutomateNOWResourceAnomaly {
    <#
    .SYNOPSIS
    Reads the Resource Anomalies in a Metric on an AutomateNOW! instance

    .DESCRIPTION
    Reads the Resource Anomalies in a Metric on an AutomateNOW! instance

    .PARAMETER Metric
    The [ANOWMetric] object representing the Metric from which the Resource Anomalies will be read. Use Get-AutomateNOWMetric to retrieve this.

    .PARAMETER sortBy
    Optional string parameter to sort the results by. Valid choices are: 'id', 'codeRepository', 'createdBy', 'dateCreated'*, 'folder', 'hasNotes', 'hasPendingNotes', 'id', 'lastUpdated', 'lastUpdatedBy', 'resourceStatus', 'resourceType'

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .INPUTS
    ONLY [ANOWBusinessView] objects are accepted (including from the pipeline)

    .OUTPUTS
    [ResourceAnomaly] objects will be returned.

    .EXAMPLE
    Gets the first 100 Resource Anomalies from a Metric named 'Metric1' via the pipeline

    Get-AutomateNOWMetric -Id 'Metric1' | Read-AutomateNOWResourceAnomaly

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    For now, this function supports all 9 types of resources but that may not be needed since Resource Anomalies may apply to Metrics only (shrug)

    #>
    [OutputType([ANOWResourceAnomaly[]])]
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWMetric]$Metric,
        [Parameter(Mandatory = $False)]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False)]
        [int32]$endRow = 100,
        [ValidateSet( 'dateCreated', 'id', 'codeRepository', 'createdBy', 'folder', 'hasNotes', 'hasPendingNotes', 'id', 'lastUpdated', 'lastUpdatedBy', 'resourceStatus', 'resourceType', ignoreCase = $false)]
        [Parameter(Mandatory = $False)]
        [string]$sortBy = 'dateCreated',
        [Parameter(Mandatory = $False)]
        [switch]$Descending,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWMetric]$Metric = $_
        }
        [string]$Metric_id = $Metric.Id
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        $BodyMetaData.Add('_constructor', 'AdvancedCriteria' )
        $BodyMetaData.Add('operator', 'and')
        $BodyMetaData.Add('criteria', '{"fieldName":"resource","operator":"equals","value":"' + $Metric_id + '"}')
        $BodyMetaData.Add('_operationType', 'fetch')
        $BodyMetaData.Add('_startRow', $startRow)
        $BodyMetaData.Add('_endRow', $endRow)
        If ($Descending -eq $true) {
            $BodyMetaData.'_sortBy' = '-' + $sortBy
        }
        Else {
            $BodyMetaData.'_sortBy' = $sortBy
        }
        $BodyMetaData.Add('_textMatchStyle', 'exact')
        $BodyMetaData.Add('_componentId', 'ResourceAnomalyList')
        $BodyMetaData.Add('_dataSource', 'ResourceAnomalyDataSource')
        $BodyMetaData.Add('isc_metaDataPrefix', '_')
        $BodyMetaData.Add('isc_dataFormat', 'json')
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        [string]$command = ('/resourceAnomaly/read' + '?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.'Command' = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Metric_id] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        If ($results.response.data.count -gt 0) {
            $Error.Clear()
            Try {
                [ANOWResourceAnomaly[]]$ResourceAnomalys = ForEach ($Anomaly in $results.response.data) {
                    $Anomaly.resource = $Metric
                    $Anomaly
                }
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the Resource Anomaly Items under Read-AutomateNOWResourceAnomaly due to [$Message]"
                Break
            }
            Write-Verbose -Message "Resource Anomalies successfully read from $Metric_id"
            If ($ResourceAnomalys.Count -gt 0) {
                Return $ResourceAnomalys
            }
        }
        Else {
            Write-Verbose -Message "There were no Resource Anomalies within $Metric_id"
        }
    }
    End {

    }
}

Function Remove-AutomateNOWResourceAnomaly {
    <#
    .SYNOPSIS
    Removes (deletes) a Resource Anomaly from a Metric in an AutomateNOW! instance

    .DESCRIPTION
    Removes (deletes) a Resource Anomaly from a Metric in an AutomateNOW! instance

    .PARAMETER ResourceAnomaly
    Mandatory ResourceAnomaly object to be removed from a Metric. Use Read-AutomateNOWResourceAnomaly to retrieve them.

    .PARAMETER Force
    Force the removal of the object without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the display of the results

    .INPUTS
    You must pass [ANOWResourceAnomaly] objects. The pipeline may be used.

    .OUTPUTS
    The Resource Anomaly that was removed from the Metric will be returned

    .EXAMPLE
    Forcibly removes the first page of Resource Anomalies from a Metric named 'Metric1' (one-liner format)
    Get-AutomateNOWMetric -Id 'Metric11' | Read-AutomateNOWResourceAnomaly | Remove-AutomateNOWResourceAnomaly -Force

    .EXAMPLE
    Removes the first page of Resource Anomalies from a Metric named 'Metric1' (multi-line format)
    [ANOWMetric]$metric = Get-AutomateNOWMetric -Id 'Metric1'
    [ANOWResourceAnomaly[]]$resource_anomalies = $metric | Read-AutomateNOWResourceAnomaly
    $resource_anomalies | Remove-AutomateNOWResourceAnomaly

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([PSCustomObject])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWResourceAnomaly]$ResourceAnomaly,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('Command', '/resourceAnomaly/delete')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Id.Length -gt 0 ) {
            [ANOWResourceAnomaly]$ResourceAnomaly = $_
        }
        [string]$ResourceAnomaly_id = $ResourceAnomaly.id
        If ($ResourceAnomaly_id.Length -eq 0) {
            Write-Warning -Message "Somehow a Resource Anomaly with an empty Id was passed to Remove-AutomateNOWResourceAnomaly. Please look into this."
            Break
        }
        [string]$Metric_id = $ResourceAnomaly.resource.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$ResourceAnomaly_id")) -eq $true) {
            [string]$old_values = $ResourceAnomaly.CreateOldValues()
            $Body.'id' = $ResourceAnomaly_id
            $Body.'_oldValues' = $old_values
            $Body.'_operationType' = 'remove'
            $Body.'_textMatchStyle' = 'exact'
            $Body.'_componentId' = 'ResourceAnomalyList'
            $Body.'_dataSource' = 'ResourceAnomalyDataSource'
            $Body.'isc_metaDataPrefix' = '_'
            $Body.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $Body
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Resource Anomaly $ResourceAnomaly_id was removed from its Metric $Metric_id"
        }
    }
    End {

    }
}

Function Export-AutomateNOWResourceAnomaly {
    <#
    .SYNOPSIS
    Exports the Resource Anomaly objects from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Resource Anomaly objects from an instance of AutomateNOW! to a local .csv file

    .PARAMETER ResourceAnomaly
    Mandatory [ANOWResourceAnomaly] object (Use Get-AutomateNOWResourceAnomaly to retrieve them)

    .INPUTS
    ONLY [ANOWResourceAnomaly] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWResourceAnomaly] objects are exported to the local disk in CSV format

    .EXAMPLE
    Exports the first page of Resource Anomalies that have been added to a Metric named 'Metric1'

    Get-AutomateNOWMetric -Id 'Metric1' | Read-AutomateNOWResourceAnomaly | Export-AutomateNOWResourceAnomaly

    .NOTES
	You must present [ANOWResourceAnomaly] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWResourceAnomaly]$ResourceAnomaly
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-ResourceAnomaly-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWResourceAnomaly]$ResourceAnomaly = $_
        }
        $Error.Clear()
        Try {
            $ResourceAnomaly | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWResourceAnomaly] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function Add-AutomateNOWResourceAnomaly {
    <#
    .SYNOPSIS
    Adds a Resource Anomaly to a Metric on an AutomateNOW! instance

    .DESCRIPTION
    Adds a Resource Anomaly to a Metric on an AutomateNOW! instance

    .PARAMETER Metric
    The mandatory [ANOWMetric] object representing the Metric to which the Resource Anomalies will be added. Use Get-AutomateNOWMetric to retrieve this.

    .PARAMETER CheckProperty
    Optional string to add a Composite Function to for checking a property on the Metric(?). This value cannot be unset and will default to CURRENT_VALUE if not specified. Valid choices are: CURRENT_VALUE*; AVERAGE; MEDIAN; FIRST_QUARTILE; SECOND_QUARTILE; THIRD_QUARTILE; FOURTH_QUARTILE; MIN; MAX; COUNT; MEAN; GEOMETRIC_MEAN; POPULATION_VARIANCE; PRODUCT; SUM_LOG; SUM_SQ; VARIANCE; KURTOSIS; SKEWNESS; STANDARD_DEVIATION;

    .PARAMETER StatisticPeriod
    Optional int64 to specify milliseconds ONLY applies when the -CheckProperty is set to CURRENT_VALUE. When not specified, the value is considered 0. The max value is 1 year (in ms) which is consistent with the UI.

    .PARAMETER CheckOperator
    The mandatory operator to apply to the value of the Resource Anomaly. There is no default value so you must make this choice. Valid choices are: 'EQ_NUM', 'NE_NUM', 'LT_NUM', 'GT_NUM', 'LE_NUM', 'GE_NUM'

    .PARAMETER CheckValue
    The mandatory int64 value (that will be checked) to the Resource Anomaly. This value can be as low as -9223372036854776000 in the negative or as high as 9223372036854776000.

    .PARAMETER Anomaly
    The mandatory [ANOWAnomaly] object that will be added to the Resource Anomaly.

    .PARAMETER MagnitudeType
    Sets a type of Magnitude to the Resource Anomaly. Valid choices are: PROPERTY_VALUE; CURRENT_VALUE; STATIC_VALUE;

    .PARAMETER Magnitude
    Required int64 if -MagnitudeType is set to STATIC_VALUE otherwise this parameter should not be set.

    .PARAMETER Quiet
    Switch parameter to silence the output from a successful update

    .PARAMETER Force
    Force the addition of the object without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY an [ANOWMetric] object is accepted. There is no pipeline support in this function.

    .OUTPUTS
    The newly created [ANOWResourceAnomaly] object will be emitted. Use -Quiet to suppress this.

    .EXAMPLE
    The minimum parameters needed to add a Resource Anomaly based on an Anomaly named 'Anomaly1' to a Metric named 'Metric1' (multi-line format)

    [ANOWMetric]$metric1 = Get-AutomateNOWMetric -Id 'Metric1'
    [ANOWAnomaly]$anomaly1 = Get-AutomateNOWAnomaly -Id 'Anomaly1'
    $metric1 | Add-AutomateNOWResourceAnomaly -Anomaly $anomaly1 -CheckOperator 'EQ_NUM' -CheckValue 5

    .EXAMPLE
    Forcibly and quietly uses the minimum parameters needed to add a Resource Anomaly based on an Anomaly named 'Anomaly1' to a Metric named 'Metric1' (one-liner format)

    Get-AutomateNOWMetric -Id 'Metric1' | Add-AutomateNOWResourceAnomaly -Anomaly (Get-AutomateNOWAnomaly -Id 'Anomaly1') -CheckOperator 'EQ_NUM' -CheckValue 5 -Force -Quiet

    .EXAMPLE
    Forcibly and quietly adds a Resource Anomaly based on an Anomaly named 'Anomaly1' to a Metric named 'Metric1' with a Check Property of AVERAGE for a period of 10 seconds with an operator of "Less Than or Equal To" against a value of 5 with a Magnitude Type of STATIC_VALUE set to a Magnitude of 100 (one-liner format)

    Get-AutomateNOWMetric -Id 'Metric1' | Add-AutomateNOWResourceAnomaly -Anomaly (Get-AutomateNOWAnomaly -Id 'Anomaly1') -CheckProperty AVERAGE -StatisticPeriod 10000 -CheckOperator 'LE_NUM' -CheckValue 5 -MagnitudeType STATIC_VALUE -Magnitude 100 -Force -Quiet

    .EXAMPLE
    Adds a Resource Anomaly based on an Anomaly named 'Anomaly1' to a Metric named 'Metric1' with a Check Property of FIRST_QUARTILE for a period of 90 seconds with an operator of "Not Equal To" against a value of 10 and a Magnitude Type of PROPERTY_VALUE (multi-line format)

    [ANOWMetric]$metric = Get-AutomateNOWMetric -Id 'Metric1'
    [ANOWAnomaly]$anomaly = Get-AutomateNOWAnomaly -Id 'Anomaly1'
    Add-AutomateNOWResourceAnomaly -Metric $metric -Anomaly $anomaly -CheckProperty FIRST_QUARTILE -StatisticPeriod 90000 -CheckOperator 'NE_NUM' -CheckValue 10 -MagnitudeType PROPERTY_VALUE

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Even though DYNAMIC_VALUE is an available magnitude type according to the schema, it is not available in the UI so it is disabled here.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWMetric]$Metric,
        [Parameter(Mandatory = $false)]
        [ANOWResourceAnomaly_statisticFunction]$CheckProperty = 'CURRENT_VALUE',
        [ValidateRange(0, 31536000000)]
        [Parameter(Mandatory = $false)]
        [Nullable[int64]]$StatisticPeriod,
        [ValidateSet('EQ_NUM', 'NE_NUM', 'LT_NUM', 'GT_NUM', 'LE_NUM', 'GE_NUM', ignoreCase = $false)]
        [Parameter(Mandatory = $true)]
        [string]$CheckOperator,
        [Parameter(Mandatory = $true)]
        [int64]$CheckValue,
        [Parameter(Mandatory = $true)]
        [ANOWAnomaly]$Anomaly,
        [Parameter(Mandatory = $false)]
        [ANOWResourceAnomaly_magnitudeCalculationType]$MagnitudeType,
        [Parameter(Mandatory = $false)]
        [Nullable[int64]]$Magnitude,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($CheckProperty -eq 'CURRENT_VALUE' -and $null -ne $StatisticPeriod) {
            Write-Warning -Message "You cannot set a statistic period if the Check Property is set to CURRENT_VALUE."
            Break
        }
        If ($MagnitudeType -eq 'DYNAMIC_VALUE') {
            Write-Warning -Message "Please choose a different magnitudeCalculationType. DYNAMIC_VALUE is not selectable in the UI so it is not supported here (yet)."
            Break
        }
        If ($null -ne $Magnitude -and $MagnitudeType -ne 'STATIC_VALUE') {
            Write-Warning -Message "You can only include the -Magnitude if the -MagnitudeType is also set to STATIC_VALUE"
            Break
        }
        [string]$Anomaly_id = $Anomaly.id
        [string]$Anomaly_simpleId = $Anomaly.simpleId
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to add it.
        $Error.Clear()
        Try {
            [ANOWAnomaly]$current_anomaly_result = Get-AutomateNOWAnomaly -Id $Anomaly_simpleId
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWAnomaly failed to check if the Anomaly $Anomaly_id existed under Add-AutomateNOWResourceAnomaly due to [$Message]."
            Break
        }
        If ($current_anomaly_result.id.length -eq 0) {
            Write-Warning -Message "The Anomaly object that you specified $Anomaly_id does not seem to exist under Add-AutomateNOWResourceAnomaly"
            Break
        }
        ## End warning ##
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
        [string]$command = '/resourceAnomaly/create'
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWMetric]$Metric = $_
        }
        [string]$Metric_id = $Metric.id
        [string]$Metric_simpleId = $Metric.simpleId
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Add $($Anomaly_id) to $($Metric_id)?")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [ANOWMetric]$current_metric_result = Get-AutomateNOWMetric -Id $Metric_simpleId
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWMetric failed to check if the Metric $Metric_id existed under Add-AutomateNOWResourceAnomaly due to [$Message]."
                Break
            }
            If ($current_metric_result.id.length -eq 0) {
                Write-Warning -Message "The Metric object that you specified $Metric_id does not seem to exist under Add-AutomateNOWResourceAnomaly"
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('resource', $Metric_id )
            $BodyMetaData.Add('resourceType', 'METRIC')
            If ($CheckProperty -eq 'CURRENT_VALUE') {
                $BodyMetaData.Add('statisticPeriod', 'P1h')
            }
            ElseIf ($CheckProperty.Length -gt 0) {
                $BodyMetaData.Add('statisticFunction', $CheckProperty)
                If ($StatisticPeriod -gt 0) {
                    # Note that the console ignores when this value is set to 0 and just sets it to null
                    $BodyMetaData.Add('statisticPeriod', $StatisticPeriod)
                }
                Else {
                    $BodyMetaData.Add('statisticPeriod', $null)
                }
            }
            $BodyMetaData.Add('value', $CheckValue )
            $BodyMetaData.Add('anomaly', $Anomaly_id )
            $BodyMetaData.Add('checkValueOperatorType', $CheckOperator)
            If ($MagnitudeType.Length -gt 0) {
                $BodyMetaData.Add('magnitudeCalculationType', $MagnitudeType)
            }
            If ($null -ne $Magnitude) {
                $BodyMetaData.Add('magnitude', $Magnitude)
            }
            $BodyMetaData.Add('_operationType', 'add')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_oldValues', '{}')
            $BodyMetaData.Add('_componentId', 'ResourceAnomalyEditForm')
            $BodyMetaData.Add('_dataSource', 'ResourceAnomalyDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $parameters.Add('command', $command)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Task_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            $Error.Clear()
            Try {
                [ANOWResourceAnomaly]$ResourceAnomaly = $results.response.data | Select-Object -First 1 -ExcludeProperty resource | Add-Member -MemberType NoteProperty -Name resource -Value $Metric
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the response into an [ANOWResourceAnomaly] object under Add-AutomateNOWResourceAnomaly due to [$Message]."
                Break
            }
            If ($Quiet -ne $true) {
                Return $ResourceAnomaly
            }
        }
    }
    End {

    }
}

#endregion

#Region - Resource List (Menu Specialty)

Function Get-AutomateNOWResourceList {
    <#
    .SYNOPSIS
    Gets the Resource List from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Resource List from an AutomateNOW! instance

    .PARAMETER Id
    Optional string parameter to limit the result to a single result by Id. This parameter cannot be combined with other parameters.

    .PARAMETER sortBy
    Optional string parameter to sort the results by (may not be used with the Id parameter). Valid choices are: 'id'*, 'tags', 'dateCreated', 'lastUpdated', 'createdBy', 'lastUpdatedBy', 'codeRepository'

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100. The console default hard limit is 10,000.

    .PARAMETER Folder
    Optional string to filter by a particular Folder

    .PARAMETER Tags
    Optional string array of Tags to filter by. Note that the 'containsAny' operator will be used.

    .OUTPUTS
    An array of one or more [ANOWResource] class objects

    .EXAMPLE
    Gets the first page of items in the Resource List

    Get-AutomateNOWResourceList

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This is a "menu specialty" function meaning that its purpose is to mimic one of the UI buttons. This function returns all types of Resource items. You should instead use the 9 respective Get Resource functions (e.g. Get-AutomateNOWStock)

    #>
    [OutputType([ANOWResource[]])]
    [Cmdletbinding( DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $True, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [string]$Id,
        [ValidateSet('id', 'tags', 'dateCreated', 'lastUpdated', 'createdBy', 'lastUpdatedBy', 'codeRepository')]
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$sortBy = 'id',
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$Descending,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$Folder,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string[]]$Tags
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 -or $Id.Length -gt 0) {
            If ( $_.Length -gt 0 ) {
                [string]$Id = $_
            }
            $BodyMetaData.'id' = $Id
            $BodyMetaData.'_operationId' = 'read'
            [string]$textMatchStyle = 'exactCase'
        }
        Else {
            $BodyMetaData.'_constructor' = 'AdvancedCriteria'
            $BodyMetaData.'operator' = 'and'
            [string]$textMatchStyle = 'substring'
            If ($Folder.Length -gt 0) {
                $BodyMetaData.'criteria1' = ('{"fieldName":"folder","operator":"equals","value":"' + $Folder + '"}')
            }
            If ($Tags.Count -gt 0) {
                If ($Tags.Count -gt 1) {
                    $Error.Clear()
                    Try {
                        [string]$TagString = $Tags | ConvertTo-Json -Compress
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "ConvertTo-Json failed to convert the provided tag names under Get-AutomateNOWResourceList due to [$Message]."
                        Break
                    }
                }
                Else {
                    [string]$TagString = $Tags
                }
                $BodyMetaData.'criteria2' = ('{"fieldName":"tags","operator":"containsAny","value":' + $TagString + '}')
            }
            $BodyMetaData.'_startRow' = $startRow
            $BodyMetaData.'_endRow' = $endRow
            If ($Descending -eq $true) {
                $BodyMetaData.'_sortBy' = '-' + $sortBy
            }
            Else {
                $BodyMetaData.'_sortBy' = $sortBy
            }
        }
        $BodyMetaData.'_textMatchStyle' = $textMatchStyle
        $BodyMetaData.'_operationType' = 'fetch'
        $BodyMetaData.'_componentId' = 'ResourceList'
        $BodyMetaData.'_dataSource' = 'ResourceDataSource'
        $BodyMetaData.'isc_metaDataPrefix' = '_'
        $BodyMetaData.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        [string]$command = ('/resource/read' + '?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.'Command' = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWResource[]]$Resources = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWResource] objects due to [$Message]."
            Break
        }
        If ($Resources.Count -gt 0) {
            Return $Resources
        }
    }
    End {

    }
}

#endregion

#Region - Result Mappings

Function Get-AutomateNOWResultMapping {
    <#
    .SYNOPSIS
    Gets the Result Mapping objects from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Result Mapping objects from an AutomateNOW! instance

    .PARAMETER Id
    Optional string containing the simple id of the Result Mapping to fetch or you can pipeline a series of simple id strings. You may not enter an array here.

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100. The console default hard limit is 10,000.

    .PARAMETER Folder
    Optional string to filter by a particular Folder

    .PARAMETER Tags
    Optional string array of Tags to filter by. Note that the 'containsAny' operator will be used.

    .INPUTS
    Accepts a string representing the simple id of the Result Mapping from the pipeline or individually (but not an array).

    .OUTPUTS
    An array of one or more [ANOWResultMapping] class objects

    .EXAMPLE
    Gets the first page of Result Mapping objects

    Get-AutomateNOWResultMapping

    .EXAMPLE
    Gets the first 500 Result Mapping objects

    Get-AutomateNOWResultMapping -startRow 0 -endRow 500

    .EXAMPLE
    Gets a single Result Mapping named 'ResultMapping1'

    Get-AutomateNOWResultMapping -Id 'ResultMapping1'

    .EXAMPLE
    Gets a series of Result Mapping objects through the pipeline

    'ResultMapping1', 'ResultMapping2' | Get-AutomateNOWResultMapping

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWResultMapping[]])]
    [Cmdletbinding(DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $True, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$Folder,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string[]]$Tags
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 -or $Id.Length -gt 0) {
            If ($_.Length -gt 0 ) {
                $Body.'id' = $_
            }
            Else {
                $Body.'id' = $Id
            }
            $Body.'_operationId' = 'read'
            [string]$textMatchStyle = 'exactCase'
        }
        Else {
            $Body.'operator' = 'and'
            $Body.'_constructor' = 'AdvancedCriteria'
            If ($Folder.Length -gt 0) {
                $Body.'criteria1' = ('{"fieldName":"folder","operator":"equals","value":"' + $Folder + '"}')
            }
            If ($Tags.Count -gt 0) {
                If ($Tags.Count -gt 1) {
                    $Error.Clear()
                    Try {
                        [string]$TagString = $Tags | ConvertTo-Json -Compress
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "ConvertTo-Json failed to convert the provided tag names under Get-AutomateNOWResultMapping due to [$Message]."
                        Break
                    }
                }
                Else {
                    [string]$TagString = $Tags
                }
                $Body.'criteria2' = ('{"fieldName":"tags","operator":"containsAny","value":' + $TagString + '}')
            }
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
            $Body.'_textMatchStyle' = 'substring'
            $Body.'_componentId' = 'ResultMappingList'
        }
        $Body.'_operationType' = 'fetch'
        $Body.'_textMatchStyle' = $textMatchStyle
        $Body.'_dataSource' = 'ResultMappingDataSource'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/resultMapping/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        [ANOWResultMapping[]]$ResultMappings = ForEach ($ResultMapping in $results.response.data) {
            If ($null -ne $ResultMapping.definition) {
                If ($ResultMapping.definition[0] -is [string]) {
                    Try {
                        $ResultMapping.definition = $ResultMapping.definition | ConvertFrom-Json -Depth 10
                        [ANOWResultMapping]$ResultMapping
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Failed to parse the response into a series of [ANOWResultMapping] under Get-AutomateNOWResultMapping objects due to [$Message]."
                        Break
                    }
                }
                Else {
                    $Error.Clear()
                    [ANOWResultMappingRule[]]$definitions = Try {
                        ForEach ($definition in $ResultMapping.definition) {
                            [ANOWResultMappingRule]$definition_placeholder = $definition
                            [ANOWResultMappingRule]$definition_placeholder
                        }
                    }
                    Catch {
                        [string]$definition_placeholder_display = $definition_placeholder | ConvertTo-Json -Compress
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Failed to parse the response definition [$definition_placeholder_display] into an [ANOWResultMappingRule] object under Get-AutomateNOWResultMappingRule due to [$Message]."
                        Break
                    }
                    $ResultMapping.definition = $definitions
                }
            }
            [ANOWResultMapping]$ResultMapping
        }
        If ($ResultMappings.Count -gt 0) {
            Return $ResultMappings
        }
    }
    End {

    }
}

Function Export-AutomateNOWResultMapping {
    <#
    .SYNOPSIS
    Exports the Result Mapping objects from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Result Mapping objects from an instance of AutomateNOW! to a local .csv file

    .PARAMETER ResultMapping
    Mandatory [ANOWResultMapping] object (Use Get-AutomateNOWResultMapping to retrieve them)

    .INPUTS
    ONLY [ANOWResultMapping] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWResultMapping] objects are exported to the local disk in CSV format

    .EXAMPLE
    Exports all of the Result Mapping objects (up to 100 by default)

    Get-AutomateNOWResultMapping | Export-AutomateNOWResultMapping

    .EXAMPLE
    Exports 1 Result Mapping by name

    Get-AutomateNOWResultMapping -Id 'result_mapping01' | Export-AutomateNOWResultMapping

    .EXAMPLE
    Exports a series of Result Mapping objects by the pipeline

    @( 'result_mapping01', 'result_mapping02' ) | Get-AutomateNOWResultMapping | Export-AutomateNOWResultMapping

    .NOTES
	You must present [ANOWResultMapping] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWResultMapping]$ResultMapping
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-ResultMappings-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWResultMapping]$ResultMapping = $_
        }
        $Error.Clear()
        Try {
            $ResultMapping | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWResultMapping] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function New-AutomateNOWResultMapping {
    <#
    .SYNOPSIS
    Creates a Result Mapping within an AutomateNOW! instance

    .DESCRIPTION
    Creates a Result Mapping within an AutomateNOW! instance and returns back the newly created [ANOWResultMapping] object

    .PARAMETER Id
    The intended name of the Result Mapping. For example: 'result_mapping1'. This value may not contain the domain in brackets.

    .PARAMETER Description
    Optional description of the Result Mapping (may not exceed 255 characters).

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new Result Mapping. Do not pass [ANOWTag] objects here.

    .PARAMETER Folder
    Optional name of the folder to place the Result Mapping into.

    .PARAMETER CodeRepository
    Optional name of the code repository to place the Result Mapping into.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWResultMapping.

    .OUTPUTS
    An [ANOWResultMapping] object representing the newly created Result Mapping

    .EXAMPLE
    New-AutomateNOWResultMapping

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The name (id) of the Result Mapping must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    #>
    [OutputType([ANOWResultMapping])]
    [Cmdletbinding()]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $true)]
        [string]$Id,
        [Parameter(Mandatory = $false, HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [string]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [boolean]$ResultMapping_exists = ($null -ne (Get-AutomateNOWResultMapping -Id $Id))
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWResultMapping failed to check if the Result Mapping [$Id] already existed due to [$Message]."
        Break
    }
    If ($ResultMapping_exists -eq $true) {
        [string]$current_domain = $anow_session.header.domain
        Write-Warning -Message "There is already a Result Mapping named [$Id] in [$current_domain]. Please check into this."
        Break
    }
    ## End warning ##
    [System.Collections.Specialized.OrderedDictionary]$ANOWResultMapping = [System.Collections.Specialized.OrderedDictionary]@{}
    $ANOWResultMapping.Add('id', $Id)
    If ($Description.Length -gt 0) {
        $ANOWResultMapping.Add('description', $Description)
    }
    If ($Tags.Count -gt 0) {
        [int32]$total_tags = $Tags.Count
        [int32]$current_tag = 1
        ForEach ($tag_id in $Tags) {
            $Error.Clear()
            Try {
                [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] running under New-AutomateNOWResultMapping due to [$message]"
                Break
            }
            If ($tag_object.simpleId.length -eq 0) {
                Throw "New-AutomateNOWResultMapping has detected that the tag [$tag_id] does not appear to exist. Please check again."
                Break
            }
            ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                [string]$tag_object_simpleId = $tag_object.simpleId
                Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                Break
            }
            [string]$tag_display = $tag_object | ConvertTo-Json -Compress
            Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
            [string]$tag_name_sequence = ('tags' + $current_tag)
            $ANOWResultMapping.Add($tag_name_sequence, $tag_id)
            $include_properties += $tag_name_sequence
            $current_tag++
        }
    }
    If ($Folder.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] existed under New-AutomateNOWResultMapping due to [$Message]"
            Break
        }
        If ($folder_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] under New-AutomateNOWResultMapping. Please check again."
            Break
        }
        [string]$folder_display = $folder_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding folder $folder_display to [ANOWResultMapping] [$Id]"
        $ANOWResultMapping.Add('folder', $Folder)
        $include_properties += 'folder'
    }
    If ($CodeRepository.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository] existed under New-AutomateNOWResultMapping due to [$Message]"
            Break
        }
        If ($code_repository_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository] under New-AutomateNOWResultMapping. Please check again."
            Break
        }
        [string]$code_repository_display = $code_repository_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding code repository $code_repository_display to [ANOWResultMapping] [$Id]"
        $ANOWResultMapping.Add('codeRepository', $CodeRepository)
        $include_properties += 'codeRepository'
    }
    [string]$BodyObject = ConvertTo-QueryString -InputObject $ANOWResultMapping -IncludeProperties id, description, tags, folder, codeRepository
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_operationType' = 'add'
    $BodyMetaData.'_oldValues' = '{}'
    $BodyMetaData.'_componentId' = 'ResultMappingCreateWindow_form'
    $BodyMetaData.'_dataSource' = 'ResultMappingDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$BodyMetaDataString = ConvertTo-QueryString -InputObject $BodyMetaData
    [string]$Body = ($BodyObject + '&' + $BodyMetaDataString)
    [string]$command = '/resultMapping/create'
    [hashtable]$parameters = @{}
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('Body', $Body)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWResultMapping]$ResultMapping = $results.response.data | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to create [ANOWResultMapping] object due to [$Message]."
        Break
    }
    If ($ResultMapping.id.Length -eq 0) {
        Write-Warning -Message "Somehow the newly created [ANOWResultMapping] ResultMapping is empty!"
        Break
    }
    If ($Quiet -ne $true) {
        Return $ResultMapping
    }
}

Function Copy-AutomateNOWResultMapping {
    <#
    .SYNOPSIS
    Copies a Result Mapping from an AutomateNOW! instance

    .DESCRIPTION
    Copies a Result Mapping from an AutomateNOW! instance. AutomateNOW object id can never be changed, but we can copy the object to a new id and it will include all of the items therein.

    .PARAMETER ResultMapping
    Mandatory [ANOWResultMapping] object to be copied.

    .PARAMETER NewId
    The name (Id) of the new ResultMapping. The new Id must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    .PARAMETER UnsetDescription
    Optional switch that will ensure that the newly created ResultMapping will not have a description set.

    .PARAMETER Description
    Optional description to set on the new ResultMapping object. If you do not set this, the new ResultMapping object will copy the Description of the source object.

    .PARAMETER UnsetFolder
    Optional switch that will ensure that the newly created ResultMapping will not have a Folder set.

    .PARAMETER Folder
    Optional description to set a different folder on the new ResultMapping object. If you do not set this, the new ResultMapping object will use the same Folder of the source object.

    .PARAMETER UnsetTags
    Optional switch that will ensure that the newly created ResultMapping will not have any Tags set.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the new ResultMapping object. If you do not set this, the new ResultMapping object will apply the same Tags of the source object.

    .PARAMETER Force
    Force the copy without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    ONLY [ANOWResultMapping] object is accepted. Pipeline support is intentionally unavailable.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Creates a copy of an ResultMapping and changes the description (multi-line format)
    $ResultMapping01 = Get-AutomateNOWResultMapping -Id 'ResultMapping_01'
    Copy-AutomateNOWResultMapping -ResultMapping $ResultMapping01 -NewId 'ResultMapping_01_production' -Description 'ResultMapping01 Production'

    .EXAMPLE
    Creates a copy of an ResultMapping that omits the description (one-liner format)
    Copy-AutomateNOWResultMapping -ResultMapping (Get-AutomateNOWResultMapping -Id 'ResultMapping_01') -NewId 'ResultMapping_01_production' -UnsetDescription -Tags 'Tag1', 'Tag2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWResultMapping]$ResultMapping,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot set the Tags and unset them at the same time. Please choose one or the other. Tags from the source object will be carried over to the new object if you do not specify any tag-related parameters."
            Break
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$ResultMapping_exists = ($null -ne (Get-AutomateNOWResultMapping -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWResultMapping failed to check if the Result Mapping [$NewId] already existed due to [$Message]."
            Break
        }
        If ($ResultMapping_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Result Mapping named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End warning ##
        [string]$command = '/resultMapping/copy'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            [string]$ResultMapping_oldId = $ResultMapping.id
            [string]$ResultMapping_simpleId = $ResultMapping.simpleId
            If ($ResultMapping_oldId -eq $NewId) {
                Write-Warning -Message "The new id cannot be the same as the old id."
                Break
            }
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Copy the Result Mapping $($ResultMapping_simpleId) to $($NewId)?")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                If ($UnsetFolder -eq $True) {
                    $BodyMetaData.'folder' = $Null
                }
                ElseIf ($Folder.Length -gt 0) {
                    $BodyMetaData.'folder' = $Folder
                }
                Else {
                    If ($ResultMapping.folder.Length -gt 0) {
                        $BodyMetaData.'folder' = $ResultMapping.folder
                    }
                }
                If ($Tags.Count -gt 0) {
                    [int32]$tag_count = 1
                    ForEach ($tag in $Tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
                ElseIf ($UnsetTags -eq $true) {
                    $BodyMetaData.'tags' = $Null
                }
                Else {
                    If ($ResultMapping.Tags -gt 0) {
                        [int32]$tag_count = 1
                        ForEach ($tag in $ResultMapping.tags) {
                            $BodyMetaData.('tags' + $tag_count ) = $tag
                            $tag_count++
                        }
                    }
                }
                $BodyMetaData.'oldId' = $ResultMapping_oldId
                $BodyMetaData.'domain' = $ResultMapping.domain
                $BodyMetaData.'id' = $NewId
                If ($UnsetDescription -ne $true) {
                    If ($Description.Length -gt 0) {
                        $BodyMetaData.'description' = $Description
                    }
                    Else {
                        $BodyMetaData.'description' = $ResultMapping.description
                    }
                }
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_operationId' = 'copy'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_dataSource' = 'ResultMappingDataSource'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties oldId, domain, NewId, description, folder, tags
                $parameters.Body = $Body
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ResultMapping_oldId] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                $Error.Clear()
                Try {
                    [ANOWResultMapping]$NewResultMapping = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to create copied [ANOWResultMapping] object [$NewId] due to [$Message]."
                    Break
                }
                If ($NewResultMapping.id.Length -eq 0) {
                    Write-Warning -Message "Somehow the newly created (copied) [ANOWResultMapping] object [$NewId] is empty!"
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $NewResultMapping
                }
            }
        }
    }
    End {

    }
}

Function Rename-AutomateNOWResultMapping {
    <#
    .SYNOPSIS
    Renames an Result Mapping on an AutomateNOW! instance

    .DESCRIPTION
    Performs a psuedo-rename operations of an Result Mapping from an AutomateNOW! instance by copying it first and then deleting the source. This function merely combines Copy-AutomateNOWResultMapping and Remove-AutomateNOWResultMapping therefore it is to be considered destructive.

    .PARAMETER ResultMapping
    An [ANOWResultMapping] object representing the Result Mapping to be renamed.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the Result Mapping. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER Force
    Force the renaming without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly renamed object.

    .INPUTS
    ONLY [ANOWResultMapping] objects are accepted. There is intentionally no support for the pipeline.

    .OUTPUTS
    The newly renamed [ANOWResultMapping] object will be returned.

    .EXAMPLE
    $ResultMapping = Get-AutomateNOWResultMapping -Id 'ResultMapping01'
    Rename-AutomateNOWResultMapping -ResultMapping $ResultMapping -NewId 'ResultMapping_01'

    .EXAMPLE
    Rename-AutomateNOWResultMapping -ResultMapping (Get-AutomateNOWResultMapping -Id 'ResultMapping01') -NewId 'ResultMapping_01'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    When renaming, you may only specify a different Id (name).

    This action will be blocked if any existing referrals are found on the object.
    #>
    [OutputType([ANOWResultMapping])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWResultMapping]$ResultMapping,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin standard warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$new_ResultMapping_exists = ($null -ne (Get-AutomateNOWResultMapping -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWResultMapping failed to check if the Result Mapping [$NewId] already existed due to [$Message]."
            Break
        }
        If ($new_ResultMapping_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Result Mapping named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        #[string]$ResultMapping_id = $ResultMapping.id
        [string]$ResultMapping_id = $ResultMapping.simpleId
        $Error.Clear()
        Try {
            [boolean]$old_ResultMapping_exists = ($null -ne (Get-AutomateNOWResultMapping -Id $ResultMapping_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWResultMapping failed to check if the Result Mapping [$ResultMapping_id] already existed due to [$Message]."
            Break
        }
        If ($old_ResultMapping_exists -eq $false) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not a Result Mapping named [$ResultMapping_id] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End standard warning ##
        ## Begin referrals warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [int32]$referrals_count = Find-AutomateNOWObjectReferral -ResultMapping $ResultMapping -Count | Select-Object -Expandproperty referrals
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Find-AutomateNOWObjectReferral failed to extract the referrals on Result Mapping [$ResultMapping_id] due to [$Message]."
            Break
        }
        If ($referrals_count -gt 0) {
            Write-Warning -Message "Unfortunately, you cannot rename a Result Mapping that has referrals. This is because the rename is not actually renaming but copying anew and deleting the old. Please, use the Find-AutomateNOWObjectReferral function to identify referrals and remove them."
            Break
        }
        Else {
            Write-Verbose -Message "The Result Mapping [$ResultMapping_id] does not have any referrals. It is safe to proceed."
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ResultMapping_id)")) -eq $true) {
                $Error.Clear()
                Try {
                    [ANOWResultMapping]$new_ResultMapping = Copy-AutomateNOWResultMapping -ResultMapping $ResultMapping -NewId $NewId -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Copy-AutomateNOWResultMapping failed to create a new Result Mapping [$NewId] as Part 1 of the renaming process due to [$Message]."
                    Break
                }
                If ($new_ResultMapping.simpleId -eq $NewId) {
                    Write-Verbose -Message "Part 1: Result Mapping [$ResultMapping_id] successfully copied to [$NewId]"
                }
                Else {
                    Write-Warning -Message "Somehow the first phase (Copy-AutomateNOWResultMapping) failed. Please look into this."
                    Break
                }
                $Error.Clear()
                Try {
                    Remove-AutomateNOWResultMapping -ResultMapping $ResultMapping -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Remove-AutomateNOWResultMapping failed to remove [$ResultMapping_id] as Part 2 of the renaming process due to [$Message]."
                    Break
                }
                Write-Verbose -Message "Part 2: Result Mapping [$ResultMapping_id] removed"
                Write-Verbose -Message "Result Mapping [$ResultMapping_id] successfully renamed to [$NewId]"
                If ($Quiet -ne $true) {
                    Return $new_ResultMapping
                }
            }
        }
        Else {
            Write-Warning -Message "No action was taken because either the source object didn't exist or the new object already existed"
        }
    }
    End {
    }
}

Function Remove-AutomateNOWResultMapping {
    <#
    .SYNOPSIS
    Removes a Result Mapping from an AutomateNOW! instance

    .DESCRIPTION
    Removes a Result Mapping from an AutomateNOW! instance

    .PARAMETER ResultMapping
    An [ANOWResultMapping] object representing the Result Mapping to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWResultMapping] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Remove a single Result Mapping by name

    Get-AutomateNOWResultMapping -Id 'result_mapping01' | Remove-AutomateNOWResultMapping

    .EXAMPLE
    Removes a series of Result Mapping objects via input from the pipeline

    @( 'result_mapping01', 'result_mapping02', 'result_mapping03') | Remove-AutomateNOWResultMapping

    .EXAMPLE
    Forcefully removes all Result Mapping objects that reside within a particular folder

    Get-AutomateNOWResultMapping | Where-Object { $_.folder -eq 'folder_01'} | Remove-AutomateNOWResultMapping -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWResultMapping]$ResultMapping,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/resultMapping/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWResultMapping]$ResultMapping = $_
        }
        [string]$ResultMapping_id = $ResultMapping.id
        If ($ResultMapping_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ResultMapping_id)")) -eq $true) {
            [string]$oldvalues = $ResultMapping.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $ResultMapping_id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'ResultMappingList'
            $BodyMetaData.'_dataSource' = 'ResultMappingDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ResultMapping_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Result Mapping [$ResultMapping_id] successfully removed"
        }
    }
    End {

    }
}

#endregion

#Region - Result Mapping Rules

Function Add-AutomateNOWResultMappingRule {
    <#
    .SYNOPSIS
    Adds a Rule to a Result Mapping on an AutomateNOW! instance

    .DESCRIPTION
    Adds a Rule to a Result Mapping on an AutomateNOW! instance

    .PARAMETER ResultMapping
    Mandatory [ANOWResultMapping] object (Use Get-AutomateNOWResultMapping to retrieve them). This is the object you created with New-AutomateNOWResultMapping.

    .PARAMETER ResultMappingRule
    Mandatory [ANOWResultMappingRule] object (use New-AutomateNOWResultMappingRule to create them).

    .PARAMETER Quiet
    Switch parameter to silence the output from a successful update

    .PARAMETER Force
    Force the addition of the object without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWResultMapping] objects are accepted (including from the pipeline).

    .OUTPUTS
    The updated [ANOWResultMapping] object will be returned.

    .EXAMPLE
    Quietly creates and adds two Rules to an existing Result Mapping object named 'result_mapping1' (multi-line format)

    $criteria1 = New-AutomateNOWResultMappingRuleConditionCriteria -operatorNumber 'EQ_NUM' -FieldName 'statusCode' -value '1'
    $criteria2 = New-AutomateNOWResultMappingRuleConditionCriteria -operatorNumber 'EQ_NUM' -FieldName 'statusCode' -value '2'
    $criteria3 = New-AutomateNOWResultMappingRuleConditionCriteria -operatorNumber 'EQ_NUM' -FieldName 'statusCode' -value '3'
    $criteria4 = New-AutomateNOWResultMappingRuleConditionCriteria -operatorNumber 'EQ_NUM' -FieldName 'statusCode' -value '4'
    $condition1 = @($criteria1, $criteria2) | New-AutomateNOWResultMappingRuleCondition -operator 'AllMatch'
    $condition2 = @($criteria3, $criteria4) | New-AutomateNOWResultMappingRuleCondition -operator 'AllMatch'
    $rule1 = New-AutomateNOWResultMappingRule -ProcessingStatus 'COMPLETED' -StatusCode 0 -StatusMessage 'SUCCESS' -Condition $condition1
    $rule2 = New-AutomateNOWResultMappingRule -ProcessingStatus 'FAILED' -StatusCode 1 -StatusMessage 'FAILED' -Condition $condition2
    $result_mapping = Get-AutomateNOWResultMapping -Id 'result_mapping1'
    @($rule1, $rule2) | Add-AutomateNOWResultMappingRule -ResultMapping $result_mapping -Quiet

    .EXAMPLE
    Quietly creates and adds two Rules to an existing Result Mapping object named 'result_mapping1' (one-liner format)

    @((New-AutomateNOWResultMappingRule -ProcessingStatus 'COMPLETED' -StatusCode 0 -StatusMessage 'SUCCESS' -Condition (@((New-AutomateNOWResultMappingRuleConditionCriteria -operatorNumber 'EQ_NUM' -FieldName 'statusCode' -value '1'), (New-AutomateNOWResultMappingRuleConditionCriteria -operatorNumber 'EQ_NUM' -FieldName 'statusCode' -value '2')) | New-AutomateNOWResultMappingRuleCondition -operator 'AllMatch')), (New-AutomateNOWResultMappingRule -ProcessingStatus 'FAILED' -StatusCode 1 -StatusMessage 'FAILED' -Condition (@((New-AutomateNOWResultMappingRuleConditionCriteria -operatorNumber 'EQ_NUM' -FieldName 'statusCode' -value '3'), (New-AutomateNOWResultMappingRuleConditionCriteria -operatorNumber 'EQ_NUM' -FieldName 'statusCode' -value '4')) | New-AutomateNOWResultMappingRuleCondition -operator 'AllMatch'))) | Add-AutomateNOWResultMappingRule -ResultMapping (Get-AutomateNOWResultMapping -Id 'result_mapping1') -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This capability should be considered limited. There are complex configurations of criteria and conditions which may not be supported. Avoid the "or" operators for now to avoid complexity.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWResultMapping]$ResultMapping,
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWResultMappingRule]$ResultMappingRule,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
        [PSCustomObject]$ResultMappingRuleArray = @()
        [string]$command = '/resultMapping/update'
    }
    Process {
        If ($_.Length -eq 0) {
            [PSCustomObject[]]$ResultMappingRuleArray += $ResultMappingRule
        }
        Else {
            [PSCustomObject[]]$ResultMappingRuleArray += $_
        }
    }
    End {
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        [string]$ResultMapping_id = $ResultMapping.simpleId
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Add the Result Mapping Rule to $($ResultMapping_id)?")) -eq $true) {
            $Error.Clear()
            Try {
                [ANOWResultMapping]$current_result = Get-AutomateNOWResultMapping -Id $ResultMapping_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWResultMapping failed to check if the Result Mapping [$ResultMapping_id] existed under Add-AutomateNOWResultMappingRule due to [$Message]."
                Break
            }
            If ($current_result.id.length -eq 0) {
                Write-Warning -Message "The Result Mapping object that you specified [$ResultMapping_id] does not seem to exist under Add-AutomateNOWResultMappingRule"
                Break
            }
            ## End warning ##
            If ($ResultMapping.definition -is [ANOWResultMappingRule[]]) {
                $ResultMappingRuleArray += $ResultMapping.definition
            }
            $Error.Clear()
            Try {
                [string]$ConvertedResultMappingRuleArray = $ResultMappingRuleArray | ConvertTo-Json -Depth 10 -Compress
                If ($ConvertedResultMappingRuleArray[0] -ne '[') {
                    [string]$ResultMappingArrayFormatted = ('[' + $ConvertedResultMappingRuleArray + ']')
                }
                Else {
                    [string]$ResultMappingArrayFormatted = $ResultMappingRuleArray | ConvertTo-Json -Depth 10 -Compress
                }
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "ConvertTo-Json failed to convert the array of Result Mapping rules due to [$Message]."
                Break
            }
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $ResultMapping_id )
            $BodyMetaData.Add('definition', $ResultMappingArrayFormatted )
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_oldValues', $ResultMapping.CreateOldValues())
            $BodyMetaData.Add('_componentId', 'ResultMappingEditForm')
            $BodyMetaData.Add('_dataSource', 'ResultMappingDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $parameters.Add('command', $command)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Task_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            $Error.Clear()
            [ANOWResultMappingRule[]]$definitions = Try {
                ForEach ($definition in $results.response.data.definition) {
                    [ANOWResultMappingRule]$definition
                }
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the response into an [ANOWResultMapping] object under Add-AutomateNOWResultMappingRule due to [$Message]."
                Break
            }
            [PSCustomObject]$temp_results = $results.response.data | Select-Object -ExcludeProperty definition
            $temp_results | Add-Member -MemberType NoteProperty -Name definition -Value $definitions -TypeName ANOWResultMappingRule
            [ANOWResultMapping]$UpdatedResultMapping = $temp_results
            If ($Quiet -ne $true) {
                Return $UpdatedResultMapping
            }
        }
    }
}

Function Remove-AutomateNOWResultMappingRule {
    <#
    .SYNOPSIS
    Removes a Rule to a Result Mapping on an AutomateNOW! instance

    .DESCRIPTION
    Removes a Rule to a Result Mapping on an AutomateNOW! instance

    .PARAMETER ResultMapping
    Mandatory [ANOWResultMapping] object. Use Get-AutomateNOWResultMapping to retrieve one.

    .PARAMETER ResultMappingRule
    Mandatory [ANOWResultMappingRule] object. Use (Get-AutomateNOWResultMapping | Select-Object -ExpandProperty definition) to retrieve them.

    .PARAMETER Quiet
    Switch parameter to silence the output from a successful update

    .PARAMETER Force
    Force the addition of the object without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    One [ANOWResultMapping] object and one or more [ANOWResultMappingRule] objects are accepted.

    .OUTPUTS
    The updated [ANOWResultMapping] object will be returned.

    .EXAMPLE
    Removes the first Result Mapping rule with a processingStatus of COMPLETED, a fieldName of exitCode and a value of 2 from a Result Mapping named 'ResultMapping1'

    $ResultMapping = Get-AutomateNOWResultMapping -Id 'ResultMapping1'
    $ResultMappingRuleToRemove = $ResultMapping | Select-Object -ExpandProperty definition | Where-Object { $_.processingStatus -eq 'COMPLETED' -and $_.condition.criteria.fieldName -eq 'exitCode' -and $_.condition.criteria.value -eq "2" } | Select-Object -First 1
    $ResultMappingRuleToRemove | Remove-AutomateNOWResultMappingRule -ResultMapping $ResultMapping

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWResultMapping]$ResultMapping,
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWResultMappingRule]$ResultMappingRule,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
        [string]$ResultMappingId = $ResultMapping.id
        [int32]$OriginalResultMappingRulesCount = $ResultMapping.definition.Count
        If ($OriginalResultMappingRulesCount -eq 0) {
            Write-Warning -Message "There are no rules inside of this Result Mapping. Please check again."
            Break
        }
        Else {
            Write-Verbose -Message "[$ResultMappingId] originally contained [$OriginalResultMappingRulesCount] rules"
        }
        $Error.Clear()
        Try {
            [System.Collections.ArrayList]$UpdatedResultMappingRules = $ResultMapping.definition.Clone()
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to make a clone of the Result Mapping Rules (under Remove-AutomateNOWResultMappingRule) due to [$Message]."
            Break
        }
        [string]$command = '/resultMapping/update'
    }
    Process {
        If ($_.processingStatus.Length -gt 0) {
            [ANOWResultMappingRule]$ResultMappingRule = $_
        }
        $Error.Clear()
        Try {
            [int32]$RuleLocation = $UpdatedResultMappingRules.IndexOf($ResultMappingRule)
            $UpdatedResultMappingRules.RemoveAt($RuleLocation)
        }
        Catch {
            [string]$Message = $_.Exception.Message
            [string]$ResultMappingRuleJson = $ResultMappingRule | ConvertTo-Json -Compress
            Write-Warning -Message "Failed to locate (or remove) the submitted Result Mapping Rule ($ResultMappingRuleJson) within the Result Mapping (under Remove-AutomateNOWResultMappingRule) due to [$Message]."
            Break
        }
    }
    End {
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        [string]$ResultMapping_id = $ResultMapping.simpleId
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Remove the Result Mapping Rule from $($ResultMapping_id)?")) -eq $true) {
            $Error.Clear()
            Try {
                [ANOWResultMapping]$current_result = Get-AutomateNOWResultMapping -Id $ResultMapping_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWResultMapping failed to check if the Result Mapping [$ResultMapping_id] existed under Remove-AutomateNOWResultMappingRule due to [$Message]."
                Break
            }
            If ($current_result.id.length -eq 0) {
                Write-Warning -Message "The Result Mapping object that you specified [$ResultMapping_id] does not seem to exist under Remove-AutomateNOWResultMappingRule"
                Break
            }
            ## End warning ##
            $Error.Clear()
            Try {
                [string]$ConvertedResultMappingRuleArray = $UpdatedResultMappingRules | ConvertTo-Json -Depth 10 -Compress
                If ($ConvertedResultMappingRuleArray[0] -ne '[') {
                    [string]$ResultMappingArrayFormatted = ('[' + $ConvertedResultMappingRuleArray + ']')
                }
                Else {
                    [string]$ResultMappingArrayFormatted = $UpdatedResultMappingRules | ConvertTo-Json -Depth 10 -Compress
                }
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "ConvertTo-Json failed to convert the array of Result Mapping rules under Remove-AutomateNOWResultMappingRule due to [$Message]."
                Break
            }
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $ResultMapping_id )
            $BodyMetaData.Add('definition', $ResultMappingArrayFormatted )
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_oldValues', $ResultMapping.CreateOldValues())
            $BodyMetaData.Add('_componentId', 'ResultMappingEditForm')
            $BodyMetaData.Add('_dataSource', 'ResultMappingDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $parameters.Add('command', $command)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Task_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            If ($Quiet -ne $true) {
                $Error.Clear()
                [ANOWResultMappingRule[]]$definitions = Try {
                    ForEach ($definition in $results.response.data.definition) {
                        [ANOWResultMappingRule]$definition
                    }
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to parse the response into [ANOWResultMappingRule] objects under Remove-AutomateNOWResultMappingRule due to [$Message]."
                    Break
                }
                [PSCustomObject]$temp_results = $results.response.data | Select-Object -ExcludeProperty definition
                $temp_results | Add-Member -MemberType NoteProperty -Name definition -Value $definitions -TypeName ANOWResultMappingRule
                [ANOWResultMapping]$UpdatedResultMapping = $temp_results
                Return $UpdatedResultMapping
            }
        }
    }
}

Function Pop-AutomateNOWResultMappingRule {
    <#
    .SYNOPSIS
    Moves (pops) a Result Mapping Rule to the bottom of the stack within a Result Mapping on an AutomateNOW! instance

    .DESCRIPTION
    Moves (pops) a Result Mapping Rule to the bottom of the stack within a Result Mapping on an AutomateNOW! instance

    .PARAMETER ResultMapping
    Mandatory [ANOWResultMapping] object. Use Get-AutomateNOWResultMapping to retrieve one.

    .PARAMETER ResultMappingRule
    Mandatory [ANOWResultMappingRule] object. Use (Get-AutomateNOWResultMapping | Select-Object -ExpandProperty definition) to retrieve them.

    .PARAMETER Quiet
    Switch parameter to silence the output from a successful update

    .PARAMETER Force
    Force the update of the object without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    One [ANOWResultMapping] object and one [ANOWResultMappingRule] object is accepted.

    .OUTPUTS
    The updated [ANOWResultMapping] object will be returned.

    .EXAMPLE
    Moves the first Result Mapping rule with a processingStatus of COMPLETED, a fieldName of exitCode and a value of 2 to the bottom of the stack within a Result Mapping named 'ResultMapping1'

    $ResultMapping = Get-AutomateNOWResultMapping -Id 'ResultMapping1'
    $ResultMappingRuleToRemove = $ResultMapping | Select-Object -ExpandProperty definition | Where-Object { $_.processingStatus -eq 'FAILED' -and $_.condition.criteria.fieldName -eq 'exitCode' -and $_.condition.criteria.value -eq -1 } | Select-Object -First 1
    Pop-AutomateNOWResultMappingRule -ResultMapping $ResultMapping -ResultMappingRule $ResultMappingRuleToRemove

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWResultMapping]$ResultMapping,
        [Parameter(Mandatory = $true)]
        [ANOWResultMappingRule]$ResultMappingRule,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    [hashtable]$parameters = @{}
    $parameters.Add('Method', 'POST')
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$ResultMappingId = $ResultMapping.id
    [int32]$OriginalResultMappingRulesCount = $ResultMapping.definition.Count
    If ($OriginalResultMappingRulesCount -eq 0) {
        Write-Warning -Message "There are no rules inside of this Result Mapping. Please check again."
        Break
    }
    Else {
        Write-Verbose -Message "[$ResultMappingId] originally contained [$OriginalResultMappingRulesCount] rules"
    }
    $Error.Clear()
    Try {
        [System.Collections.ArrayList]$UpdatedResultMappingRules = $ResultMapping.definition.Clone()
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to make a clone of the Result Mapping Rules (under Pop-AutomateNOWResultMappingRule) due to [$Message]."
        Break
    }
    [string]$command = '/resultMapping/update'
    If ($_.processingStatus.Length -gt 0) {
        [ANOWResultMappingRule]$ResultMappingRule = $_
    }
    $Error.Clear()
    Try {
        [int32]$RuleLocation = $UpdatedResultMappingRules.IndexOf($ResultMappingRule)
        $UpdatedResultMappingRules.RemoveAt($RuleLocation)
        $UpdatedResultMappingRules.Add($ResultMappingRule)
    }
    Catch {
        [string]$Message = $_.Exception.Message
        [string]$ResultMappingRuleJson = $ResultMappingRule | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Failed to move the submitted Result Mapping Rule ($ResultMappingRuleJson) within the Result Mapping (under Pop-AutomateNOWResultMappingRule) due to [$Message]."
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    [string]$ResultMapping_id = $ResultMapping.simpleId
    If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Move the Result Mapping Rule from $($ResultMapping_id) to the bottom of the stack?")) -eq $true) {
        $Error.Clear()
        Try {
            [ANOWResultMapping]$current_result = Get-AutomateNOWResultMapping -Id $ResultMapping_id
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWResultMapping failed to check if the Result Mapping [$ResultMapping_id] existed under Pop-AutomateNOWResultMappingRule due to [$Message]."
            Break
        }
        If ($current_result.id.length -eq 0) {
            Write-Warning -Message "The Result Mapping object that you specified [$ResultMapping_id] does not seem to exist under Pop-AutomateNOWResultMappingRule"
            Break
        }
        ## End warning ##
        $Error.Clear()
        Try {
            [string]$ConvertedResultMappingRuleArray = $UpdatedResultMappingRules | ConvertTo-Json -Depth 10 -Compress
            If ($ConvertedResultMappingRuleArray[0] -ne '[') {
                [string]$ResultMappingArrayFormatted = ('[' + $ConvertedResultMappingRuleArray + ']')
            }
            Else {
                [string]$ResultMappingArrayFormatted = $UpdatedResultMappingRules | ConvertTo-Json -Depth 10 -Compress
            }
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "ConvertTo-Json failed to convert the array of Result Mapping rules under Pop-AutomateNOWResultMappingRule due to [$Message]."
            Break
        }
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        $BodyMetaData.Add('id', $ResultMapping_id )
        $BodyMetaData.Add('definition', $ResultMappingArrayFormatted )
        $BodyMetaData.Add('_operationType', 'update')
        $BodyMetaData.Add('_textMatchStyle', 'exact')
        $BodyMetaData.Add('_oldValues', $ResultMapping.CreateOldValues())
        $BodyMetaData.Add('_componentId', 'ResultMappingEditForm')
        $BodyMetaData.Add('_dataSource', 'ResultMappingDataSource')
        $BodyMetaData.Add('isc_metaDataPrefix', '_')
        $BodyMetaData.Add('isc_dataFormat', 'json')
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        If ($null -eq $parameters.Body) {
            $parameters.Add('Body', $Body)
        }
        Else {
            $parameters.Body = $Body
        }
        $parameters.Add('command', $command)
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Task_id] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        If ($Quiet -ne $true) {
            $Error.Clear()
            [ANOWResultMappingRule[]]$definitions = Try {
                ForEach ($definition in $results.response.data.definition) {
                    [ANOWResultMappingRule]$definition
                }
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the response into [ANOWResultMappingRule] objects under Pop-AutomateNOWResultMappingRule due to [$Message]."
                Break
            }
            [PSCustomObject]$temp_results = $results.response.data | Select-Object -ExcludeProperty definition
            $temp_results | Add-Member -MemberType NoteProperty -Name definition -Value $definitions -TypeName ANOWResultMappingRule
            [ANOWResultMapping]$UpdatedResultMapping = $temp_results
            Return $UpdatedResultMapping
        }
    }
}

Function Push-AutomateNOWResultMappingRule {
    <#
    .SYNOPSIS
    Moves (pushes) a Result Mapping Rule to the top of the stack within a Result Mapping on an AutomateNOW! instance

    .DESCRIPTION
    Moves (pushes) a Result Mapping Rule to the top of the stack within a Result Mapping on an AutomateNOW! instance

    .PARAMETER ResultMapping
    Mandatory [ANOWResultMapping] object. Use Get-AutomateNOWResultMapping to retrieve one.

    .PARAMETER ResultMappingRule
    Mandatory [ANOWResultMappingRule] object. Use (Get-AutomateNOWResultMapping | Select-Object -ExpandProperty definition) to retrieve them.

    .PARAMETER Quiet
    Switch parameter to silence the output from a successful update

    .PARAMETER Force
    Force the update of the object without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    One [ANOWResultMapping] object and one [ANOWResultMappingRule] object is accepted.

    .OUTPUTS
    The updated [ANOWResultMapping] object will be returned.

    .EXAMPLE
    Moves the first Result Mapping rule with a processingStatus of COMPLETED, a fieldName of exitCode and a value of 2 to the top of the stack within a Result Mapping named 'ResultMapping1'

    $ResultMapping = Get-AutomateNOWResultMapping -Id 'ResultMapping1'
    $ResultMappingRuleToRemove = $ResultMapping | Select-Object -ExpandProperty definition | Where-Object { $_.processingStatus -eq 'FAILED' -and $_.condition.criteria.fieldName -eq 'exitCode' -and $_.condition.criteria.value -eq -1 } | Select-Object -First 1
    Push-AutomateNOWResultMappingRule -ResultMapping $ResultMapping -ResultMappingRule $ResultMappingRuleToRemove

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWResultMapping]$ResultMapping,
        [Parameter(Mandatory = $true)]
        [ANOWResultMappingRule]$ResultMappingRule,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    [hashtable]$parameters = @{}
    $parameters.Add('Method', 'POST')
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$ResultMappingId = $ResultMapping.id
    [int32]$OriginalResultMappingRulesCount = $ResultMapping.definition.Count
    If ($OriginalResultMappingRulesCount -eq 0) {
        Write-Warning -Message "There are no rules inside of this Result Mapping. Please check again."
        Break
    }
    Else {
        Write-Verbose -Message "[$ResultMappingId] originally contained [$OriginalResultMappingRulesCount] rules"
    }
    $Error.Clear()
    Try {
        [System.Collections.ArrayList]$UpdatedResultMappingRules = $ResultMapping.definition.Clone()
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to make a clone of the Result Mapping Rules (under Push-AutomateNOWResultMappingRule) due to [$Message]."
        Break
    }
    [string]$command = '/resultMapping/update'
    $Error.Clear()
    Try {
        [int32]$RuleLocation = $UpdatedResultMappingRules.IndexOf($ResultMappingRule)
        $UpdatedResultMappingRules.RemoveAt($RuleLocation)
        $UpdatedResultMappingRules.Insert(0, $ResultMappingRule)
    }
    Catch {
        [string]$Message = $_.Exception.Message
        [string]$ResultMappingRuleJson = $ResultMappingRule | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Failed to move the submitted Result Mapping Rule ($ResultMappingRuleJson) within the Result Mapping (under Push-AutomateNOWResultMappingRule) due to [$Message]."
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    [string]$ResultMapping_id = $ResultMapping.simpleId
    If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Move the Result Mapping Rule from $($ResultMapping_id) to the bottom of the stack?")) -eq $true) {
        $Error.Clear()
        Try {
            [ANOWResultMapping]$current_result = Get-AutomateNOWResultMapping -Id $ResultMapping_id
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWResultMapping failed to check if the Result Mapping [$ResultMapping_id] existed under Push-AutomateNOWResultMappingRule due to [$Message]."
            Break
        }
        If ($current_result.id.length -eq 0) {
            Write-Warning -Message "The Result Mapping object that you specified [$ResultMapping_id] does not seem to exist under Push-AutomateNOWResultMappingRule"
            Break
        }
        ## End warning ##
        $Error.Clear()
        Try {
            [string]$ConvertedResultMappingRuleArray = $UpdatedResultMappingRules | ConvertTo-Json -Depth 10 -Compress
            If ($ConvertedResultMappingRuleArray[0] -ne '[') {
                [string]$ResultMappingArrayFormatted = ('[' + $ConvertedResultMappingRuleArray + ']')
            }
            Else {
                [string]$ResultMappingArrayFormatted = $UpdatedResultMappingRules | ConvertTo-Json -Depth 10 -Compress
            }
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "ConvertTo-Json failed to convert the array of Result Mapping rules under Push-AutomateNOWResultMappingRule due to [$Message]."
            Break
        }
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        $BodyMetaData.Add('id', $ResultMapping_id )
        $BodyMetaData.Add('definition', $ResultMappingArrayFormatted )
        $BodyMetaData.Add('_operationType', 'update')
        $BodyMetaData.Add('_textMatchStyle', 'exact')
        $BodyMetaData.Add('_oldValues', $ResultMapping.CreateOldValues())
        $BodyMetaData.Add('_componentId', 'ResultMappingEditForm')
        $BodyMetaData.Add('_dataSource', 'ResultMappingDataSource')
        $BodyMetaData.Add('isc_metaDataPrefix', '_')
        $BodyMetaData.Add('isc_dataFormat', 'json')
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        If ($null -eq $parameters.Body) {
            $parameters.Add('Body', $Body)
        }
        Else {
            $parameters.Body = $Body
        }
        $parameters.Add('command', $command)
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Task_id] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        If ($Quiet -ne $true) {
            $Error.Clear()
            [ANOWResultMappingRule[]]$definitions = Try {
                ForEach ($definition in $results.response.data.definition) {
                    [ANOWResultMappingRule]$definition
                }
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the response into [ANOWResultMappingRule] objects under Push-AutomateNOWResultMappingRule due to [$Message]."
                Break
            }
            [PSCustomObject]$temp_results = $results.response.data | Select-Object -ExcludeProperty definition
            $temp_results | Add-Member -MemberType NoteProperty -Name definition -Value $definitions -TypeName ANOWResultMappingRule
            [ANOWResultMapping]$UpdatedResultMapping = $temp_results
            Return $UpdatedResultMapping
        }
    }
}

Function New-AutomateNOWResultMappingRuleConditionCriteria {
    <#

    .SYNOPSIS
    Creates a Result Mapping Rule Condition Criteria object

    .DESCRIPTION
    Creates a Result Mapping Rule Condition Criteria object for use with Result Mapping Rule Condition objects

    .PARAMETER operatorText
    The name of the operator for text based criteria

    .PARAMETER operatorNumber
    The name of the operator for numeric based criteria

    .PARAMETER operatorDate
    The name of the operator for time based criteria

    .PARAMETER fieldName
    The name of the field to which the criteria is applied against. Valid values are: 'cycleActualCounter', 'duration', 'endTime', 'exitCode', 'exitMessage', 'id', 'name', 'owner', 'parentId', 'parentName', 'parentTemplate', 'processingStatus', 'processingTimestamp', 'rootId', 'rootName', 'rootTemplate', 'serviceStatus', 'skip', 'startTime', 'statusCode', 'statusMessage', 'template', 'timesRestarted'

    .PARAMETER value
    The value of the criteria.

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWResultMappingRuleConditionCriteria.

    .OUTPUTS
    An [ANOWResultMappingRuleConditionCriteria] object representing the newly created Result Mapping Rule Condition Criteria object

    .EXAMPLE
    New-AutomateNOWResultMappingRuleConditionCriteria -operatorNumber 'EQ_NUM' -FieldName 'statusCode' -value '1'

    .NOTES
    This function is intended to be used in conjunction with New-AutomateNOWResultMappingRuleCondition

    Below is a table of the criteria operators based on their type (i.e. Text, Number or Date)

    "Text"
    ------
    'EQ' = '=='
    'NE' = '!='
    'LT_TEXT' = '<'
    'GT_TEXT' = '>'
    'LE_TEXT' = '<='
    'GE_TEXT' = '>='
    'SW' = 'starts with'
    'NSW' = 'does not start with'
    'EW' = 'ends with'
    'NEW' = 'does not end with'
    'CONTAINS' = 'contains'
    'NOT_CONTAIN' = 'does not contain'
    'REGEXP' = 'matches'
    'NOT_REGEXP' = 'does not match'
    'IS_NULL' = 'is empty'
    'IS_NOT_NULL' = 'is not empty'

    "Number"
    --------
    'EQ_NUM' = '=='
    'NE_NUM' = '!='
    'LT_NUM' = '<'
    'GT_NUM' = '>'
    'LE_NUM' = '<='
    'GE_NUM' = '>='

    "Date"
    ------
    'EQ_DATE' = '=='
    'NE_DATE' = '!='
    'LT_DATE' = '<'
    'GT_DATE' = '>'
    'LE_DATE' = '<='
    'GE_DATE' = '>='
    'CAL' = 'in calendar'
    'NOT_IN_CAL' = 'not in calendar'

    #>
    [OutputType([ANOWResultMappingRuleConditionCriteria])]
    [CmdletBinding()]
    Param(
        [ValidateSet('EQ', 'NE', 'LT_TEXT', 'GT_TEXT', 'LE_TEXT', 'GE_TEXT', 'SW', 'NSW', 'EW', 'NEW', 'CONTAINS', 'NOT_CONTAIN', 'REGEXP', 'NOT_REGEXP', 'IS_NULL', 'IS_NOT_NULL', ignoreCase = $false)]
        [Parameter(Mandatory = $true, ParameterSetName = 'Text')]
        [string]$operatorText,
        [ValidateSet('EQ_NUM', 'NE_NUM', 'LT_NUM', 'GT_NUM', 'LE_NUM', 'GE_NUM', ignoreCase = $false)]
        [Parameter(Mandatory = $true, ParameterSetName = 'Number')]
        [string]$operatorNumber,
        [ValidateSet('EQ_DATE', 'NE_DATE', 'LT_DATE', 'GT_DATE', 'LE_DATE', 'GE_DATE', 'CAL', 'NOT_IN_CAL', ignoreCase = $false)]
        [Parameter(Mandatory = $true, ParameterSetName = 'Date')]
        [string]$operatorDate,
        [ValidateSet('cycleActualCounter', 'duration', 'endTime', 'exitCode', 'exitMessage', 'id', 'name', 'owner', 'parentId', 'parentName', 'parentTemplate', 'processingStatus', 'processingTimestamp', 'rootId', 'rootName', 'rootTemplate', 'serviceStatus', 'skip', 'startTime', 'statusCode', 'statusMessage', 'template', 'timesRestarted', ignoreCase = $false)]
        [Parameter(Mandatory = $true)]
        [string]$FieldName,
        [Parameter(Mandatory = $true)]
        [string]$value
    )
    If ($operatorText.Length -gt 0) {
        [string]$operator = $operatorText
    }
    ElseIf ($operatorNumber.Length -gt 0) {
        [string]$operator = $operatorNumber
    }
    Else {
        [string]$operator = $operatorDate
    }
    [ANOWResultMappingRuleConditionCriteria]$criteria = [PSCustomObject]@{'operator' = $operator; 'fieldName' = $FieldName; 'value' = $value; }
    Return $criteria
}

Function New-AutomateNOWResultMappingRuleCondition {
    <#

    .SYNOPSIS
    Creates a Result Mapping Rule Condition object

    .DESCRIPTION
    Creates a Result Mapping Rule Condition object for use with Result Mapping Rule objects

    .PARAMETER operator
    The name of the operator for the condition. Valid values are: 'AllMatch', 'AnyMatch', 'SingleMatch', 'AllMismatch', 'AnyMismatch', 'SingleMismatch'

    .PARAMETER criteria
    A [ANOWResultMappingRuleConditionCriteria] representing the criteria for this condition. Use New-AutomateNOWResultMappingRuleConditionCriteria to create these.

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWResultMappingRuleCondition.

    .OUTPUTS
    An [ANOWResultMappingRuleCondition] object representing the newly created Result Mapping Rule Condition Criteria object

    .EXAMPLE
    New-AutomateNOWResultMappingRuleCondition -operator 'AllMatch' -criteria $criteria

    .NOTES
    This function is intended to be used in conjunction with New-AutomateNOWResultMapping

    #>
    [OutputType([ANOWResultMappingRuleCondition])]
    [CmdletBinding()]
    Param(
        [ValidateSet('AllMatch', 'AnyMatch', 'SingleMatch', 'AllMismatch', 'AnyMismatch', 'SingleMismatch')]
        [Parameter(Mandatory = $true)]
        [string]$operator,
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWResultMappingRuleConditionCriteria]$criteria
    )
    Begin {
        [string]$operator_formatted = Switch ($operator) {
            'AllMatch' { 'AND'; Break }
            'AnyMatch' { 'OR'; Break }
            'SingleMatch' { 'XOR'; Break }
            'AllMismatch' { 'NAND'; Break }
            'AnyMismatch' { 'NOR'; Break }
            'SingleMismatch' { 'XNOR'; Break }
        }
        [ANOWResultMappingRuleConditionCriteria[]]$CriteriaArray = @()
    }
    Process {
        If ($_.Length -eq 0) {
            [ANOWResultMappingRuleConditionCriteria[]]$CriteriaArray += $criteria
        }
        Else {
            [ANOWResultMappingRuleConditionCriteria[]]$CriteriaArray += $_
        }
    }
    End {
        [ANOWResultMappingRuleCondition]$condition = [PSCustomObject]@{'operator' = $operator_formatted; 'criteria' = $CriteriaArray; }
        Return $condition
    }
}

Function New-AutomateNOWResultMappingRule {
    <#
    .SYNOPSIS
    Creates a Result Mapping Rule for use with Add-AutomateNOWResultMapping

    .DESCRIPTION
    Creates a Result Mapping Rule for use with Add-AutomateNOWResultMapping

    .PARAMETER Condition
    The mandatory condition object that must be included. Use New-AutomateNOWResultMappingRuleCondition to create it.

    .PARAMETER ProcessingStatus
    Processing Status to be set on the Task if condition is true. Valid values are: COMPLETED, FAILED

    .PARAMETER StatusCode
    Optional status code string to be set on the Task if condition is true. If not specified, the Result Mapping object will use exit code of the processing item.

    .PARAMETER StatusMessage
    Optional status message string to be set on the Task if condition is true. If not specified, the Result Mapping object will use exit code of the processing item.

    .INPUTS
    A single [ANOWResultMappingRuleCondition] object

    .OUTPUTS
    An [ANOWResultMapping] object representing the newly created Result Mapping

    .EXAMPLE
    New-AutomateNOWResultMappingRule -ProcessingStatus 'COMPLETED' -StatusCode 0 -StatusMessage 'SUCCESS' -Condition $condition

    .NOTES
    This cmdlet does not require a connection to the AutomateNOW console.

    The statusCode and statusMessage parameters appear to have unlimited character length allowance!

    #>
    [OutputType([ANOWResultMappingRule])]
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWResultMappingRuleCondition]$condition,
        [ValidateSet('COMPLETED', 'FAILED', ignoreCase = $false)]
        [Parameter(Mandatory = $true)]
        [string]$ProcessingStatus,
        [Parameter(Mandatory = $false)]
        [string]$StatusCode,
        [Parameter(Mandatory = $false)]
        [string]$StatusMessage
    )
    $Error.Clear()
    Try {
        [ANOWResultMappingRule]$rule = [PSCustomObject]@{ 'condition' = $condition; 'processingStatus' = $ProcessingStatus; 'statusCode' = $StatusCode; 'statusMessage' = $StatusMessage }
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to create the [ANOWResultMappingRule] object (under New-AutomateNOWResultMappingRule) due to [$Message]."
        Break
    }
    Return $rule
}

#endregion

#Region - Runtime Actions (PROCESSING_ACTION)

Function Get-AutomateNOWRuntimeAction {
    <#
    .SYNOPSIS
    Gets the Runtime Actions from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Runtime Actions from an AutomateNOW! instance

    .PARAMETER Id
    Optional string containing the 36-character guid Id of the Runtime Action to fetch or you can pipeline a series of simple id strings. You may not enter an array here.

    .PARAMETER simpleId
    Optional string containing the "simpleId" of the Runtime Action to fetch or you can pipeline a series of simple id strings. You may not enter an array here.

    .PARAMETER sortBy
    Optional string parameter to sort the results by. Valid choices are: id {To be continued...}

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .INPUTS
    Accepts a string representing the simple id of the Runtime Action from the pipeline or individually (but not an array).

    .OUTPUTS
    An array of one or more [ANOWProcessingAction] class objects

    .EXAMPLE
    Gets the first page of Runtime Actions

    Get-AutomateNOWRuntimeAction

    .EXAMPLE
    Gets a single Runtime Action by simpleId

    Get-AutomateNOWRuntimeAction -Id 'RuntimeAction1'

    .EXAMPLE
    Gets a series of Runtime Actions from an array of Id's sent across the pipeline

    '823fd7ea-3106-40f7-acd3-f33cdd26b7s1', '4631b806-9d2c-4d8e-b1e4-e1f685c13939' | Get-AutomateNOWRuntimeAction

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    "Runtime Actions" are the friendly name for Processing Actions.

    #>
    [OutputType([ANOWProcessingAction[]])]
    [Cmdletbinding(DefaultParameterSetName = 'Default')]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}$' })]
        [Parameter(Mandatory = $False, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [string]$Id,
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $False, ParameterSetName = 'SimpleId')]
        [string]$simpleId,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$sortBy = 'processingActionOrder',
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$Descending
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0) {
            If ( $_ -match '^[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}$') {
                [string]$Id = $_
            }
            ElseIf ($_ -match '^[0-9a-zA-z_.-]{1,}$' ) {
                [string]$SimpleId = $_
            }
            Else {
                Write-Warning -Message "Somehow was unable to determine the type of object passed through the pipeline. Please look into this."
                Break
            }
        }
        If ($Id.Length -gt 0) {
            [string]$textMatchStyle = 'exactCase'
            $Body.'id' = $Id
            $Body.'_operationId' = 'read'
        }
        Else {
            [string]$textMatchStyle = 'substring'
            $Body.'_constructor' = 'AdvancedCriteria'
            $Body.'operator' = 'and'
            $Body.'criteria1' = '{"fieldName":"isRule","operator":"equals","value":true}'
            If ($SimpleId.Length -gt 0) {
                $Body.'criteria2' = ('{"fieldName":"simpleId","operator":"equals","value":"' + $SimpleId + '"}')
            }
            $Body.'_componentId' = 'ProcessingRuleList'
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
        }
        $Body.'_operationType' = 'fetch'
        $Body.'_textMatchStyle' = $textMatchStyle
        $Body.'_dataSource' = 'ProcessingActionDataSource'
        If ($Descending -eq $true) {
            $Body.'_sortBy' = '-' + $sortBy
        }
        Else {
            $Body.'_sortBy' = $sortBy
        }
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/processingAction/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWProcessingAction[]]$RuntimeActions = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWProcessingAction] objects due to [$Message]."
            Break
        }
        If ($RuntimeActions.Count -gt 0) {
            Return $RuntimeActions
        }
    }
    End {

    }
}

Function Set-AutomateNOWRuntimeAction {
    <#
    .SYNOPSIS
    Changes the settings of a Runtime Action on an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of a Runtime Action on an AutomateNOW! instance

    .PARAMETER RuntimeAction
    An [ANOWProcessingAction] object representing the Runtime Action to be modified.

    .PARAMETER simpleId
    Optional string to change the "Id" (which is actually the simpleId) of the object.

    .PARAMETER Description
    Optional string to set the description on the new Runtime Action object.

    .PARAMETER UnsetDescription
    Optional switch that will remove (blank out to null) the Description from the Runtime Action object.

    .PARAMETER CodeRepository
    Optional Code Repository to place the Runtime Action into. Use Get-AutomateNOWCodeRepository to fetch this object.

    .PARAMETER UnsetCodeRepository
    Switch parameter that will remove the the Runtime Action from its Code Repository.

    .PARAMETER simpleId
    Optional string to change the simpleId of the Runtime Action. This value need not be unique from other Runtime Actions.

    .PARAMETER StartDate
    Optional string to set the Start Date of the Runtime Action. Example format: '2038-12-31 23:45:00'

    .PARAMETER UnsetStartDate
    Switch parameter to remove the Start Date from the Runtime Action.

    .PARAMETER EndDate
    Optional string to set the End Date of the Runtime Action. Example format: '2038-12-31 23:45:00'

    .PARAMETER UnsetEndDate
    Switch parameter to remove the End Date from the Runtime Action.

    .PARAMETER Calendar
    A [ANOWCalendar] object representing the Calendar object to set on the Runtime Action. Use Get-AutomateNOWCalendar to fetch one of these.

    .PARAMETER UnsetCalendar
    A switch parameter that will remove the Calendar assignment from the Runtime Action.

    .PARAMETER ActionOrder
    An optional int64 to specify the "Action Order" to the Runtime Action. This number may be negative.

    .PARAMETER UnsetActionOrder
    A switch parameter that will remove the "Action Order" value from the Runtime Action.

    .PARAMETER Skip
    Optional boolean that will enable or disable the skip flag

    .PARAMETER ProcessingType
    Optional string to set the Processing Type. Value values are: 'TASK', 'WORKFLOW', 'SERVICE'

    .PARAMETER UnsetProcessingType
    A switch parameter that will remove the ProcessingType and a TaskType/WorkflowType/ServiceType (if set) from the 'Apply To' tab of the Runtime Action

    .PARAMETER TaskType
    An optional string if -ProcessingType is set to 'TASK'. Valid values are: PROCESSING_OBSERVER; TRIGGER_ITEM; SH; PYTHON; PERL; POWERSHELL; TCL; RUBY; GROOVY; SCALA; KOTLIN; C; CPP; JAVA; JAVASCRIPT; TYPESCRIPT; RUST; GO; SWIFT; VBSCRIPT; AS400_COMMAND_CALL; AS400_PROGRAM_CALL; AS400_BATCH_JOB; AS400_RPA; Z_OS_DYNAMIC_JCL; Z_OS_STORED_JCL; Z_OS_COMMAND; AWS_GLUE_WORKFLOW; AWS_GLUE_JOB; AWS_GLUE_CRAWLER; AWS_GLUE_TRIGGER; AWS_EMR_WORKFLOW; AWS_EMR_PUT; AWS_EMR_GET; AWS_EMR_START_NOTEBOOK_EXECUTION; AWS_EMR_STOP_NOTEBOOK_EXECUTION; AWS_EMR_API_COMMAND; AWS_EMR_ADD_STEPS; AWS_EMR_CANCEL_STEPS; AWS_EMR_TERMINATE_JOB_FLOW; AWS_SAGE_MAKER_API_COMMAND; AWS_SAGE_MAKER_ADD_MODEL; AWS_SAGE_MAKER_DELETE_MODEL; AWS_SAGE_MAKER_PROCESSING; AWS_SAGE_MAKER_TRAINING; AWS_SAGE_MAKER_TRANSFORM; AWS_SAGE_MAKER_TUNING; AWS_EC2_START_INSTANCE; AWS_EC2_STOP_INSTANCE; AWS_EC2_TERMINATE_INSTANCE; AWS_EC2_DELETE_VOLUME; AWS_LAMBDA_INVOKE; AWS_LAMBDA_CREATE_FUNCTION; AWS_LAMBDA_DELETE_FUNCTION; AWS_BATCH_JOB; AWS_START_STEP_FUNCTION_STATE_MACHINE; AWS_S3_DELETE_OBJECT; AWS_S3_COPY_OBJECT; AWS_S3_MOVE_OBJECT; AWS_S3_RENAME_OBJECT; AZURE_DATA_LAKE_JOB; AZURE_DATA_FACTORY_TRIGGER; AZURE_DATA_FACTORY_PIPELINE; AZURE_DATABRICKS_JOB; AZURE_DATABRICKS_TERMINATE_CLUSTER; AZURE_DATABRICKS_START_CLUSTER; AZURE_DATABRICKS_LIST_CLUSTERS; AZURE_DATABRICKS_DELETE_CLUSTER; AZURE_BATCH_JOB; AZURE_RUN_LOGIC_APP; GOOGLE_DATA_FLOW_JOB; INFORMATICA_CLOUD_TASKFLOW; HTTP_REQUEST; REST_WEB_SERVICE_CALL; SOAP_WEB_SERVICE_CALL; EMAIL_SEND; EMAIL_CONFIRMATION; EMAIL_INPUT; IBM_MQ_SEND; JMS_SEND; AMQP_SEND; RABBIT_MQ_SEND; KAFKA_SEND; MQTT_SEND; XMPP_SEND; STOMP_SEND; IBM_DATASTAGE; INFORMATICA_WORKFLOW; INFORMATICA_WS_WORKFLOW; DBT_CORE_JOB; INFORMATICA_START; INFORMATICA_EMAIL; INFORMATICA_ASSIGNMENT; INFORMATICA_TIMER; INFORMATICA_CONTROL; INFORMATICA_COMMAND; INFORMATICA_SESSION; INFORMATICA_EVENT_RAISE; INFORMATICA_EVENT_WAIT; SAP_R3_JOB; SAP_R3_VARIANT_CREATE; SAP_R3_VARIANT_COPY; SAP_R3_VARIANT_UPDATE; SAP_R3_VARIANT_DELETE; SAP_R3_RAISE_EVENT; SAP_R3_MONITOR_EXISTING_JOB; SAP_R3_RELEASE_EXISTING_JOB; SAP_R3_COPY_EXISTING_JOB; SAP_R3_START_SCHEDULED_JOB; SAP_R3_JOB_INTERCEPTOR; SAP_BW_PROCESS_CHAIN; SAP_ARCHIVE; SAP_CM_PROFILE_ACTIVATE; SAP_CM_PROFILE_DEACTIVATE; SAP_EXPORT_CALENDAR; SAP_FUNCTION_MODULE_CALL; SAP_READ_TABLE; SAP_EXPORT_JOB; SAP_MODIFY_INTERCEPTION_CRITERIA; SAP_GET_APPLICATION_LOG; SAP_SWITCH_OPERATION_MODE; SAP_4H_JOB; SAP_4H_VARIANT_CREATE; SAP_4H_VARIANT_COPY; SAP_4H_VARIANT_UPDATE; SAP_4H_VARIANT_DELETE; SAP_4H_RAISE_EVENT; SAP_4H_MONITOR_EXISTING_JOB; SAP_4H_RELEASE_EXISTING_JOB; SAP_4H_COPY_EXISTING_JOB; SAP_4H_START_SCHEDULED_JOB; SAP_4H_JOB_INTERCEPTOR; SAP_4H_BW_PROCESS_CHAIN; SAP_4H_ARCHIVE; SAP_4H_CM_PROFILE_ACTIVATE; SAP_4H_CM_PROFILE_DEACTIVATE; SAP_4H_EXPORT_CALENDAR; SAP_4H_FUNCTION_MODULE_CALL; SAP_4H_READ_TABLE; SAP_4H_EXPORT_JOB; SAP_4H_MODIFY_INTERCEPTION_CRITERIA; SAP_4H_GET_APPLICATION_LOG; SAP_4H_SWITCH_OPERATION_MODE; SAP_ODATA_API_CALL; SAP_IBP_JOB; SAP_IBP_CREATE_PROCESS; SAP_IBP_DELETE_PROCESS; SAP_IBP_SET_PROCESS_STEP_STATUS; ORACLE_EBS_PROGRAM; ORACLE_EBS_REQUEST_SET; ORACLE_EBS_EXECUTE_PROGRAM; ORACLE_EBS_EXECUTE_REQUEST_SET; PEOPLESOFT_APPLICATION_ENGINE_TASK; PEOPLESOFT_COBOL_SQL_TASK; PEOPLESOFT_CRW_ONLINE_TASK; PEOPLESOFT_CRYSTAL_REPORTS_TASK; PEOPLESOFT_CUBE_BUILDER_TASK; PEOPLESOFT_NVISION_TASK; PEOPLESOFT_SQR_PROCESS_TASK; PEOPLESOFT_SQR_REPORT_TASK; PEOPLESOFT_WINWORD_TASK; PEOPLESOFT_JOB_TASK; FILE_TRANSFER; XFTP_COMMAND; FILE_CHECK; FILE_WATCHER; DATASOURCE_UPLOAD_FILE; DATASOURCE_DOWNLOAD_FILE; DATASOURCE_DELETE_FILE; RDBMS_STORED_PROCEDURE; RDBMS_SQL_STATEMENT; RDBMS_SQL; MONGO_DB_INSERT; COUCH_DB_INSERT; CASSANDRA_CQL_SCRIPT; COUCH_BASE_INSERT; DYNAMO_DB_INSERT; ARANGO_DB_INSERT; NEO4J_INSERT; TITAN_INSERT; PROCESSING_ACTION_SKIP_ON; PROCESSING_ACTION_SKIP_OFF; NOTIFY_GROUP; NOTIFY_CHANNEL; NOTIFY_EMAIL; SET_PROCESSING_STATUS; SET_SERVER_NODE; SET_SEMAPHORE_STATE; SET_SEMAPHORE_TIMESTAMP_STATE; SET_TIME_WINDOW_STATE; SET_VARIABLE_VALUE; SET_VARIABLE_TIMESTAMP_VALUE; SET_STOCK_TOTAL_PERMITS; SET_CONTEXT_VARIABLE_VALUE; SET_CONTEXT_VARIABLE_VALUES; SET_RESOURCES; SET_PHYSICAL_RESOURCE; SET_METRIC; TRIGGER_EVENT; DATA_SOURCE_GET; DATA_SOURCE_SET; DATA_SOURCE_REMOVE; CHECK_SEMAPHORE_STATE; CHECK_TIME_WINDOW_STATE; CHECK_PROCESSING_STATE; CHECK_STOCK_TOTAL_PERMITS; CHECK_STOCK_AVAILABLE_PERMITS; CHECK_LOCK_STATE; CHECK_VARIABLE_VALUE; CHECK_PHYSICAL_RESOURCE; CHECK_METRIC; CHECK_CALENDAR; RESOURCE_ADD_TAG; RESOURCE_REMOVE_TAG; RESOURCE_SET_FOLDER; PROCESSING_REGISTER_STATE; PROCESSING_UNREGISTER_STATE; PROCESSING_CLEAR_STATE_REGISTRY; PROCESSING_ADD_NOTE; PROCESSING_TEMPLATE_ADD_NOTE; SEVER_NODE_ADD_NOTE; AGENT_ADD_NOTE; ENDPOINT_ADD_NOTE; RESOURCE_ADD_NOTE; RESTART; RETRY; FORCE_COMPLETED; FORCE_FAILED; FORCE_READY; HOLD; RESUME; ABORT; KILL; SKIP_ON; SKIP_OFF; SET_PRIORITY; ADD_TAG; REMOVE_TAG; SET_FOLDER; PROCESSING_RUN_NOW; SET_STATUS_CODE; SERVER_NODE_ABORT_ALL; SERVER_NODE_KILL_ALL; SERVER_NODE_HOLD; SERVER_NODE_SET_CONNECTION; SERVER_NODE_RESUME; SERVER_NODE_SKIP_ON; SERVER_NODE_SKIP_OFF; SERVER_NODE_STOP; SERVER_NODE_ADD_TAG; SERVER_NODE_REMOVE_TAG; SERVER_NODE_SET_FOLDER; SERVER_NODE_SET_PARAMETERS; SERVER_NODE_SET_TOTAL_WEIGHT_CAPACITY; PROCESSING_TEMPLATE_HOLD; PROCESSING_TEMPLATE_RESUME; PROCESSING_TEMPLATE_SKIP_ON; PROCESSING_TEMPLATE_SKIP_OFF; ARCHIVE; ARCHIVE_INTERVAL; ARCHIVE_CLEANUP; RECALCULATE_STATISTICS; DESIGN_BACKUP; DESIGN_IMPORT; CHECK_TIME; WAIT; USER_CONFIRM; USER_INPUT; ADHOC_REPORT_SEND; AE_SCRIPT; MS_SSIS; RAINCODE_DYNAMIC_JCL; RAINCODE_STORED_JCL; OPENTEXT_DYNAMIC_JCL; OPENTEXT_STORED_JCL; SAS_DI; SAS_4GL; SAS_JOB; SAS_VIYA_JOB; ODI_SESSION; ODI_LOAD_PLAN; DBT_JOB; TALEND_JOB; REDIS_CLI; REDIS_SET; REDIS_GET; REDIS_DELETE; FLINK_JAR_UPLOAD; FLINK_JAR_DELETE; FLINK_RUN_JOB; HDFS_UPLOAD_FILE; HDFS_APPEND_FILE; HDFS_DOWNLOAD_FILE; HDFS_DELETE_FILE; HDFS_CREATE_DIRECTORY; HDFS_DELETE_DIRECTORY; HDFS_RENAME; SPARK_RUN_JOB; SPARK_JAVA; SPARK_SCALA; SPARK_R; SPARK_PYTHON; SPARK_SQL; MICROSOFT_POWER_BI_DATASET_REFRESH; MICROSOFT_POWER_BI_DATAFLOW_REFRESH; TABLEAU_REFRESH_EXTRACT; BLUE_PRISM_STOP_ROBOT; BLUE_PRISM_START_ROBOT; BLUE_PRISM_UNDEPLOY_ROBOT; BLUE_PRISM_DEPLOY_ROBOT; BLUE_PRISM; UI_PATH_STOP_ROBOT; UI_PATH_START_ROBOT; UI_PATH_UNDEPLOY_ROBOT; UI_PATH_DEPLOY_ROBOT; UI_PATH; AUTOMATION_ANYWHERE; AUTOMATION_ANYWHERE_STOP_ROBOT; AUTOMATION_ANYWHERE_START_ROBOT; AUTOMATION_ANYWHERE_UNDEPLOY_ROBOT; AUTOMATION_ANYWHERE_DEPLOY_ROBOT; WORK_FUSION_STOP_ROBOT; WORK_FUSION_START_ROBOT; WORK_FUSION_UNDEPLOY_ROBOT; WORK_FUSION_DEPLOY_ROBOT; PEGA_STOP_ROBOT; PEGA_START_ROBOT; PEGA_UNDEPLOY_ROBOT; PEGA_DEPLOY_ROBOT; ROBOT_FRAMEWORK_STOP_ROBOT; ROBOT_FRAMEWORK_START_ROBOT; ROBOT_FRAMEWORK_UNDEPLOY_ROBOT; ROBOT_FRAMEWORK_DEPLOY_ROBOT; CONTROL_M_RUN_JOB; STONEBRANCH_RUN_JOB; CA_WLA_RUN_JOB; AUTOMIC_WLA_RUN_JOB; IBM_WLA_RUN_JOB; TERMA_RUN_JOB; TIDAL_RUN_JOB; AUTOMATE_NOW_RUN_JOB; FACEBOOK_POST; INSTAGRAM_POST; TWITTER_POST; YOUTUBE_POST; LINKED_IN_POST; TUMBLR_POST; TIKTOK_POST; REDDIT_POST; TELEGRAM_MESSAGE; WHATSAPP_MESSAGE; TEAMS_CHAT_MESSAGE; TEAMS_CHANNEL_MESSAGE; JIRA_ADD_ISSUE; JIRA_CLOSE_ISSUE; SERVICE_NOW_CREATE_INCIDENT; SERVICE_NOW_UPDATE_INCIDENT; SERVICE_NOW_RESOLVE_INCIDENT; SERVICE_NOW_CLOSE_INCIDENT; SERVICE_NOW_INCIDENT_STATUS_SENSOR; SERVICE_NOW_ADD_ATTACHMENT; ORACLE_SERVICE_CENTER_CASE; IBM_CONTROL_DESK_INCIDENT; BMC_REMEDY_INCIDENT; CA_SERVICE_MANAGEMENT_INCIDENT; SAP_SOLUTION_MANAGER_TICKET; HP_OPEN_VIEW_SERVICE_MANAGER_INCIDENT; AUTOMATE_NOW_TRIGGER_EVENT; APACHE_AIRFLOW_RUN_DAG; ANSIBLE_PLAYBOOK_PATH; ANSIBLE_PLAYBOOK; POWER_AUTOMATE_EXECUTE_FLOW; CTRLM_DELETE_CONDITION; CTRLM_ADD_CONDITION; CTRLM_ORDER_JOB; CTRLM_CREATE_JOB; CTRLM_RESOURCE_TABLE_ADD; CTRLM_RESOURCE_TABLE_UPDATE; CTRLM_RESOURCE_TABLE_DELETE; AE_SHELL_SCRIPT;

    .PARAMETER UnsetTaskType
    A switch parameter that will remove the TaskType from the 'Apply To' tab.

    .PARAMETER WorkflowType
    An optional string if -ProcessingType is set to 'WORKFLOW'. Valid values are: STANDARD; BROADCAST; FOR_EACH; TIME_SERIES; SWITCH; CYCLE;

    .PARAMETER UnsetWorkflowType
    A switch parameter that will remove the WorkflowType from the 'Apply To' tab.

    .PARAMETER ServiceType
    An optional string if -ProcessingType is set to 'SERVICE'. Valid values are: SERVICE_MANAGER; SENSOR; MONITOR;

    .PARAMETER UnsetServiceType
    A switch parameter that will remove the Service Type from the 'Apply To' tab.

    .PARAMETER ProcessingTemplateOperator
    The operator to use when targeting a Processing Template. Value values are: EQUALS*, NOT_EQUAL, STARTS_WITH, ENDS_WITH, CONTAINS

    .PARAMETER ProcessingTemplate
    An [ANOWProcessingTemplate] object, that is an [ANOWTaskTemplate], [ANOWWorkflowTemplate] or [ANOWServiceManagerTemplate] object to apply as the processing template of the Runtime Action.

    .PARAMETER UnsetProcessingTemplate
    A switch parameter that will remove the Processing Template that was applied in the 'Apply To' tab.

    .PARAMETER ParentProcessingTemplate
    An [ANOWProcessingTemplate] object, that is an [ANOWTaskTemplate], [ANOWWorkflowTemplate] or [ANOWServiceManagerTemplate] object to apply as the parent processing template of the Runtime Action.

    .PARAMETER UnsetParentProcessingTemplate
    A switch parameter that will remove the Parent Processing Template that was applied in the 'Apply To' tab.

    .PARAMETER NodeType
    A string representing the type of Server Node to apply the Runtime Action to. Valid values are: AZURE; AWS; GOOGLE_CLOUD; GOOGLE_DATA_FLOW; AZURE_DATABRICKS; INFORMATICA_CLOUD; UNIX; LINUX; WINDOWS; SOLARIS; HPUX; AIX; OPENVMS; MACOS; AS400; Z_OS; RAINCODE; CTRL_M; OPENTEXT; INFORMATICA; INFORMATICA_WS; SAS; SAS_VIYA; IBM_DATASTAGE; ODI; MS_SSIS; AB_INITIO; SAP_BODI; SKYVIA; TALEND; DBT; DBT_CORE; SAP; SAP_S4_HANA; SAP_S4_HANA_CLOUD; SAP_IBP; JD_EDWARDS; ORACLE_EBS; PEOPLESOFT; MICROSOFT_DYNAMICS; HIVE_QL; GOOGLE_BIG_QUERY; AZURE_SQL_DATA_WAREHOUSE; AZURE_SQL_DATABASE; DASHDB; DB2; MYSQL; NETEZZA; ORACLE; POSTGRESQL; SQL_SERVER; TERADATA; SINGLESTORE; SNOWFLAKE; VERTICA; PRESTO_DB; SYBASE; INFORMIX; H2; FILE_MANAGER; SNMP; HTTP; EMAIL; SOAP_WEB_SERVICE; REST_WEB_SERVICE; INTERNAL; IBM_MQ; RABBIT_MQ; SQS; ACTIVE_MQ; QPID; IBM_SIBUS; HORNETQ; SOLACE; JORAM_MQ; QMQ; ZERO_MQ; KAFKA; PULSAR; AMAZON_KINESIS; GOOGLE_CLOUD_PUB_SUB; MICROSOFT_AZURE_EVENT_HUB; AMQP; XMPP; STOMP; HDFS; REDIS; HADOOP; HIVE; IMPALA; SQOOP; YARN; SPARK; FLUME; FLINK; STORM; OOZIE; AMBARI; ELASTIC_SEARCH; CASSANDRA; SAP_HANA; MONGO_DB; COUCH_DB; COUCH_BASE; DYNAMO_DB; ARANGO_DB; NEO4J; ORIENT_DB; TITAN; ANDROID; IOS; WINDOWS_MOBILE; MICROSOFT_POWER_BI; TABLEAU; BLUE_PRISM; UI_PATH; AUTOMATION_ANYWHERE; WORK_FUSION; PEGA; ROBOT_FRAMEWORK; CONTROL_M; STONEBRANCH; CA_WLA; AUTOMIC_WLA; IBM_WLA; TIDAL; FACEBOOK; INSTAGRAM; TWITTER; YOUTUBE; LINKED_IN; TUMBLR; TIKTOK; REDDIT; TELEGRAM; WHATSAPP; TEAMS; JIRA; SERVICE_NOW; ORACLE_SERVICE_CENTER; BMC_REMEDY; CA_SERVICE_MANAGEMENT; IBM_CONTROL_DESK; HP_OPEN_VIEW_SERVICE_MANAGER; SAP_SOLUTION_MANAGER; AUTOMATE_NOW; APACHE_AIRFLOW; POWER_AUTOMATE; ANSIBLE;

    .PARAMETER UnsetNodeType
    A switch parameter that will remove the Node Type that was applied in the 'Apply To' tab.

    .PARAMETER ServerNodeOperator
    The operator to use when targeting a Server Node. Valid values are: EQUALS*, NOT_EQUAL, STARTS_WITH, ENDS_WITH, CONTAINS

    .PARAMETER ServerNode
    An [ANOWServerNode] object to apply as the Server Node of the Runtime Action

    .PARAMETER UnsetServerNode
    A switch parameter that will remove the Server Node that was applied in the 'Apply To' tab.

    .PARAMETER TagOperator
    The operator to use when applying Tags. Valid values are: EQUALS*, NOT_EQUAL, STARTS_WITH, ENDS_WITH, CONTAINS

    .PARAMETER UnsetTagOperator
    A switch parameter that will remove the Tag Operator. This operator can be set to null but other operators can not.

    .PARAMETER Folder
    A string representing the Folder to apply the Runtime Action to.

    .PARAMETER UnsetFolder
    A switch parameter that will remove the Folder that the Runtime Action is configured against.

    .PARAMETER Tags
    A string array representing the tag(s) to be added to the Runtime Action. Note that you must include a TagOperator if one is not already set on the Runtime Action.

    .PARAMETER UnsetTags
    A switch parameter that will remove the tag(s) from the Runtime Action.

    .PARAMETER EventCondition
    Always optional Event Condition object to apply in the 'On Event' tab. Use New-AutomateNOWResultMappingRuleCondition to create this. See the examples in the in-line help.

    .PARAMETER StepConditionMode
    Sets the Step Condition Mode. Valid options are: SIMPLE, ADVANCED

    .PARAMETER UnsetStepConditionMode
    A switch parameter that will remove the Step Condition Mode from the Runtime Action.

    .PARAMETER StepName
    The name [string] of the Step in the Step Condition Mode. Only used (and required) when setting the Step Condition Mode to SIMPLE. The maximum length is 255 characters.

    .PARAMETER StepOperator
    The name of the Step Operator to use in the Step Condition Mode. Only used (and required) when setting the Step Condition Mode to SIMPLE. Valid values are: 'EQ'*, 'NE', 'LT', 'GT', 'LE', 'GE'

    .PARAMETER StepReturnCode
    The name [string] of the Step Return Code in the Step Condition Mode. Only used (and required) when setting the Step Condition Mode to SIMPLE. The maximum length is 255 characters.

    .PARAMETER StepCondition
    Only used (and required) when enabling ADVANCED for the Step Condition Mode. Use New-AutomateNOWResultMappingRuleCondition to create this. See the examples in the in-line help.

    .PARAMETER Quiet
    Switch parameter to prevent the output of the modified object

    .PARAMETER Force
    Switch parameter to force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWProcessingAction] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWProcessingAction] object will be returned

    .EXAMPLE
    Forcefully and quietly enables the Skip flag (checkbox) for a Runtime Action with an Id of '123db6dd-d78d-481d-b012-a3f50548c5ad' (multi-line format)

    $runtime_action = Get-AutomateNOWRuntimeAction -Id '123db6dd-d78d-481d-b012-a3f50548c5ad'
    Set-AutomateNOWRunTimeAction -RuntimeAction $runtime_action -skip $true -Force -Quiet

    .EXAMPLE
    Quietly modifies the description of a Runtime Action with a simpleId of 'RuntimeAction1' (one-liner format)

    Get-AutomateNOWRuntimeAction -simpleId 'RuntimeAction1' | Set-AutomateNOWRunTimeAction -Description 'New Description' -Quiet

    .EXAMPLE
    Sets the TaskType to 'PowerShell' and processingType to 'TASK' and the processingTemplate to any PowerShell Task Template except the one named 'POWERSHELL_TASK_1' to a Runtime Action with an Id of '123db6dd-d78d-481d-b012-a3f50548c5ad' (multi-line format)
    $runtime_action = Get-AutomateNOWRuntimeAction -Id '123db6dd-d78d-481d-b012-a3f50548c5ad'
    $runtime_action | Set-AutomateNOWRunTimeAction -TaskType 'POWERSHELL' -ProcessingType 'TASK' -ProcessingTemplateOperator 'NOT_EQUAL' -ProcessingTemplate (Get-AutomateNOWTaskTemplate -Id 'POWERSHELL_TASK_1')

    .EXAMPLE
    Sets the Server Node to any Server Node except the one named 'Windows1' and sets the NodeType to 'WINDOWS' to a Runtime Action with an Id of '123db6dd-d78d-481d-b012-a3f50548c5ad' (multi-line format)

    $runtime_action = Get-AutomateNOWRuntimeAction -Id '123db6dd-d78d-481d-b012-a3f50548c5ad'
    $server_node = Get-AutomateNOWServerNode -Id 'Windows1'
    Set-AutomateNOWRuntimeAction -RuntimeAction $runtime_action -ServerNode $server_node -NodeType 'Windows' -ServerNodeOperator 'NOT_EQUAL'

    .EXAMPLE
    Sets the Tags to Tag1 and Tag2 and the Tag Operator to 'ALL' on a Runtime Action with an Id of '123db6dd-d78d-481d-b012-a3f50548c5ad' (multi-line format)

    $runtime_action = Get-AutomateNOWRuntimeAction -Id '123db6dd-d78d-481d-b012-a3f50548c5ad'
    Set-AutomateNOWRuntimeAction -RuntimeAction $runtime_action -TagOperator 'ALL' -Tags 'Tag1', 'Tag2'

    .EXAMPLE
    Forcibly and quietly creates an Event Condition (which is actually an [ANOWResultMappingRuleCondition] object) and applies it to a Runtime Action with a simpleId of 'EventCondition1' (multi-line format)

    $runtime_action = Get-AutomateNOWRuntimeAction -SimpleId 'EventCondition1'
    $criteria = New-AutomateNOWResultMappingRuleConditionCriteria -operatorNumber 'EQ_NUM' -FieldName 'statusCode' -value '2'
    $condition = New-AutomateNOWResultMappingRuleCondition -operator 'AnyMatch' -criteria $criteria
    $runtime_action | Set-AutomateNOWRuntimeAction -Force -Quiet -EventCondition $condition

    .EXAMPLE
    Sets the Step Condition Mode to ADVANCED and provides the required condition object (which is actually an [ANOWResultMappingRuleCondition] object) and applies it to a Runtime Action with an Id of '123db6dd-d78d-481d-b012-a3f50548c5ad' (multi-line format)

    $runtime_action = Get-AutomateNOWRuntimeAction -Id '123db6dd-d78d-481d-b012-a3f50548c5ad'
    $criteria = New-AutomateNOWResultMappingRuleConditionCriteria -operatorNumber 'EQ_NUM' -FieldName 'statusCode' -value '3'
    $condition = New-AutomateNOWResultMappingRuleCondition -operator 'AnyMatch' -criteria $criteria
    $runtime_action | Set-AutomateNOWRuntimeAction -StepConditionMode 'ADVANCED' -StepCondition $condition

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Be careful basing anything on the simpleId of a runtime action as the value is not unique! Use the 36-character GUID ID instead.

    Be sure to double-check any time you are setting things like Node Type along with a Node that isn't the same type. This function will do its best to warn you but the UI itself has some discrepancies here. Just make sure you know what you are doing with this function.

    Operators for Processing Templates, Parent Processing Templates and Server Nodes cannot be unset (set to null) in the UI (the operator for Tags however, can).

    Use -UnsetStepConditionMode to remove a Step Condition Mode.

    The 'Do Action' tab is not supported yet but everything else is.

    #>
    [OutputType([ANOWProcessingAction])]
    [Cmdletbinding(SupportsShouldProcess, DefaultParameterSetName = 'Default', ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'Default', ValueFromPipeline = $True)]
        [Parameter(Mandatory = $true, ParameterSetName = 'Task', ValueFromPipeline = $True)]
        [Parameter(Mandatory = $true, ParameterSetName = 'Workflow', ValueFromPipeline = $True)]
        [Parameter(Mandatory = $true, ParameterSetName = 'Service', ValueFromPipeline = $True)]
        [ANOWProcessingAction]$RuntimeAction,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [string]$simpleId,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [switch]$UnsetCodeRepository,
        [ValidateScript({ $_ -match '([0-9]{4}-[0-9]{2}-[0-9]{2}){0,}( {0,}[0-9]{2}:[0-9]{2}:[0-9]{2}){0,}' })]
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [string]$StartDate,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [switch]$UnsetStartDate,
        [ValidateScript({ $_ -match '([0-9]{4}-[0-9]{2}-[0-9]{2}){0,}( {0,}[0-9]{2}:[0-9]{2}:[0-9]{2}){0,}' })]
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [string]$EndDate,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [switch]$UnsetEndDate,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [ANOWCalendar]$Calendar,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [switch]$UnsetCalendar,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [Nullable[int64]]$ActionOrder,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [switch]$UnsetActionOrder,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [Nullable[boolean]]$skip,
        [ValidateSet('TASK', 'WORKFLOW', 'SERVICE' )]
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [string]$ProcessingType,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [switch]$UnsetProcessingType,
        [Parameter(Mandatory = $true, ParameterSetName = 'Task')]
        [ANOWProcessingTemplate_taskType]$TaskType,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [switch]$UnsetTaskType,
        [Parameter(Mandatory = $true, ParameterSetName = 'Workflow')]
        [ANOWProcessingTemplate_workflowType]$WorkflowType,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [switch]$UnsetWorkflowType,
        [Parameter(Mandatory = $true, ParameterSetName = 'Service')]
        [ANOWProcessingTemplate_serviceType]$ServiceType,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [switch]$UnsetServiceType,
        [ValidateSet('EQUALS', 'NOT_EQUAL', 'STARTS_WITH', 'ENDS_WITH', 'CONTAINS')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [string]$processingTemplateOperator,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [ANOWProcessingTemplate]$processingTemplate,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [switch]$UnsetProcessingTemplate,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [ANOWProcessingTemplate]$parentProcessingTemplate,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [switch]$UnsetParentProcessingTemplate,
        [ValidateSet('EQUALS', 'NOT_EQUAL', 'STARTS_WITH', 'ENDS_WITH', 'CONTAINS')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [string]$ServerNodeOperator,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [ANOWServerNode_serverNodeType]$NodeType,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [switch]$UnsetNodeType,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [ANOWServerNode]$ServerNode,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [switch]$UnsetServerNode,
        [ValidateSet('ALL', 'ANY', 'NONE', 'IS_EMPTY', 'IS_NOT_EMPTY')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [string]$TagOperator,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [switch]$UnsetTagOperator,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [string[]]$Tags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [string]$Folder,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [ANOWResultMappingRuleCondition]$EventCondition,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [switch]$UnsetEventCondition,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [ANOWProcessingAction_subTaskConditionMode]$StepConditionMode,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [switch]$UnsetStepConditionMode,
        [ValidateScript({ $_.Length -lt 256 })]
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [string]$StepName,
        [ValidateSet('EQ', 'NE', 'LT', 'GT', 'LE', 'GE')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [string]$StepOperator,
        [ValidateScript({ $_.Length -lt 256 })]
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [string]$StepReturnCode,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [ANOWResultMappingRuleCondition]$StepCondition,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [switch]$Quiet,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Task')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Workflow')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Service')]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetCodeRepository -eq $true -and $CodeRepository.Id.Length -gt 0) {
            Write-Warning -Message "You cannot unset the Code Repository and set it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetStartDate -eq $true -and $StartDate.Length -gt 0) {
            Write-Warning -Message "You cannot set the start date and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetEndDate -eq $true -and $EndDate.Length -gt 0) {
            Write-Warning -Message "You cannot set the end date and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetCalendar -eq $true -and $Calendar.Id.Length -gt 0) {
            Write-Warning -Message "You cannot set a calendar and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetActionOrder -eq $true -and $null -ne $ActionOrder) {
            Write-Warning -Message "You cannot set the Action Order and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetProcessingType -eq $true -and $ProcessingType.Length -gt 0) {
            Write-Warning -Message "You cannot set the Processing Type and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($ProcessingType.Length -eq 0 -and ($TaskType.Length -gt 0 -or $WorkflowType.Length -gt 0 -or $ServiceType.Length -gt 0)) {
            [string]$ProcessingType = $RuntimeAction.processingType
            If ($ProcessingType.Length -eq 0) {
                Write-Warning -Message "You cannot set the Task/Workflow/Service type if the processingType is not also set (either during this operion or previously on the Runtime Action). Please include the -ProcessingType parameter if the processingType was not already set."
                Break
            }
        }
        If ($UnsetProcessingTemplate -eq $true -and $ProcessingTemplate.Id.Length -gt 0) {
            Write-Warning -Message "You cannot set the Processing Template and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetParentProcessingTemplate -eq $true -and $ParentProcessingTemplate.Id.Length -gt 0) {
            Write-Warning -Message "You cannot set the Parent Processing Template and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetNodeType -eq $true -and $NodeType.Length -gt 0) {
            Write-Warning -Message "You cannot set the Node Type and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetServerNode -eq $true -and $ServerNode.Id.Length -gt 0) {
            Write-Warning -Message "You cannot set the Server Node and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTagOperator -eq $true -and $TagOperator.Length -gt 0) {
            Write-Warning -Message "You cannot set the Tag Operator and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot set the Tags and unset them at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTagOperator -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot remove the Tag Operator and set Tags at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $TagOperator.Length -gt 0) {
            Write-Warning -Message "You cannot remove the Tags and set the Tag Operator at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetStepConditionMode -eq $true -and $StepConditionMode.Length -gt 0) {
            Write-Warning -Message "You cannot set the Step Condition Mode and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($StepConditionMode -eq 'SIMPLE') {
            If ($StepName.Length -eq 0) {
                Write-Warning -Message "You must include the -StepName when setting the Step Condition Mode to SIMPLE"
                Break
            }
            If ($StepOperator.Length -eq 0) {
                Write-Warning -Message "You must include the -StepOperator when setting the Step Condition Mode to SIMPLE"
                Break
            }
            If ($StepReturnCode.Length -eq 0) {
                Write-Warning -Message "You must include the -StepReturnCode when setting the Step Condition Mode to SIMPLE"
                Break
            }
        }
        ElseIf ($StepConditionMode -eq 'ADVANCED') {
            If ($null -eq $StepCondition) {
                Write-Warning -Message "You must include the -StepCondition when setting the Step Condition Mode to ADVANCED"
                Break
            }
        }
        [string]$command = '/processingAction/update'
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWProcessingAction]$RuntimeAction = $_
        }
        [string]$RuntimeAction_id = $RuntimeAction.id
        [string]$RuntimeAction_simpleId = $RuntimeAction.simpleId
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$RuntimeAction_id / $RuntimeAction_simpleId")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$RuntimeAction_exists = ($null -eq (Get-AutomateNOWRuntimeAction -Id $RuntimeAction_id))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWRuntimeAction failed to check if the Runtime Action [$RuntimeAction_id / $RuntimeAction_simpleId] already existed due to [$Message]."
                Break
            }
            If ($RuntimeAction_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not a Runtime Action named [$RuntimeAction_id / $RuntimeAction_simpleId] in the [$current_domain] domain. Please check into this."
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            [string]$oldValues = $RuntimeAction.CreateOldValues()
            $BodyMetaData.'id' = $RuntimeAction_id
            If ($simpleId.Length -gt 0) {
                $BodyMetaData.'simpleId' = $simpleId
            }
            If ($Description.Length -gt 0) {
                $BodyMetaData.'description' = $Description
            }
            ElseIf ($UnsetDescription -eq $true) {
                $BodyMetaData.'description' = $Null
            }
            If ($CodeRepository.Id.Length -gt 0) {
                [string]$CodeRepository_Id = $CodeRepository.Id
                $Error.Clear()
                Try {
                    [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository_Id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository_Id] actually existed under Set-AutomateNOWRuntimeAction due to [$Message]"
                    Break
                }
                If ($code_repository_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository_Id] under Set-AutomateNOWRuntimeAction. Please check again."
                    Break
                }
                $BodyMetaData.'codeRepository' = $CodeRepository_Id
            }
            ElseIf ($UnsetCodeRepository -eq $true) {
                $BodyMetaData.'codeRepository' = $null
            }
            # 'Rule' tab
            If ($StartDate.Length -gt 0) {
                $BodyMetaData.'ruleStartDate' = $StartDate
            }
            ElseIf ($UnsetStartDate -eq $true) {
                $BodyMetaData.'ruleStartDate' = $null
            }
            If ($EndDate.Length -gt 0) {
                $BodyMetaData.'ruleEndDate' = $EndDate
            }
            ElseIf ($UnsetendDate -eq $true) {
                $BodyMetaData.'ruleEndDate' = $null
            }
            If ($Calendar.Id.Length -gt 0) {
                [string]$Calendar_id = $Calendar.simpleId
                $Error.Clear()
                Try {
                    [ANOWCalendar]$Calendar_object = Get-AutomateNOWCalendar -Id $Calendar_id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWCalendar failed to confirm that the Calendar object [$Calendar_id] actually existed under Set-AutomateNOWRuntimeAction due to [$Message]"
                    Break
                }
                If ($Calendar_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWCalendar failed to locate the Calendar object [$Calendar_id] under Set-AutomateNOWRuntimeAction. Please check again."
                    Break
                }
                Write-Verbose -Message "Adding Calendar object [$Calendar_id] to [ANOWRuntimeAction] [$RuntimeAction_id / $RuntimeAction_simpleId]"
                $BodyMetaData.'ruleCalendar' = $Calendar_id
            }
            ElseIf ($UnsetCalendar -eq $true) {
                [string]$Calendar_id = $Calendar.simpleId
                Write-Verbose -Message "Removing [ANOWCalendar] [$Calendar_id] from [ANOWRuntimeAction] [$RuntimeAction_id / $RuntimeAction_simpleId]"
                $BodyMetaData.'ruleCalendar' = $null
            }
            If ($null -ne $ActionOrder) {
                $BodyMetaData.'processingActionOrder' = $ActionOrder
            }
            ElseIf ($UnsetActionOrder -eq $true) {
                $BodyMetaData.'processingActionOrder' = $null
            }
            If ($skip -eq $true) {
                $BodyMetaData.'skip' = 'true'
            }
            ElseIf ($skip -eq $false) {
                $BodyMetaData.'skip' = 'false'
            }
            # 'Apply To' tab
            If ($null -ne $RuntimeAction.ruleDefinition) {
                [int32]$definition_count = $RuntimeAction.ruleDefinition | Get-Member -MemberType NoteProperty | Measure-Object | Select-Object -ExpandProperty Count
                If ($definition_count -gt 0) {
                    [PSCustomObject]$OriginalRuleDefinition = $RuntimeAction.ruleDefinition
                }
            }
            Else {
                [PSCustomObject]$OriginalRuleDefinition = [PSCustomObject]@{}
            }
            [hashtable]$NewRuleDefinition = @{}
            If ($ProcessingType.Length -gt 0) {
                $NewRuleDefinition.Add('processingType', $ProcessingType)
            }
            ElseIf ($UnsetProcessingType -eq $true) {
                $NewRuleDefinition.'processingType' = $null
            }
            If ($TaskType.Length -gt 0) {
                $BodyMetaData.Add('taskType', $TaskType.ToString())
            }
            ElseIf ($UnsetTaskType -eq $true) {
                $BodyMetaData.Add('taskType', $null)
            }
            If ($WorkflowType.Length -gt 0) {
                $BodyMetaData.Add('workflowType', $WorkflowType.ToString())
            }
            ElseIf ($UnsetWorkflowType -eq $true) {
                $BodyMetaData.Add('workflowType', $null)
            }
            If ($ServiceType.Length -eq $true) {
                $BodyMetaData.Add('serviceType', $ServiceType.ToString())
            }
            ElseIf ($UnsetServiceType -eq $true) {
                $BodyMetaData.Add('serviceType', $null)
            }
            If ($ProcessingTemplateOperator.Length -gt 0) {
                $NewRuleDefinition.Add('processingTemplateOperator', $ProcessingTemplateOperator)
            }
            Else {
                $NewRuleDefinition.Add('processingTemplateOperator', 'EQUALS')
            }
            If ($ProcessingTemplate.Id.Length -gt 0) {
                [string]$ProcessingTemplate_Id = $ProcessingTemplate.Id
                $NewRuleDefinition.Add('processingTemplate', $ProcessingTemplate_Id)
            }
            ElseIf ($UnsetProcessingTemplate -eq $true) {
                $NewRuleDefinition.Add('processingTemplate', $null)
            }

            If ($ParentProcessingTemplateOperator.Length -gt 0) {
                $NewRuleDefinition.Add('parentTemplateOperator', $ParentProcessingTemplateOperator)
            }
            Else {
                $NewRuleDefinition.Add('parentTemplateOperator', 'EQUALS')
            }
            If ($ParentProcessingTemplate.Id.Length -gt 0) {
                [string]$ParentProcessingTemplate_Id = $ParentProcessingTemplate.Id
                $NewRuleDefinition.Add('parentTemplate', $ParentProcessingTemplate_Id)
            }
            ElseIf ($UnsetParentProcessingTemplate -eq $true) {
                $NewRuleDefinition.Add('parentTemplate', $null)
            }
            If ($NodeType.Length -gt 0) {
                $NewRuleDefinition.Add('serverNodeType', $NodeType.ToString())
            }
            ElseIf ($UnsetNodeType -eq $true) {
                $NewRuleDefinition.Add('serverNodeType', $null)
            }
            If ($ServerNodeOperator.Length -gt 0) {
                $NewRuleDefinition.Add('nodeOperator', $ServerNodeOperator)
            }
            Else {
                $NewRuleDefinition.Add('nodeOperator', 'EQUALS')
            }
            If ($ServerNode.Id.Length -gt 0) {
                [string]$ServerNode_Id = $ServerNode.Id
                If ($NodeType.Length -gt 0 -or $RuntimeAction.ruleDefinition.serverNodeType.Length -gt 0) {
                    [string]$ServerNode_Type = $ServerNode.serverNodeType
                    If ($NodeType.Length -gt 0) {
                        If ($NodeType -ne $ServerNode_Type) {
                            Write-Warning -Message "Wait! You cannot set the general Node Type of a Runtime Action to [$NodeType] and then also apply a Server Node object of a different node type! $ServerNode_Id a [$ServerNode_Type], not a [$NodeType]. This is not permitted. Please check your assignments."
                            Break
                        }
                        Else {
                            Write-Verbose -Message "$ServerNode_Id which is a Node type of [$ServerNode_Type] matches the Node type set [$NodeType]"
                        }
                    }
                    ElseIf ($RuntimeAction.ruleDefinition.serverNodeType.Length -gt 0) {
                        [string]$ExistingServerNodeType = $RuntimeAction.ruleDefinition.serverNodeType
                        If ($ExistingServerNodeType -ne $ServerNode_Type) {
                            Write-Warning -Message "Wait! Runtime Action $RuntimeAction_simpleId ($RuntimeAction_id) has a Server Node Type set for [$ExistingServerNodeType] but you're trying to apply $ServerNode_Id which is of type [$ServerNode_Type]. This is not permitted. Please check your assignments."
                            Break
                        }
                        Else {
                            Write-Verbose -Message "$ServerNode_Id which is a Node type of [$ServerNode_Type] matches the existing Node type [$ExistingServerNodeType]"
                        }
                    }
                    Else {
                        Write-Warning -Message "Somehow couldn't determine the node configuration of $RuntimeAction_id / $RuntimeAction_simpleId"
                        Break
                    }
                }
                $NewRuleDefinition.Add('node', $ServerNode_Id)
            }
            ElseIf ($UnsetServerNode -eq $true) {
                $NewRuleDefinition.Add('node', $null)
            }
            If ($TagOperator.Length -gt 0) {
                $NewRuleDefinition.Add('tagOperator', $TagOperator)
            }
            ElseIf ($UnsetTagOperator -eq $true) {
                $NewRuleDefinition.Add('tagOperator', $null)
                [int32]$existing_tags = $RuntimeAction.ruleDefinition.tags.Count
                If ($existing_tags -gt 0 -and $UnsetTags -ne $true) {
                    [string]$existing_tags_display = $RuntimeAction.ruleDefinition.tags | ConvertTo-Json -Compress
                    If ($existing_tags -eq 1) {
                        Write-Warning -Message "There was still 1 Tag $existing_tags_display applied to this Runtime Action ($RuntimeAction_id / $RuntimeAction_simpleId) but you have set the Tag Operator off. If you revert this particular setting, the ANOW console will remember that this tag was set."
                    }
                    Else {
                        Write-Warning -Message "There were still $existing_tags tags $existing_tags_display applied to this Runtime Action ($RuntimeAction_id / $RuntimeAction_simpleId) but you have set the Tag Operator off. If you revert this particular setting, the ANOW console will remember that these tags were set."
                    }
                }
            }
            If ($Tags.Count -gt 0) {
                ForEach ($tag_id in $Tags) {
                    $Error.Clear()
                    Try {
                        [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] under Set-AutomateNOWRuntimeAction due to [$message]"
                        Break
                    }
                    If ($tag_object.simpleId.length -eq 0) {
                        Throw "Set-AutomateNOWRuntimeAction has detected that the tag [$tag_id] does not appear to exist. Please check again."
                        Break
                    }
                    ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                        [string]$tag_object_simpleId = $tag_object.simpleId
                        Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                        Break
                    }
                }
                $NewRuleDefinition.'tags' = $Tags
            }
            ElseIf ($UnsetTags -eq $true) {
                $NewRuleDefinition.'tags' = $null
            }
            ElseIf ($Folder.Length -gt 0) {
                $Error.Clear()
                Try {
                    [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] actually existed under Set-AutomateNOWRuntimeAction due to [$Message]"
                    Break
                }
                If ($folder_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] under Set-AutomateNOWRuntimeAction. Please check again."
                    Break
                }
                [string]$folder_display = $folder_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Applying folder $folder_display to [ANOWRuntimeAction] [$Id]"
                $NewRuleDefinition.'folder' = $Folder
            }
            ElseIf ($UnsetFolder -eq $true) {
                $NewRuleDefinition.'folder' = $null
            }
            If ($NewRuleDefinition.Keys.Count -gt 0) {
                # The existing rules in the ruleDefinition must also be included in this update otherwise they will be lost
                $Error.Clear()
                Try {
                    ForEach ($rule_name in $NewRuleDefinition.Keys) {
                        If ($OriginalRuleDefinition."$rule_name".Length -eq 0) {
                            $OriginalRuleDefinition | Add-Member -MemberType NoteProperty -Name $rule_name -Value ($NewRuleDefinition."$rule_name")
                        }
                        Else {
                            If ($null -eq ($NewRuleDefinition."$rule_name")) {
                                $OriginalRuleDefinition."$rule_name" = $null
                            }
                            Else {
                                $OriginalRuleDefinition."$rule_name" = ($NewRuleDefinition."$rule_name")
                            }
                        }
                    }
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Somehow there was a failure during the processing of the ruleDefinition object under Set-AutomateNOWProcessingAction due to [$Message]."
                    Break
                }
                $Error.Clear()
                Try {
                    [string]$FinalRuleDefinition = $OriginalRuleDefinition | ConvertTo-Json -Compress
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "ConvertTo-Json failed to convert the ruleDefinition object under Set-AutomateNOWProcessingAction due to [$Message]."
                    Break
                }
                $BodyMetaData.'ruleDefinition' = $FinalRuleDefinition
            }
            If ($StepConditionMode.Length -gt 0) {
                $BodyMetaData.'subTaskConditionMode' = $StepConditionMode
            }
            ElseIf ($UnsetStepConditionMode -eq $true) {
                $BodyMetaData.'subTaskConditionMode' = $null
            }
            If ($StepName.Length -gt 0) {
                $BodyMetaData.'subTask' = $StepName
            }
            If ($StepOperator.Length -gt 0) {
                $BodyMetaData.'subTaskOperator' = $StepOperator
            }
            If ($StepReturnCode.Length -gt 0) {
                $BodyMetaData.'subTaskReturnCode' = $StepReturnCode
            }
            If ($null -ne $EventCondition) {
                [string]$EventCondition_string = $EventCondition | ConvertTo-Json -Compress
                $BodyMetaData.'condition' = $EventCondition_string
            }
            ElseIf ($UnsetEventCondition -eq $true) {
                $BodyMetaData.'condition' = $null
            }
            If ($null -ne $StepCondition) {
                [string]$StepCondition_string = $StepCondition | ConvertTo-Json -Compress
                $BodyMetaData.'subTaskCondition' = $StepCondition_string
            }
            # 'Do Action' tab - This section is not complete yet
            $BodyMetaData.'_oldValues' = $oldValues
            $BodyMetaData.'_operationType' = 'update'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_componentId' = 'ProcessingRuleVM'
            $BodyMetaData.'_dataSource' = 'ProcessingActionDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $parameters.Add('Command', $command)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$RuntimeAction_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Runtime Action object [$RuntimeAction_id] was successfully updated"
            $Error.Clear()
            Try {
                [ANOWProcessingAction]$UpdatedRuntimeAction = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the returned object into an [ANOWProcessingAction] under Set-AutomateNOWRuntimeAction due to [$Message]."
                Break
            }
            If ($Quiet -ne $true ) {
                Return $UpdatedRuntimeAction
            }
        }
    }
    End {
    }
}

Function New-AutomateNOWRuntimeAction {
    <#
    .SYNOPSIS
    Creates a Runtime Action within an AutomateNOW! instance

    .DESCRIPTION
    Creates a Runtime Action within an AutomateNOW! instance and returns back the newly created [ANOWProcessingAction] object

    .PARAMETER Id
    The intended name of the Runtime Action. For example: 'RuntimeAction1'. Important! This value will become the "SimpleId" of the object, not the actual Id which is a 36-character guid.

    .PARAMETER Description
    Optional description of the Runtime Action (may not exceed 255 characters).

    .PARAMETER CodeRepository
    Optional [ANOWCodeRepository] object to place the Runtime Action into.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWRuntimeAction.

    .OUTPUTS
    An [ANOWProcessingAction] object representing the newly created Runtime Action

    .EXAMPLE
    Creates a Runtime Action named 'RuntimeAction1' which places any processing item on hold in which a critical path was changed.

    New-AutomateNOWRuntimeAction -Id 'RuntimeAction1' -Description 'Description!' -processingEventCategory PROCESSING -processingEventType CRITICAL_PATH_CHANGED -processingActionType HOLD

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWProcessingAction])]
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true)]
        [string]$Id,
        [Parameter(Mandatory = $false, HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $true)]
        [ANOWProcessingAction_processingEventCategory]$processingEventCategory,
        [Parameter(Mandatory = $true)]
        [ANOWProcessingAction_processingEventType]$processingEventType,
        [Parameter(Mandatory = $true)]
        [ANOWProcessingAction_processingActionType]$processingActionType,
        [Parameter(Mandatory = $false)]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [boolean]$RuntimeAction_exists = ($null -ne (Get-AutomateNOWRuntimeAction -SimpleId $Id))
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWRuntimeAction failed to check if the Runtime Action $Id already existed due to [$Message]."
        Break
    }
    If ($RuntimeAction_exists -eq $true) {
        [string]$current_domain = $anow_session.header.domain
        Write-Warning -Message "There is already a Runtime Action with id $Id in [$current_domain]. Please check into this."
        Break
    }
    ## End warning ##
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    $BodyMetaData.'simpleId' = $Id
    If ($Description.Length -gt 0) {
        $BodyMetaData.'description' = $Description
    }
    If ($CodeRepository.Id.Length -gt 0) {
        [string]$CodeRepository_Id = $CodeRepository.Id
        $Error.Clear()
        Try {
            [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository_Id
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository_Id] existed under New-AutomateNOWRuntimeAction due to [$Message]"
            Break
        }
        If ($code_repository_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository_Id] under New-AutomateNOWRuntimeAction. Please check again."
            Break
        }
        Write-Verbose -Message "Adding Tag $Id to code repository $CodeRepository_Id"
        $BodyMetaData.'codeRepository' = $CodeRepository_Id
    }
    $BodyMetaData.'processingEventCategory' = $processingEventCategory # e.g. 'PROCESSING'
    $BodyMetaData.'processingEventType' = $processingEventType # e.g. 'PROCESSING_READY'
    $BodyMetaData.'processingActionType' = $processingActionType # e.g. 'RESTART'
    $BodyMetaData.'processingCommand' = '{"restartMode":"COUNTER","restartCounter":1,"restartType":"RESTART_FROM_BEGINNING","actionTargetType":"SELF","keepForcedStatus":true}' # Note, this line of code is not a mistake. The application includes this line when creating this object.
    $BodyMetaData.'isRule' = 'true'
    $BodyMetaData.'_operationType' = 'add'
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_oldValues' = '{}'
    $BodyMetaData.'_componentId' = 'ProcessingRuleVM'
    $BodyMetaData.'_dataSource' = 'ProcessingActionDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
    [string]$command = '/processingAction/create'
    [hashtable]$parameters = @{}
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('Body', $Body)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWProcessingAction]$RuntimeAction = $results.response.data | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to create [ANOWProcessingAction] object due to [$Message]."
        Break
    }
    If ($RuntimeAction.id.Length -eq 0) {
        Write-Warning -Message 'Somehow the newly created [ANOWProcessingAction] object is empty!'
        Break
    }
    If ($Quiet -ne $true) {
        Return $RuntimeAction
    }
}

Function Remove-AutomateNOWRuntimeAction {
    <#
    .SYNOPSIS
    Removes a Runtime Action from an AutomateNOW! instance

    .DESCRIPTION
    Removes a Runtime Action from an AutomateNOW! instance

    .PARAMETER RuntimeAction
    An [ANOWSecRole] object representing the Runtime Action to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWSecRole] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Removes a single Runtime Action
    Get-AutomateNOWRuntimeAction -Id 'RuntimeAction1' | Remove-AutomateNOWRuntimeAction

    .EXAMPLE
    Forcefully removes three Runtime Actions by way of the pipeline
    'RuntimeAction1', 'RuntimeAction2', 'RuntimeAction3' | Get-AutomateNOWRuntimeAction | Remove-AutomateNOWRuntimeAction -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWProcessingAction]$RuntimeAction,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processingAction/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWProcessingAction]$RuntimeAction = $_
        }
        [string]$RuntimeAction_id = $RuntimeAction.id
        If ($RuntimeAction_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($RuntimeAction_id)")) -eq $true) {
            [string]$oldvalues = $RuntimeAction.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $RuntimeAction_id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'ProcessingRuleList'
            $BodyMetaData.'_dataSource' = 'ProcessingActionDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$RuntimeAction_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Runtime Action [$RuntimeAction_id] successfully removed"
        }
    }
    End {

    }
}

Function Export-AutomateNOWRuntimeAction {
    <#
    .SYNOPSIS
    Exports the Runtime Actions from an instance of AutomateNOW! to a local .csv file

    .DESCRIPTION
    Exports the Runtime Actions from an instance of AutomateNOW! to a local .csv file

    .PARAMETER RuntimeAction
    Mandatory [ANOWProcessingAction] object (Use Get-AutomateNOWRuntimeAction to retrieve them)

    .INPUTS
    ONLY [ANOWProcessingAction] objects (including from the pipeline) are accepted

    .OUTPUTS
    The [ANOWProcessingAction] objects are exported to the local disk in CSV format

    .EXAMPLE
    Exports a single Runtime Action named 'RuntimeAction1'

    Get-AutomateNOWRuntimeAction -Id 'RuntimeAction1' | Remove-AutomateNOWRuntimeAction

    .NOTES
	You must present [ANOWProcessingAction] objects to the pipeline to use this function.

    #>

    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWProcessingAction]$RuntimeAction
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = "Export-AutomateNOW-RuntimeActions-" + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWProcessingAction]$RuntimeAction = $_
        }
        $Error.Clear()
        Try {
            $RuntimeAction | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWProcessingAction] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function Copy-AutomateNOWRuntimeAction {
    <#
    .SYNOPSIS
    Copies a Runtime Action from an AutomateNOW! instance

    .DESCRIPTION
    Copies a Runtime Action from an AutomateNOW! instance. AutomateNOW object id can never be changed, but we can copy the object to a new id and it will include all of the items therein.

    .PARAMETER RuntimeAction
    Mandatory [ANOWProcessingAction] object to be copied.

    .PARAMETER NewSimpleId
    The new "name" (simpleId) of the new Runtime Action. The new simpleId -should- be unique (per domain) but it is not required. It may consist only of letters, numbers, underscore, dot or hyphen.

    .PARAMETER UnsetDescription
    Optional switch that will ensure that the newly created Runtime Action will not have a description set.

    .PARAMETER Description
    Optional description to set on the new Runtime Action object. If you do not set this, the new Runtime Action object will copy the Description of the source object.

    .PARAMETER Force
    Force the copy without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    ONLY [ANOWProcessingAction] object is accepted. Pipeline support is intentionally unavailable.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Creates a copy of a Runtime Action and changes the description (multi-line format)
    $RuntimeAction1 = Get-AutomateNOWRuntimeAction -Id 'RuntimeAction1'
    Copy-AutomateNOWRuntimeAction -RuntimeAction $RuntimeAction1 -NewId 'RuntimeAction1_production' -Description 'Runtime Action 1 Production'

    .EXAMPLE
    Creates a copy of a Runtime Action that omits the description (one-liner format)
    Copy-AutomateNOWRuntimeAction -RuntimeAction (Get-AutomateNOWRuntimeAction -Id 'RuntimeAction1') -NewId 'RuntimeAction1_production' -UnsetDescription -Tags 'Tag1', 'Tag2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This Copy function is different from most other Copy functions because the Id is a 36-character guid. You are only changing the "simpleId" in this case which does not need to be unique.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWProcessingAction]$RuntimeAction,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewSimpleId,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        [string]$command = '/processingAction/copy'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            $Error.Clear()
            Try {
                [string]$new_object_id = New-GUID | Select-Object -ExpandProperty Guid
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "New-GUID failed to create a new GUID under Copy-AutomateNOWRuntimeAction due to [$Message]."
                Break
            }
            Write-Verbose -Message "Created new guid $new_object_id for $NewSimpleId under Copy-AutomateNOWRuntimeAction"
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$RuntimeAction_exists = ($null -ne (Get-AutomateNOWRuntimeAction -Id $new_object_id))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWRuntimeAction failed to check if the Runtime Action [$new_object_id] already existed due to [$Message]."
                Break
            }
            If ($RuntimeAction_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is already a Runtime Action with an Id of [$new_object_id] in [$current_domain]. You may not proceed. Are you debugging?"
                Break
            }
            ## End warning ##
            [string]$RuntimeAction_oldId = $RuntimeAction.id
            [string]$RuntimeAction_simpleId = $RuntimeAction.simpleId
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Copy the Runtime Action $("[$RuntimeAction_simpleId]") to $("[$NewSimpleId]")")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                $BodyMetaData.'oldId' = $RuntimeAction_oldId
                $BodyMetaData.'domain' = $RuntimeAction.domain
                $BodyMetaData.'id' = $new_object_id
                $BodyMetaData.'simpleId' = $NewSimpleId
                If ($UnsetDescription -ne $true) {
                    If ($Description.Length -gt 0) {
                        $BodyMetaData.'description' = $Description
                    }
                    Else {
                        $BodyMetaData.'description' = $RuntimeAction.description
                    }
                }
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_operationId' = 'copy'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_dataSource' = 'ProcessingActionDataSource'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties oldId, domain, NewId, description, simpleId
                $parameters.Body = $Body
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$RuntimeAction_oldId] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                $Error.Clear()
                Try {
                    [ANOWProcessingAction]$NewRuntimeAction = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to create copied [ANOWProcessingAction] object [$NewSimpleId] due to [$Message]."
                    Break
                }
                If ($NewRuntimeAction.id.Length -eq 0) {
                    Write-Warning -Message "Somehow the newly created (copied) [ANOWProcessingAction] object [$NewSimpleId] is empty!"
                    Break
                }
                Else {
                    [string]$NewRuntimeActionId = $NewRuntimeAction.id
                }
                $Error.Clear()
                Try {
                    [ANOWProcessingAction]$UpdatedRuntimeAction = Set-AutomateNOWRuntimeAction -RuntimeAction $NewRuntimeAction -simpleId $NewSimpleId
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Set-AutomateNOWProcessingAction failed to update the simpleId of newly created Runtime Action [$NewRuntimeActionId] under Copy-AutomateNOWProcessingAction due to [$Message]."
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $UpdatedRuntimeAction
                }
            }
        }
    }
    End {

    }
}

#endregion

#Region - Schedules (PROCESSING)

Function Get-AutomateNOWSchedule {
    <#
    .SYNOPSIS
    Gets the Schedules from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Schedules from an AutomateNOW! instance

    .PARAMETER Id
    A single int64 containing the NUMERICAL id of the Schedule to fetch (a.k.a. RunId)

    .PARAMETER ScheduleTemplate
    Optional [ANOWScheduleTemplate] object by which to filter results by.

    .PARAMETER triggerType
    Optional 'trigger type' of Schedule. This can also be known as "item type" with respect to Schedule Templates. Valid choices are: SCHEDULE, EVENT, SELF_SERVICE, USER (note: PROCESSING and SERVER_NODE are in the schema but unused?)

    .PARAMETER processingType
    Optional 'processing type' of Schedule. Valid choices are: TASK, WORKFLOW, SERVICE, TRIGGER

    .PARAMETER processingStatus
    Optional 'processing status' to filterby. You can only choose one. Valid choices are: WAITING, READY, EXECUTING, COMPLETED, FAILED

    .PARAMETER sortBy
    Optional string parameter to sort the results by (may not be used with the Id parameter). Valid choices are: {To be continued...}

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100. The console default hard limit is 10,000.

    .PARAMETER IncludeArchived
    Optional switch parameter removes the filter for archived items thus both archived and non-archived items will be returned.

    .PARAMETER OnlyArchived
    Optional switch parameter filters out non-archived items thus only archived items will be returned.

    .PARAMETER Folder
    Optional string to filter by a particular Folder

    .PARAMETER Tags
    Optional string array of Tags to filter by. Note that the 'containsAny' operator will be used.

    .INPUTS
    Accepts [int64] RunId's from the pipeline or you can specify a [ANOWScheduleTemplate] object with -ScheduleTemplate

    .OUTPUTS
    An array of one or more [ANOWSchedule] objects

    .EXAMPLE
    Gets the first page of Schedules (Triggers)
    Get-AutomateNOWSchedule

    .EXAMPLE
    Gets the first page of Schedules (Triggers) with a Trigger Type of SCHEULE

    Get-AutomateNOWSchedule -triggerType SCHEDULE

    .EXAMPLE
    Gets a single Schedule by its numerical Id

    Get-AutomateNOWSchedule -Id 1738954

    .EXAMPLE
    Gets all of the schedules where the processing type is Time Trigger and the processing status is Waiting

    Get-AutomateNOWSchedule -processingType TRIGGER -processingStatus WAITING

    .EXAMPLE
    Gets the first 1000 Schedules

    Get-AutomateNOWSchedule -startRow 0 -endRow 1000

    .EXAMPLE
    Gets the first 1000 archived Schedules

    Get-AutomateNOWSchedule -startRow 0 -endRow 1000 -OnlyArchived

    .EXAMPLE
    Gets the first (archived or not archived) 1000 Schedules from a Schedule Template named 'Schedule1'

    Get-AutomateNOWSchedule -ScheduleTemplate (Get-AutomateNOWScheduleTemplate -Id 'Schedule1') -startRow 0 -endRow 1000 -IncludeArchived

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Use Get-AutomateNOWScheduleTemplate if you are looking for Schedule Templates

    Protip: Executed Schedules can be found under Triggers in the Monitor tab in the UI

    #>
    [OutputType([ANOWSchedule[]])]
    [Cmdletbinding(DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $False, ValueFromPipeline = $true, ParameterSetName = 'Default')]
        [int64]$Id,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Template')]
        [ANOWScheduleTemplate]$ScheduleTemplate,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [ANOWProcessing_triggerType]$triggerType,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [ANOWProcessing_processingType]$processingType,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'Template')]
        [ANOWProcessing_processingStatus]$processingStatus,
        [ValidateSet('dateCreated', 'id', 'firstStartTime', 'startTime', 'endTime', ignoreCase = $false)]
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'Template')]
        [string]$sortBy = 'dateCreated',
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'Template')]
        [switch]$Descending,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'Template')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'Template')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'Template')]
        [switch]$IncludeArchived,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'Template')]
        [switch]$OnlyArchived,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'Template')]
        [string]$Folder,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'Template')]
        [string[]]$Tags
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [string]$command = ('/processing/read')
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWScheduleTemplate]$ScheduleTemplate = $_
        }
        ElseIf ($_ -gt 0) {
            [int64]$Id = $_
        }
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($Id -gt 0) {
            $BodyMetaData.'id' = $Id
            $BodyMetaData.'_textMatchStyle' = 'exactCase'
            $BodyMetaData.'_operationId' = 'read'
        }
        Else {
            $BodyMetaData.'operator' = 'and'
            $BodyMetaData.'_constructor' = 'AdvancedCriteria'
            If ($OnlyArchived -eq $true) {
                $BodyMetaData.'criteria1' = '{"fieldName":"archived","operator":"equals","value":true}'
            }
            ElseIf ($IncludeArchived -ne $true) {
                $BodyMetaData.'criteria1' = '{"fieldName":"archived","operator":"equals","value":false}'
            }
            $BodyMetaData.'criteria2' = '{"fieldName":"isProcessing","operator":"equals","value":false}'
            If ($triggerType.Length -gt 0) {
                $BodyMetaData.'criteria3' = ('{"fieldName":"itemType","operator":"equals","value":"' + $triggerType + '"}')
            }
            ElseIf ($ScheduleTemplate.Id.Length -gt 0) {
                $BodyMetaData.'criteria3' = ('{"fieldName":"template","operator":"equals","value":"' + $ScheduleTemplate.Id + '"}')
            }
            Else {
                $BodyMetaData.'criteria3' = '{"fieldName":"itemType","operator":"inSet","value":["SCHEDULE","USER","EVENT","SELF_SERVICE"]}'
            }
            If ($processingType.Length -gt 0) {
                $BodyMetaData.'criteria4' = ('{"fieldName":"processingType","operator":"equals","value":"' + $processingType + '"}')
            }
            If ($processingStatus.Length -gt 0) {
                $BodyMetaData.'criteria5' = '{"fieldName":"processingStatus","operator":"equals","value":"' + $processingStatus + '"}'
            }
            If ($Folder.Length -gt 0) {
                $BodyMetaData.'criteria6' = ('{"fieldName":"folder","operator":"equals","value":"' + $Folder + '"}')
            }
            If ($Tags.Count -gt 0) {
                If ($Tags.Count -gt 1) {
                    $Error.Clear()
                    Try {
                        [string]$TagString = $Tags | ConvertTo-Json -Compress
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "ConvertTo-Json failed to convert the provided tag names under Get-AutomateNOWSchedule due to [$Message]."
                        Break
                    }
                }
                Else {
                    [string]$TagString = $Tags
                }
                $BodyMetaData.'criteria7' = ('{"fieldName":"tags","operator":"containsAny","value":' + $TagString + '}')
            }
            $BodyMetaData.'_textMatchStyle' = 'substring'
            $BodyMetaData.'_startRow' = $startRow
            $BodyMetaData.'_endRow' = $endRow
            $BodyMetaData.'_componentId' = 'ProcessingList'
            If ($Descending -eq $true) {
                $BodyMetaData.'_sortBy' = '-' + $sortBy
            }
            Else {
                $BodyMetaData.'_sortBy' = $sortBy
            }
        }
        $BodyMetaData.'_operationType' = 'fetch'
        $BodyMetaData.'_dataSource' = 'ProcessingDataSource'
        $BodyMetaData.'isc_metaDataPrefix' = '_'
        $BodyMetaData.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        If ($null -eq $parameters.Body) {
            $parameters.Add('Body', $Body)
        }
        Else {
            $parameters.Body = $Body
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWSchedule[]]$Schedules = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWSchedule] objects due to [$Message]."
            Break
        }
        If ($Schedules.Count -gt 0) {
            Return $Schedules
        }
    }
    End {

    }
}

Function Export-AutomateNOWSchedule {
    <#
    .SYNOPSIS
    Exports the Schedules from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Schedules from an instance of AutomateNOW! to a local .csv file

    .PARAMETER Schedule
    Mandatory [ANOWSchedule] object (Use Get-AutomateNOWSchedule to retrieve them)

    .INPUTS
    ONLY [ANOWSchedule] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWSchedule] objects are exported to the local disk in CSV format

    .EXAMPLE
    Get-AutomateNOWSchedule | Export-AutomateNOWSchedule

    .EXAMPLE
    Get-AutomateNOWSchedule -Id 3338818 | Export-AutomateNOWSchedule

    .EXAMPLE
    @( 3338818, 3338819 ) | Get-AutomateNOWSchedule | Export-AutomateNOWSchedule

    .EXAMPLE
    Get-AutomateNOWSchedule -processingStatus EXECUTING | Export-AutomateNOWSchedule

    .NOTES
	You must present [ANOWSchedule] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWSchedule]$Schedule
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-Schedules-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWSchedule]$Schedule = $_
        }
        $Error.Clear()
        Try {
            $Schedule | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWScheduleTemplate] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function Remove-AutomateNOWSchedule {
    <#
    .SYNOPSIS
    Archives a Schedule from an AutomateNOW! instance

    .DESCRIPTION
    Archives a Schedule from an AutomateNOW! instance

    .PARAMETER Schedule
    An [ANOWSchedule] object representing the Schedule Template to be archived.

    .PARAMETER Force
    Force the archiving without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWSchedule] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Gets a single Schedule by its Id

    Get-AutomateNOWSchedule -Id 1738954 | Remove-AutomateNOWSchedule

    .EXAMPLE
    Forcibly archives two Schedules by sending their Id across the pipeline

    @( 3517403, 3533110) | Get-AutomateNOWSchedule | Remove-AutomateNOWSchedule -Force

    .EXAMPLE
    Archives all of the Schedules of type Self Service

    Get-AutomateNOWSchedule -triggerType SELF_SERVICE | Remove-AutomateNOWSchedule

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The term Remove and Archive are synonymous from the API perspective. In ANOW parlance, Task/Workflow/Schedule Templates are 'Deleted' whereas Tasks/Workflows/Schedules are 'Archived'.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWSchedule]$Schedule,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processing/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWSchedule]$Schedule = $_
        }
        [string]$Schedule_id = $Schedule.id
        If ($Schedule_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess($Schedule_id, 'Archive')) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
            $Body.Add('id', $Schedule_id)
            $Body.Add('_operationType', 'remove')
            $Body.Add('_operationId', 'delete')
            $Body.Add('_textMatchStyle', 'exact')
            $Body.Add('_dataSource', 'ProcessingDataSource')
            $Body.Add('isc_metaDataPrefix', '_')
            $Body.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $Body
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Schedule_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Schedule $Schedule_id successfully archived"
        }
    }
    End {

    }
}

Function Restart-AutomateNOWSchedule {
    <#
    .SYNOPSIS
    Restarts a Schedule from an AutomateNOW! instance

    .DESCRIPTION
    Restarts a Schedule from an AutomateNOW! instance

    .PARAMETER Schedule
    An [ANOWSchedule] object representing the Schedule to be restarted

    .PARAMETER Quiet
    Switch parameter to omit the informational message if the Restart was successful

    .PARAMETER Force
    Force the restart without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWSchedule] objects are accepted (including from the pipeline)

    .OUTPUTS
    An informational message is written to the screen unless -Quiet is used

    .EXAMPLE
    Restarts a single Schedule

    Get-AutomateNOWSchedule -Id 'Schedule_01' | Restart-AutomateNOWSchedule

    .EXAMPLE
    Quietly restarts multiple Schedules

    @('Schedule1', 'Schedule2') | Get-AutomateNOWSchedule | Restart-AutomateNOWSchedule -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWSchedule]$Schedule,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processing/restart'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id -gt 0) {
            [ANOWSchedule]$Schedule = $_
        }
        [int64]$Schedule_id = $Schedule.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Schedule_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [ANOWSchedule]$current_Schedule = Get-AutomateNOWSchedule -Id $Schedule_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWSchedule failed to check if the Schedule [$Schedule_id] existed under Restart-AutomateNOWSchedule due to [$Message]."
                Break
            }
            If ($current_Schedule.id.length -eq 0) {
                Write-Warning -Message "The Schedule you specified does not seem to exist (Restart-AutomateNOWSchedule)"
                Break
            }
            [string]$current_Schedule_status = $current_Schedule.processingStatus
            If ($current_Schedule_status -notin [ANOWProcessing_processingStatus].GetEnumNames()) {
                Write-Warning -Message "Somehow the processing status of the Schedule [$Schedule_id] cannot be read (Restart-AutomateNOWSchedule)"
                Break
            }
            If ($current_Schedule_status -notin @('COMPLETED', 'FAILED')) {
                Write-Warning -Message "[$Schedule_id] cannot be restarted as it currently in [$current_Schedule_status] processing status"
                Break
            }
            Else {
                Write-Verbose -Message "[$Schedule_id] had a status of $current_Schedule_status"
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('restartType', 'RESTART_FROM_BEGINNING')
            $BodyMetaData.Add('restartFailedOnly', 'false' ) # Note this value is currently not available in the console
            $BodyMetaData.Add('id', $Schedule_id )
            $BodyMetaData.Add('_operationType', 'custom')
            $BodyMetaData.Add('_operationId', 'restart')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Schedule_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            If ($Quiet -ne $true) {
                Write-Information -MessageData "Schedule $Schedule_id was successfully restarted"
            }
        }
    }
    End {

    }
}

Function Stop-AutomateNOWSchedule {
    <#
    .SYNOPSIS
    Stops a Schedule on an AutomateNOW! instance

    .DESCRIPTION
    Stops a Schedule on an AutomateNOW! instance with either a soft or hard stop

    .PARAMETER Schedule
    An [ANOWSchedule] object representing the Schedule to be stopped

    .PARAMETER Kill
    Switch parameter to indicate 'Hard kill' of the Schedule. You must include either this parameter or -Abort

    .PARAMETER Abort
    Switch parameter to indicate 'Soft abort' of the Schedule. You must include either this parameter or -Kill

    .PARAMETER Force
    Force the stoppage without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWSchedule] objects are accepted (including from the pipeline)

    .OUTPUTS
    An informational message is written to the screen unless -Quiet is used

    .EXAMPLE
    Stops a single Schedule

    Get-AutomateNOWSchedule -Id 'Schedule_01' | Stop-AutomateNOWSchedule -Abort

    .EXAMPLE
    Stops multiple Schedules

    @('Schedule1', 'Schedule2') | Get-AutomateNOWSchedule | Stop-AutomateNOWSchedule -Kill

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWSchedule]$Schedule,
        [Parameter(Mandatory = $true, ParameterSetName = 'Kill')]
        [switch]$Kill,
        [Parameter(Mandatory = $true, ParameterSetName = 'Abort')]
        [switch]$Abort,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($Kill -eq $true) {
            [string]$operation_id = 'kill'
        }
        Else {
            [string]$operation_id = 'abort'
        }
        [string]$command = ('/processing/' + $operation_id)
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id -gt 0) {
            [ANOWSchedule]$Schedule = $_
        }
        [int64]$Schedule_id = $Schedule.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Schedule_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [ANOWSchedule]$current_Schedule = Get-AutomateNOWSchedule -Id $Schedule_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWSchedule failed to check if the Schedule [$Schedule_id] existed under Restart-AutomateNOWSchedule due to [$Message]."
                Break
            }
            If ($current_Schedule.id.length -eq 0) {
                Write-Warning -Message "The Schedule you specified does not seem to exist (Stop-AutomateNOWSchedule)"
                Break
            }
            [string]$current_Schedule_status = $current_Schedule.processingStatus
            If ($current_Schedule_status -notin [ANOWProcessing_processingStatus].GetEnumNames()) {
                Write-Warning -Message "Somehow the processing status of the Schedule [$Schedule_id] cannot be read (Stop-AutomateNOWSchedule)"
                Break
            }
            If ($current_Schedule_status -in @('COMPLETED', 'FAILED')) {
                Write-Warning -Message "[$Schedule_id] cannot be stopped as it currently in [$current_Schedule_status] processing status"
                Break
            }
            Else {
                Write-Verbose -Message "[$Schedule_id] had a status of $current_Schedule_status"
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $Schedule_id )
            $BodyMetaData.Add('_operationType', 'custom')
            $BodyMetaData.Add('_operationId', $operation_id)
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Schedule_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Schedule $Schedule_id was successfully stopped"
        }
    }
    End {

    }
}

Function Resume-AutomateNOWSchedule {
    <#
    .SYNOPSIS
    Resumes a Schedule that is on hold (suspended) on an AutomateNOW! instance

    .DESCRIPTION
    Resumes a Schedule that is on hold (suspended) on an AutomateNOW! instance

    .PARAMETER Schedule
    An [ANOWSchedule] object representing the Schedule to be resumed

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWSchedule] objects are accepted (including from the pipeline)

    .OUTPUTS
    A verbose information message will be sent indicating success

    .EXAMPLE
    Get-AutomateNOWSchedule -Id 3576423 | Resume-AutomateNOWSchedule -Force

    .EXAMPLE
    @(3576423, 3576424) | Get-AutomateNOWSchedule | Resume-AutomateNOWSchedule

    .EXAMPLE
    Get-AutomateNOWSchedule | ? { $_.serverScheduleType -eq 'LINUX' } | Resume-AutomateNOWSchedule

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $True, ValueFromPipeline = $True)]
        [ANOWSchedule]$Schedule,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processing/resume'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWSchedule]$Schedule = $_
        }
        [int64]$Schedule_id = $Schedule.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Schedule_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [ANOWSchedule]$current_Schedule = Get-AutomateNOWSchedule -Id $Schedule_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWSchedule failed to check if the Schedule [$Schedule_id] existed under Resume-AutomateNOWSchedule due to [$Message]."
                Break
            }
            If ($current_Schedule.id.length -eq 0) {
                Write-Warning -Message "The Schedule you specified does not seem to exist (Resume-AutomateNOWSchedule)"
                Break
            }
            [boolean]$current_Schedule_hold_status = $current_Schedule.onHold
            If ($current_Schedule_hold_status -eq $false) {
                Write-Warning -Message "[$Schedule_id] cannot be resumed as it is not currently suspended (on hold)"
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $Schedule_id )
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_operationId', 'resume')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Schedule_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Schedule $Schedule_id successfully resumed"
        }
    }
    End {

    }
}

Function Suspend-AutomateNOWSchedule {
    <#
    .SYNOPSIS
    Places a Schedule on hold (suspend) from execution on an AutomateNOW! instance

    .DESCRIPTION
    Places a Schedule on hold (suspend) from execution on an AutomateNOW! instance

    .PARAMETER Schedule
    An [ANOWSchedule] object representing the Schedule to be suspended (placed on hold)

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWSchedule] objects are accepted (including from the pipeline)

    .OUTPUTS
    A verbose information message will be sent indicating success

    .EXAMPLE
    Get-AutomateNOWSchedule -Id 3576423 | Suspend-AutomateNOWSchedule -Force

    .EXAMPLE
    @( 3576423, 3576424 ) | Get-AutomateNOWSchedule | Suspend-AutomateNOWSchedule

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWSchedule]$Schedule,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processing/hold'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWSchedule]$Schedule = $_
        }
        [string]$Schedule_id = $Schedule.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Schedule_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [ANOWSchedule]$current_Schedule = Get-AutomateNOWSchedule -Id $Schedule_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWSchedule failed to check if the Schedule [$Schedule_id] existed under Resume-AutomateNOWSchedule due to [$Message]."
                Break
            }
            If ($current_Schedule.id.length -eq 0) {
                Write-Warning -Message "The Schedule you specified does not seem to exist (Resume-AutomateNOWSchedule)"
                Break
            }
            [boolean]$current_Schedule_hold_status = $current_Schedule.onHold
            If ($current_Schedule_hold_status -eq $true) {
                Write-Warning -Message "[$Schedule_id] cannot be suspended (placed on hold) as it is already suspended (on hold)"
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $Schedule_id )
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_operationId', 'hold')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Schedule_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Schedule $Schedule_id successfully suspended (placed on hold)"
        }
    }
    End {

    }
}

Function Skip-AutomateNOWSchedule {
    <#
    .SYNOPSIS
    Sets or unsets the Skip flag on a Schedule on an AutomateNOW! instance

    .DESCRIPTION
    Sets or unsets the Skip flag on a Schedule on an AutomateNOW! instance

    .PARAMETER Schedule
    An [ANOWSchedule] object representing the Schedule to be set to skipped or unskipped

    .PARAMETER UnSkip
    Removes the skip flag from an [ANOWSchedule] object. This is the opposite of the default behavior.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Switch parameter to silence the emitted [ANOWSchedule] object

    .INPUTS
    ONLY [ANOWSchedule] objects are accepted (including from the pipeline)

    .OUTPUTS
    The skipped/unskipped [ANOWSchedule] object will be returned

    .EXAMPLE
    Sets a Schedule to Skip (bypass)

    Get-AutomateNOWSchedule -Id 1234567 | Skip-AutomateNOWSchedule -Force

    .EXAMPLE
    Unsets the Skip (bypass) flag on a Schedule

    12374894 | Get-AutomateNOWSchedule | Skip-AutomateNOWSchedule -UnSkip

    .EXAMPLE
    Sets a group of Schedules to Skip (bypass) by passing their Id's across the pipeline

    @( 3576423, 3576423 ) | Skip-AutomateNOWSchedule

    .EXAMPLE
    Forcibly and quietly sets all Schedules of trigger type Self Service to skip (bypass)

    Get-AutomateNOWSchedule -triggerType SELF_SERVICE | Skip-AutomateNOWSchedule -Force -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWSchedule]$Schedule,
        [Parameter(Mandatory = $false)]
        [switch]$UnSkip,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnSkip -ne $True) {
            [string]$skip_flag_status = 'On'
            [string]$operation_id = 'passByOn'
            [string]$ProcessDescription = 'Add the Skip flag'
        }
        Else {
            [string]$skip_flag_status = 'Off'
            [string]$operation_id = 'passByOff'
            [string]$ProcessDescription = 'Remove the Skip flag'
        }
        [string]$command = ('/processing/' + $operation_id)
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWSchedule]$Schedule = $_
        }
        [string]$Schedule_id = $Schedule.id
        If ($Schedule.passBy -eq $true -and $UnSkip -ne $True) {
            Write-Warning -Message "Schedule $Schedule_id already has the skip flag set. No action is required."
            Break
        }
        ElseIf ($Schedule.passBy -eq $false -and $UnSkip -eq $True) {
            Write-Warning -Message "Schedule $Schedule_id does not have the skip flag set. No action is required."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess($Schedule_id, $ProcessDescription)) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $Schedule_id )
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_operationId', $operation_id)
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Schedule_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Successfully set the skip flag to [$skip_flag_status] on [$Schedule_id]"
        }
    }
    End {

    }
}

#endregion

#Region - Schedule Templates (PROCESSING_TEMPLATE)

Function Get-AutomateNOWScheduleTemplate {
    <#
    .SYNOPSIS
    Gets the Schedule templates from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Schedule templates from an AutomateNOW! instance

    .PARAMETER Id
    Optional string containing the simple id of the Schedule template to fetch or you can pipeline a series of simple id strings. You may not enter an array here.

    .PARAMETER triggerType
    Optional string to filter the results based on the type of trigger. Valid choices are: SCHEDULE, EVENT, SELF_SERVICE, USER, PROCESSING, SERVER_NODE

    .PARAMETER sortBy
    Optional string parameter to sort the results by. Valid choices are: id, processingType, simpleId, dateCreated, node, outOfSync, keepResourcesOnFailure, onHold, lastUpdated, highRisk, weight, ScheduleType, userIp, createdBy, lazyLoad, passBy, lastUpdatedBy, durationSum, serverNodeType, eagerScriptExecution, passResourceDependenciesToChildren, owner, checkedOut, estimatedDuration, passActionsToChildren. Defaults to id.

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER Folder
    Optional string to filter by a particular Folder

    .PARAMETER Tags
    Optional string array of Tags to filter by. Note that the 'containsAny' operator will be used.

    .INPUTS
    Accepts a string representing the simple id of the Schedule Template from the pipeline or individually (but not an array).

    .OUTPUTS
    An array of one or more [ANOWScheduleTemplate] class objects

    .EXAMPLE
    Gets the first page of Schedule Templates

    Get-AutomateNOWScheduleTemplate

    .EXAMPLE
    Gets a single Schedule Template named 'ScheduleTemplate1'

    Get-AutomateNOWScheduleTemplate -Id 'ScheduleTemplate1'

    .EXAMPLE
    Gets the first page of Schedule Templates of trigger type Schedule

    Get-AutomateNOWScheduleTemplate -triggerType SCHEDULE

    .EXAMPLE
    Gets the first page of Schedule Templates that are tagged with 'Tag1' or 'Tag2'

    Get-AutomateNOWScheduleTemplate -Tags 'Tag1', 'Tag2'

    .EXAMPLE
    Gets a series of Schedule Templates using their names across the pipeline

    'ScheduleTemplate1', 'ScheduleTemplate2' | Get-AutomateNOWScheduleTemplate

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    "Schedule Templates" in this module are known as "Schedules" in the console
    "Schedules" in this module are known as "Scheduled Items" in the console

    It's important to understand that Task Templates, Workflow Templates, Schedule Templates and Service Manager Templates are all essentially the same object, that is the "ProcessingTemplate" in the ANOW API. This module attempts to mimic the same human friendly divisions and categories of the Processing Templates that the console presents.

    #>
    [OutputType([ANOWScheduleTemplate[]])]
    [Cmdletbinding(DefaultParameterSetName = 'Default' )]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $False, ValueFromPipeline = $true, ParameterSetName = 'Default')]
        [string]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [ANOWProcessingTemplate_triggerType]$triggerType,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [ValidateSet('id', 'processingType', 'simpleId', 'dateCreated', 'node', 'outOfSync', 'keepResourcesOnFailure', 'onHold', 'lastUpdated', 'highRisk', 'weight', 'ScheduleType', 'userIp', 'createdBy', 'lazyLoad', 'passBy', 'lastUpdatedBy', 'durationSum', 'serverNodeType', 'eagerScriptExecution', 'passResourceDependenciesToChildren', 'owner', 'checkedOut', 'estimatedDuration', 'passActionsToChildren', ignoreCase = $false)]
        [string]$sortBy = 'id',
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [switch]$Descending,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [string[]]$tags,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [string]$Folder

    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 -or $Id.Length -gt 0) {
            If ($_.Length -gt 0 ) {
                $Body.'id' = $_
            }
            Else {
                $Body.'id' = $Id
            }
            $Body.'_operationId' = 'read'
            [string]$textMatchStyle = 'exactCase'
        }
        Else {
            $Body.'_constructor' = 'AdvancedCriteria'
            $Body.'operator' = 'and'
            $Body.'criteria1' = '{"fieldName":"processingType","operator":"equals","value":"TRIGGER"}'
            If ($triggerType.Length -gt 0) {
                $Body.'criteria2' = ('{"fieldName":"triggerType","operator":"equals","value":"' + $triggerType + '"}')
            }
            If ($Folder.Length -gt 0) {
                $Body.'criteria3' = ('{"fieldName":"folder","operator":"equals","value":"' + $Folder + '"}')
            }
            If ($Tags.Count -gt 0) {
                If ($Tags.Count -gt 1) {
                    $Error.Clear()
                    Try {
                        [string]$TagString = $Tags | ConvertTo-Json -Compress
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "ConvertTo-Json failed to convert the provided tag names under Get-AutomateNOWScheduleTemplate due to [$Message]."
                        Break
                    }
                }
                Else {
                    [string]$TagString = $Tags
                }
                $Body.'criteria4' = ('{"fieldName":"tags","operator":"containsAny","value":' + $TagString + '}')
            }
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
            $Body.'_componentId' = 'ScheduleList'
            [string]$textMatchStyle = 'exact'
        }
        $Body.'_operationType' = 'fetch'
        $Body.'_textMatchStyle' = $textMatchStyle
        $Body.'_dataSource' = 'ProcessingTemplateDataSource'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        If ($Descending -eq $true) {
            $Body.'_sortBy' = '-' + $sortBy
        }
        Else {
            $Body.'_sortBy' = $sortBy
        }
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/processingTemplate/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWScheduleTemplate[]]$ScheduleTemplates = ForEach ($result in $results.response.data) {
                If ($null -eq $result.description) {
                    $result | Add-Member NoteProperty -Name 'description' -Value ''
                }
                If ($null -eq $result.lastUpdatedBy) {
                    $result | Add-Member NoteProperty -Name 'lastUpdatedBy' -Value ''
                }
                [ANOWScheduleTemplate]$result
            }
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWScheduleTemplate] objects due to [$Message]."
            Break
        }
        If ($ScheduleTemplates.Count -gt 0) {
            If ($ScheduleTemplates.Count -eq 1 -and $ScheduleTemplates.processingType -ne 'TRIGGER') {
                [string]$processingType = $ScheduleTemplates.processingType
                If ($processingType -eq 'WORKFLOW') {
                    Write-Warning -Message "$Id is actually a Workflow Template. Please use Get-AutomateNOWWorkflowTemplate instead."
                }
                ElseIf ($processingType -in @('TASK', 'SERVICE')) {
                    Write-Warning -Message "$Id is actually a Task Template. Please use Get-AutomateNOWTaskTemplate instead."
                }
                Else {
                    Write-Warning -Message "Could not identify what type of template object [$processingType] is. Please look into this..."
                }
                Break
            }
            Return $ScheduleTemplates
        }
    }
    End {

    }
}

Function Set-AutomateNOWScheduleTemplate {
    <#
    .SYNOPSIS
    Changes the settings of a Schedule Template on an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of a Schedule Template on an AutomateNOW! instance

    .PARAMETER ScheduleTemplate
    An [ANOWScheduleTemplate] object representing the Schedule Template to be changed.

    .PARAMETER Description
    Optional description of the Schedule Template (may not exceed 255 characters).

    .PARAMETER UnsetDescription
    Optional switch that will remove the Description from the Schedule Template object.

    .PARAMETER Folder
    A string representing the name of the Folder to move the Schedule Template into.

    .PARAMETER UnsetFolder
    A switch parameter that will move the Schedule Template out of its current folder.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to include with this object.

    .PARAMETER UnsetTags
    A switch parameter that will remove the Tags from the Schedule Template

    .PARAMETER CodeRepository
    Optional Code Repository to place the Schedule Template into. Use Get-AutomateNOWCodeRepository to fetch this object.

    .PARAMETER UnsetCodeRepository
    Switch parameter that will remove the the Schedule Template from its Code Repository.

    .PARAMETER statisticalDuration
    A int64 number in milliseconds of the expected duration of the Task Template. The minimum/maximum is 1000/31536000000 (1 second/1 year). The default is 60000 (1 minute).

    .PARAMETER Quiet
    Switch parameter that silences the output of the updated object.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWScheduleTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWScheduleTemplate] object will be returned

    .EXAMPLE
    Forcefully and quietly sets the tags, folder and description on Schedule Template

    $schedule_template = Get-AutomateNOWScheduleTemplate -Id 'ScheduleTemplate01'
    Set-AutomateNOWScheduleTemplate -Scheduletemplate $schedule_template -Tags 'Tag1', 'Tag2' -Force -Quiet
    Set-AutomateNOWScheduleTemplate -Scheduletemplate $schedule_template -Folder 'Folder1' -Force -Quiet
    Set-AutomateNOWScheduleTemplate -Scheduletemplate $schedule_template -Description 'Descriptive text' -Force -Quiet

    .EXAMPLE
    Forcefully and quietly unsets the tags, folder and description on Schedule Template

    $schedule_template = Get-AutomateNOWScheduleTemplate -Id 'ScheduleTemplate01'
    Set-AutomateNOWScheduleTemplate -Scheduletemplate $schedule_template -UnsetTags -Force -Quiet
    Set-AutomateNOWScheduleTemplate -Scheduletemplate $schedule_template -UnsetFolder -Force -Quiet
    Set-AutomateNOWScheduleTemplate -Scheduletemplate $schedule_template -UnsetDescription -Force -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.
    #>
    [OutputType([ANOWScheduleTemplate])]
    [Cmdletbinding(SupportsShouldProcess, DefaultParameterSetName = 'Default', ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWScheduleTemplate]$ScheduleTemplate,
        [ValidateScript({ $_.Length -le 255 })]
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [string]$Description,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false, ParameterSetName = 'SetFolder')]
        [string]$Folder,
        [Parameter(Mandatory = $false, ParameterSetName = 'SetFolder')]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [string[]]$Tags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetCodeRepository,
        [ValidateRange(1000, 31536000000)]
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [int64]$statisticalDuration,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($Description.Length -gt 0 -and $UnsetDescription -eq $true) {
            Write-Warning -Message 'You cannot set the Description and unset it at the same time. Please choose one or the other.'
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Exit
        }
        If ($Tags.count -gt 0 -and $UnsetTags -eq $true) {
            Write-Warning -Message "You cannot set the tags and unset them at the same time. Please choose one or the other."
        }
        If ($UnsetCodeRepository -eq $true -and $CodeRepository.Id.Length -gt 0) {
            Write-Warning -Message "You cannot unset the Code Repository and set it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -or $Folder.Length -gt 0) {
            [string]$command = '/processingTemplate/setFolder'
            [string]$operationId = 'setFolder'
        }
        Else {
            [string]$command = '/processingTemplate/update'
            [string]$componentId = 'ProcessingTemplateValuesManager'
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWScheduleTemplate]$ScheduleTemplate = $_
        }
        [string]$ScheduleTemplate_id = $ScheduleTemplate.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ScheduleTemplate_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$ScheduleTemplate_exists = ($null -eq (Get-AutomateNOWScheduleTemplate -Id $ScheduleTemplate_id))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWScheduleTemplate failed to check if the Schedule Template [$ScheduleTemplate_id] already existed due to [$Message]."
                Break
            }
            If ($ScheduleTemplate_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not a Schedule Template named [$ScheduleTemplate_id] in the current domain [$current_domain]. Please check into this."
                Break
            }
            ## End warning ##
            [System.Collections.ArrayList]$include_properties = [System.Collections.ArrayList]@()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $ScheduleTemplate_id
            If ($Description.Length -gt 0) {
                $BodyMetaData.'description' = $Description
            }
            ElseIf ($UnsetDescription -eq $true) {
                $BodyMetaData.'description' = $null
                $include_properties += 'description'
            }
            If ($Folder.Length -gt 0) {
                $Error.Clear()
                Try {
                    [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the Folder [$Folder] actually existed while running under Set-AutomateNOWScheduleTemplate due to [$Message]"
                    Break
                }
                If ($folder_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] running under Set-AutomateNOWScheduleTemplate. Please check again."
                    Break
                }
                [string]$folder_display = $folder_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Adding Folder $folder_display to [ANOWScheduleTemplate] [$ScheduleTemplate_id]"
                $BodyMetaData.'folder' = $Folder
                $include_properties += 'folder'
            }
            ElseIf ($UnsetFolder -eq $true) {
                [string]$folder_display = $folder_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Removing [ANOWScheduleTemplate] [$ScheduleTemplate_id] from Folder $folder_display"
                $BodyMetaData.'folder' = $null
                $include_properties += 'folder'
            }
            If ($Tags.Count -gt 0) {
                [int32]$total_tags = $Tags.Count
                [int32]$current_tag = 1
                ForEach ($tag_id in $Tags) {
                    $Error.Clear()
                    Try {
                        [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] running under Set-AutomateNOWScheduleTemplate due to [$message]"
                        Break
                    }
                    If ($tag_object.simpleId.length -eq 0) {
                        Throw "Set-AutomateNOWScheduleTemplate has detected that the tag [$tag_id] does not appear to exist. Please check again."
                        Break
                    }
                    ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                        [string]$tag_object_simpleId = $tag_object.simpleId
                        Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                        Break
                    }
                    [string]$tag_display = $tag_object | ConvertTo-Json -Compress
                    Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
                    [string]$tag_name_sequence = ('tags' + $current_tag)
                    $BodyMetaData.Add($tag_name_sequence, $tag_id)
                    $include_properties += $tag_name_sequence
                    $current_tag++
                }
            }
            ElseIf ($UnsetTags -eq $true) {
                [string]$tags_display = ($Calendar.tags) | ConvertTo-Json -Compress
                Write-Verbose -Message "Removing tags [$tags_display] from [$ScheduleTemplate_id]"
                $BodyMetaData.'tags' = $null
                $include_properties += 'tags'
            }
            If ($CodeRepository.Id.Length -gt 0) {
                [string]$CodeRepository_Id = $CodeRepository.Id
                $Error.Clear()
                Try {
                    [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository_Id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository_Id] actually existed under Set-AutomateNOWScheduleTemplate due to [$Message]"
                    Break
                }
                If ($code_repository_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository_Id] under Set-AutomateNOWScheduleTemplate. Please check again."
                    Break
                }
                $BodyMetaData.'codeRepository' = $CodeRepository_Id
            }
            ElseIf ($UnsetCodeRepository -eq $true) {
                $BodyMetaData.'codeRepository' = $null
            }
            If ($statisticalDuration -ge 1000) {
                $BodyMetaData.'statisticalDuration' = $statisticalDuration
            }
            $BodyMetaData.'_operationType' = 'update'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_oldValues' = $ScheduleTemplate.CreateOldValues()
            If ($componentId.Length -gt 0) {
                $BodyMetaData.'_componentId' = $componentId
            }
            If ($operationId.Length -gt 0) {
                $BodyMetaData.'_operationId' = $operationId
            }
            $BodyMetaData.'_dataSource' = 'ProcessingTemplateDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties $include_properties
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ScheduleTemplate_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Schedule Template $ScheduleTemplate_id was successfully updated"
            $Error.Clear()
            Try {
                [ANOWScheduleTemplate]$UpdatedScheduleTemplate = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the response into an [ANOWScheduleTemplate] object (under Set-AutomateNOWScheduleTemplate) due to [$Message]."
                Break
            }
            If ($Quiet -ne $true) {
                Return $UpdatedScheduleTemplate
            }
        }
    }
    End {
    }
}

Function Export-AutomateNOWScheduleTemplate {
    <#
    .SYNOPSIS
    Exports the Schedule Templates from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Schedule Templates from an instance of AutomateNOW! to a local .csv file

    .INPUTS
    ONLY [ANOWScheduleTemplate] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWScheduleTemplate] objects are exported to the local disk in CSV format

    .EXAMPLE
    Get-AutomateNOWScheduleTemplate | Export-AutomateNOWScheduleTemplate

    .EXAMPLE
    Get-AutomateNOWScheduleTemplate -Id 'ScheduleTemplate01' | Export-AutomateNOWScheduleTemplate

    .EXAMPLE
    @( 'ScheduleTemplate01', 'ScheduleTemplate02' ) | Get-AutomateNOWScheduleTemplate | Export-AutomateNOWScheduleTemplate

    .NOTES
	You must present [ANOWScheduleTemplate] objects to the pipeline to use this function.

    "Schedule Templates" in this module are known as "Schedules" in the console
    "Schedules" in this module are known as "Scheduled Items" in the console
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWScheduleTemplate]$ScheduleTemplate
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-ScheduleTemplates-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWScheduleTemplate]$ScheduleTemplate = $_
        }
        $Error.Clear()
        Try {
            $ScheduleTemplate | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWScheduleTemplate] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function New-AutomateNOWScheduleTemplate {
    <#
    .SYNOPSIS
    Creates a Schedule Template within an AutomateNOW! instance

    .DESCRIPTION
    Creates a Schedule Template within an AutomateNOW! instance and returns back the newly created [ANOWScheduleTemplate] object

    .PARAMETER ScheduleType
    Type of the Schedule Template. Valid options are: SCHEDULE, EVENT, SELF_SERVICE, USER, PROCESSING, SERVER_NODE

    .PARAMETER Id
    Mandatory "name" of the Schedule Template. For example: 'LinuxScheduleTemplate1'. This value may not contain the domain in brackets. This is the unique key of this object.

    .PARAMETER Description
    Optional description of the Schedule Template (may not exceed 255 characters).

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to include with this object.

    .PARAMETER Folder
    Optional string representing the Folder to place this object into.

    .PARAMETER CodeRepository
    Optional string representing the Code Repository to place this object into.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWScheduleTemplate.

    .OUTPUTS
    An [ANOWScheduleTemplate] object representing the newly created Schedule Template. Use the -Quiet parameter to suppress this.

    .EXAMPLE
    Creates a new Schedule Template

    New-AutomateNOWScheduleTemplate -ScheduleType SCHEDULE -Id 'ScheduleTemplate01' -Description 'Description text' -Tags 'Tag1', 'Tag2' -Folder 'Folder1'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The name (id) of the Schedule Template must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    SELF_SERVICE ARE NOT SUPPORTED YET BECAUSE INTEGRATION OBJECTS ARE NOT ADDED YET

    #>
    [OutputType([ANOWScheduleTemplate])]
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWProcessingTemplate_triggerType]$ScheduleType,
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $true)]
        [string]$Id,
        [ValidateScript({ $_.Length -le 255 })]
        [Parameter(Mandatory = $false, HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [string]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    If ($ScheduleType -notin ('SCHEDULE', 'EVENT', 'SELF_SERVICE')) {
        Write-Warning -Message "Schedule Type [$ScheduleType] is not supported in this module yet"
        Break
    }
    If ($ScheduleType -eq 'SELF_SERVICE') {
        Write-Warning -Message 'Support for Self Service Schedule Templates is pending support for Integration objects :|'
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [boolean]$ScheduleTemplate_exists = ($null -ne (Get-AutomateNOWScheduleTemplate -Id $Id))
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWScheduleTemplate failed to check if the Schedule Template [$Id] already existed due to [$Message]."
        Break
    }
    If ($ScheduleTemplate_exists -eq $true) {
        [string]$current_domain = $anow_session.header.domain
        Write-Warning -Message "There is already a Schedule Template named [$Id] in [$current_domain]. Please check into this."
        Break
    }
    ## End warning ##
    [System.Collections.Specialized.OrderedDictionary]$ANOWScheduleTemplate = [System.Collections.Specialized.OrderedDictionary]@{}
    [string]$old_values = ('{"processingType":"TRIGGER","triggerType":"' + $ScheduleType + '"}')
    $ANOWScheduleTemplate.Add('id', $Id)
    $ANOWScheduleTemplate.Add('processingType', 'TRIGGER')
    $ANOWScheduleTemplate.Add('triggerType', $ScheduleType)
    $ANOWScheduleTemplate.Add('serverNodeType', $ServerNodeType)
    $ANOWScheduleTemplate.Add('_oldValues', $old_values)

    [string[]]$include_properties = 'id', 'processingType', 'ScheduleType'
    If ($Integration.Id.Length -gt 0) {
        [string]$Integration_Id = $Integration.Id
        $ANOWScheduleTemplate.Add('integration', $Integration_Id)
        $ANOWScheduleTemplate.Add('integrationType', 'TEMPLATE')
    }
    If ($Description.Length -gt 0) {
        $ANOWScheduleTemplate.Add('description', $Description)
        $include_properties += 'description'
    }
    If ($Tags.Count -gt 0) {
        [int32]$total_tags = $Tags.Count
        [int32]$current_tag = 1
        ForEach ($tag_id in $Tags) {
            $Error.Clear()
            Try {
                [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] running under New-AutomateNOWScheduleTemplate due to [$message]"
                Break
            }
            If ($tag_object.simpleId.length -eq 0) {
                Throw "New-AutomateNOWScheduleTemplate has detected that the tag [$tag_id] does not appear to exist. Please check again."
                Break
            }
            ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                [string]$tag_object_simpleId = $tag_object.simpleId
                Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                Break
            }
            [string]$tag_display = $tag_object | ConvertTo-Json -Compress
            Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
            [string]$tag_name_sequence = ('tags' + $current_tag)
            $ANOWScheduleTemplate.Add($tag_name_sequence, $tag_id)
            $include_properties += $tag_name_sequence
            $current_tag++
        }
    }
    If ($Folder.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] actually existed while running under New-AutomateNOWScheduleTemplate due to [$Message]"
            Break
        }
        If ($folder_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] running under New-AutomateNOWScheduleTemplate. Please check again."
            Break
        }
        [string]$folder_display = $folder_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding folder $folder_display to [ANOWScheduleTemplate] [$Id]"
        $ANOWScheduleTemplate.Add('folder', $Folder)
        $include_properties += 'folder'
    }
    If ($CodeRepository.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository] actually existed while running under New-AutomateNOWScheduleTemplate due to [$Message]"
            Break
        }
        If ($code_repository_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository] running under New-AutomateNOWScheduleTemplate. Please check again."
            Break
        }
        [string]$code_repository_display = $code_repository_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding code repository $code_repository_display to [ANOWScheduleTemplate] [$Id]"
        $ANOWScheduleTemplate.Add('codeRepository', $CodeRepository)
        $include_properties += 'codeRepository'
    }
    [string]$BodyObject = ConvertTo-QueryString -InputObject $ANOWScheduleTemplate -IncludeProperties $include_properties
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_operationType' = 'add'
    $BodyMetaData.'_oldValues' = $old_values
    $BodyMetaData.'_componentId' = 'ProcessingTemplateCreateWindow_form'
    $BodyMetaData.'_dataSource' = 'ProcessingTemplateDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$BodyMetaDataString = ConvertTo-QueryString -InputObject $BodyMetaData
    [string]$Body = ($BodyObject + '&' + $BodyMetaDataString)
    [string]$command = '/processingTemplate/create'
    [hashtable]$parameters = @{}
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('Body', $Body)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWScheduleTemplate]$ScheduleTemplate = $results.response.data | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to create [ANOWScheduleTemplate] object due to [$Message]."
        Break
    }
    If ($ScheduleTemplate.id.Length -eq 0) {
        Write-Warning -Message "Somehow the newly created [ANOWScheduleTemplate] is empty!"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWScheduleTemplate]$ScheduleTemplate = Get-AutomateNOWScheduleTemplate -Id $Id
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWScheduleTemplate failed to confirm that the [ANOWScheduleTemplate] object [$Id] was created due to [$Message]."
        Break
    }
    If ($Quiet -ne $true) {
        Return $ScheduleTemplate
    }
}

Function Remove-AutomateNOWScheduleTemplate {
    <#
    .SYNOPSIS
    Removes a Schedule Template from an AutomateNOW! instance

    .DESCRIPTION
    Removes a Schedule Template from an AutomateNOW! instance

    .PARAMETER ScheduleTemplate
    An [ANOWScheduleTemplate] object representing the Schedule Template to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWScheduleTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Get-AutomateNOWScheduleTemplate -Id 'ScheduleTemplate01' | Remove-AutomateNOWScheduleTemplate

    .EXAMPLE
    Get-AutomateNOWScheduleTemplate -Id 'ScheduleTemplate01', 'ScheduleTemplate02' | Remove-AutomateNOWScheduleTemplate

    .EXAMPLE
    @( 'ScheduleTemplate1', 'ScheduleTemplate2', 'ScheduleTemplate3') | Remove-AutomateNOWScheduleTemplate

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWScheduleTemplate]$ScheduleTemplate,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processingTemplate/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWScheduleTemplate]$ScheduleTemplate = $_
        }
        [string]$ScheduleTemplate_id = $ScheduleTemplate.id
        If ($ScheduleTemplate_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ScheduleTemplate_id)")) -eq $true) {
            [string]$oldvalues = $ScheduleTemplate.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $ScheduleTemplate_id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'ScheduleList'
            $BodyMetaData.'_dataSource' = 'ProcessingTemplateDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ScheduleTemplate_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$error_message = $results.response.data
                If ($error_message -match 'Object may still be in use') {
                    [string]$ScheduleTemplate_id_formatted = $ScheduleTemplate_id -split '\]' | Select-Object -Last 1
                    Write-Warning -Message "This object $ScheduleTemplate_id_formatted is still in use somewhere therefore it cannot be removed! Please use 'Find-AutomateNOWObjectReferral -Object $ScheduleTemplate_id_formatted' to list the references for this object and then remove them."
                }
                Else {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
            }
            Write-Verbose -Message "Schedule $ScheduleTemplate_id successfully removed"
        }
    }
    End {

    }
}

Function Copy-AutomateNOWScheduleTemplate {
    <#
    .SYNOPSIS
    Copies a Schedule Template from an AutomateNOW! instance

    .DESCRIPTION
    Copies a Schedule Template from an AutomateNOW! instance. AutomateNOW object id can never be changed, but we can copy the object to a new id and it will include all of the items therein.

    .PARAMETER ScheduleTemplate
    Mandatory [ANOWScheduleTemplate] object to be copied.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the Schedule Template. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER UnsetTags
    Optional switch that will purposely omit the previously existing tags on the new copy of the Schedule Template. You can still specify new tags with -Tags but the old previous ones will not be carried over. In the UI, this is accomplished by clicking the existing tags off.

    .PARAMETER UnsetFolder
    Optional switch that will ensure that the newly created Schedule Template will not be placed in a folder.

    .PARAMETER UnsetDescription
    Optional switch that will ensure that the newly created Schedule Template will not carry over its previous description.

    .PARAMETER Description
    Optional description of the Schedule Template (may not exceed 255 characters). You may send an empty string here to ensure that the description is blanked out. Do not use this parameter if your intention is to keep the description from the previous Schedule Template.

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new Schedule Template.

    .PARAMETER Folder
    Optional name of the folder to place the Schedule Template into. The UnsetFolder parameter overrides this setting.

    .PARAMETER Force
    Force the copy without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    ONLY [ANOWScheduleTemplate] objects are accepted. Pipeline support is intentionally unavailable.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    This is a safe standard example that is recommended

    $Schedule01 = Get-AutomateNOWScheduleTemplate -Id 'old_name_ScheduleTemplate01'
    Copy-AutomateNOWScheduleTemplate -ScheduleTemplate $ScheduleTemplate01 -NewId 'new_name_ScheduleTemplate02'

    .EXAMPLE
    This is a one-liner approach

    Copy-AutomateNOWScheduleTemplate -ScheduleTemplate (Get-AutomateNOWScheduleTemplate -Id 'old_name_ScheduleTemplate01') -NewId 'new_name_ScheduleTemplate02'

    .EXAMPLE
    This approach users a For Each loop to iterate through a standard renaming pattern. This approach is not recommended.

    @( 'ScheduleTemplate1', 'ScheduleTemplate2', 'ScheduleTemplate3') | Get-AutomateNOWScheduleTemplate | ForEachObject { Copy-AutomateNOWScheduleTemplate -ScheduleTemplate $_ -NewId ($_.simpleId -replace 'Schedule[0-9]', ()'Schedule-' + $_.simpleId[-1]))}

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The new id (name) of the Schedule Template must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.
    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWScheduleTemplate]$ScheduleTemplate,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$Schedule_template_exists = ($null -ne (Get-AutomateNOWScheduleTemplate -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWScheduleTemplate failed to check if the Schedule template [$NewId] already existed due to [$Message]."
            Break
        }
        If ($Schedule_template_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Schedule Template named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End warning ##
        [string]$command = '/processingTemplate/copy'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            [string]$ScheduleTemplate_oldId = $ScheduleTemplate.id
            [string]$ScheduleTemplate_simpleId = $ScheduleTemplate.simpleId
            If ($ScheduleTemplate_oldId -eq $NewId) {
                Write-Warning -Message "The new id cannot be the same as the old id."
                Break
            }
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Copy the Schedule Template $($ScheduleTemplate_simpleId) to $($NewId)?")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                $BodyMetaData.'oldId' = $ScheduleTemplate_oldId
                $BodyMetaData.'domain' = $ScheduleTemplate.domain
                $BodyMetaData.'id' = $NewId
                If ($UnsetDescription -ne $true) {
                    If ($Description.Length -gt 0) {
                        $BodyMetaData.'description' = $Description
                    }
                    Else {
                        $BodyMetaData.'description' = $ScheduleTemplate.description
                    }
                }
                If ($UnsetFolder -ne $True) {
                    If ($Folder.Length -gt 0) {
                        $BodyMetaData.'folder' = $Folder
                    }
                    Else {
                        $BodyMetaData.'folder' = $ScheduleTemplate.folder
                    }
                }
                [int32]$tag_count = 1
                If ($Tags.Count -gt 0) {
                    ForEach ($tag in $Tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
                If ($UnsetTags -ne $true) {
                    If ($ScheduleTemplate.tags -gt 0) {
                        ForEach ($tag in $ScheduleTemplate.tags) {
                            $BodyMetaData.('tags' + $tag_count ) = $tag
                            $tag_count++
                        }
                    }
                }
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_operationId' = 'copy'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_dataSource' = 'ProcessingTemplateDataSource'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties oldId, domain, NewId, description, folder
                [string]$Body = $Body -replace '&tags[0-9]{1,}', '&tags'
                $parameters.Body = $Body
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ScheduleTemplate_id] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                $Error.Clear()
                Try {
                    [ANOWScheduleTemplate]$ScheduleTemplate = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to create copied [ANOWScheduleTemplate] object due to [$Message]."
                    Break
                }
                If ($ScheduleTemplate.id.Length -eq 0) {
                    Write-Warning -Message "Somehow the newly created (copied) [ANOWScheduleTemplate] object is empty!"
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $ScheduleTemplate
                }
            }
        }
    }
    End {

    }
}

Function Rename-AutomateNOWScheduleTemplate {
    <#
    .SYNOPSIS
    Renames a Schedule Template from an AutomateNOW! instance

    .DESCRIPTION
    Performs a psuedo-rename operations of a Schedule Template from an AutomateNOW! instance by copying it first and then deleting the source. This function merely combines Copy-AutomateNOWScheduleTemplate and Remove-AutomateNOWScheduleTemplate therefore it is to be considered destructive.

    .PARAMETER ScheduleTemplate
    An [ANOWScheduleTemplate] object representing the Schedule Template to be renamed.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the Schedule Template. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER Force
    Force the renaming without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly renamed object.

    .INPUTS
    ONLY [ANOWScheduleTemplate] objects are accepted. There is intentionally no support for the pipeline.

    .OUTPUTS
    The newly renamed [ANOWScheduleTemplate] object will be returned.

    .EXAMPLE
    $Schedule_template = Get-AutomateNOWScheduleTemplate -Id 'Schedule01'
    Rename-AutomateNOWScheduleTemplate -ScheduleTemplate $Schedule_template -NewId 'Schedule_TEMPLATE_01'

    .EXAMPLE
    Rename-AutomateNOWScheduleTemplate -ScheduleTemplate (Get-AutomateNOWScheduleTemplate -Id 'Schedule01') -NewId 'Schedule_TEMPLATE_01'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    When renaming, you may only specify a different Id (name).

    This action will be blocked if any existing referrals are found on the object.
    #>
    [OutputType([ANOWScheduleTemplate])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWScheduleTemplate]$ScheduleTemplate,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin standard warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$new_Schedule_template_exists = ($null -ne (Get-AutomateNOWScheduleTemplate -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWScheduleTemplate failed to check if the Schedule Template [$NewId] already existed due to [$Message]."
            Break
        }
        If ($new_Schedule_template_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Schedule Template named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        [string]$ScheduleTemplate_id = $ScheduleTemplate.id
        $Error.Clear()
        Try {
            [boolean]$old_Schedule_template_exists = ($null -ne (Get-AutomateNOWScheduleTemplate -Id $ScheduleTemplate_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWScheduleTemplate failed to check if the Schedule Template [$ScheduleTemplate_id] already existed due to [$Message]."
            Break
        }
        If ($old_Schedule_template_exists -eq $false) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not a Schedule Template named [$ScheduleTemplate_id] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End standard warning ##
        ## Begin referrals warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [int32]$referrals_count = Find-AutomateNOWObjectReferral -ScheduleTemplate $ScheduleTemplate -Count | Select-Object -Expandproperty referrals
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Find-AutomateNOWObjectReferral failed to extract the referrals on Schedule Template [$ScheduleTemplate_id] due to [$Message]."
            Break
        }
        If ($referrals_count -gt 0) {
            Write-Warning -Message "Unfortunately, you cannot rename a Schedule Template that has referrals. This is because the rename is not actually renaming but copying anew and deleting the old. Please, use the Find-AutomateNOWObjectReferral function to identify referrals and remove them."
            Break
        }
        Else {
            Write-Verbose -Message "The Schedule Template [$ScheduleTemplate_id] does not have any referrals. It is safe to proceed."
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ScheduleTemplate_id)")) -eq $true) {
                $Error.Clear()
                Try {
                    [ANOWScheduleTemplate]$new_Schedule_template = Copy-AutomateNOWScheduleTemplate -ScheduleTemplate $ScheduleTemplate -NewId $NewId -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Copy-AutomateNOWScheduleTemplate failed to create a new Schedule Template [$NewId] as Part 1 of the renaming process due to [$Message]."
                    Break
                }
                If ($new_Schedule_template.simpleId -eq $NewId) {
                    Write-Verbose -Message "Part 1: Schedule Template [$ScheduleTemplate_id] successfully copied to [$NewId]"
                }
                Else {
                    Write-Warning -Message "Somehow the first phase (Copy-AutomateNOWScheduleTemplate) failed. Please look into this."
                    Break
                }
                $Error.Clear()
                Try {
                    Remove-AutomateNOWScheduleTemplate -ScheduleTemplate $ScheduleTemplate -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Remove-AutomateNOWScheduleTemplate failed to remove [$ScheduleTemplate_id] as Part 2 of the renaming process due to [$Message]."
                    Break
                }
                Write-Verbose -Message "Part 2: Schedule Template [$ScheduleTemplate_id] removed"
                Write-Verbose -Message "Schedule [$ScheduleTemplate_id] successfully renamed to [$NewId]"
                If ($Quiet -ne $true) {
                    Return $new_Schedule_template
                }
            }
        }
        Else {
            Write-Warning -Message "No action was taken because either the source object didn't exist or the new object already existed"
        }
    }
    End {
    }
}

Function Start-AutomateNOWScheduleTemplate {
    <#
    .SYNOPSIS
    Starts a Schedule Template from an AutomateNOW! instance

    .DESCRIPTION
    Starts (executes) a Schedule Template from an AutomateNOW! instance

    .PARAMETER ScheduleTemplate
    An [ANOWScheduleTemplate] object representing the Schedule Template to be started.

    .PARAMETER ScheduleTemplateId
    A string representing the Id of the Schedule Template. Do not include the domain prefix.

    .PARAMETER ScheduleParameters
    An optional [hashtable] containing the parameters to start the Task Template with. Example: @{"parameter1"="ABC";"parameter2"="123";}

    .PARAMETER Description
    Optional description of the executed Schedule (may not exceed 255 characters).

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new Schedule.

    .PARAMETER Folder
    Optional name of the folder to place the executed Schedule into.

    .PARAMETER processingTimestamp
    An optional datetime object specifying a unique timestamp on this schedule to distinguish it from others. Do not use this option unless you need to. The default is now.

    .PARAMETER DelayedStartTime
    Optional string that allows processing items to start on a specific date or time or delay the execution for a period ranging from days to seconds. Example 1: 2029-12-31, Example 2: 2029-12-31 23:59:59, Example 3: 23:59:59

    .PARAMETER TimeZone
    Optional [ANOWTimeZone] object that modifies (it is unknown exactly what this property modifies since it is not defined in the documentation yet)

    .PARAMETER Priority
    Optional integer between 0 and 1000 to specify the priority of the executed Schedule. Defaults to 0.

    .PARAMETER Hold
    Optional switch to set the 'On Hold' property of the executed Schedule to enabled. This is $false by default but in the console the checkbox is enabled.

    .PARAMETER VerboseMode
    Optional switch that will cause the Workflow to "produce more events with minor performance impact"

    .PARAMETER ForceLoad
    Optional switch that overrides any 'Ignore Condition' that might exist on the Schedule Template

    .PARAMETER Quiet
    Switch parameter to silence the newly created [ANOWSchedule] object

    .INPUTS
    ONLY [ANOWScheduleTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    An [ANOWSchedule] object representing the started Schedule will be returned.

    .EXAMPLE
    Get-AutomateNOWScheduleTemplate -Id 'ScheduleTemplate_01' | Start-AutomateNOWScheduleTemplate

    .EXAMPLE
    Get-AutomateNOWScheduleTemplate -Id 'ScheduleTemplate_01' | Start-AutomateNOWScheduleTemplate -Name 'Manual Execution - ScheduleTemplate_01' -Tags 'Tag1', 'Tag2' -ForceLoad -Hold -Priority 100 -Description 'My executed Schedule'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This function is under construction as the [ANOWSchedule] class object it returns is not defined yet. You can still use this function but the output is experimental.

    #>
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'Object', ValueFromPipeline = $True)]
        [ANOWScheduleTemplate]$ScheduleTemplate,
        [Parameter(Mandatory = $true, ParameterSetName = 'Id')]
        [string]$ScheduleTemplateId,
        [Parameter(Mandatory = $false)]
        [hashtable]$ScheduleParameters,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [string]$Folder = '',
        [Parameter(Mandatory = $false)]
        [datetime]$processingTimestamp,
        [ValidateScript({ $_ -match '([0-9]{4}-[0-9]{2}-[0-9]{2}){0,}( {0,}[0-9]{2}:[0-9]{2}:[0-9]{2}){0,}' })]
        [Parameter(Mandatory = $false)]
        [string]$DelayedStartTime,
        [Parameter(Mandatory = $false)]
        [ANOWTimeZone]$TimeZone,
        [ValidateRange(0, 1000)]
        [Parameter(Mandatory = $false)]
        [int32]$Priority = 0,
        [Parameter(Mandatory = $false)]
        [switch]$Hold,
        [Parameter(Mandatory = $false)]
        [switch]$VerboseMode,
        [Parameter(Mandatory = $false)]
        [switch]$ForceLoad,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processing/executeScheduleNow'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [string]$domain = $anow_session.current_domain
        If ($_.id.Length -gt 0) {
            [string]$ScheduleTemplate_id = $_.id
        }
        ElseIf ($ScheduleTemplateId.Length -gt 0) {
            [string]$ScheduleTemplate_Id = ('[' + $domain + ']' + $ScheduleTemplateId)
        }
        ElseIf ($Id.Length -gt 0) {
            [string]$ScheduleTemplate_Id = ('[' + $domain + ']' + $Id)
        }
        Else {
            [string]$ScheduleTemplate_id = $ScheduleTemplate.id
        }
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        $BodyMetaData.Add('id', $ScheduleTemplate_id )
        $BodyMetaData.Add('runId', $ScheduleTemplate_id )
        $BodyMetaData.Add('priority', $priority )
        If ($null -ne $TimeZone) {
            [string]$timezone_id = ($TimeZone.id)
            $BodyMetaData.Add('timeZone', $timezone_id )
        }
        If ($null -eq $processingTimestamp) {
            [string]$processingTimestamp = Get-Date -Date ((Get-Date).ToUniversalTime()) -Format 'yyyy-MM-ddTHH:mm:ss.fff'
        }
        Else {
            [string]$processingTimestamp = Get-Date -Date $processingTimestamp -Format 'yyyy-MM-ddTHH:mm:ss.fff'
        }
        $BodyMetaData.Add('processingTimestamp', $processingTimestamp)
        [string[]]$include_properties = 'id', 'runId', 'priority', 'processingTimestamp', 'hold', 'forceLoad', 'name'
        If ($Tags.Count -gt 0) {
            [int32]$total_tags = $Tags.Count
            [int32]$current_tag = 1
            ForEach ($tag_id in $Tags) {
                $Error.Clear()
                Try {
                    [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] under Start-AutomateNOWScheduleTemplate due to [$message]"
                    Break
                }
                If ($tag_object.simpleId.length -eq 0) {
                    Throw "Start-AutomateNOWScheduleTemplate has detected that the tag [$tag_id] does not appear to exist. Please check again."
                    Break
                }
                ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                    [string]$tag_object_simpleId = $tag_object.simpleId
                    Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                    Break
                }
                [string]$tag_display = $tag_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
                [string]$tag_name_sequence = ('tags' + $current_tag)
                $BodyMetaData.Add($tag_name_sequence, $tag_id)
                $include_properties += $tag_name_sequence
                $current_tag++
            }
        }
        If ($folder.Length -gt 0) {
            $Error.Clear()
            Try {
                [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWFolder had an error while retrieving the folder [$folder] under Start-AutomateNOWScheduleTemplate due to [$message]"
                Break
            }
            If ($folder_object.simpleId.Length -eq 0) {
                Throw "Start-AutomateNOWScheduleTemplate has detected that the folder [$folder] does not appear to exist. Please check again."
                Break
            }
            $BodyMetaData.Add('folder', $folder)
            $include_properties += $folder
        }
        If ($hold -ne $true) {
            $BodyMetaData.Add('hold', 'false')
        }
        Else {
            $BodyMetaData.Add('hold', 'true')
        }
        If ($VerboseMode -ne $true) {
            $BodyMetaData.Add('verboseMode', 'true')
        }
        Else {
            $BodyMetaData.Add('verboseMode', 'true')
        }
        If ($forceLoad -ne $true) {
            $BodyMetaData.Add('forceLoad', 'false')
        }
        Else {
            $BodyMetaData.Add('forceLoad', 'true')
        }
        If ($ScheduleParameters.Count -gt 0) {
            $Error.Clear()
            Try {
                [string]$task_parameters_json = $ScheduleParameters | ConvertTo-Json -Compress
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "ConvertTo-Json failed to execute the provided parameters to Start-AutomateNOWTaskTemplate due to [$Message]."
                Break
            }
            $BodyMetaData.Add('parameters', $task_parameters_json)
        }
        Else {
            $BodyMetaData.Add('parameters', '{}')
        }
        $BodyMetaData.Add('_operationType', 'update')
        $BodyMetaData.Add('_operationId', 'executeScheduleNow')
        $BodyMetaData.Add('_textMatchStyle', 'exact')
        $BodyMetaData.Add('_dataSource', 'ProcessingDataSource')
        $BodyMetaData.Add('isc_metaDataPrefix', '_')
        $BodyMetaData.Add('isc_dataFormat', 'json')
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        If ($null -eq $parameters.Body) {
            $parameters.Add('Body', $Body)
        }
        Else {
            $parameters.Body = $Body
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ScheduleTemplate_id] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        Write-Verbose -Message "Schedule $ScheduleTemplate_id successfully started"
        $Error.Clear()
        Try {
            [ANOWSchedule]$ANOWSchedule = $results.response.data | Select-Object -First 1
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Unable to create the [ANOWSchedule] object under Start-AutomateNOWScheduleTemplate from the response due to [$Message]."
            Break
        }
        If ($Quiet -ne $true) {
            Return $ANOWSchedule
        }
    }
    End {

    }
}

Function Resume-AutomateNOWScheduleTemplate {
    <#
    .SYNOPSIS
    Resumes a Schedule Template that is on hold (suspended) on an AutomateNOW! instance

    .DESCRIPTION
    Resumes a Schedule Template that is on hold (suspended) on an AutomateNOW! instance

    .PARAMETER ScheduleTemplate
    An [ANOWScheduleTemplate] object representing the Schedule Template to be resumed

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Switch parameter to silence the emitted [ANOWScheduleTemplate] object

    .INPUTS
    ONLY [ANOWScheduleTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    The resumed [ANOWScheduleTemplate] object will be returned

    .EXAMPLE
    Get-AutomateNOWScheduleTemplate -Id 'Schedule01' | Resume-AutomateNOWScheduleTemplate -Force

    .EXAMPLE
    Get-AutomateNOWScheduleTemplate -Id 'ScheduleTemplate01', 'ScheduleTemplate02' | Resume-AutomateNOWScheduleTemplate

    .EXAMPLE
    @( 'ScheduleTemplate1', 'ScheduleTemplate2', 'ScheduleTemplate3') | Get-AutomateNOWScheduleTemplate | Resume-AutomateNOWScheduleTemplate

    .EXAMPLE
    Get-AutomateNOWScheduleTemplate | ? { $_.ScheduleType -eq 'SELF_SERVICE' } | Resume-AutomateNOWScheduleTemplate

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWScheduleTemplate]$ScheduleTemplate,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processingTemplate/resume'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWScheduleTemplate]$ScheduleTemplate = $_
        }
        [string]$ScheduleTemplate_id = $ScheduleTemplate.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ScheduleTemplate_id)")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $ScheduleTemplate_id )
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_operationId', 'resume')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingTemplateDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ScheduleTemplate_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            $Error.Clear()
            Try {
                [ANOWScheduleTemplate]$resumed_Schedule_template = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to create the [ANOWScheduleTemplate] object after resuming [$ScheduleTemplate_id] due to [$Message]."
                Break
            }
            Write-Verbose -Message "Schedule $ScheduleTemplate_id successfully resumed"
            If ($Quiet -ne $true) {
                Return $resumed_Schedule_template
            }
        }
    }
    End {

    }
}

Function Suspend-AutomateNOWScheduleTemplate {
    <#
    .SYNOPSIS
    Places a Schedule Template on hold (suspend) from execution on an AutomateNOW! instance

    .DESCRIPTION
    Places a Schedule Template on hold (suspend) from execution on an AutomateNOW! instance

    .PARAMETER ScheduleTemplate
    An [ANOWScheduleTemplate] object representing the Schedule Template to be suspended (placed on hold)

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Switch parameter to silence the emitted [ANOWScheduleTemplate] object

    .INPUTS
    ONLY [ANOWScheduleTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    The suspended [ANOWScheduleTemplate] object will be returned

    .EXAMPLE
    Get-AutomateNOWScheduleTemplate -Id 'Schedule01' | Suspend-AutomateNOWScheduleTemplate -Force

    .EXAMPLE
    Get-AutomateNOWScheduleTemplate -Id 'ScheduleTemplate01', 'ScheduleTemplate02' | Suspend-AutomateNOWScheduleTemplate

    .EXAMPLE
    @( 'ScheduleTemplate1', 'ScheduleTemplate2', 'ScheduleTemplate3') | Get-AutomateNOWScheduleTemplate | Suspend-AutomateNOWScheduleTemplate

    .EXAMPLE
    Get-AutomateNOWScheduleTemplate | ? { $_.ScheduleType -eq 'SELF_SERVICE' } | Suspend-AutomateNOWScheduleTemplate

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWScheduleTemplate]$ScheduleTemplate,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processingTemplate/hold'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWScheduleTemplate]$ScheduleTemplate = $_
        }
        [string]$ScheduleTemplate_id = $ScheduleTemplate.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ScheduleTemplate_id)")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $ScheduleTemplate_id )
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_operationId', 'hold')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingTemplateDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ScheduleTemplate_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            $Error.Clear()
            Try {
                [ANOWScheduleTemplate]$suspended_Schedule_template = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to create the [ANOWScheduleTemplate] object after suspending [$ScheduleTemplate_id] due to [$Message]."
                Break
            }
            Write-Verbose -Message "Schedule $ScheduleTemplate_id successfully suspended (placed on hold)"
            If ($Quiet -ne $true) {
                Return $suspended_Schedule_template
            }
        }
    }
    End {

    }
}

Function Skip-AutomateNOWScheduleTemplate {
    <#
    .SYNOPSIS
    Sets or unsets the Skip flag on a Schedule Template on an AutomateNOW! instance

    .DESCRIPTION
    Sets or unsets the Skip flag on a Schedule Template on an AutomateNOW! instance

    .PARAMETER ScheduleTemplate
    An [ANOWScheduleTemplate] object representing the Schedule Template to be set to skipped or unskipped

    .PARAMETER UnSkip
    Removes the skip flag from a [ANOWScheduleTemplate] object. This is the opposite of the default behavior.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Switch parameter to silence the emitted [ANOWScheduleTemplate] object

    .INPUTS
    ONLY [ANOWScheduleTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    The skipped/unskipped [ANOWScheduleTemplate] object will be returned

    .EXAMPLE
    Sets a Schedule Template to Skip (bypass)

    Get-AutomateNOWScheduleTemplate -Id 'ScheduleTemplate01' | Skip-AutomateNOWScheduleTemplate -Force

    .EXAMPLE
    Unsets the Skip (bypass) flag on a Schedule Template

    Get-AutomateNOWScheduleTemplate | Skip-AutomateNOWScheduleTemplate -UnSkip

    .EXAMPLE
    Sets an array of Schedule Template to Skip (bypass)

    @( 'ScheduleTemplate1', 'ScheduleTemplate2', 'ScheduleTemplate3') | Skip-AutomateNOWScheduleTemplate

    .EXAMPLE
    Get-AutomateNOWScheduleTemplate | ? { $_.ScheduleType -eq 'SELF_SERVICE' } | Skip-AutomateNOWScheduleTemplate -UnSkip -Force -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWScheduleTemplate]$ScheduleTemplate,
        [Parameter(Mandatory = $false)]
        [switch]$UnSkip,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnSkip -ne $True) {
            [string]$skip_flag_status = 'On'
            [string]$operation_id = 'passByOn'
            [string]$ProcessDescription = 'Add the Skip flag'
        }
        Else {
            [string]$skip_flag_status = 'Off'
            [string]$operation_id = 'passByOff'
            [string]$ProcessDescription = 'Remove the Skip flag'
        }
        [string]$command = ('/processingTemplate/' + $operation_id)
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWScheduleTemplate]$ScheduleTemplate = $_
        }
        [string]$ScheduleTemplate_id = $ScheduleTemplate.id
        If ($ScheduleTemplate.passBy -eq $true -and $UnSkip -ne $True) {
            Write-Warning -Message "Schedule Template $ScheduleTemplate_id already has the skip flag set. No action is required."
            Break
        }
        ElseIf ($ScheduleTemplate.passBy -eq $false -and $UnSkip -eq $True) {
            Write-Warning -Message "Schedule Template $ScheduleTemplate_id does not have the skip flag set. No action is required."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess($ScheduleTemplate_id, $ProcessDescription)) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $ScheduleTemplate_id )
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_operationId', $operation_id)
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingTemplateDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ScheduleTemplate_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            $Error.Clear()
            Try {
                [ANOWScheduleTemplate]$skipped_Schedule_template = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to create the [ANOWScheduleTemplate] object after setting the skip flag to [$skip_flag_status] on [$ScheduleTemplate_id] due to [$Message]."
                Break
            }
            Write-Verbose -Message "Successfully set the skip flag to [$skip_flag_status] on [$ScheduleTemplate_id]"
            If ($Quiet -ne $true) {
                Return $skipped_Schedule_template
            }
        }
    }
    End {

    }
}

Function Confirm-AutomateNOWScheduleTemplate {
    <#
    .SYNOPSIS
    Validates (confirms) a Schedule Template on an AutomateNOW! instance

    .DESCRIPTION
    Validates (confirms) a Schedule Template on an AutomateNOW! instance

    .PARAMETER ScheduleTemplate
    An [ANOWScheduleTemplate] object representing the Schedule Template to be set to confirmed (verified)

    .PARAMETER Quiet
    Returns a boolean $true or $false based on the result of the validation check

    .INPUTS
    ONLY [ANOWScheduleTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    A string with the results from the API will returned.

    .EXAMPLE
    Validates a single Schedule Template

    Get-AutomateNOWScheduleTemplate -Id 'ScheduleTemplate01' | Confirm-AutomateNOWScheduleTemplate

    .EXAMPLE
    Validates a series of Schedule Templates

    @( 'ScheduleTemplate01', 'ScheduleTemplate02', 'ScheduleTemplate03') | Confirm-AutomateNOWScheduleTemplate

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWScheduleTemplate]$ScheduleTemplate,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [string]$ScheduleTemplate_id = $_.id
        }
        ElseIf ($ScheduleTemplate.id.Length -gt 0) {
            [string]$ScheduleTemplate_id = $ScheduleTemplate.id
        }
        Else {
            [string]$ScheduleTemplate_id = $Id
        }
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        $BodyMetaData.Add('id', $ScheduleTemplate_id )
        $BodyMetaData.Add('_operationType', 'custom')
        $BodyMetaData.Add('_operationId', 'validate')
        $BodyMetaData.Add('_textMatchStyle', 'exact')
        $BodyMetaData.Add('_dataSource', 'ProcessingTemplateDataSource')
        $BodyMetaData.Add('isc_metaDataPrefix', '_')
        $BodyMetaData.Add('isc_dataFormat', 'json')
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        [string]$command = ('/processingTemplate/validate?' + $Body)
        $parameters.Add('Command', $command)
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ScheduleTemplate_id] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            If ($Quiet -eq $true) {
                Return $false
            }
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "The response code was [$response_code] instead of 0. The Schedule Template $ScheduleTemplate_id is not validated. Please see the full response $full_response_display"
        }
        Else {
            If ($Quiet -eq $true) {
                Return $true
            }
            Else {
                Write-Information -MessageData "The Schedule Template $ScheduleTemplate_id is confirmed as valid."
            }
        }
    }
    End {

    }
}

#endregion

#Region - Schedule Template Items (PROCESSING_TEMPLATE_ITEM)

Function Read-AutomateNOWScheduleTemplateItem {
    <#
    .SYNOPSIS
    Reads the processing items and their -sort order- within a Schedule Template from an AutomateNOW! instance

    .DESCRIPTION
    Reads the processing items and their -sort order- within a Schedule Template from an AutomateNOW! instance

    .PARAMETER ScheduleTemplate
    An [ANOWScheduleTemplate] object representing the Schedule Template to be read.

    .INPUTS
    ONLY [ANOWScheduleTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    [ANOWProcessingTemplateItem] objects that represent the processing template items will be returned.

    .EXAMPLE
    Get all of the items in a specified Schedule.

    $Schedule_template = Get-AutomateNOWScheduleTemplate -Id 'ScheduleTemplate1'
    $Schedule_template_items = $Schedule_template | Read-AutomateNOWScheduleTemplateItem

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The first item listed will be the Schedule itself which has a sort order of -1. The remaining child items will start at sort order 1 or above. There is no sort order of 0.

    #>
    [OutputType([ANOWProcessingTemplateItem[]])]
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWScheduleTemplate]$ScheduleTemplate,
        [Parameter(Mandatory = $False)]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False)]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWScheduleTemplate]$ScheduleTemplate = $_
        }
        [string]$ScheduleTemplate_id = $ScheduleTemplate.Id
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        $BodyMetaData.Add('_constructor', 'AdvancedCriteria')
        $BodyMetaData.Add('operator', 'and')
        $BodyMetaData.Add('criteria1', '{"fieldName":"workflow","operator":"equals","value":"' + $ScheduleTemplate_id + '"}')
        $BodyMetaData.Add('_operationType', 'fetch')
        $BodyMetaData.Add('_startRow', $startRow)
        $BodyMetaData.Add('_endRow', $endRow)
        $BodyMetaData.Add('_sortBy', 'processingTemplate')
        $BodyMetaData.Add('_textMatchStyle', 'exact')
        $BodyMetaData.Add('_componentId', 'TriggerItemList')
        $BodyMetaData.Add('_dataSource', 'ProcessingTemplateItemDataSource')
        $BodyMetaData.Add('isc_metaDataPrefix', '_')
        $BodyMetaData.Add('isc_dataFormat', 'json')
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        [string]$command = ('/processingTemplateItem/read' + '?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.'Command' = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ScheduleTemplate_id] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        If ($results.response.data.count -gt 0) {
            $Error.Clear()
            Try {
                [array]$ProcessingTemplateItems = $results.response.data | Where-Object { $_.sortOrder -ge 0 } | ForEach-Object {
                    $_.workflow = $ScheduleTemplate
                    If ($_.processingType -eq 'TRIGGER' -or $_.parentProcessingType -eq 'TRIGGER') {
                        [ANOWScheduleTemplateItem]$_
                    }
                    ElseIf ($_.processingType -eq 'WORKFLOW' -or $_.parentProcessingType -eq 'WORKFLOW') {
                        [ANOWWorkflowTemplateItem]$_
                    }
                    ElseIf ($_.processingType -eq 'TASK' -or $_.parentProcessingType -eq 'TASK') {
                        [ANOWTaskTemplateItem]$_
                    }
                    ElseIf ($_.processingType -eq 'SERVICE' -or $_.parentProcessingType -eq 'SERVICE') {
                        [ANOWServiceManagerTemplateItem]$_
                    }
                    Else {
                        [string]$processingType = $_.processingType
                        [string]$parentProcessingType = $_.parentProcessingType
                        Write-Warning -Message "Unable to determine the type of Processing Template ($processingType / $parentProcessingType) under Read-AutomateNOWScheduleTemplateItem reading $ScheduleTemplate_id. Please look into this."
                        Break
                    }
                }
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the Processing Template Items from $ScheduleTemplate_id due to [$Message]"
                Break
            }
            Write-Verbose -Message "Schedule Template Items successfully read from $ScheduleTemplate_id"
            If ($Quiet -ne $true) {
                Return $ProcessingTemplateItems
            }
        }
        Else {
            Write-Verbose -Message "There were no Schedule Template Items within $ScheduleTemplate_id"
        }
    }
    End {

    }
}

Function Add-AutomateNOWScheduleTemplateItem {
    <#
    .SYNOPSIS
    Adds a Processing Template to a Schedule Template

    .DESCRIPTION
    Adds a Processing Template (i.e. Task, Workflow, Service Manager or Integration) to a Schedule Template

    .PARAMETER ScheduleTemplate
    Mandatory [ANOWScheduleTemplate] object representing the Schedule Template that will receive the new Processing Template.

    .Parameter ProcessingTemplate
    Mandatory [ANOWProcessingTemplate] (either Task Template or Workflow Template) object representing the Processing Template Item that is being added to the Schedule Template.

    .PARAMETER sortOrder
    Optional int32 specifying the sort order. When not specified, the sort order will be LAST. If needed, use Read-AutomateNOWSchedule to obtain the current sort order of the items in the Schedule.

    .PARAMETER Quiet
    Switch parameter to silence the emitted [ANOWScheduleTemplateItem] object

    .PARAMETER Force
    Force the addition of the object without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    Either [ANOWTaskTemplate] or [ANOWWorkflowTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Forcibly adds a Task Template ($task_template1) and a Workflow Template ($workflow_template1) to a Schedule Template ($schedule_template)

    $task_template1 = Get-AutomateNOWTaskTemplate -Id 'TaskTemplate01'
    $workflow_template1 = Get-AutomateNOWWorkflowTemplate -Id 'WorkflowTemplate01'
    $schedule_template1 = Get-AutomateNOWScheduleTemplate -Id 'ScheduleTemplate02'

    @($task_template1, $workflow_template1) | Add-AutomateNOWScheduleTemplateItem -ScheduleTemplate $schedule_template1 -Force

    .EXAMPLE
    Forcibly adds a Workflow to a Schedule Template in a single line

    Get-AutomateNOWWorkflowTemplate -Id 'Workflow1' | Add-AutomateNOWScheduleTemplateItem -ScheduleTemplate (Get-AutomateNOWScheduleTemplate -Id 'Schedule1') -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Note: See Add-AutomateNOWTimeTrigger for adding Time Triggers to the Schedule tab of the Schedule Template

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWScheduleTemplate]$ScheduleTemplate,
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [PSObject]$ProcessingTemplate,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$ScheduleTemplate_id = $ScheduleTemplate.Id
        [string]$command = '/processingTemplateItem/create'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [PSObject]$ProcessingTemplate = $_
        }
        [string]$ProcessingTemplate_id = $ProcessingTemplate.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Add $($ProcessingTemplate_id) to $($ScheduleTemplate_id)")) -eq $true) {
            $Error.Clear()
            Try {
                [ANOWProcessingTemplateItem[]]$ScheduleTemplateItems = Read-AutomateNOWScheduleTemplateItem -ScheduleTemplate $ScheduleTemplate
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Read-AutomateNOWScheduleTemplateItem failed to Read $ScheduleTemplate_id under Add-AutomateNOWScheduleTemplateItem due to [$Message]."
                Break
            }
            [int32]$ScheduleTemplateItems_Count = $ScheduleTemplateItems.Count
            If ($ScheduleTemplateItems_Count -gt 0) {
                Write-Verbose -Message "$ScheduleTemplate_id currently has $ScheduleTemplateItems_Count items before any changes were made"
                [int32]$last_item_order = ($ScheduleTemplateItems | Sort-Object -Property sortOrder | Select-Object -Last 1 | Select-Object -ExpandProperty sortOrder) + 1
            }
            Else {
                Write-Verbose -Message "$ScheduleTemplate_id does not have any items yet. This will be the first item added to it."
                [int32]$last_item_order = 0
            }
            [ANOWProcessingTemplate_processingType]$processingType = $ProcessingTemplate.processingType
            # Note that the taskType property is still sent as an empty property when the Processing Template is a Workflow
            If ($null -ne $ProcessingTemplate.taskType) {
                [ANOWProcessingTemplate_taskType]$taskType = $ProcessingTemplate.taskType
            }
            Else {
                [string]$taskType = ''
            }
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('workflow', $ScheduleTemplate_id )
            $BodyMetaData.Add('processingType', $processingType )
            $BodyMetaData.Add('processingTemplate', $ProcessingTemplate_id )
            $BodyMetaData.Add('taskType', $taskType )
            $BodyMetaData.Add('sortOrder', $last_item_order )
            $BodyMetaData.Add('_operationType', 'add')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingTemplateItemDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties 'taskType'
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ScheduleTemplate_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            [string]$processing_template_item_id = $results.response.data.id
            If ($processing_template_item_id -notmatch '^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$') {
                Write-Warning -Message "Somehow the returned Id of the newly added Processing Template Item did not match the expected format of a Processing Template Item which is that of a 36-character GUID. Instead, [$processing_template_item_id] was received. Please look into this."
            }
            Write-Verbose -Message "Processing Template $ProcessingTemplate_id ($processingType) was added to $ScheduleTemplate_id (as $processing_template_item_id)"
            If ($results.response.data.count -gt 0) {
                $Error.Clear()
                Try {
                    [array]$ProcessingTemplateItem = $results.response.data | Where-Object { $_.sortOrder -ge 0 } | ForEach-Object {
                        $_.workflow = $ScheduleTemplate
                        If ($_.processingType -eq 'TRIGGER' -or $_.parentProcessingType -eq 'TRIGGER') {
                            [ANOWScheduleTemplateItem]$_
                        }
                        ElseIf ($_.processingType -eq 'WORKFLOW' -or $_.parentProcessingType -eq 'WORKFLOW') {
                            [ANOWWorkflowTemplateItem]$_
                        }
                        ElseIf ($_.processingType -eq 'TASK' -or $_.parentProcessingType -eq 'TASK') {
                            [ANOWTaskTemplateItem]$_
                        }
                        ElseIf ($_.processingType -eq 'SERVICE' -or $_.parentProcessingType -eq 'SERVICE') {
                            [ANOWServiceManagerTemplateItem]$_
                        }
                        Else {
                            [string]$processingType = $_.processingType
                            [string]$parentProcessingType = $_.parentProcessingType
                            Write-Warning -Message "Unable to determine the type of Processing Template ($processingType / $parentProcessingType) under Add-AutomateNOWScheduleTemplateItem reading $ScheduleTemplate_id. Please look into this."
                            Break
                        }
                    }
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to parse the Schedule Template Item from $ScheduleTemplate_id due to [$Message]"
                    Break
                }
                Write-Verbose -Message "Schedule Template Item successfully added to $ScheduleTemplate_id"
                If ($Quiet -ne $true) {
                    Return $ProcessingTemplateItem
                }
            }
            Else {
                Write-Verbose -Message "There were no Schedule Template Items within $ScheduleTemplate_id"
            }
        }
    }
    End {

    }
}

Function Remove-AutomateNOWScheduleTemplateItem {
    <#
    .SYNOPSIS
    Removes a Processing Template from a Schedule Template

    .DESCRIPTION
    Removes a Processing Template Item (i.e. Task, Workflow, Service Manager or Integration) from a Schedule Template

    .PARAMETER ScheduleTemplate
    Mandatory [ANOWScheduleTemplate] object representing the Schedule Template that will lose a Processing Template.

    .Parameter ProcessingTemplateItem
    Mandatory [ANOWProcessingTemplateItem] (i.e. Task, Workflow, Service Manager or Integration) object representing the Processing Template Item that is being removed from the Schedule Template. Use Read-AutomateNOWScheduleTemplate to retrieve the Processing Template Items from a Schedule Template.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    You must present a [ANOWScheduleTemplate] object to the -ScheduleTemplate parameter along with [ANOWProcessingTemplateItem] objects to the -ProcessingTemplateItem parameter. The latter can be pipelined.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Removes a single Processing Template Item from a Schedule Template

    $schedule_template = Get-AutomateNOWScheduleTemplate -Id 'ScheduleTemplate1'
    $processing_template_item = Read-AutomateNOWScheduleTemplateItem -ScheduleTemplate $schedule_template | Where-Object { $_.Id -eq '3fc63622-5e87-468e-a71f-bd78450219e3'}
    Remove-AutomateNOWScheduleTemplateItem -ScheduleTemplate $schedule_template -ProcessingTemplateItem $processing_template_item

    .EXAMPLE
    Forcibly removes all instances of a Workflow named 'Workflow1' that was added to a Schedule Template named 'ScheduleTemplate1'.

    $schedule_template = Get-AutomateNOWScheduleTemplate -Id 'ScheduleTemplate1'
    $workflow_items = Read-AutomateNOWScheduleTemplateItem -ScheduleTemplate $schedule_template | Where-Object { $_.processingTemplate -eq 'Workflow1'}
    $workflow_items | Remove-AutomateNOWScheduleTemplateItem -ScheduleTemplate $schedule_template -Force

    .EXAMPLE
    Removes all Processing Template Items from a Schedule Template

    Read-AutomateNOWScheduleTemplateItem -ScheduleTemplate (Get-AutomateNOWScheduleTemplate -Id 'ScheduleTemplate1') | Remove-AutomateNOWScheduleTemplateItem -ScheduleTemplate (Get-AutomateNOWScheduleTemplate -Id 'ScheduleTemplate1')

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Only Task Templates and Workflow Templates are supported. Service Managers and Integrations are not supported yet.

    Remember that once a Processing Template is added to a Workflow Template or Schedule Template it becomes a Processing Template Item which have a 36-character GUID for the Id.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWScheduleTemplate]$ScheduleTemplate,
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWProcessingTemplateItem]$ProcessingTemplateItem,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$ScheduleTemplate_id = $ScheduleTemplate.Id
        [string]$command = '/processingTemplateItem/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWProcessingTemplateItem]$ProcessingTemplateItem = $_
        }
        [string]$ProcessingTemplateItem_id = $ProcessingTemplateItem.id
        If ($ProcessingTemplateItem_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If ($ProcessingTemplateItem_id -notmatch '^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$') {
            Write-Warning -Message "Was expecting the Id of the Processing Template Id to match a 36-character GUID, instead received [$ProcessingTemplateItem_id]. Please check into this."
            Break
        }
        Else {
            Write-Verbose -Message "Received [$ProcessingTemplateItem_id] for the Id of the Processing Template Item to be removed"
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ProcessingTemplateItem_id)")) -eq $true) {
            $Error.Clear()
            Try {
                [PSCustomObject]$ScheduleTemplateItems = Read-AutomateNOWScheduleTemplateItem -ScheduleTemplate $ScheduleTemplate
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Read-AutomateNOWScheduleTemplateItem failed to Read [$ScheduleTemplate_id] under Remove-AutomateNOWScheduleTemplateItem due to [$Message]."
                Break
            }
            [int32]$ScheduleTemplateItems_Count = $ScheduleTemplateItems.Count
            If ($ScheduleTemplateItems_Count -eq 0) {
                Write-Verbose -Message "$ScheduleTemplate_id does not have any Processing Template items added to it yet... Please check again."
                Break
            }
            If ($ProcessingTemplateItem_id -notin ($ScheduleTemplateItems.Id) ) {
                Write-Warning -Message "The Processing Template Item $ProcessingTemplateItem_id is not actually added to [$ScheduleTemplate_id]. Please check this."
                Break
            }
            [string]$old_values = $ProcessingTemplateItem.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $ProcessingTemplateItem_id )
            $BodyMetaData.Add('_oldValues', $old_values )
            $BodyMetaData.Add('_operationType', 'remove')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingTemplateItemDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ScheduleTemplate_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Processing Template $ProcessingTemplateItem_id ($processingType) was removed from $ScheduleTemplate_id"
        }
    }
    End {

    }
}

#endregion

#Region - Security Access Tokens

Function Read-AutomateNOWSecurityAccessToken {
    <#
    .SYNOPSIS
    Reads the Security Access Token that is associated with a User on an AutomateNOW! instance

    .DESCRIPTION
    Reads the Security Access Token that is associated with a User on an AutomateNOW! instance (DOES NOT GIVE YOU THE ACTUAL ACCESS TOKEN!)

    .PARAMETER SecUser
    The mandatory [ANOWSecUser] object representing the User to read the Security Access Tokens from.

    .PARAMETER sortBy
    Optional case-sensitive string parameter to sort the results by. Valid choices are: 'id', 'dateCreated'* and 'tokenExpirationDate'

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER IncludeExpired
    An optional switch parameter that will include expired tokens. These are normally filtered out by default.

    .PARAMETER OnlyExpired
    An optional switch parameter that will exclude non-expired tokens. These are normally filtered out by default.

    .INPUTS
    ONLY [ANOWSecUser] objects are accepted (including from the pipeline)

    .OUTPUTS
    [ANOWSecurityAccessToken] objects will be returned.

    .EXAMPLE
    Gets the first page of all Security Access Tokens

    Get-AutomateNOWSecUser -APIUsersOnly | Read-AutomateNOWSecurityAccessToken

    .EXAMPLE
    Gets the Security Access Tokens from a User named 'User1' via the pipeline

    Get-AutomateNOWSecUser -Id 'User1' | Read-AutomateNOWSecurityAccessToken

    .EXAMPLE
    Gets the expired Security Access Tokens from a User named 'User1'

    Get-AutomateNOWSecUser -Id 'User1' | Read-AutomateNOWSecurityAccessToken -OnlyExpired

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The accessToken property is not included here! This is by design. The only time that the accessToken property is exposed is upon creation. See Add-AutomateNOWSecurityAccessToken.

    #>
    [OutputType([ANOWSecurityAccessToken[]])]
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWSecUser]$SecUser,
        [Parameter(Mandatory = $False)]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False)]
        [int32]$endRow = 100,
        [ValidateSet( 'dateCreated', 'id', 'tokenExpirationDate', ignoreCase = $false)]
        [Parameter(Mandatory = $False)]
        [string]$sortBy = 'dateCreated',
        [Parameter(Mandatory = $False)]
        [switch]$Descending,
        [Parameter(Mandatory = $False)]
        [switch]$IncludeExpired,
        [Parameter(Mandatory = $False)]
        [switch]$OnlyExpired
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWSecUser]$SecUser = $_
        }
        [string]$User_id = $SecUser.Id
        [boolean]$API_User = $SecUser.apiUser
        If ($API_User -ne $true) {
            Write-Warning -Message "Only API Users can possess a Security Access Token. $User_id is not an API User."
            Break
        }
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        $BodyMetaData.Add('_constructor', 'AdvancedCriteria')
        $BodyMetaData.Add('operator', 'and')
        $BodyMetaData.Add('criteria1', '{"fieldName":"userId","operator":"equals","value":"' + $User_id + '"}')
        If ($IncludeExpired -ne $true -and $OnlyExpired -ne $true) {
            $BodyMetaData.Add('criteria2', '{"fieldName":"tokenExpired","operator":"equals","value":false}')
        }
        ElseIf ( $OnlyExpired -eq $true) {
            $BodyMetaData.Add('criteria2', '{"fieldName":"tokenExpired","operator":"equals","value":true}')
        }
        $BodyMetaData.Add('_operationType', 'fetch')
        $BodyMetaData.Add('_startRow', $startRow)
        $BodyMetaData.Add('_endRow', $endRow)
        If ($Descending -eq $true) {
            $BodyMetaData.'_sortBy' = '-' + $sortBy
        }
        Else {
            $BodyMetaData.'_sortBy' = $sortBy
        }
        $BodyMetaData.Add('_textMatchStyle', 'substring')
        $BodyMetaData.Add('_componentId', 'SecurityAccessTokenList')
        $BodyMetaData.Add('_dataSource', 'SecurityAccessTokenDataSource')
        $BodyMetaData.Add('isc_metaDataPrefix', '_')
        $BodyMetaData.Add('isc_dataFormat', 'json')
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        [string]$command = ('/securityAccessToken/read' + '?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.'Command' = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ScheduleTemplate_id] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        If ($results.response.data.count -gt 0) {
            Try {
                [ANOWSecurityAccessToken[]]$SecurityAccessTokens = $results.response.data
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the Security Access Tokens from $User_id due to [$Message]"
                Break
            }
            Write-Verbose -Message "Security Access Tokens successfully read from $User_id"
            If ($SecurityAccessTokens.Count -gt 0) {
                Return $SecurityAccessTokens
            }
        }
        Else {
            Write-Verbose -Message "There were no Security Access Tokens within $User_id"
        }
    }
    End {

    }
}

Function Export-AutomateNOWSecurityAccessToken {
    <#
    .SYNOPSIS
    Exports the Security Access Tokens from an API User on an instance of AutomateNOW! to a local .csv file

    .DESCRIPTION
    Exports the Security Access Tokens from an API User on an instance of AutomateNOW! to a local .csv file (the actual access token is not included)

    .PARAMETER Security Access Token
    Mandatory [ANOWSecurityAccessToken] object (Use Read-AutomateNOWSecurityAccessToken to retrieve them)

    .INPUTS
    ONLY [ANOWSecurityAccessToken] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWSecurityAccessToken] objects are exported to the local disk in CSV format

    .EXAMPLE

    .NOTES
	You must present [ANOWSecurityAccessToken] objects to the pipeline to use this function.

    The only way to read the actual accessToken property of the Security Access Token is when you create it. See Add-AutomateNOWSecurityAccessToken for more information.
    #>

    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWSecurityAccessToken]$SecurityAccessToken
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = "Export-AutomateNOW-SecurityAccessTokens-" + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            $SecurityAccessToken = $_ # do not hard type this variable
        }
        $Error.Clear()
        Try {
            $SecurityAccessToken | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWSecurityAccessToken] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function Add-AutomateNOWSecurityAccessToken {

    <#
    .SYNOPSIS
    Adds a new Security Access Token to an API User (a.k.a. SecUser) on an AutomateNOW! instance

    .DESCRIPTION
    Adds a new Security Access Token to an API User (a.k.a. SecUser) on an AutomateNOW! instance

    .PARAMETER SecUser
    The mandatory [ANOWSecUser] object representing the User that is receiving the new Security Access Token. Note that this -must- be a User of type API.

    .PARAMETER Password
    The mandatory [SecureString] representing the password to be set with the Access Token

    .PARAMETER tokenExpirationDate
    The mandatory [DateTime] object representing the UTC date of token expiration. Use Get-Date to create this.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    An [ANOWSecUser], [SecureString] and [DateTime] objects are required. The pipeline is not supported.

    .OUTPUTS
    The resulting [ANOWSecurityAccessToken] object will be returned. Make sure you retain this result (by checking the accessToken property of the returned object as you will not be able to see it ever again.

    .EXAMPLE
    Forcibly creates a new access token to the variable $user_access_token for an API User named 'APIUser1' in a multi-line format.
    $sec_user = Get-AutomateNOWSecUser -Id 'APIUser1'
    $sec_pass = 'MyCoolPassword1!1' | ConvertTo-SecureString -AsPlainText -Force
    $pass_valid = Get-Date '2029-12-31'
    $user_access_token = Add-AutomateNOWSecurityAccessToken -SecUser $sec_user -Password $sec_pass -tokenExpirationDate $pass_valid -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Make sure you retain this result (by checking the accessToken property of the returned object as you will not be able to see it ever again.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWSecUser]$SecUser,
        [Parameter(Mandatory = $true)]
        [SecureString]$Password,
        [Parameter(Mandatory = $true)]
        [datetime]$tokenExpirationDate,
        [Parameter(Mandatory = $false)]
        [switch]$Force

    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    [string]$command = '/securityAccessToken/create'
    [hashtable]$parameters = @{}
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$User_id = $SecUser.id
    [boolean]$API_User = $SecUser.apiUser
    If ($API_User -ne $true) {
        Write-Warning -Message "Only API Users may receive a new Security Token. $User_id is not an API User."
        Break
    }
    If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($User_id)")) -eq $true) {
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [ANOWSecUser]$User = Get-AutomateNOWSecUser -Id $User_id
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWSecUser failed to check if the User [$User_id] already existed under Set-AutomateNOWSecUser due to [$Message]."
            Break
        }
        [boolean]$User_exists = ($User.Id.Length -gt 0)
        If ($User_exists -eq $false) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not a User named [$User_id] in the current domain [$current_domain]. Please check into this."
            Break
        }
        ## End warning ##
        $Error.Clear()
        Try {
            [string]$decoded_password = $Password | ConvertFrom-SecureString -AsPlainText
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "ConvertFrom-SecureString failed to convert the SecureString object under Add-AutomateNOWSecurityAccessToken due to [$Message]."
            Break
        }
        [string]$tokenExpirationDate_string = Get-Date -Date $tokenExpirationDate -Format 'yyyy-MM-ddThh:mm:ss.fff'
        [string]$oldValues = ('{"j_username":"' + $User_id + '","tokenExpirationDate":"' + $tokenExpirationDate_string + '"}')
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        $BodyMetaData.'j_username' = $User_id
        $BodyMetaData.'j_password' = $decoded_password
        Remove-Variable -Name decoded_password -Force
        $BodyMetaData.'tokenExpirationDate' = $tokenExpirationDate_string
        $BodyMetaData.'_operationType' = 'add'
        $BodyMetaData.'_textMatchStyle' = 'exact'
        $BodyMetaData.'_oldValues' = $oldValues
        $BodyMetaData.'_componentId' = 'SecurityAccessTokenCreateWindow_form'
        $BodyMetaData.'_dataSource' = 'SecurityAccessTokenDataSource'
        $BodyMetaData.'isc_metaDataPrefix' = '_'
        $BodyMetaData.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        Remove-Variable -Name BodyMetaData -Force
        If ($null -eq $parameters.Body) {
            $parameters.Add('Body', $Body)
        }
        Else {
            $parameters.Body = $Body
        }
        Remove-Variable -Name Body -Force
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$User_id] due to [$Message]."
            Break
        }
        Remove-Variable -Name Parameters -Force
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWSecurityAccessToken]$SecurityAccessToken = $results.response.data | Select-Object -First 1
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Add-AutomateNOWSecurityAccessToken failed to parse the results into an [ANOWSecurityAccessToken] object due to [$Message]."
            Break
        }
        Write-Warning -Message 'Make sure you retain this result (by checking the accessToken property of the returned object as you will not be able to see it ever again.'
        Return $SecurityAccessToken
    }
}

Function Remove-AutomateNOWSecurityAccessToken {
    <#
    .SYNOPSIS
    Removes (invalidates) a Security Access Token from a User in an AutomateNOW! instance

    .DESCRIPTION
    Removes (invalidates) a Security Access Token from a User in an AutomateNOW! instance

    .PARAMETER SecUser
    The mandatory [ANOWSecUser] object representing the User that is losing a Security Access Token. Note that this -must- be a User of type API.

    .PARAMETER SecurityAccessToken
    Mandatory SecurityAccessToken object to be removed from an API User. Use Read-AutomateNOWSecurityAccessToken to retrieve them.

    .PARAMETER Force
    Force the removal of the object without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    You must present one [ANOWSecUser] along with 1 or more [ANOWSecurityAccessTokens] objects. The pipeline may be used to send the [ANOWSecurityAccessTokens] objects.

    .OUTPUTS
    A verbose message confirming the removal will be emitted.

    .EXAMPLE
    Deletes the expired Security Access Tokens for a user named 'APIUser1'
    $sec_user = Get-AutomateNOWSecUser -Id 'APIUser1'
    $expired_access_tokens = $sec_user | Read-AutomateNOWSecurityAccessToken -OnlyExpired
    $expired_access_tokens | Remove-AutomateNOWSecurityAccessToken -SecUser $sec_user

    .EXAMPLE
    Forcibly removes the first page of Security Access Tokens from an API User named 'APIUser1' via the pipeline
    Get-AutomateNOWSecUser -Id 'APIUser1' | Read-AutomateNOWSecurityAccessToken | Remove-AutomateNOWSecurityAccessToken -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([PSCustomObject])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWSecUser]$SecUser,
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWSecurityAccessToken]$SecurityAccessToken,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('Command', '/securityAccessToken/delete')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
        [string]$User_id = $SecUser.Id
        [boolean]$API_User = $SecUser.apiUser
        If ($API_User -ne $true) {
            Write-Warning -Message "Only API Users can possess a Security Access Token. $User_id is not an API User."
            Break
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWSecurityAccessToken]$SecurityAccessToken = $_
        }
        [string]$SecurityAccessToken_id = $SecurityAccessToken.id
        [string]$old_values = $SecurityAccessToken.CreateOldValues()
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$SecurityAccessToken_id from $($User_id)")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $SecurityAccessToken_id
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_oldValues' = $old_values
            $BodyMetaData.'_componentId' = 'SecurityAccessTokenList'
            $BodyMetaData.'_dataSource' = 'SecurityAccessTokenDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Security Access Token $SecurityAccessToken_id was removed from API User [$User_id]"
        }
    }
    End {

    }
}

#endregion

#Region - Security Log (Users)

Function Get-AutomateNOWSecurityEventLog {
    <#
    .SYNOPSIS
    Gets the Security Event Log entries from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Security Event Log entries from an AutomateNOW! instance

    .PARAMETER sortBy
    Optional string parameter to sort the results by. Valid choices are: id, dateCreated, createdBy, userIp, eventType, accessToken

    .PARAMETER Ascending
    Optional switch parameter to sort in ascending order

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100. The console default hard limit is 10,000.

    .INPUTS
    You cannot pipe input to `Get-AutomateNOWSecurityEventLog`

    .OUTPUTS
    An array of one or more [ANOWSecurityEvent] objects

    .EXAMPLE
    Gets the first 100 entries in the Security Log

    Get-AutomateNOWSecurityEventLog

    .EXAMPLE
    Gets the first 10,000 entries in the Security Log

    Get-AutomateNOWSecurityEventLog -startRow 0 -endrow 10000

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWSecurityEvent[]])]
    [Cmdletbinding()]
    Param(
        [ValidateSet('id', 'dateCreated', 'createdBy', 'userIp', 'eventType', 'accessToken', ignoreCase = $false)]
        [Parameter(Mandatory = $False)]
        [string]$sortBy = 'dateCreated',
        [Parameter(Mandatory = $False)]
        [switch]$Ascending,
        [Parameter(Mandatory = $False)]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False)]
        [int32]$endRow = 100
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    If ($endRow -le $startRow) {
        Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
        Break
    }
    [hashtable]$parameters = @{}
    $parameters.Add('Method', 'POST')
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
    $Body.'_operationType' = 'fetch'
    $Body.'_startRow' = $startRow
    $Body.'_endRow' = $endRow
    If ($Ascending -eq $true) {
        $Body.'_sortBy' = $sortBy
    }
    Else {
        $Body.'_sortBy' = '-' + $sortBy
    }
    $Body.'_textMatchStyle' = 'exact'
    $Body.'_componentId' = 'SecurityEventList'
    $Body.'_dataSource' = 'SecurityEventDataSource'
    $Body.'isc_metaDataPrefix' = '_'
    $Body.'isc_dataFormat' = 'json'
    [string]$Body = ConvertTo-QueryString -InputObject $Body
    $parameters.Add('Body', $Body)
    [string]$command = ('/securityEvent/read')
    If ($null -eq $parameters["Command"]) {
        $parameters.Add('Command', $command)
    }
    Else {
        $parameters.Command = $command
    }
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWSecurityEvent[]]$SecurityEvents = $results.response.data
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to parse the response into a series of [ANOWSecurityEvent] objects due to [$Message]."
        Break
    }
    If ($SecurityEvents.Count -gt 0) {
        Return $SecurityEvents
    }
}

Function Export-AutomateNOWSecurityEventLog {
    <#
    .SYNOPSIS
    Exports the Security Events (log entries) from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Security Events (log entries) from an instance of AutomateNOW! to a local .csv file

    .PARAMETER SecurityEvent
    Mandatory [ANOWSecurityEvent] object (Use Get-AutomateNOWSecurityEvent to retrieve them)

    .INPUTS
    ONLY [ANOWSecurityEvent] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWSecurityEvent] objects are exported to the local disk in CSV format

    .EXAMPLE
    Get-AutomateNOWSecurityEvent | Export-AutomateNOWSecurityEvent

    .NOTES
	You must present [ANOWSecurityEvent] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWSecurityEvent]$SecurityEvent
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-SecurityEvents-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWSecurityEvent]$SecurityEvent = $_
        }
        $Error.Clear()
        Try {
            $SecurityEvent | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWSecurityEvent] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

#endregion

#Region - Security Role Domains (a.k.a. Domain Roles)

Function Read-AutomateNOWSecurityRoleDomain {
    <#
    .SYNOPSIS
    Reads the Security Role Domain objects within a Security Role from an AutomateNOW! instance

    .DESCRIPTION
    Reads the Security Role Domain objects within a Security Role from an AutomateNOW! instance

    .PARAMETER Id
    An optional Id string representing the Security Role object to be read.

    .PARAMETER ItemId
    An optional Id string representing the Security Domain Role object to be read.

    .PARAMETER SecurityRole
    An optional [ANOWSecRole] object representing the Security Role object to be read.

    .INPUTS
    ONLY [ANOWSecRole] objects are accepted (including from the pipeline)

    .OUTPUTS
    [ANOWDashboard] objects that represent the Security Domain Roles will be returned.

    .EXAMPLE
    Get the first page of Domain Roles within a Security Role

    $security_role = Get-AutomateNOWSecurityRole1 -Id 'SecurityRole1'
    $domain_roles = $security_role | Read-AutomateNOWSecurityRoleDomain

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWSecRoleDomain[]])]
    [Cmdletbinding( DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $true, ParameterSetName = 'Default', ValueFromPipeline = $true)]
        [ANOWSecRole]$SecurityRole,
        [Parameter(Mandatory = $true, ParameterSetName = 'ItemId')]
        [string]$ItemId,
        [Parameter(Mandatory = $False)]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False)]
        [int32]$endRow = 100
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0 -or $SecurityRole.Id.Length -gt 0) {
            If ($_.id.Length -gt 0) {
                [ANOWSecRole]$SecurityRole = $_
            }
            [string]$SecurityRole_id = $SecurityRole.Id
        }
        ElseIf ($_.Length -gt 0) {
            [string]$SecurityRole_id = $_
        }
        ElseIf ($Id.Length -gt 0) {
            [string]$SecurityRole_id = $Id
        }
        ElseIf ($ItemId.Length -gt 0) {
            If ($ItemId -notmatch '^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$') {
                Write-Warning -Message "Was expecting the Id of the destination SecurityRoleDomain Id to match a 36-character GUID, instead received [$ItemId]. Please check into this."
                Break
            }
        }
        Else {
            Write-Warning -Message "Somehow was not able to determine the Id of the Security Role under Read-AutomateNOWSecurityRoleDomain. Please look into this."
            Break
        }
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($ItemId.Length -eq 0) {
            $BodyMetaData.Add('_constructor', 'AdvancedCriteria')
            $BodyMetaData.Add('operator', 'and')
            $BodyMetaData.Add('criteria1', '{"fieldName":"secRole","operator":"equals","value":"' + $SecurityRole_id + '"}')
            $BodyMetaData.Add('_startRow', $startRow)
            $BodyMetaData.Add('_endRow', $endRow)
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_componentId', 'SecRoleDomainList')

        }
        Else {
            $BodyMetaData.Add('id', $ItemId)
            $BodyMetaData.Add('_operationId', 'read')
            $BodyMetaData.Add('_textMatchStyle', 'exactCase')
        }
        $BodyMetaData.Add('_operationType', 'fetch')
        $BodyMetaData.Add('_dataSource', 'SecRoleDomainDataSource')
        $BodyMetaData.Add('isc_metaDataPrefix', '_')
        $BodyMetaData.Add('isc_dataFormat', 'json')
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        [string]$command = ('/secRoleDomain/read' + '?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.'Command' = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$SecurityRole_id] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        If ($results.response.data.count -gt 0) {
            $Error.Clear()
            Try {
                [ANOWSecRoleDomain[]]$FormattedDomainRoles = ForEach ($domainRole in $results.response.data) {
                    $domainRole.secRole = $SecurityRole
                    $domainRole
                }
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the Domain Roles from $SecurityRole_id into formatted [ANOWSecRoleDomain] objects due to [$Message]"
                Break
            }
            Write-Verbose -Message "Domain Roles successfully read from $SecurityRole_id"
            If ($Quiet -ne $true) {
                Return $FormattedDomainRoles
            }
        }
        Else {
            Write-Verbose -Message "There were no Domain Roles within $SecurityRole_id"
        }
    }
    End {

    }
}

Function Export-AutomateNOWSecurityRoleDomain {
    <#
    .SYNOPSIS
    Exports the Security Role Domain objects from a Security Role on an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Security Role Domain objects from a Security Role on an instance of AutomateNOW! to a local .csv file

    .Parameter DomainRole
    Mandatory [ANOWSecRoleDomain] object representing the Security Role Domain that is to be exported.

    .INPUTS
    ONLY [ANOWSecRoleDomain] objects are accepted (including from the pipeline)

    .OUTPUTS
    The [ANOWSecRoleDomain] objects are exported to the local disk in CSV format

    .EXAMPLE
    Exports all of the Domain Roles from within a Security Role named 'SecurityRole1'

    $security_role = Get-AutomateNOWSecurityRole -Id 'SecurityRole1'
    $domain_roles = $security_role | Read-AutomateNOWSecurityRoleDomain
    $domain_roles | Export-AutomateNOWSecurityRoleDomain

    .NOTES
	
    #>

    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWSecRoleDomain]$DomainRole
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = "Export-AutomateNOW-DomainRole-" + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWSecRoleDomain]$DomainRole = $_
        }
        [string]$DomainRole_Name = $DomainRole.roleDomain
        $Error.Clear()
        Try {
            $DomainRole | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWSecRoleDomain] object $DomainRole_Name due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function Remove-AutomateNOWSecurityRoleDomain {
    <#
    .SYNOPSIS
    Removes a SecurityRoleDomain from a Security Role

    .DESCRIPTION
    Removes a SecurityRoleDomain from a Security Role

    .Parameter domainRole
    Mandatory [ANOWSecRoleDomain] object representing the SecurityRoleDomain that is being removed from a Security Role. Use Read-AutomateNOWSecurityRoleDomain to retrieve the SecurityRoleDomains from a Security Role.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    You must present a [ANOWSecRoleDomain] object to the -domainRole parameter (including from the pipeline). You do not need to specify the Security Role!

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Removes a single Domain Role for a Domain named 'Domain1' from within a Security Role named 'SecurityRole1'

    $security_role = Get-AutomateNOWSecurityRole -Id 'SecurityRole1'
    $domain_role = Read-AutomateNOWSecurityRoleDomain -SecurityRole $security_role | Where-Object { $_.roleDomain -eq 'Domain1' }
    Remove-AutomateNOWSecurityRoleDomain -domainRole $domain_role

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWSecRoleDomain]$domainRole,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/secRoleDomain/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWSecRoleDomain]$domainRole = $_
        }
        [string]$domainRole_id = $domainRole.Id
        If ($domainRole_id.Length -eq 0) {
            Write-Warning -Message "Somehow an empty Id was passed to this function (Remove-AutomateNOWSecurityRoleDomain). Please look into this."
            Break
        }
        If ($domainRole_id -notmatch '^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$') {
            Write-Warning -Message "Was expecting the Id of the SecurityRoleDomain Id to match a 36-character GUID, instead received [$domainRole_id]. Please check into this."
            Break
        }
        Else {
            Write-Verbose -Message "Received [$domainRole_id] for the Id of the SecurityRoleDomain Item to be removed"
        }
        [string]$Domain_Id = $domainRole.roleDomain
        [string]$SecurityRole_Id = $domainRole.secRole.Id
        If ($Domain_Id.Length -eq 0) {
            Write-Warning -Message "Somehow the roleDomain property was missing from the provided Domain Role object. Please look into this."
            Break
        }
        ElseIf ($SecurityRole_Id.Length -eq 0) {
            Write-Warning -Message "Somehow the secRole property was missing from the provided Domain Role object. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Domain_Id) from $($SecurityRole_Id)")) -eq $true) {
            $Error.Clear()
            Try {
                [PSCustomObject]$SecurityRoleDomains = Read-AutomateNOWSecurityRoleDomain -Id $SecurityRole_Id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Read-AutomateNOWSecurityRoleDomain failed to Read [$SecurityRole_Id] under Remove-AutomateNOWSecurityRoleDomain due to [$Message]."
                Break
            }
            [int32]$SecurityRoleDomains_Count = $SecurityRoleDomains.Count
            If ($SecurityRoleDomains_Count -eq 0) {
                Write-Verbose -Message "$SecurityRole_Id does not have any SecurityRoleDomains added to it yet... Please check again."
                Break
            }
            If ($domainRole_id -notin ($SecurityRoleDomains.Id) ) {
                Write-Warning -Message "The SecurityRoleDomain $domainRole_id is not actually added to [$SecurityRole_Id]. Please check this."
                Break
            }
            [string]$old_values = $domainRole.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $domainRole_id )
            $BodyMetaData.Add('_oldValues', $old_values )
            $BodyMetaData.Add('_operationType', 'remove')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_componentId', 'SecRoleDomainList')
            $BodyMetaData.Add('_dataSource', 'SecRoleDomainDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Domain_Id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "SecurityRoleDomain $Domain_Id ($domainRole_id) was removed from $SecurityRole_Id"
        }
    }
    End {

    }
}

Function Add-AutomateNOWSecurityRoleDomain {
    <#
    .SYNOPSIS
    Adds a Domain to a Security Role on an AutomateNOW! instance

    .DESCRIPTION
    Adds a Domain to a Security Role on an AutomateNOW! instance

    .PARAMETER SecurityRole
    Mandatory [ANOWSecRole] object representing the Security Role that will receive the Domain

    .Parameter Domain
    Mandatory [ANOWDomain] object representing the Domain that is being added to the Security Role

    .PARAMETER Quiet
    Switch parameter to silence the emitted [ANOWSecRoleDomain] object

    .PARAMETER Force
    Force the addition of the object without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    An [ANOWSecRole] object must be presented along with [ANOWDomain] objects which can be sent to the pipeline.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Adds a Domain named 'Domain1' to a Security Role named 'SecurityRole1' (multi-line format)

    [ANOWDomain]$domain = Get-AutomateNOWDomain -Id 'Domain1'
    [ANOWSecRole]$secRole = Get-AutomateNOWSecurityRole -Id 'SecurityRole1'
    $domain | Add-AutomateNOWSecurityRoleDomain -SecurityRole $secRole

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWSecRoleDomain])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWSecRole]$SecurityRole,
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWDomain]$Domain,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$SecurityRole_id = $SecurityRole.Id
        [string]$command = '/secRoleDomain/create'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWDomain]$Domain = $_
        }
        [string]$Domain_id = $Domain.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Add $($Domain_id) to $($SecurityRole_id)")) -eq $true) {
            $Error.Clear()
            Try {
                [ANOWSecRoleDomain[]]$ExistingRoleDomains = $SecurityRole.domainRoles
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to extract the domainRoles from $SecurityRole_id due to [$Message]."
                Break
            }
            [int32]$ExistingRoleDomains_Count = $ExistingRoleDomains.Count
            If ($ExistingRoleDomains_Count -gt 0) {
                Write-Verbose -Message "$SecurityRole_id currently has $ExistingRoleDomains_Count items before any changes were made"
            }
            Else {
                Write-Verbose -Message "$SecurityRole_id does not have any items yet. $Domain_id will be the first domain added to it."
            }
            If ( $Domain_id -in $ExistingRoleDomains.roleDomain) {
                Write-Warning -Message "$SecurityRole_id already contains $Domain_id!"
                Break
            }
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('roleDomain', $Domain_id )
            $BodyMetaData.Add('secRole', $SecurityRole_id )
            $BodyMetaData.Add('_operationType', 'add')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'SecRoleDomainDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$SecurityRole_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            If ($results.response.data.count -gt 0) {
                $Error.Clear()
                Try {
                    $results.response.data[0].secRole = $SecurityRole
                    [ANOWSecRoleDomain]$domainRole = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to parse the [ANOWSecRoleDomain] object after adding $Domain_id to $SecurityRole_id due to [$Message]."
                    Break
                }
                If ($Quiet -ne $true) {
                    Write-Verbose -Message "$Domain_id was added to $SecurityRole_id"
                    Return $domainRole
                }
            }
        }
    }
    End {

    }
}

Function Copy-AutomateNOWSecurityRoleDomain {
    <#
    .SYNOPSIS
    Copies a Security Role Domain within a Security Role on an AutomateNOW! instance

    .DESCRIPTION
    Copies a Security Role Domain within a Security Role on an AutomateNOW! instance and includes all of the properties from the copied Security Role Domain

    .PARAMETER SecurityRole
    Mandatory [ANOWSecRole] object representing the Security Role that will receive the Security Role Domain

    .Parameter SourceDomainRole
    Mandatory [ANOWSecRoleDomain] object representing the Security Role Domain that contains the settings you want to copy to the destination Security Role Domains. This parameter does not exist in Add-AutomateNOWSecurityRoleDomain.

    .Parameter DestinationDomain
    Mandatory [ANOWDomain] objects representing the Domain that will be added to the Security Role but with the settings from the SourceDomainRole.

    .PARAMETER Quiet
    Switch parameter to silence the emitted [ANOWSecRoleDomain] object

    .PARAMETER Force
    Force the addition of the object without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    An [ANOWSecRole] object must be presented along with a single [ANOWDomain] object for the source domain and at least one [ANOWDomain] object for the destination domain. Destination domains can be sent across the pipeline.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Quietly and forcefully copies the settings from a Security Role Domain (i.e. Domain Role) with Id 'fae6a025-6639-4e1e-8e7d-74da7fd6b4d1') into a new Security Role Domain based on a domain named 'Domain1' that will be placed into a Security Role named 'SecurityRole1'
    $domain = Get-AutomateNOWDomain -Id 'Domain1'
    $secRole = Get-AutomateNOWSecurityRole -Id 'SecurityRole1'
    $sourceSecurityRoleDomain = Read-AutomateNOWSecurityRoleDomain -ItemId 'fae6a025-6639-4e1e-8e7d-74da7fd6b4d1'
    Copy-AutomateNOWSecurityRoleDomain -SecurityRole $secRole -SourceDomain $sourceSecurityRoleDomain -DestinationDomain $domain -Force -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWSecRoleDomain])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWSecRole]$SecurityRole,
        [Parameter(Mandatory = $true)]
        [ANOWSecRoleDomain]$SourceDomainRole,
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWDomain]$DestinationDomain,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$SecurityRole_id = $SecurityRole.Id
        [string]$SourceDomainRole_id = $SourceDomainRole.Id
        # This section counts the memmbers from the source domain role before the pipeline starts
        $Error.Clear()
        Try {
            [PSCustomObject[]]$MembersToAdd = $SourceDomainRole | Get-Member -MemberType Property | Where-Object { $_.Name -notin ('designCoreModify', 'id', 'roleDomain', 'secRole', 'userIp') } | ForEach-Object { [PSCustomObject]@{Name = $_.Name; Value = $SourceDomainRole.($_.Name); Type = ($_.Definition -split ' ' | Select-Object -First 1); } }
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-Member failed to extract the properties from [$SourceDomainRole_id] due to [$Message]."
            Break
        }
        [int32]$MembersToAdd_Count = $MembersToAdd.Count
        If ($MembersToAdd_Count -eq 0) {
            Write-Warning -Message "Somehow $SourceDomainRole_id does not have any members"
        }
        [string]$command = '/secRoleDomain/create'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWDomain]$DestinationDomain = $_
        }
        [string]$DestinationDomain_id = $DestinationDomain.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Add $($DestinationDomain_id) to $($SecurityRole_id) with settings copied from $($SourceDomainRole_id)?")) -eq $true) {
            $Error.Clear()
            Try {
                [ANOWSecRoleDomain[]]$ExistingRoleDomains = $SecurityRole.domainRoles
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to extract the domain Roles from $SecurityRole_id due to [$Message]."
                Break
            }
            [int32]$ExistingRoleDomains_Count = $ExistingRoleDomains.Count
            If ($ExistingRoleDomains_Count -gt 0) {
                Write-Verbose -Message "$SecurityRole_id currently has $ExistingRoleDomains_Count items before any changes were made"
            }
            Else {
                Write-Verbose -Message "$ExistingRoleDomains does not have any items yet. $DestinationDomain_id will be the first domain added to it."
            }
            If ( $DestinationDomain_id -in $ExistingRoleDomains.roleDomain) {
                Write-Warning -Message "$SecurityRole_id already contains a Domain Role for $DestinationDomain_id!"
                Break
            }
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('roleDomain', $DestinationDomain_id )
            $BodyMetaData.Add('secRole', $SecurityRole_id )
            $Error.Clear()
            Try {
                ForEach ($Member in $MembersToAdd) {
                    [string]$name = $Member.Name
                    [string]$value = $Member.Value
                    [string]$type = $Member.Type
                    If ($type -eq 'bool') {
                        If ($value -eq $true) {
                            [string]$value = 'true'
                        }
                        ElseIf ($value -eq $false) {
                            [string]$value = 'false'
                        }
                        Else {
                            Write-Warning -Message "Somehow failed to determine the value of a boolean member property [$name/$value] while extracting properties from Domain Role: $SourceDomainRole_id"
                            Break
                        }
                    }
                    ElseIf ($type -eq 'string') {
                        # This space left blank
                    }
                    ElseIf ($type -eq 'datetime') {
                        [string]$value = Get-Date -Date $value -Format "yyyy-MM-ddTHH:mm:ss.fff"
                    }
                    Else {
                        Write-Warning -Message "Somehow failed to determine the type of an unknown type member property [$name/$type] while extracting properties from Domain Role: $SourceDomainRole_id"
                    }
                    $BodyMetaData.Add($name, $value)
                }
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to extract the domain Roles from $SecurityRole_id due to [$Message]."
                Break
            }
            $BodyMetaData.Add('_operationType', 'add')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'SecRoleDomainDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$SecurityRole_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            If ($results.response.data.count -gt 0) {
                $Error.Clear()
                Try {
                    [ANOWSecRoleDomain]$domainRole = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to parse the [ANOWSecRoleDomain] object after adding $DestinationDomain_id to $SecurityRole_id due to [$Message]."
                    Break
                }
                If ($Quiet -ne $true) {
                    Write-Verbose -Message "$DestinationDomain_id was added to $SecurityRole_id"
                    Return $domainRole
                }
            }
        }
    }
    End {

    }
}

Function Set-AutomateNOWSecurityRoleDomain {
    <#
    .SYNOPSIS
    Modifies the settings of a Security Role Domain within a Security Role on an AutomateNOW! instance

    .DESCRIPTION
    Modifies the settings of a Security Role Domain within a Security Role on an AutomateNOW! instance

    .PARAMETER SecurityRole
    Mandatory [ANOWSecRole] object representing the Security Role that contains the Security Role Domain that will be modified.

    .Parameter DomainRole
    Mandatory [ANOWSecRoleDomain] object representing the Security Role Domain that is to be modified.

	.PARAMETER DomainAdmin
	[boolean] parameter to enable 'Domain Admin'

	.PARAMETER AllowBusinessViewAccess
	[boolean] parameter to enable 'Allow Business View Access'

	.PARAMETER AllowBusinessViewAccessTags
	[string] array for limiting to tags on 'Allow Business View Access'

	.PARAMETER AllowDesignBusinessViewAccess
	[boolean] parameter to enable 'Allow Design Business View Access'

	.PARAMETER AllowDesignBusinessViewModification
	[boolean] parameter to enable 'Allow Design Business View Modification'

	.PARAMETER AllowMonitoringBusinessViewAccess
	[boolean] parameter to enable 'Allow Monitoring Business View Access'

	.PARAMETER AllowMonitoringAccess
	[boolean] parameter to enable 'Allow Monitoring Access'

	.PARAMETER AllowMonitoringAccessTags
	[string] array for limiting to tags on 'Allow Monitoring Access'

	.PARAMETER AllowProcessingRestart
	[boolean] parameter to enable 'Allow Processing Restart'

	.PARAMETER AllowProcessingRestartTags
	[string] array for limiting to tags on 'Allow Processing Restart'

	.PARAMETER AllowProcessingSkip
	[boolean] parameter to enable 'Allow Processing Skip'

	.PARAMETER AllowProcessingSkipTags
	[string] array for limiting to tags on 'Allow Processing Skip'

	.PARAMETER AllowProcessingHold
	[boolean] parameter to enable 'Allow Processing Hold'

	.PARAMETER AllowProcessingHoldTags
	[string] array for limiting to tags on 'Allow Processing Hold'

	.PARAMETER AllowProcessingKill
	[boolean] parameter to enable 'Allow Processing Kill'

	.PARAMETER AllowProcessingKillTags
	[string] array for limiting to tags on 'Allow Processing Kill'

	.PARAMETER AllowProcessingForceCompleted
	[boolean] parameter to enable 'Allow Processing Force Completed'

	.PARAMETER AllowProcessingForceCompletedTags
	[string] array for limiting to tags on 'Allow Processing Force Completed'

	.PARAMETER AllowProcessingForceFailed
	[boolean] parameter to enable 'Allow Processing Force Failed'

	.PARAMETER AllowProcessingForceFailedTags
	[string] array for limiting to tags on 'Allow Processing Force Failed'

	.PARAMETER AllowProcessingForceLaunch
	[boolean] parameter to enable 'Allow Processing Force Launch'

	.PARAMETER AllowProcessingForceLaunchTags
	[string] array for limiting to tags on 'Allow Processing Force Launch'

	.PARAMETER AllowInternalActions
	[boolean] parameter to enable 'Allow Internal Actions'

	.PARAMETER AllowInternalActionsTags
	[string] array for limiting to tags on 'Allow Internal Actions'

	.PARAMETER AllowProcessingModification
	[boolean] parameter to enable 'Allow Processing Modification'

	.PARAMETER AllowProcessingModificationTags
	[string] array for limiting to tags on 'Allow Processing Modification'

	.PARAMETER AllowRuntimeActionsModification
	[boolean] parameter to enable 'Allow Runtime Actions Modification'

	.PARAMETER AllowProcessingArchive
	[boolean] parameter to enable 'Allow Processing Archive'

	.PARAMETER AllowProcessingArchiveTags
	[string] array for limiting to tags on 'Allow Processing Archive'

	.PARAMETER LowLevelApproval
	[boolean] parameter to enable 'Low Level Approval'

	.PARAMETER LowLevelApprovalTags
	[string] array for limiting to tags on 'Low Level Approval'

	.PARAMETER MediumLevelApproval
	[boolean] parameter to enable 'Medium Level Approval'

	.PARAMETER MediumLevelApprovalTags
	[string] array for limiting to tags on 'Medium Level Approval'

	.PARAMETER HighLevelApproval
	[boolean] parameter to enable 'High Level Approval'

	.PARAMETER HighLevelApprovalTags
	[string] array for limiting to tags on 'High Level Approval'

	.PARAMETER AllowArchiveAccess
	[boolean] parameter to enable 'Allow Archive Access'

	.PARAMETER AllowDesignAccess
	[boolean] parameter to enable 'Allow Design Access'

	.PARAMETER AllowBusinessViewAccessTags
	[string] array for limiting to tags on 'Allow Business View Access'

	.PARAMETER AllowDesignCoreModification
	[boolean] parameter to enable 'Allow Design Core Modification'

	.PARAMETER AllowDesignCoreModificationTags
	[string] array for limiting to tags on 'Allow Design Core Modification'

	.PARAMETER AllowWorkflowItemsModification
	[boolean] parameter to enable 'Allow Workflow Items Modification'

	.PARAMETER AllowDesignResourceModification
	[boolean] parameter to enable 'Allow Design Resource Modification'

	.PARAMETER AllowDesignActionModification
	[boolean] parameter to enable 'Allow Design Action Modification'

	.PARAMETER AllowResultMappingAccess
	[boolean] parameter to enable 'Allow Result Mapping Access'

	.PARAMETER AllowResultMappingAccessTags
	[string] array for limiting to tags on 'Allow Result Mapping Access'

	.PARAMETER AllowResultMappingModification
	[boolean] parameter to enable 'Allow Result Mapping Modification'

	.PARAMETER AllowResultMappingModificationTags
	[string] array for limiting to tags on 'Allow Result Mapping Modification'

	.PARAMETER AllowIntefaceAccess
	[boolean] parameter to enable 'Allow Inteface Access'

	.PARAMETER AllowIntefaceAccessTags
	[string] array for limiting to tags on 'Allow Inteface Access'

	.PARAMETER AllowIntefaceModification
	[boolean] parameter to enable 'Allow Inteface Modification'

	.PARAMETER AllowIntefaceModificationTags
	[string] array for limiting to tags on 'Allow Inteface Modification'

	.PARAMETER AllowNodeAccess
	[boolean] parameter to enable 'Allow Node Access'

	.PARAMETER AllowNodeAccessTags
	[string] array for limiting to tags on 'Allow Node Access'

	.PARAMETER AllowNodeModification
	[boolean] parameter to enable 'Allow Node Modification'

	.PARAMETER AllowNodeModificationTags
	[string] array for limiting to tags on 'Allow Node Modification'

	.PARAMETER AllowNodeHold
	[boolean] parameter to enable 'Allow Node Hold'

	.PARAMETER AllowNodeHoldTags
	[string] array for limiting to tags on 'Allow Node Hold'

	.PARAMETER AllowNodeSkip
	[boolean] parameter to enable 'Allow Node Skip'

	.PARAMETER AllowNodeSkipTags
	[string] array for limiting to tags on 'Allow Node Skip'

	.PARAMETER AllowNodeStart/Stop
	[boolean] parameter to enable 'Allow Node Start/Stop'

	.PARAMETER AllowNodeStart/StopTags
	[string] array for limiting to tags on 'Allow Node Start/Stop'

	.PARAMETER AllowNodeKill
	[boolean] parameter to enable 'Allow Node Kill'

	.PARAMETER AllowNodeKillTags
	[string] array for limiting to tags on 'Allow Node Kill'

	.PARAMETER AllowNodeEndpointModification
	[boolean] parameter to enable 'Allow Node Endpoint Modification'

	.PARAMETER AllowNodeEndpointModificationTags
	[string] array for limiting to tags on 'Allow Node Endpoint Modification'

	.PARAMETER AllowEndpointAccess
	[boolean] parameter to enable 'Allow Endpoint Access'

	.PARAMETER AllowEndpointAccessTags
	[string] array for limiting to tags on 'Allow Endpoint Access'

	.PARAMETER AllowEndpointModification
	[boolean] parameter to enable 'Allow Endpoint Modification'

	.PARAMETER AllowEndpointModificationTags
	[string] array for limiting to tags on 'Allow Endpoint Modification'

	.PARAMETER AllowResourceAccess
	[boolean] parameter to enable 'Allow Resource Access'

	.PARAMETER AllowResourceAccessTags
	[string] array for limiting to tags on 'Allow Resource Access'

	.PARAMETER AllowResourceModification
	[boolean] parameter to enable 'Allow Resource Modification'

	.PARAMETER AllowResourceModificationTags
	[string] array for limiting to tags on 'Allow Resource Modification'

	.PARAMETER AllowDataSourceAccess
	[boolean] parameter to enable 'Allow Data Source Access'

	.PARAMETER AllowDataSourceAccessTags
	[string] array for limiting to tags on 'Allow Data Source Access'

	.PARAMETER AllowDataSourceModification
	[boolean] parameter to enable 'Allow Data Source Modification'

	.PARAMETER DataSourceModifyTags
	[string] array for limiting to tags on 'Allow Data Source Modification'

	.PARAMETER AllowAnomalyAccess
	[boolean] parameter to enable 'Allow Anomaly Access'

	.PARAMETER AllowAnomalyAccessTags
	[string] array for limiting to tags on 'Allow Anomaly Access'

	.PARAMETER AllowAnomalyModification
	[boolean] parameter to enable 'Allow Anomaly Modification'

	.PARAMETER AllowAnomalyModificationTags
	[string] array for limiting to tags on 'Allow Anomaly Modification'

	.PARAMETER AllowAdHocReportAccess
	[boolean] parameter to enable 'Allow AdHoc Report Access'

	.PARAMETER AllowAdHocReportAccessTags
	[string] array for limiting to tags on 'Allow AdHoc Report Access'

	.PARAMETER AllowAdHocReportModification
	[boolean] parameter to enable 'Allow AdHoc Report Modification'

	.PARAMETER AllowAdHocReportModificationTags
	[string] array for limiting to tags on 'Allow AdHoc Report Modification'

	.PARAMETER AllowDashboardAccess
	[boolean] parameter to enable 'Allow Dashboard Access'

	.PARAMETER AllowDashboardAccessTags
	[string] array for limiting to tags on 'Allow Dashboard Access'

	.PARAMETER AllowDashboardModification
	[boolean] parameter to enable 'Allow Dashboard Modification'

	.PARAMETER AllowDashboardModificationTags
	[string] array for limiting to tags on 'Allow Dashboard Modification'

	.PARAMETER AllowUserReportAccess
	[boolean] parameter to enable 'Allow User Report Access'

	.PARAMETER AllowUserReportAccessTags
	[string] array for limiting to tags on 'Allow User Report Access'

	.PARAMETER AllowUserReportModification
	[boolean] parameter to enable 'Allow User Report Modification'

	.PARAMETER AllowUserReportModificationTags
	[string] array for limiting to tags on 'Allow User Report Modification'

	.PARAMETER AllowWorkspaceAccess
	[boolean] parameter to enable 'Allow Workspace Access'

	.PARAMETER AllowWorkspaceAccessTags
	[string] array for limiting to tags on 'Allow Workspace Access'

	.PARAMETER AllowWorkspaceModification
	[boolean] parameter to enable 'Allow Workspace Modification'

	.PARAMETER AllowWorkspaceModificationTags
	[string] array for limiting to tags on 'Allow Workspace Modification'

	.PARAMETER AllowApprovalConfiguration
	[boolean] parameter to enable 'Allow Approval Configuration'

	.PARAMETER AllowNotificationAccess
	[boolean] parameter to enable 'Allow Notification Access'

	.PARAMETER AllowNotificationAccessTags
	[string] array for limiting to tags on 'Allow Notification Access'

	.PARAMETER AllowNotificationModification
	[boolean] parameter to enable 'Allow Notification Modification'

	.PARAMETER AllowNotificationModificationTags
	[string] array for limiting to tags on 'Allow Notification Modification'

	.PARAMETER AllowManagementofCodeRepositories
	[boolean] parameter to enable 'Allow Management of Code Repositories'

	.PARAMETER AllowManagementofCodeRepositoriesTags
	[string] array for limiting to tags on 'Allow Management of Code Repositories'

	.PARAMETER AllowexecutionofPushonCodeRepository
	[boolean] parameter to enable 'Allow execution of Push on Code Repository'

	.PARAMETER AllowexecutionofPullonCodeRepository
	[boolean] parameter to enable 'Allow execution of Pull on Code Repository'

	.PARAMETER AllowCreationofMergeRequests
	[boolean] parameter to enable 'Allow Creation of Merge Requests'

	.PARAMETER AllowApprovalofMergeRequests
	[boolean] parameter to enable 'Allow Approval of Merge Requests'

	.PARAMETER DataMigrationViewer
	[boolean] parameter to enable 'Data Migration Viewer'

	.PARAMETER DataMigration
	[boolean] parameter to enable 'Data Migration'

	.PARAMETER AllowNewProcessingLaunch
	[boolean] parameter to enable 'Allow New Processing Launch'

	.PARAMETER AllowNewProcessingLaunchTags
	[string] array for limiting to tags on 'Allow New Processing Launch'

	.PARAMETER AllowSelfService
	[boolean] parameter to enable 'Allow Self Service'

	.PARAMETER AllowSelfServiceTags
	[string] array for limiting to tags on 'Allow Self Service'

    .PARAMETER Quiet
    Switch parameter to silence the emitted [ANOWSecRoleDomain] object

    .PARAMETER Force
    Force the addition of the object without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    An [ANOWSecRole] object must be presented along with one (or more across the pipeline) [ANOWSecRoleDomain] objects that will be modified.

    .OUTPUTS
    The updated [ANOWSecRoleDomain] object will be returned

    .EXAMPLE
    Forcibly enables 'Allow Monitoring Access' for 2 tags named 'Tag1' and 'Tag2' in a Domain Security Role for a Domain called 'Domain1' that is located within a Security Role named 'SecurityRole1' (multi-line format)

    [ANOWSecRole]$secRole = Get-AutomateNOWSecurityRole -Id 'SecurityRole1'
    [ANOWSecRoleDomain]$domainRole = $secRole.domainRoles | Where-Object { $_.roleDomain -eq 'Domain1'}
    Set-AutomateNOWSecurityRoleDomain -SecurityRole $secRole -domainRole $domainRole -AllowMonitoringAccess $true -AllowMonitoringAccessTags 'Tag1', 'Tag2' -Force

    .EXAMPLE
    Disables 'Allow Monitoring Access' in a Domain Security Role for a Domain called 'Domain1' that is located within a Security Role named 'SecurityRole1' (multi-line format)

    [ANOWSecRole]$secRole = Get-AutomateNOWSecurityRole -Id 'SecurityRole1'
    [ANOWSecRoleDomain]$domainRole = $secRole.domainRoles | Where-Object { $_.roleDomain -eq 'Domain1'}
    Set-AutomateNOWSecurityRoleDomain -SecurityRole $secRole -domainRole $domainRole -AllowMonitoringAccess $false

    .EXAMPLE
    Forcibly enables 'Allow Monitoring Access' for 2 tags named 'Tag1' and 'Tag2' in a Domain Security Role for a Domain called 'Domain1' that is located within a Security Role named 'SecurityRole1' (one-liner format)

    Get-AutomateNOWSecurityRole -Id 'SecurityRole1' | Select-Object -ExpandProperty domainRoles | Where-Object { $_.roleDomain -eq 'Domain1'} | Set-AutomateNOWSecurityRoleDomain -SecurityRole (Get-AutomateNOWSecurityRole -Id 'SecurityRole1') -AllowMonitoringAccess $true -AllowMonitoringAccessTags 'Tag1', 'Tag2' -Force

    .EXAMPLE
    Forcibly enables 'Domain Admin' in a Domain Security Role for a Domain called 'Domain1' that is located within a Security Role named 'SecurityRole1' (multi-line format)

    [ANOWSecRole]$secRole = Get-AutomateNOWSecurityRole -Id 'SecurityRole1'
    [ANOWSecRoleDomain]$domainRole = $secRole.domainRoles | Where-Object { $_.roleDomain -eq 'Domain1'}
    Set-AutomateNOWSecurityRoleDomain -SecurityRole $secRole -domainRole $domainRole -DomainAdmin $true -Force

    .EXAMPLE
    Quietly enables all privileges and limits those privileges to two Tags named 'Tag1' and 'Tag2' within a Domain Security Role for a Domain called 'Domain1' that is located within a Security Role named 'SecurityRole1' (multi-line format)

    [ANOWSecRole]$secRole = Get-AutomateNOWSecurityRole -Id 'SecurityRole1'
    [ANOWSecRoleDomain]$domainRole = $secRole.domainRoles | Where-Object { $_.roleDomain -eq 'Domain1'}
    Set-AutomateNOWSecurityRoleDomain -Quiet -SecurityRole $secRole -domainRole $domainRole -AllowBusinessViewAccess $true -AllowBusinessViewAccessTags 'Tag1', 'Tag2' -AllowDesignBusinessViewAccess $true -AllowDesignBusinessViewModification $true -AllowMonitoringBusinessViewAccess $true -AllowMonitoringAccess $true -AllowMonitoringAccessTags 'Tag1', 'Tag2' -AllowProcessingRestart $true -AllowProcessingRestartTags 'Tag1', 'Tag2' -AllowProcessingSkip $true -AllowProcessingSkipTags 'Tag1', 'Tag2' -AllowProcessingHold $true -AllowProcessingHoldTags 'Tag1', 'Tag2' -AllowProcessingKill $true -AllowProcessingKillTags 'Tag1', 'Tag2' -AllowProcessingForceCompleted $true -AllowProcessingForceCompletedTags 'Tag1', 'Tag2' -AllowProcessingForceFailed $true -AllowProcessingForceFailedTags 'Tag1', 'Tag2' -AllowProcessingForceLaunch $true -AllowProcessingForceLaunchTags 'Tag1', 'Tag2' -AllowInternalActions $true -AllowInternalActionsTags 'Tag1', 'Tag2' -AllowProcessingModification $true -AllowProcessingModificationTags 'Tag1', 'Tag2' -AllowRuntimeActionsModification $true -AllowProcessingArchive $true -AllowProcessingArchiveTags 'Tag1', 'Tag2' -LowLevelApproval $true -LowLevelApprovalTags 'Tag1', 'Tag2' -MediumLevelApproval $true -MediumLevelApprovalTags 'Tag1', 'Tag2' -HighLevelApproval $true -HighLevelApprovalTags 'Tag1', 'Tag2' -AllowArchiveAccess $true -AllowDesignAccess $true -AllowDesignAccessTags 'Tag1', 'Tag2' -AllowDesignCoreModification $true -AllowDesignCoreModificationTags 'Tag1', 'Tag2' -AllowWorkflowItemsModification $true -AllowDesignResourceModification $true -AllowDesignActionModification $true -AllowResultMappingAccess $true -AllowResultMappingAccessTags 'Tag1', 'Tag2' -AllowResultMappingModification $true -AllowResultMappingModificationTags 'Tag1', 'Tag2' -AllowIntefaceAccess $true -AllowIntefaceAccessTags 'Tag1', 'Tag2' -AllowIntefaceModification $true -AllowIntefaceModificationTags 'Tag1', 'Tag2' -AllowNodeAccess $true -AllowNodeAccessTags 'Tag1', 'Tag2' -AllowNodeModification $true -AllowNodeModificationTags 'Tag1', 'Tag2' -AllowNodeHold $true -AllowNodeHoldTags 'Tag1', 'Tag2' -AllowNodeSkip $true -AllowNodeSkipTags 'Tag1', 'Tag2' -AllowNodeStartStop $true -AllowNodeStartStopTags 'Tag1', 'Tag2' -AllowNodeKill $true -AllowNodeKillTags 'Tag1', 'Tag2' -AllowNodeEndpointModification $true -AllowNodeEndpointModificationTags 'Tag1', 'Tag2' -AllowEndpointAccess $true -AllowEndpointAccessTags 'Tag1', 'Tag2' -AllowEndpointModification $true -AllowEndpointModificationTags 'Tag1', 'Tag2' -AllowResourceAccess $true -AllowResourceAccessTags 'Tag1', 'Tag2' -AllowResourceModification $true -AllowResourceModificationTags 'Tag1', 'Tag2' -AllowDataSourceAccess $true -AllowDataSourceAccessTags 'Tag1', 'Tag2' -AllowDataSourceModification $true -DataSourceModifyTags 'Tag1', 'Tag2' -AllowAnomalyAccess $true -AllowAnomalyAccessTags 'Tag1', 'Tag2' -AllowAnomalyModification $true -AllowAnomalyModificationTags 'Tag1', 'Tag2' -AllowAdHocReportAccess $true -AllowAdHocReportAccessTags 'Tag1', 'Tag2' -AllowAdHocReportModification $true -AllowAdHocReportModificationTags 'Tag1', 'Tag2' -AllowDashboardAccess $true -AllowDashboardAccessTags 'Tag1', 'Tag2' -AllowDashboardModification $true -AllowDashboardModificationTags 'Tag1', 'Tag2' -AllowUserReportAccess $true -AllowUserReportAccessTags 'Tag1', 'Tag2' -AllowUserReportModification $true -AllowUserReportModificationTags 'Tag1', 'Tag2' -AllowWorkspaceAccess $true -AllowWorkspaceAccessTags 'Tag1', 'Tag2' -AllowWorkspaceModification $true -AllowWorkspaceModificationTags 'Tag1', 'Tag2' -AllowApprovalConfiguration $true -AllowNotificationAccess $true -AllowNotificationAccessTags 'Tag1', 'Tag2' -AllowNotificationModification $true -AllowNotificationModificationTags 'Tag1', 'Tag2' -AllowManagementofCodeRepositories $true -AllowManagementofCodeRepositoriesTags 'Tag1', 'Tag2' -AllowexecutionofPushonCodeRepository $true -AllowexecutionofPullonCodeRepository $true -AllowCreationofMergeRequests $true -AllowApprovalofMergeRequests $true -DataMigrationViewer $true -DataMigration $true -AllowNewProcessingLaunch $true -AllowNewProcessingLaunchTags 'Tag1', 'Tag2' -AllowSelfService $true -AllowSelfServiceTags 'Tag1', 'Tag2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    If the -DomainAdmin parameter is set to $true then ALL OTHER parameters will be ignored by this function.

    Changes to the assigned tags on a privilege will be ignored by the API if the privilege is not set to $true. This function will not warn you in this scenario.

    To remove the tag assignments from a privilege while keeping the privilege enabled, set it to $false then back to $true.

    Use with function with caution and only after extensive testing in your test environment.

    #>
    [OutputType([ANOWSecRoleDomain])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWSecRole]$SecurityRole,
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWSecRoleDomain]$DomainRole,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$DomainAdmin,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowBusinessViewAccess,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowBusinessViewAccessTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowDesignBusinessViewAccess,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowDesignBusinessViewModification,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowMonitoringBusinessViewAccess,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowMonitoringAccess,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowMonitoringAccessTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowProcessingRestart,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowProcessingRestartTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowProcessingSkip,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowProcessingSkipTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowProcessingHold,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowProcessingHoldTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowProcessingKill,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowProcessingKillTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowProcessingForceCompleted,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowProcessingForceCompletedTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowProcessingForceFailed,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowProcessingForceFailedTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowProcessingForceLaunch,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowProcessingForceLaunchTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowInternalActions,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowInternalActionsTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowProcessingModification,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowProcessingModificationTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowRuntimeActionsModification,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowProcessingArchive,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowProcessingArchiveTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$LowLevelApproval,
        [Parameter(Mandatory = $false)]
        [string[]]$LowLevelApprovalTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$MediumLevelApproval,
        [Parameter(Mandatory = $false)]
        [string[]]$MediumLevelApprovalTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$HighLevelApproval,
        [Parameter(Mandatory = $false)]
        [string[]]$HighLevelApprovalTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowArchiveAccess,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowDesignAccess,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowDesignAccessTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowDesignCoreModification,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowDesignCoreModificationTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowWorkflowItemsModification,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowDesignResourceModification,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowDesignActionModification,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowResultMappingAccess,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowResultMappingAccessTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowResultMappingModification,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowResultMappingModificationTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowIntefaceAccess,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowIntefaceAccessTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowIntefaceModification,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowIntefaceModificationTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowNodeAccess,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowNodeAccessTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowNodeModification,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowNodeModificationTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowNodeHold,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowNodeHoldTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowNodeSkip,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowNodeSkipTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowNodeStartStop,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowNodeStartStopTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowNodeKill,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowNodeKillTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowNodeEndpointModification,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowNodeEndpointModificationTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowEndpointAccess,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowEndpointAccessTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowEndpointModification,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowEndpointModificationTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowResourceAccess,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowResourceAccessTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowResourceModification,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowResourceModificationTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowDataSourceAccess,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowDataSourceAccessTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowDataSourceModification,
        [Parameter(Mandatory = $false)]
        [string[]]$DataSourceModifyTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowAnomalyAccess,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowAnomalyAccessTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowAnomalyModification,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowAnomalyModificationTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowAdHocReportAccess,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowAdHocReportAccessTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowAdHocReportModification,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowAdHocReportModificationTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowDashboardAccess,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowDashboardAccessTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowDashboardModification,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowDashboardModificationTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowUserReportAccess,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowUserReportAccessTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowUserReportModification,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowUserReportModificationTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowWorkspaceAccess,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowWorkspaceAccessTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowWorkspaceModification,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowWorkspaceModificationTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowApprovalConfiguration,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowNotificationAccess,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowNotificationAccessTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowNotificationModification,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowNotificationModificationTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowManagementofCodeRepositories,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowManagementofCodeRepositoriesTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowexecutionofPushonCodeRepository,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowexecutionofPullonCodeRepository,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowCreationofMergeRequests,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowApprovalofMergeRequests,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$DataMigrationViewer,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$DataMigration,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowNewProcessingLaunch,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowNewProcessingLaunchTags,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$AllowSelfService,
        [Parameter(Mandatory = $false)]
        [string[]]$AllowSelfServiceTags,
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$SecurityRole_id = $SecurityRole.Id
        [string]$command = '/secRoleDomain/update'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWSecRoleDomain]$DomainRole = $_
        }
        [string]$DomainRole_Id = $DomainRole.Id
        [string]$DomainRole_Domain = $DomainRole.roleDomain
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$DomainRole_Domain's domain role in $($SecurityRole_id)?")) -eq $true) {
            $Error.Clear()
            Try {
                [ANOWSecRoleDomain[]]$ExistingRoleDomains = $SecurityRole.domainRoles
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to extract the domain Roles from $SecurityRole_id due to [$Message]."
                Break
            }
            [int32]$ExistingRoleDomains_Count = $ExistingRoleDomains.Count
            If ($ExistingRoleDomains_Count -gt 0) {
                Write-Verbose -Message "$SecurityRole_id currently has $ExistingRoleDomains_Count Domain Roles"
            }
            Else {
                Write-Warning -Message "$SecurityRole_id does not have any Domain Roles yet. Please look into this."
                Break
            }
            If ( $DomainRole_Id -notin $ExistingRoleDomains.id) {
                Write-Warning -Message "$DomainRole_Id is not actually attached to $SecurityRole_id!"
                Break
            }
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $DomainRole_Id)
            If ($DomainAdmin -eq $true) {
                $BodyMetaData.Add('domainAdmin', 'true')
            }
            Else {
                $BodyMetaData.Add('domainAdmin', 'false')
                If ($AllowBusinessViewAccess -eq $true) {
                    $BodyMetaData.Add('businessView', 'true')
                }
                ElseIf ($AllowBusinessViewAccess -eq $false) {
                    $BodyMetaData.Add('businessView', 'false')
                }
                If ($AllowDesignBusinessViewAccess -eq $true) {
                    $BodyMetaData.Add('designBusinessView', 'true')
                }
                ElseIf ($AllowDesignBusinessViewAccess -eq $false) {
                    $BodyMetaData.Add('designBusinessView', 'false')
                }
                If ($AllowDesignBusinessViewModification -eq $true) {
                    $BodyMetaData.Add('designBusinessViewModify', 'true')
                }
                ElseIf ($AllowDesignBusinessViewModification -eq $false) {
                    $BodyMetaData.Add('designBusinessViewModify', 'false')
                }
                If ($AllowMonitoringBusinessViewAccess -eq $true) {
                    $BodyMetaData.Add('monitorBusinessView', 'true')
                }
                ElseIf ($AllowMonitoringBusinessViewAccess -eq $false) {
                    $BodyMetaData.Add('monitorBusinessView', 'false')
                }
                If ($AllowMonitoringAccess -eq $true) {
                    $BodyMetaData.Add('monitor', 'true')
                }
                ElseIf ($AllowMonitoringAccess -eq $false) {
                    $BodyMetaData.Add('monitor', 'false')
                }
                If ($AllowProcessingRestart -eq $true) {
                    $BodyMetaData.Add('monitorRestart', 'true')
                }
                ElseIf ($AllowProcessingRestart -eq $false) {
                    $BodyMetaData.Add('monitorRestart', 'false')
                }
                If ($AllowProcessingSkip -eq $true) {
                    $BodyMetaData.Add('monitorPassBy', 'true')
                }
                ElseIf ($AllowProcessingSkip -eq $false) {
                    $BodyMetaData.Add('monitorPassBy', 'false')
                }
                If ($AllowProcessingHold -eq $true) {
                    $BodyMetaData.Add('monitorHold', 'true')
                }
                ElseIf ($AllowProcessingHold -eq $false) {
                    $BodyMetaData.Add('monitorHold', 'false')
                }
                If ($AllowProcessingKill -eq $true) {
                    $BodyMetaData.Add('monitorKill', 'true')
                }
                ElseIf ($AllowProcessingKill -eq $false) {
                    $BodyMetaData.Add('monitorKill', 'false')
                }
                If ($AllowProcessingForceCompleted -eq $true) {
                    $BodyMetaData.Add('monitorForceCompleted', 'true')
                }
                ElseIf ($AllowProcessingForceCompleted -eq $false) {
                    $BodyMetaData.Add('monitorForceCompleted', 'false')
                }
                If ($AllowProcessingForceFailed -eq $true) {
                    $BodyMetaData.Add('monitorForceFailed', 'true')
                }
                ElseIf ($AllowProcessingForceFailed -eq $false) {
                    $BodyMetaData.Add('monitorForceFailed', 'false')
                }
                If ($AllowProcessingForceLaunch -eq $true) {
                    $BodyMetaData.Add('monitorForceLaunch', 'true')
                }
                ElseIf ($AllowProcessingForceLaunch -eq $false) {
                    $BodyMetaData.Add('monitorForceLaunch', 'false')
                }
                If ($AllowInternalActions -eq $true) {
                    $BodyMetaData.Add('monitorInternalActions', 'true')
                }
                ElseIf ($AllowInternalActions -eq $false) {
                    $BodyMetaData.Add('monitorInternalActions', 'false')
                }
                If ($AllowProcessingModification -eq $true) {
                    $BodyMetaData.Add('processingModify', 'true')
                }
                ElseIf ($AllowProcessingModification -eq $false) {
                    $BodyMetaData.Add('processingModify', 'false')
                }
                If ($AllowRuntimeActionsModification -eq $true) {
                    $BodyMetaData.Add('runtimeActionModify', 'true')
                }
                ElseIf ($AllowRuntimeActionsModification -eq $false) {
                    $BodyMetaData.Add('runtimeActionModify', 'false')
                }
                If ($AllowProcessingArchive -eq $true) {
                    $BodyMetaData.Add('processingArchive', 'true')
                }
                ElseIf ($AllowProcessingArchive -eq $false) {
                    $BodyMetaData.Add('processingArchive', 'false')
                }
                If ($LowLevelApproval -eq $true) {
                    $BodyMetaData.Add('lowLevelApproval', 'true')
                }
                ElseIf ($LowLevelApproval -eq $false) {
                    $BodyMetaData.Add('lowLevelApproval', 'false')
                }
                If ($MediumLevelApproval -eq $true) {
                    $BodyMetaData.Add('mediumLevelApproval', 'true')
                }
                ElseIf ($MediumLevelApproval -eq $false) {
                    $BodyMetaData.Add('mediumLevelApproval', 'false')
                }
                If ($HighLevelApproval -eq $true) {
                    $BodyMetaData.Add('highLevelApproval', 'true')
                }
                ElseIf ($HighLevelApproval -eq $false) {
                    $BodyMetaData.Add('highLevelApproval', 'false')
                }
                If ($AllowArchiveAccess -eq $true) {
                    $BodyMetaData.Add('archive', 'true')
                }
                ElseIf ($AllowArchiveAccess -eq $false) {
                    $BodyMetaData.Add('archive', 'false')
                }
                If ($AllowDesignAccess -eq $true) {
                    $BodyMetaData.Add('design', 'true')
                }
                ElseIf ($AllowDesignAccess -eq $false) {
                    $BodyMetaData.Add('design', 'false')
                }
                If ($AllowDesignCoreModification -eq $true) {
                    $BodyMetaData.Add('designModify', 'true')
                }
                ElseIf ($AllowDesignCoreModification -eq $false) {
                    $BodyMetaData.Add('designModify', 'false')
                }
                If ($AllowWorkflowItemsModification -eq $true) {
                    $BodyMetaData.Add('designDependencyModify', 'true')
                }
                ElseIf ($AllowWorkflowItemsModification -eq $false) {
                    $BodyMetaData.Add('designDependencyModify', 'false')
                }
                If ($AllowDesignResourceModification -eq $true) {
                    $BodyMetaData.Add('designResourceModify', 'true')
                }
                ElseIf ($AllowDesignResourceModification -eq $false) {
                    $BodyMetaData.Add('designResourceModify', 'false')
                }
                If ($AllowDesignActionModification -eq $true) {
                    $BodyMetaData.Add('designActionModify', 'true')
                }
                ElseIf ($AllowDesignActionModification -eq $false) {
                    $BodyMetaData.Add('designActionModify', 'false')
                }
                If ($AllowResultMappingAccess -eq $true) {
                    $BodyMetaData.Add('resultMapping', 'true')
                }
                ElseIf ($AllowResultMappingAccess -eq $false) {
                    $BodyMetaData.Add('resultMapping', 'false')
                }
                If ($AllowResultMappingModification -eq $true) {
                    $BodyMetaData.Add('resultMappingModify', 'true')
                }
                ElseIf ($AllowResultMappingModification -eq $false) {
                    $BodyMetaData.Add('resultMappingModify', 'false')
                }
                If ($AllowIntefaceAccess -eq $true) {
                    $BodyMetaData.Add('integrator', 'true')
                }
                ElseIf ($AllowIntefaceAccess -eq $false) {
                    $BodyMetaData.Add('integrator', 'false')
                }
                If ($AllowIntefaceModification -eq $true) {
                    $BodyMetaData.Add('integratorModify', 'true')
                }
                ElseIf ($AllowIntefaceModification -eq $false) {
                    $BodyMetaData.Add('integratorModify', 'false')
                }
                If ($AllowNodeAccess -eq $true) {
                    $BodyMetaData.Add('node', 'true')
                }
                ElseIf ($AllowNodeAccess -eq $false) {
                    $BodyMetaData.Add('node', 'false')
                }
                If ($AllowNodeModification -eq $true) {
                    $BodyMetaData.Add('nodeModify', 'true')
                }
                ElseIf ($AllowNodeModification -eq $false) {
                    $BodyMetaData.Add('nodeModify', 'false')
                }
                If ($AllowNodeHold -eq $true) {
                    $BodyMetaData.Add('nodeHold', 'true')
                }
                ElseIf ($AllowNodeHold -eq $false) {
                    $BodyMetaData.Add('nodeHold', 'false')
                }
                If ($AllowNodeSkip -eq $true) {
                    $BodyMetaData.Add('nodePassBy', 'true')
                }
                ElseIf ($AllowNodeSkip -eq $false) {
                    $BodyMetaData.Add('nodePassBy', 'false')
                }
                If ($AllowNodeStartStop -eq $true) {
                    $BodyMetaData.Add('nodeStart', 'true')
                }
                ElseIf ($AllowNodeStartStop -eq $false) {
                    $BodyMetaData.Add('nodeStart', 'false')
                }
                If ($AllowNodeKill -eq $true) {
                    $BodyMetaData.Add('nodeKill', 'true')
                }
                ElseIf ($AllowNodeKill -eq $false) {
                    $BodyMetaData.Add('nodeKill', 'false')
                }
                If ($AllowNodeEndpointModification -eq $true) {
                    $BodyMetaData.Add('nodeModifyEndpoint', 'true')
                }
                ElseIf ($AllowNodeEndpointModification -eq $false) {
                    $BodyMetaData.Add('nodeModifyEndpoint', 'false')
                }
                If ($AllowEndpointAccess -eq $true) {
                    $BodyMetaData.Add('endpoint', 'true')
                }
                ElseIf ($AllowEndpointAccess -eq $false) {
                    $BodyMetaData.Add('endpoint', 'false')
                }
                If ($AllowEndpointModification -eq $true) {
                    $BodyMetaData.Add('endpointModify', 'true')
                }
                ElseIf ($AllowEndpointModification -eq $false) {
                    $BodyMetaData.Add('endpointModify', 'false')
                }
                If ($AllowResourceAccess -eq $true) {
                    $BodyMetaData.Add('resource', 'true')
                }
                ElseIf ($AllowResourceAccess -eq $false) {
                    $BodyMetaData.Add('resource', 'false')
                }
                If ($AllowResourceModification -eq $true) {
                    $BodyMetaData.Add('resourceModify', 'true')
                }
                ElseIf ($AllowResourceModification -eq $false) {
                    $BodyMetaData.Add('resourceModify', 'false')
                }
                If ($AllowDataSourceAccess -eq $true) {
                    $BodyMetaData.Add('dataSourceAccess', 'true')
                }
                ElseIf ($AllowDataSourceAccess -eq $false) {
                    $BodyMetaData.Add('dataSourceAccess', 'false')
                }
                If ($AllowDataSourceModification -eq $true) {
                    $BodyMetaData.Add('dataSourceModify', 'true')
                }
                ElseIf ($AllowDataSourceModification -eq $false) {
                    $BodyMetaData.Add('dataSourceModify', 'false')
                }
                If ($AllowAnomalyAccess -eq $true) {
                    $BodyMetaData.Add('anomaly', 'true')
                }
                ElseIf ($AllowAnomalyAccess -eq $false) {
                    $BodyMetaData.Add('anomaly', 'false')
                }
                If ($AllowAnomalyModification -eq $true) {
                    $BodyMetaData.Add('anomalyModify', 'true')
                }
                ElseIf ($AllowAnomalyModification -eq $false) {
                    $BodyMetaData.Add('anomalyModify', 'false')
                }
                If ($AllowAdHocReportAccess -eq $true) {
                    $BodyMetaData.Add('report', 'true')
                }
                ElseIf ($AllowAdHocReportAccess -eq $false) {
                    $BodyMetaData.Add('report', 'false')
                }
                If ($AllowAdHocReportModification -eq $true) {
                    $BodyMetaData.Add('reportModify', 'true')
                }
                ElseIf ($AllowAdHocReportModification -eq $false) {
                    $BodyMetaData.Add('reportModify', 'false')
                }
                If ($AllowDashboardAccess -eq $true) {
                    $BodyMetaData.Add('dashboard', 'true')
                }
                ElseIf ($AllowDashboardAccess -eq $false) {
                    $BodyMetaData.Add('dashboard', 'false')
                }
                If ($AllowDashboardModification -eq $true) {
                    $BodyMetaData.Add('dashboardModify', 'true')
                }
                ElseIf ($AllowDashboardModification -eq $false) {
                    $BodyMetaData.Add('dashboardModify', 'false')
                }
                If ($AllowUserReportAccess -eq $true) {
                    $BodyMetaData.Add('userReport', 'true')
                }
                ElseIf ($AllowUserReportAccess -eq $false) {
                    $BodyMetaData.Add('userReport', 'false')
                }
                If ($AllowUserReportModification -eq $true) {
                    $BodyMetaData.Add('userReportModify', 'true')
                }
                ElseIf ($AllowUserReportModification -eq $false) {
                    $BodyMetaData.Add('userReportModify', 'false')
                }
                If ($AllowWorkspaceAccess -eq $true) {
                    $BodyMetaData.Add('workspace', 'true')
                }
                ElseIf ($AllowWorkspaceAccess -eq $false) {
                    $BodyMetaData.Add('workspace', 'false')
                }
                If ($AllowWorkspaceModification -eq $true) {
                    $BodyMetaData.Add('workspaceModify', 'true')
                }
                ElseIf ($AllowWorkspaceModification -eq $false) {
                    $BodyMetaData.Add('workspaceModify', 'false')
                }
                If ($AllowApprovalConfiguration -eq $true) {
                    $BodyMetaData.Add('approvalConfiguration', 'true')
                }
                ElseIf ($AllowApprovalConfiguration -eq $false) {
                    $BodyMetaData.Add('approvalConfiguration', 'false')
                }
                If ($AllowNotificationAccess -eq $true) {
                    $BodyMetaData.Add('notification', 'true')
                }
                ElseIf ($AllowNotificationAccess -eq $false) {
                    $BodyMetaData.Add('notification', 'false')
                }
                If ($AllowNotificationModification -eq $true) {
                    $BodyMetaData.Add('notificationModify', 'true')
                }
                ElseIf ($AllowNotificationModification -eq $false) {
                    $BodyMetaData.Add('notificationModify', 'false')
                }
                If ($AllowManagementofCodeRepositories -eq $true) {
                    $BodyMetaData.Add('codeRepository', 'true')
                }
                ElseIf ($AllowManagementofCodeRepositories -eq $false) {
                    $BodyMetaData.Add('codeRepository', 'false')
                }
                If ($AllowExecutionOfPushOnCodeRepository -eq $true) {
                    $BodyMetaData.Add('push', 'true')
                }
                ElseIf ($AllowExecutionOfPushOnCodeRepository -eq $false) {
                    $BodyMetaData.Add('push', 'false')
                }
                If ($AllowExecutionOfPullOnCodeRepository -eq $true) {
                    $BodyMetaData.Add('pull', 'true')
                }
                ElseIf ($AllowExecutionOfPullOnCodeRepository -eq $false) {
                    $BodyMetaData.Add('pull', 'false')
                }
                If ($AllowCreationofMergeRequests -eq $true) {
                    $BodyMetaData.Add('createMergeRequest', 'true')
                }
                ElseIf ($AllowCreationofMergeRequests -eq $false) {
                    $BodyMetaData.Add('createMergeRequest', 'false')
                }
                If ($AllowApprovalofMergeRequests -eq $true) {
                    $BodyMetaData.Add('approveMergeRequest', 'true')
                }
                ElseIf ($AllowApprovalofMergeRequests -eq $false) {
                    $BodyMetaData.Add('approveMergeRequest', 'false')
                }
                If ($DataMigrationViewer -eq $true) {
                    $BodyMetaData.Add('dataMigrationViewer', 'true')
                }
                ElseIf ($DataMigrationViewer -eq $false) {
                    $BodyMetaData.Add('dataMigrationViewer', 'false')
                }
                If ($DataMigration -eq $true) {
                    $BodyMetaData.Add('dataMigration', 'true')
                }
                ElseIf ($DataMigration -eq $false) {
                    $BodyMetaData.Add('dataMigration', 'false')
                }
                If ($AllowNewProcessingLaunch -eq $true) {
                    $BodyMetaData.Add('processingLaunch', 'true')
                }
                ElseIf ($AllowNewProcessingLaunch -eq $false) {
                    $BodyMetaData.Add('processingLaunch', 'false')
                }
                If ($AllowSelfService -eq $true) {
                    $BodyMetaData.Add('selfService', 'true')
                }
                ElseIf ($AllowSelfService -eq $false) {
                    $BodyMetaData.Add('selfService', 'false')
                }
                If ($AllowBusinessViewAccessTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowBusinessViewAccessTags) {
                        $BodyMetaData.Add(('businessViewTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowMonitoringAccessTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowMonitoringAccessTags) {
                        $BodyMetaData.Add(('monitorTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowProcessingRestartTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowProcessingRestartTags) {
                        $BodyMetaData.Add(('monitorRestartTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowProcessingSkipTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowProcessingSkipTags) {
                        $BodyMetaData.Add(('monitorPassByTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowProcessingHoldTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowProcessingHoldTags) {
                        $BodyMetaData.Add(('monitorHoldTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowProcessingKillTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowProcessingKillTags) {
                        $BodyMetaData.Add(('monitorKillTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowProcessingForceCompletedTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowProcessingForceCompletedTags) {
                        $BodyMetaData.Add(('monitorForceCompletedTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowProcessingForceFailedTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowProcessingForceFailedTags) {
                        $BodyMetaData.Add(('monitorForceFailedTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowProcessingForceLaunchTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowProcessingForceLaunchTags) {
                        $BodyMetaData.Add(('monitorForceLaunchTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowInternalActionsTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowInternalActionsTags) {
                        $BodyMetaData.Add(('monitorInternalActionsTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowProcessingModificationTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowProcessingModificationTags) {
                        $BodyMetaData.Add(('processingModifyTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowProcessingArchiveTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowProcessingArchiveTags) {
                        $BodyMetaData.Add(('processingArchiveTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($LowLevelApprovalTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $LowLevelApprovalTags) {
                        $BodyMetaData.Add(('lowLevelApprovalTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($MediumLevelApprovalTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $MediumLevelApprovalTags) {
                        $BodyMetaData.Add(('mediumLevelApprovalTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($HighLevelApprovalTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $HighLevelApprovalTags) {
                        $BodyMetaData.Add(('highLevelApprovalTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowDesignAccessTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowDesignAccessTags) {
                        $BodyMetaData.Add(('designTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowDesignCoreModificationTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowDesignCoreModificationTags) {
                        $BodyMetaData.Add(('designCoreModifyTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowResultMappingAccessTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowResultMappingAccessTags) {
                        $BodyMetaData.Add(('resultMappingTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowResultMappingModificationTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowResultMappingModificationTags) {
                        $BodyMetaData.Add(('resultMappingModifyTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowIntefaceAccessTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowIntefaceAccessTags) {
                        $BodyMetaData.Add(('integratorTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowIntefaceModificationTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowIntefaceModificationTags) {
                        $BodyMetaData.Add(('integratorModifyTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowNodeAccessTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowNodeAccessTags) {
                        $BodyMetaData.Add(('nodeTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowNodeModificationTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowNodeModificationTags) {
                        $BodyMetaData.Add(('nodeModifyTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowNodeHoldTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowNodeHoldTags) {
                        $BodyMetaData.Add(('nodeHoldTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowNodeSkipTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowNodeSkipTags) {
                        $BodyMetaData.Add(('nodePassByTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowNodeStartStopTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowNodeStartStopTags) {
                        $BodyMetaData.Add(('nodeStartTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowNodeKillTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowNodeKillTags) {
                        $BodyMetaData.Add(('nodeKillTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowNodeEndpointModificationTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowNodeEndpointModificationTags) {
                        $BodyMetaData.Add(('nodeModifyEndpointTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowEndpointAccessTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowEndpointAccessTags) {
                        $BodyMetaData.Add(('endpointTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowEndpointModificationTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowEndpointModificationTags) {
                        $BodyMetaData.Add(('endpointModifyTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowResourceAccessTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowResourceAccessTags) {
                        $BodyMetaData.Add(('resourceTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowResourceModificationTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowResourceModificationTags) {
                        $BodyMetaData.Add(('resourceModifyTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowDataSourceAccessTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowDataSourceAccessTags) {
                        $BodyMetaData.Add(('dataSourceAccessTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($DataSourceModifyTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $DataSourceModifyTags) {
                        $BodyMetaData.Add(('dataSourceModifyTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowAnomalyAccessTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowAnomalyAccessTags) {
                        $BodyMetaData.Add(('anomalyTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowAnomalyModificationTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowAnomalyModificationTags) {
                        $BodyMetaData.Add(('anomalyModifyTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowAdHocReportAccessTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowAdHocReportAccessTags) {
                        $BodyMetaData.Add(('reportTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowAdHocReportModificationTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowAdHocReportModificationTags) {
                        $BodyMetaData.Add(('reportModifyTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowDashboardAccessTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowDashboardAccessTags) {
                        $BodyMetaData.Add(('dashboardTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowDashboardModificationTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowDashboardModificationTags) {
                        $BodyMetaData.Add(('dashboardModifyTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowUserReportAccessTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowUserReportAccessTags) {
                        $BodyMetaData.Add(('userReportTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowUserReportModificationTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowUserReportModificationTags) {
                        $BodyMetaData.Add(('userReportModifyTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowWorkspaceAccessTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowWorkspaceAccessTags) {
                        $BodyMetaData.Add(('workspaceTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowWorkspaceModificationTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowWorkspaceModificationTags) {
                        $BodyMetaData.Add(('workspaceModifyTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowNotificationAccessTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowNotificationAccessTags) {
                        $BodyMetaData.Add(('notificationTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowNotificationModificationTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowNotificationModificationTags) {
                        $BodyMetaData.Add(('notificationModifyTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowManagementofCodeRepositoriesTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowManagementofCodeRepositoriesTags) {
                        $BodyMetaData.Add(('codeRepositoryTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowNewProcessingLaunchTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowNewProcessingLaunchTags) {
                        $BodyMetaData.Add(('processingLaunchTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
                If ($AllowSelfServiceTags.Count -gt 0) {
                    [int32]$loop = 1
                    ForEach ( $tag_id in $AllowSelfServiceTags) {
                        $BodyMetaData.Add(('selfServiceTags' + $loop), $tag_id)
                        $loop++
                        $TagsToConfirm += $tag_id
                    }
                }
            }
            [string]$oldValues = $DomainRole.CreateOldValues()
            $BodyMetaData.Add('_oldValues', $oldValues)
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_componentId', 'SecRoleDomainEditForm')
            $BodyMetaData.Add('_dataSource', 'SecRoleDomainDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$SecurityRole_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            If ($results.response.data.count -gt 0) {
                $Error.Clear()
                Try {
                    $results.response.data[0].secRole = $SecurityRole
                    [ANOWSecRoleDomain]$FormattedDomainRole = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to parse the results into a formatted [ANOWSecRoleDomain] object after adding $DomainRole_Domain ($DomainRole_Id) to $SecurityRole_id due to [$Message]."
                    Break
                }
                Write-Verbose -Message "$DomainRole_Domain ($DomainRole_Id) within $SecurityRole_id was successfully modified"
                If ($Quiet -ne $true) {
                    Return $FormattedDomainRole
                }
            }
        }
    }
    End {

    }
}

#endregion

#Region - Security Roles

Function Get-AutomateNOWSecurityRole {
    <#
    .SYNOPSIS
    Gets the Security Roles from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Security Roles ("secRoles") from an AutomateNOW! instance

    .PARAMETER Id
    The Id of the Security Role. Use this when you only want to retrieve a single report. This parameter cannot be combined with -startRow/-endRow.

    .PARAMETER startRow
    Integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER IncludeInternalRoles
    Switch parameter that will include roles marked as "internal". Note that these objects are normally omitted by the UI.

    .PARAMETER OnlyInternalRoles
    Switch parameter that will fetch only roles marked as "internal". Note that these objects are normally omitted by the UI.

    .INPUTS
    Accepts a string representing the simple id of the Security Role from the pipeline or individually (but not an array) or you can specify by start and end rows.

    .OUTPUTS
    An array of one or more [ANOWSecRole] class objects

    .EXAMPLE
    Gets the first page of Security Roles
    Get-AutomateNOWSecurityRole

    .EXAMPLE
    Gets the first page of Security Roles with Internal Roles included
    Get-AutomateNOWSecurityRole -IncludeInternalRoles

    .EXAMPLE
    Gets a specific Security Role by Id
    Get-AutomateNOWSecurityRole -Id 'SecRole1'

    .EXAMPLE
    Gets the first page of internal Security Roles
    Get-AutomateNOWSecurityRole -OnlyInternalRoles

    .EXAMPLE
    Gets a series of Security Roles using the pipeline
    'SecRole1', 'SecRole2' | Get-AutomateNOWSecurityRole

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Internal roles may not be fetched by Id.

    #>
    [OutputType([ANOWSecRole[]])]
    [Cmdletbinding( DefaultParameterSetName = 'Default' )]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $False, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'IncludeInternalRoles')]
        [Parameter(Mandatory = $False, ParameterSetName = 'OnlyInternalRoles')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'IncludeInternalRoles')]
        [Parameter(Mandatory = $False, ParameterSetName = 'OnlyInternalRoles')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False, ParameterSetName = 'IncludeInternalRoles')]
        [switch]$IncludeInternalRoles,
        [Parameter(Mandatory = $False, ParameterSetName = 'OnlyInternalRoles')]
        [switch]$OnlyInternalRoles
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 -or $Id.Length -gt 0) {
            If ($_.Length -gt 0 ) {
                $Body.'id' = $_
            }
            Else {
                $Body.'id' = $Id
            }
            [string]$textMatchStyle = 'exactCase'
            $Body.'_operationId' = 'read'
        }
        Else {
            $Body.Add('operator', 'or')
            $Body.Add('_constructor', 'AdvancedCriteria')
            If ( $IncludeInternalRoles -ne $true -and $OnlyInternalRoles -ne $true ) {
                $Body.Add('criteria1', '{"fieldName":"internalRole","operator":"equals","value":false}')
                $Body.Add('criteria2', '{"fieldName":"internalRole","operator":"isNull"}')
            }
            ElseIf ( $OnlyInternalRoles -eq $true ) {
                $Body.Add('criteria1', '{"fieldName":"internalRole","operator":"equals","value":true}')
            }
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
            [string]$textMatchStyle = 'exact'
            $Body.'_componentId' = 'SecRoleList'
        }
        $Body.'_textMatchStyle' = $textMatchStyle
        $Body.'_dataSource' = 'SecRoleDataSource'
        $Body.'_operationType' = 'fetch'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/secRole/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] while running Get-AutomateNOWSecurityRole due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWSecRole[]]$Formatted_SecRoles = ForEach ($SecRole in $results.response.data) {
                [ANOWSecRoleDomain[]]$domainRoles = ForEach ($domainRole in $SecRole.domainRoles) {
                    [string]$domainRole_Id = $domainRole.Id
                    $Error.Clear()
                    Try {
                        [ANOWSecRoleDomain]$DomainRole_Object = Read-AutomateNOWSecurityRoleDomain -ItemId $domainRole_Id
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Read-AutomateNOWSecurityRoleDomain failed to read $domainRole under Get-AutomateNOWSecurityRole due to [$Message]."
                        Break
                    }
                    $DomainRole_Object
                }
                $SecRole.domainRoles = $domainRoles
                $SecRole
            }
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWSecRole] objects due to [$Message]."
            Break
        }
        If ($Formatted_SecRoles.Count -gt 0) {
            Return $Formatted_SecRoles
        }
    }
    End {

    }
}

Function Export-AutomateNOWSecurityRole {
    <#
    .SYNOPSIS
    Exports the Security Roles from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Security Roles from an instance of AutomateNOW! to a local .csv file

    .PARAMETER SecurityRole
    Mandatory [ANOWSecRole] object (Use Get-AutomateNOWSecurityRole to retrieve them)

    .INPUTS
    ONLY [ANOWSecRole] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWSecRole] objects are exported to the local disk in CSV format

    .EXAMPLE
    Exports the first page of Security Roles
    Get-AutomateNOWSecurityRole | Export-AutomateNOWSecurityRole

    .EXAMPLE
    Exports a single Security Role by Id
    Get-AutomateNOWSecurityRole -Id 'SecurityRole1' | Export-AutomateNOWSecurityRole

    .EXAMPLE
    Exports a series of Security Roles by sending the Id's across the pipeline
    'SecurityRole01', 'SecurityRole2 | Get-AutomateNOWSecurityRole | Export-AutomateNOWSecurityRole

    .NOTES
	You must present [ANOWSecRole] objects to the pipeline to use this function.

    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWSecRole]$SecurityRole
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-SecurityRoles-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWSecRole]$SecurityRole = $_
        }
        $Error.Clear()
        Try {
            $SecurityRole | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWSecRole] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function New-AutomateNOWSecurityRole {
    <#
    .SYNOPSIS
    Creates a SecurityRole within an AutomateNOW! instance

    .DESCRIPTION
    Creates a SecurityRole within an AutomateNOW! instance and returns back the newly created [ANOWSecRole] object

    .PARAMETER Id
    The intended name of the SecurityRole. For example: 'MySecurityRole1'. This value may not contain the domain in brackets.

    .PARAMETER Description
    Optional description of the SecurityRole (may not exceed 255 characters).

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWSecurityRole.

    .OUTPUTS
    An [ANOWSecRole] object representing the newly created SecurityRole

    .EXAMPLE
    Creates a new Security Role
    New-AutomateNOWSecurityRole -Id 'SecurityRole1' -Description 'This is a security role'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The name (id) of the SecurityRole must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    #>
    [OutputType([ANOWSecRole])]
    [Cmdletbinding()]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $true)]
        [string]$Id,
        [Parameter(Mandatory = $false, HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [boolean]$SecurityRole_exists = ($null -ne (Get-AutomateNOWSecurityRole -Id $Id))
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWSecurityRole failed to check if the SecurityRole [$Id] already existed due to [$Message]."
        Break
    }
    If ($SecurityRole_exists -eq $true) {
        [string]$current_domain = $anow_session.header.domain
        Write-Warning -Message "There is already a Security Role named $Id in [$current_domain]. Please check into this."
        Break
    }
    ## End warning ##
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    $BodyMetaData.'id' = $Id
    If ($Description.Length -gt 0) {
        $BodyMetaData.'description' = $Description
    }
    $BodyMetaData.'_operationType' = 'add'
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_oldValues' = '{}'
    $BodyMetaData.'_componentId' = 'SecRoleCreateWindow_form'
    $BodyMetaData.'_dataSource' = 'SecRoleDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
    [string]$command = '/secRole/create'
    [hashtable]$parameters = @{}
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('Body', $Body)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWSecRole]$SecurityRole = $results.response.data | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to create [ANOWSecRole] object due to [$Message]."
        Break
    }
    If ($SecurityRole.id.Length -eq 0) {
        Write-Warning -Message 'Somehow the newly created [ANOWSecRole] object is empty!'
        Break
    }
    If ($Quiet -ne $true) {
        Return $SecurityRole
    }
}

Function Remove-AutomateNOWSecurityRole {
    <#
    .SYNOPSIS
    Removes a Security Role from an AutomateNOW! instance

    .DESCRIPTION
    Removes a Security Role from an AutomateNOW! instance

    .PARAMETER SecurityRole
    An [ANOWSecRole] object representing the Security Role to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWSecRole] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Removes a single Security Role
    Get-AutomateNOWSecurityRole -Id 'SecurityRole1' | Remove-AutomateNOWSecurityRole

    .EXAMPLE
    Forcefully removes three Security Roles by way of the pipeline
    'SecurityRole1', 'SecurityRole2', 'SecurityRole3' | Get-AutomateNOWSecurityRole | Remove-AutomateNOWSecurityRole -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWSecRole]$SecurityRole,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/secRole/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWSecRole]$SecurityRole = $_
        }
        [string]$SecurityRole_id = $SecurityRole.id
        If ($SecurityRole_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($SecurityRole_id)")) -eq $true) {
            [string]$oldvalues = $SecurityRole.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $SecurityRole_id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'SecRoleList'
            $BodyMetaData.'_dataSource' = 'SecRoleDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$SecurityRole_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "SecurityRole [$SecurityRole_id] successfully removed"
        }
    }
    End {

    }
}

Function Copy-AutomateNOWSecurityRole {
    <#
    .SYNOPSIS
    Copies a Security Role from an AutomateNOW! instance

    .DESCRIPTION
    Copies a Security Role from an AutomateNOW! instance. AutomateNOW object id can never be changed, but we can copy the object to a new id and it will include all of the items therein.

    .PARAMETER SecurityRole
    Mandatory [ANOWSecRole] object to be copied.

    .PARAMETER NewId
    The name (Id) of the new Security Role. The new Id must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    .PARAMETER UnsetDescription
    Optional switch that will ensure that the newly created Security Role will not have a description set.

    .PARAMETER Description
    Optional description to set on the new Security Role object. If you do not set this, the new Security Role object will copy the Description of the source object.

    .PARAMETER Force
    Force the copy without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    ONLY [ANOWSecRole] object is accepted. Pipeline support is intentionally unavailable.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Creates a copy of a Security Role and changes the description (multi-line format)
    $SecurityRole1 = Get-AutomateNOWSecurityRole -Id 'SecurityRole1'
    Copy-AutomateNOWSecurityRole -SecurityRole $SecurityRole1 -NewId 'SecurityRole1_production' -Description 'Security Role 1 Production'

    .EXAMPLE
    Creates a copy of a Security Role that omits the description (one-liner format)
    Copy-AutomateNOWSecurityRole -SecurityRole (Get-AutomateNOWSecurityRole -Id 'SecurityRole1') -NewId 'SecurityRole1_production' -UnsetDescription -Tags 'Tag1', 'Tag2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWSecRole]$SecurityRole,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$SecurityRole_exists = ($null -ne (Get-AutomateNOWSecurityRole -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWSecurityRole failed to check if the Security Role [$NewId] already existed due to [$Message]."
            Break
        }
        If ($SecurityRole_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Security Role named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End warning ##
        [string]$command = '/secRole/copy'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            [string]$SecurityRole_oldId = $SecurityRole.id
            [string]$SecurityRole_simpleId = $SecurityRole.simpleId
            If ($SecurityRole_oldId -eq $NewId) {
                Write-Warning -Message "The new id cannot be the same as the old id."
                Break
            }
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Copy the Security Role $($SecurityRole_simpleId) to $($NewId)?")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                $BodyMetaData.'oldId' = $SecurityRole_oldId
                $BodyMetaData.'domain' = $SecurityRole.domain
                $BodyMetaData.'id' = $NewId
                If ($UnsetDescription -ne $true) {
                    If ($Description.Length -gt 0) {
                        $BodyMetaData.'description' = $Description
                    }
                    Else {
                        $BodyMetaData.'description' = $SecurityRole.description
                    }
                }
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_operationId' = 'copy'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_dataSource' = 'SecRoleDataSource'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties oldId, domain, NewId, description
                $parameters.Body = $Body
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$SecurityRole_oldId] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                $Error.Clear()
                Try {
                    [ANOWSecRole]$NewSecurityRole = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to create copied [ANOWSecRole] object [$NewId] due to [$Message]."
                    Break
                }
                If ($NewSecurityRole.id.Length -eq 0) {
                    Write-Warning -Message "Somehow the newly created (copied) [ANOWSecRole] object [$NewId] is empty!"
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $NewSecurityRole
                }
            }
        }
    }
    End {

    }
}

Function Rename-AutomateNOWSecurityRole {
    <#
    .SYNOPSIS
    Renames a Security Role on an AutomateNOW! instance

    .DESCRIPTION
    Performs a psuedo-rename operations of a Security Role from an AutomateNOW! instance by copying it first and then deleting the source. This function merely combines Copy-AutomateNOWSecurityRole and Remove-AutomateNOWSecurityRole therefore it is to be considered destructive.

    .PARAMETER SecurityRole
    An [ANOWSecRole] object representing the Security Role to be renamed.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the Security Role. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER Force
    Force the renaming without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly renamed object.

    .INPUTS
    ONLY [ANOWSecRole] objects are accepted. There is intentionally no support for the pipeline.

    .OUTPUTS
    The newly renamed [ANOWSecRole] object will be returned.

    .EXAMPLE
    $SecurityRole = Get-AutomateNOWSecurityRole -Id 'SecurityRole01'
    Rename-AutomateNOWSecurityRole -SecurityRole $SecurityRole -NewId 'SecurityRole1'

    .EXAMPLE
    Rename-AutomateNOWSecurityRole -SecurityRole (Get-AutomateNOWSecurityRole -Id 'SecurityRole1') -NewId 'SecurityRole1'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    When renaming, you may only specify a different Id (name).

    This action will be blocked if any existing referrals are found on the object.
    #>
    [OutputType([ANOWSecRole])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWSecRole]$SecurityRole,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin standard warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$new_SecurityRole_exists = ($null -ne (Get-AutomateNOWSecurityRole -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWSecurityRole failed to check if the Security Role [$NewId] already existed due to [$Message]."
            Break
        }
        If ($new_SecurityRole_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Security Role named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        [string]$SecurityRole_id = $SecurityRole.Id
        $Error.Clear()
        Try {
            [boolean]$old_SecurityRole_exists = ($null -ne (Get-AutomateNOWSecurityRole -Id $SecurityRole_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWSecurityRole failed to check if the SecurityRole [$SecurityRole_id] already existed due to [$Message]."
            Break
        }
        If ($old_SecurityRole_exists -eq $false) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not a securityRole named [$SecurityRole_id] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End standard warning ##
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($SecurityRole_id)")) -eq $true) {
                $Error.Clear()
                Try {
                    [ANOWSecRole]$new_SecurityRole = Copy-AutomateNOWSecurityRole -SecurityRole $SecurityRole -NewId $NewId -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Copy-AutomateNOWSecurityRole failed to create a new SecurityRole [$NewId] as Part 1 of the renaming process due to [$Message]."
                    Break
                }
                If ($new_SecurityRole.Id -eq $NewId) {
                    Write-Verbose -Message "Part 1: SecurityRole [$SecurityRole_id] successfully copied to [$NewId]"
                }
                Else {
                    Write-Warning -Message "Somehow the first phase (Copy-AutomateNOWSecurityRole) failed. Please look into this."
                    Break
                }
                $Error.Clear()
                Try {
                    Remove-AutomateNOWSecurityRole -SecurityRole $SecurityRole -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Remove-AutomateNOWSecurityRole failed to remove [$SecurityRole_id] as Part 2 of the renaming process due to [$Message]."
                    Break
                }
                Write-Verbose -Message "Part 2: SecurityRole [$SecurityRole_id] removed"
                Write-Verbose -Message "Task [$SecurityRole_id] successfully renamed to [$NewId]"
                If ($Quiet -ne $true) {
                    Return $new_SecurityRole
                }
            }
        }
        Else {
            Write-Warning -Message "No action was taken because either the source object didn't exist or the new object already existed"
        }
    }
    End {
    }
}

Function Set-AutomateNOWSecurityRole {
    <#
    .SYNOPSIS
    Changes the settings of a Security Role on an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of a Security Role on an AutomateNOW! instance

    .PARAMETER SecurityRole
    An [ANOWSecRole] object representing the Security Role to be modified.

    .PARAMETER Description
    Optional string to set on the Security Role object.

    .PARAMETER UnsetDescription
    Optional switch that will remove the Description from the Security Role object.

    .PARAMETER LDAPMapping
    Optional string of an ActiveDirectory/LDAP group to map this SecurityRole to

    .PARAMETER UnsetLDAPGroup
    Optional switch that will remove the ActiveDirectory/LDAP mapping to this Security Role object.

    .PARAMETER Quiet
    Switch parameter that silences the output of the updated object.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWSecRole] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWSecRole] object will be returned

    .EXAMPLE
    Changes the description of a Security Role

    $SecurityRole = Get-AutomateNOWSecurityRole -Id 'SecurityRole1'
    Set-AutomateNOWSecurityRole -SecurityRole $SecurityRole -Description 'My Description'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    To add users to a Security Role, use Add-AutomateNOWSecurityRoleUser

    To add domains to a Security Role, use Add-AutomateNOWSecurityRoleDomain
    #>
    [OutputType([ANOWSecRole])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWSecRole]$SecurityRole,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$LDAPMapping,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetLDAPMapping,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        [string]$command = '/secRole/update'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWSecRole]$SecurityRole = $_
        }
        [string]$SecurityRole_id = $SecurityRole.id
        [string]$SecurityRole_type = $SecurityRole.reportType
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($SecurityRole_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$SecurityRole_exists = ($null -eq (Get-AutomateNOWSecurityRole -Id $SecurityRole_id))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWSecurityRole failed to check if the Security Role [$SecurityRole_id] already existed due to [$Message]."
                Break
            }
            If ($SecurityRole_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not a Security Role named [$SecurityRole_id] in the [$current_domain] domain. Please check into this."
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $SecurityRole_id
            If ($Description.Length -gt 0) {
                $BodyMetaData.'description' = $Description
            }
            ElseIf ($UnsetDescription -eq $true) {
                $BodyMetaData.'description' = $Null
            }
            Else {
                If ($SecurityRole.description.Length -gt 0) {
                    $BodyMetaData.'description' = $SecurityRole.description
                }
            }
            If ($LDAPMapping.Length -gt 0) {
                $BodyMetaData.'ldapGroupName' = $LDAPMapping
            }
            ElseIf ($UnsetLDAPMapping -eq $true) {
                $BodyMetaData.'ldapGroupName' = $Null
            }
            Else {
                If ($SecurityRole.ldapGroupName.Length -gt 0) {
                    $BodyMetaData.'ldapGroupName' = $SecurityRole.ldapGroupName
                }
            }
            [string]$old_values = $SecurityRole.CreateOldValues()
            $BodyMetaData.'_oldValues' = $old_values
            $BodyMetaData.'_operationType' = 'update'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_componentId' = 'SecRoleVM'
            $BodyMetaData.'_dataSource' = 'SecRoleDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$SecurityRole_id] of type [$SecurityRole_type] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "SecurityRole object [$SecurityRole_id] of type [$SecurityRole_type] was successfully updated"
            $Error.Clear()
            Try {
                [ANOWSecRole]$UpdatedSecRole = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the returned updated object to an [ANOWSecRole] object due to [$Message]. The object was still updated though."
                Break
            }
            If ($Quiet -ne $true) {
                Return $UpdatedSecRole
            }
        }
    }
    End {
    }
}

#endregion

#Region - SecUsers

Function Get-AutomateNOWSecUser {
    <#
    .SYNOPSIS
    Gets the details of a user from an instance of AutomateNOW!

    .DESCRIPTION
    Gets the details of a user from an instance of AutomateNOW!

    .PARAMETER Id
    String parameter to specify the name or Id of the user. This is case-sensitive! If you do not know the username, you can try using the -LoggedOnUser parameter instead.

    .PARAMETER LoggedOnUser
    Switch parameter which skips entering the Id of the user. This is intended for use during the initial logon.

    .PARAMETER startRow
    Integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER ActiveUsersOnly
    Switch parameter which filters out inactive users.

    .PARAMETER APIUsersOnly
    Switch parameter which filters out non-API users.

    .PARAMETER IncludeAPIUsers
    Switch parameter which will include API users with non-API users in the same result

    .INPUTS
    Optional string (or an array of strings to the pipeline) representing the Id of each SecUser to retrieve

    .OUTPUTS
    [ANOWSecUser] objects

    .EXAMPLE
    Gets a user named 'User1'
    Get-AutomateNOWUser -Id 'User1'

    .EXAMPLE
    Gets the basic information on the currently logged in user. You should not need to use this as this module already uses this parameter to populate the $anow_session global variable upon logging in.
    Get-AutomateNOWUser -LoggedOnUser

    .EXAMPLE
    Gets the first page of non-API users
    Get-AutomateNOWSecUser

    .EXAMPLE
    Gets the first page of both API and non-API users
    Get-AutomateNOWSecUser -IncludeAPIUsers

    .EXAMPLE
    Gets the first page of active non-API users
    Get-AutomateNOWSecUser -ActiveUsersOnly

    .EXAMPLE
    Gets the first 10,000 active non-API and API users
    Get-AutomateNOWSecUser -startRow 0 -endRow 10000 -ActiveUsersOnly -IncludeAPIUsers

    .EXAMPLE
    Gets the first 10,000 active API users
    Get-AutomateNOWSecUser -startRow 0 -endRow 10000 -ActiveUsersOnly -APIUsersOnly

    .EXAMPLE
    Gets the first page of API users
    $users6 = Get-AutomateNOWSecUser -APIUsersOnly

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Get-AutomateNOWSecUser DOES NOT refresh the token automatically. This is because it is used during the authentication process.

    ONLY ADMINS CAN GET ALL USERS! You will get unauthorized error otherwise.

    #>
    [OutputType([ANOWSecUser])]
    [Cmdletbinding(DefaultParameterSetName = 'Default')]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $true, ParameterSetName = 'SpecificUser', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $true, ParameterSetName = 'LoggedOnUser')]
        [switch]$LoggedOnUser,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'APIUsersOnly')]
        [Parameter(Mandatory = $false, ParameterSetName = 'IncludeAPIUsers')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'APIUsersOnly')]
        [Parameter(Mandatory = $false, ParameterSetName = 'IncludeAPIUsers')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'APIUsersOnly')]
        [Parameter(Mandatory = $false, ParameterSetName = 'IncludeAPIUsers')]
        [switch]$ActiveUsersOnly,
        [Parameter(Mandatory = $false, ParameterSetName = 'APIUsersOnly')]
        [switch]$APIUsersOnly,
        [Parameter(Mandatory = $false, ParameterSetName = 'IncludeAPIUsers')]
        [switch]$IncludeAPIUsers
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet -DoNotRefresh) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$Instance = $anow_session.Instance
        [hashtable]$parameters = @{}
        If ($LoggedOnUser -eq $true) {
            [string]$command = '/secUser/getUserInfo'
            $parameters.Add('Method', 'GET')
        }
        Else {
            [string]$command = '/secUser/read'
            $parameters.Add('Method', 'POST')
        }
        If ($endRow -lt $startRow) {
            Write-Warning -Message "The endRow must be greater then the startRow"
            Break
        }
        $parameters.Add('Command', $command)
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        $parameters.Add('Instance', $Instance)
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($LoggedOnUser -ne $true) {
            If ($_.Length -gt 0) {
                [string]$id = $_
            }
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            If ($id.Length -gt 0) {
                $BodyMetaData.Add('id', $id )
                [string]$textMatchStyle = 'exactCase'
                $BodyMetaData.Add('_operationId', 'read')
            }
            Else {
                [string]$textMatchStyle = 'substring'
                $BodyMetaData.Add('operator', 'and')
                $BodyMetaData.Add('_constructor', 'AdvancedCriteria')
                If ($IncludeAPIUsers -eq $true) {
                }
                ElseIf ($APIUsersOnly -eq $true) {
                    $BodyMetaData.Add('criteria1', '{"fieldName":"apiUser","operator":"equals","value":true}')
                }
                Else {
                    $BodyMetaData.Add('criteria1', '{"_constructor":"AdvancedCriteria","operator":"or","criteria":[{"fieldName":"apiUser","operator":"equals","value":false},{"fieldName":"apiUser","operator":"isNull"}]}')
                }
                If ($ActiveUsersOnly -eq $true) {
                    $BodyMetaData.Add('criteria2', '{"fieldName":"isActive","operator":"equals","value":true}')
                }
                $BodyMetaData.Add('_componentId', 'SecUserList')
                $BodyMetaData.Add('_startRow', $startRow)
                $BodyMetaData.Add('_endRow', $endRow)
            }
            $BodyMetaData.Add('_operationType', 'fetch')
            $BodyMetaData.Add('_textMatchStyle', $textMatchStyle)
            $BodyMetaData.Add('_dataSource', 'SecUserDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        If ($LoggedOnUser -ne $True) {
            [ANOWSecUser[]]$Users = ForEach ($User in $results.response.data) {
                [string]$User_Id = $User.Id
                If ($null -eq $User.defaultTimeZone) {
                    [ANOWTimeZone]$defaultTimeZone = $anow_session.server_timezone
                    $User | Add-Member -MemberType NoteProperty -Name defaultTimeZone -Value $defaultTimeZone
                }
                Else {
                    [ANOWTimeZone]$defaultTimeZone = Get-AutomateNOWTimeZone -Id ($User.defaultTimeZone)
                    $User.defaultTimeZone = $defaultTimeZone
                }
                [ANOWSecRole[]]$secRoles2 = ForEach ($secRole in $User.secRoles) {
                    [ANOWSecRoleDomain[]]$domain_roles = ForEach ($domain_role_id in $secRole.domainRoles.id) {
                        Read-AutomateNOWSecurityRoleDomain -ItemId $domain_role_id
                    }
                    $secRole.domainRoles = $domain_roles
                    $secRole
                }
                $User.secRoles = $secRoles2
                # The following section to fix the passwordValidUntil property is due to an oversight from Beta Systems
                If ( $User.passwordValidUntil -match '^[0-9]{5,}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}.[0-9]{3}$') {
                    Write-Warning -Message "$User_Id has an invalid passwordValidUntil date. Please contact Beta Systems about this :-)"
                    [string]$passwordValidUntil = $User.passwordValidUntil
                    [int32]$passwordValidUntil_length = $passwordValidUntil.Length
                    [int32]$trim_count = $passwordValidUntil_length - 23
                    [string]$passwordValidUntil_Fixed = $passwordValidUntil.Substring($trim_count, 23)
                    If ($passwordValidUntil_Fixed -notmatch '^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}.[0-9]{3}$') {
                        Write-Warning -Message "Somehow truncating an invalid passwordValidUntil value failed"
                        Break
                    }
                    $User.passwordValidUntil = $passwordValidUntil_Fixed
                }
                $User
            }
            If ($Users.Count -gt 0) {
                Return $Users
            }
            Else {
                Write-Verbose -Message "There were 0 users found under [$User_id]"
            }
        }
        Else {
            [string]$id = $results.id
            If ($null -ne $results.defaultTimeZone) {
                [ANOWTimeZone]$defaultTimeZone = Get-AutomateNOWTimeZone -Id ($results.defaultTimeZone)
            }
            Else {
                [ANOWTimeZone]$defaultTimeZone = $anow_session.server_timezone
            }
            $results.'defaultTimeZone' = $defaultTimeZone
            $results.'secRoles' = @()
            $Error.Clear()
            If ($LoggedOnUser -eq $true) {
                Try {
                    [PSCustomObject]$User = $results | Select-Object -First 1
                    [string]$User_id = $User.id
                    # The following section to fix the passwordValidUntil property is due to an oversight from Beta Systems
                    If ( $User.passwordValidUntil -match '^[0-9]{5,}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}.[0-9]{3}$') {
                        Write-Warning -Message "$User_Id has an invalid passwordValidUntil date. Please contact Beta Systems about this :-)"
                        [string]$passwordValidUntil = $User.passwordValidUntil
                        [int32]$passwordValidUntil_length = $passwordValidUntil.Length
                        [int32]$trim_count = $passwordValidUntil_length - 23
                        [string]$passwordValidUntil_Fixed = $passwordValidUntil.Substring($trim_count, 23)
                        If ($passwordValidUntil_Fixed -notmatch '^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}.[0-9]{3}$') {
                            Write-Warning -Message "Somehow truncating an invalid passwordValidUntil value failed"
                            Break
                        }
                        $User.passwordValidUntil = $passwordValidUntil_Fixed
                    }
                    [ANOWSecUserInfo]$ANOWSecUserInfo = $User
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to convert the returned [ANOWSecUserInfo] object from direct data for [$id] due to [$Message]."
                    Remove-Variable -Name anow_session -Force
                    Break
                }
                If ($ANOWSecUserInfo.id.Length -gt 0) {
                    Return $ANOWSecUserInfo
                }
                Else {
                    Write-Warning -Message "Somehow the [ANOWSecUser] object appears to be empty"
                    Break
                }
            }
            Else {
                Try {
                    [ANOWSecUser]$ANOWSecUser = $results
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to convert the returned [ANOWSecUser] object from direct data for [$id] due to [$Message]."
                    Break
                }
                If ($ANOWSecUser.id.Length -gt 0) {
                    Return $ANOWSecUser
                }
                Else {
                    Write-Warning -Message "Somehow the [ANOWSecUser] object appears to be empty"
                    Break
                }
            }
        }
    }
    End {

    }
}

Function Set-AutomateNOWSecUser {
    <#
    .SYNOPSIS
    Changes the settings of a User from an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of a User from an AutomateNOW! instance

    .PARAMETER User
    An [ANOWSecUser] object representing the User to be changed.

    .PARAMETER skinThemeType
    A string representing the theme. Valid choice are: LIGHT, GRAY, DARK, CONTRAST_ULTRA

    .PARAMETER skinDensityType
    A string representing the theme. Valid choice are: DENSE, COMPACT, STANDARD, EXPANDED, SPACIOUS

    .PARAMETER admin
    A boolean parameter representing administrative privileges. Use this with caution!

    .PARAMETER ResetDefaultTimeZone
    Switch parameter that will blank out the user accounts default timezone.

    .PARAMETER defaultDomain
    String that will be set as the user's default domain. Note that this function will check to ensure that the domain exists before trying to set it.

    .PARAMETER unsetDefaultDomain
    Unsets the user's default domain.

    .PARAMETER Quiet
    Switch parameter that silences the output of the updated object.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWSecUser] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWSecUser] object will be returned

    .EXAMPLE
    Sets the theme for a user named 'User1' to Dark (multi-line format)
    Get-AutomateNOWSecUser -Id 'User1' | Set-AutomateNOWSecUser -skinTheme 'DARK'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    There's at least 2 missing properties: Admin, OAuth_clientid

    This function does not support any roles. It is only to be used for the basic user properties.

    #>
    [OutputType([ANOWSecUser])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWSecUser]$User,
        [AllowEmptyString()]
        [ValidateLength(0, 255)]
        [Parameter(Mandatory = $false)]
        [string]$FirstName,
        [AllowEmptyString()]
        [ValidateLength(0, 255)]
        [Parameter(Mandatory = $false)]
        [string]$LastName,
        [AllowEmptyString()]
        [ValidateLength(0, 255)]
        [Parameter(Mandatory = $false)]
        [string]$Department,
        [AllowEmptyString()]
        [ValidateLength(0, 255)]
        [Parameter(Mandatory = $false)]
        [string]$Location,
        [ValidateScript({ $_ -match '^[\w\.-]+@[a-zA-Z\d\.-]+\.[a-zA-Z]{2,}$' })]
        [Parameter(Mandatory = $false, HelpMessage = 'Enter a valid email address')]
        [string]$Email,
        [AllowEmptyString()]
        [ValidateScript({ $_ -match '^[\d]{0,255}$' })]
        [Parameter(Mandatory = $false, HelpMessage = 'Enter numbers only')]
        [string]$PhoneNumber,
        [Parameter(Mandatory = $false)]
        [datetime]$AccountValidUntil,
        [Parameter(Mandatory = $false)]
        [ANOWTimeZone]$DefaultTimeZone,
        [Parameter(Mandatory = $false)]
        [ANOWSecUser_skinThemeType]$skinThemeType,
        [Parameter(Mandatory = $false)]
        [ANOWSecUser_skinDensityType]$skinDensityType,
        [Parameter(Mandatory = $false, HelpMessage = 'Set this to true to promote the user to full admin privileges')]
        [boolean]$admin,
        [Parameter(Mandatory = $false)]
        [switch]$ResetDefaultTimeZone,
        [Parameter(Mandatory = $false)]
        [string]$defaultDomain,
        [Parameter(Mandatory = $false)]
        [boolean]$unsetDefaultDomain,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($defaultDomain.Length -gt 0 -and $unsetDefaultDomain -eq $true) {
            Write-Warning -Message "You cannot both set and unset the default domain. Please choose one or the other."
            Break
        }
        [string]$command = '/secUser/update'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWSecUser]$User = $_
        }
        [string]$User_id = $User.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($User_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [ANOWSecUser]$User = Get-AutomateNOWSecUser -Id $User_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWSecUser failed to check if the User [$User_id] already existed under Set-AutomateNOWSecUser due to [$Message]."
                Break
            }
            [boolean]$User_exists = ($User.Id.Length -gt 0)
            If ($User_exists -eq $false) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not a User named [$User_id] in the current domain [$current_domain]. Please check into this."
                Break
            }
            ## End warning ##
            [boolean]$account_has_changed = $false
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $User_id
            If ($FirstName.Length -gt 0) {
                $BodyMetaData.'firstName' = $FirstName
                $BodyMetaData.'firstLastName' = ($FirstName + ' ' + $User.LastName)
                [boolean]$account_has_changed = $true
            }
            If ($LastName.Length -gt 0) {
                $BodyMetaData.'lastName' = $LastName
                $BodyMetaData.'firstLastName' = ($User.FirstName + ' ' + $LastName)
                [boolean]$account_has_changed = $true
            }
            If ($FirstName.Length -gt 0 -and $LastName.Length -gt 0) {
                $BodyMetaData.'firstLastName' = ($FirstName + ' ' + $LastName)
            }
            If ($Department.Length -gt 0) {
                $BodyMetaData.'department' = $Department
                [boolean]$account_has_changed = $true
            }
            If ($Location.Length -gt 0) {
                $BodyMetaData.'location' = $Location
                [boolean]$account_has_changed = $true
            }
            If ($Email.Length -gt 0) {
                $BodyMetaData.'email' = $Email
                [boolean]$account_has_changed = $true
            }
            If ($PhoneNumber.Length -gt 0) {
                $BodyMetaData.'phone' = $PhoneNumber
                [boolean]$account_has_changed = $true
            }
            If ($null -ne $AccountValidUntil) {
                $BodyMetaData.'accountValidUntil' = Get-Date -Date $AccountValidUntil -Format 'yyyy-MM-ddTHH:mm:ss.fff'
                [boolean]$account_has_changed = $true
            }
            If ($null -ne $DefaultTimeZone) {
                $BodyMetaData.'defaultTimeZone' = ($DefaultTimeZone.Id)
                [boolean]$account_has_changed = $true
            }
            ElseIf ($ResetDefaultTimeZone -eq $true) {
                $BodyMetaData.'defaultTimeZone' = ''
                [boolean]$account_has_changed = $true
            }
            If ($defaultDomain.Length -gt 0) {
                $Error.Clear()
                Try {
                    [ANOWDomain]$domain_object = Get-AutomateNOWDomain -Id $defaultDomain
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWDomain failed to confirm that the Domain [$defaultDomain] actually existed while running under Set-AutomateNOWSecUser due to [$Message]"
                    Break
                }
                If ($domain_object.Id.Length -eq 0) {
                    Throw "Get-AutomateNOWDomain failed to locate the Domain [$Domain] running under Set-AutomateNOWSecUser. Please check again."
                    Break
                }
                Write-Verbose -Message "Setting $defaultDomain as the default domain for [$User_id]"
                $BodyMetaData.'defaultDomain' = $defaultDomain
                $include_properties += 'defaultDomain'
                [boolean]$account_has_changed = $true
            }
            ElseIf ($unsetDefaultDomain -eq $true) {
                Write-Verbose -Message "Unsetting the default domain for [$User_id]"
                $BodyMetaData.'defaultDomain' = $null
                $include_properties += 'defaultDomain'
                [boolean]$account_has_changed = $true
            }
            If ($skinThemetype.Length -gt 0) {
                $BodyMetaData.'skinThemeType' = $skinThemeType
                [boolean]$account_has_changed = $true
            }
            If ($skinDensityType.Length -gt 0) {
                $BodyMetaData.'skinDensityType' = $skinDensityType
                [boolean]$account_has_changed = $true
            }
            If ($account_has_changed -eq $false) {
                Write-Warning -Message "There must be at least 1 change to use Set-AutomateNOWSecUser"
                Break
            }
            $BodyMetaData.'createdBy' = $User.createdBy
            If (-not ($User.lastAccountExpired -gt (Get-Date -Date '1970/1/1')) -eq $true) {
                $BodyMetaData.'lastAccountExpired' = $null
            }
            Else {
                $BodyMetaData.'lastAccountExpired' = $User.lastAccountExpired
            }
            $BodyMetaData.'languageCode' = $User.languageCode
            $BodyMetaData.'_operationType' = 'update'
            $BodyMetaData.'_oldValues' = $User.CreateOldValues()
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_componentId' = 'SecUserEditForm'
            $BodyMetaData.'_dataSource' = 'SecUserDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$User_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            [PSCustomObject]$results_response_data = $results.response.data
            If ($null -eq $results_response_data.defaultTimeZone) {
                [ANOWTimeZone]$defaultTimeZone = $anow_session.server_timezone
            }
            Else {
                [ANOWTimeZone]$defaultTimeZone = Get-AutomateNOWTimeZone -Id ($results_response_data.defaultTimeZone)
                [PSCustomObject]$results_response_data = $results_response_data | Select-Object -ExcludeProperty defaultTimeZone
            }
            $Error.Clear()
            Try {
                [ANOWSecRole[]]$secRoles = $results.response.data.secRoles.Id | Get-AutomateNOWSecurityRole
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWSecurityRole failed to add the required Security Roles under Set-AutomateNOWSecUser due to [$Message]."
                Break
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results_response_data | Add-Member -MemberType NoteProperty -Name defaultTimeZone -Value $defaultTimeZone
                [PSCustomObject]$results_response_data = $results_response_data | Select-Object -ExcludeProperty secRoles
                [PSCustomObject]$results_response_data | Add-Member -MemberType NoteProperty -Name secRoles -Value $secRoles
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Add-Member failed to add the required SecUser members under Set-AutomateNOWSecUser due to [$Message]."
                Break
            }
            $Error.Clear()
            Try {
                [ANOWSecUser]$UpdatedUser = $results_response_data
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to cast the updated user object into an [ANOWSecUser] object due to [$Message]."
                Break
            }
            If ($Quiet -ne $true) {
                Return $UpdatedUser
            }
        }
    }
    End {
    }
}

Function Unlock-AutomateNOWSecUser {
    <#
    .SYNOPSIS
    Changes a Users locked state to unlocked on an AutomateNOW! instance

    .DESCRIPTION
    Changes a Users locked state to unlocked on an AutomateNOW! instance

    .PARAMETER User
    An [ANOWSecUser] object representing the User to be unlocked.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Switch parameter that silences the output of the updated object.

    .INPUTS
    ONLY [ANOWSecUser] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWSecUser] object will be returned

    .EXAMPLE
    Forcefully and quietly unlocks a user named 'User1' (one-liner format)

    Get-AutomateNOWSecUser -Id 'User1' | Unlock-AutomateNOWSecUser -Force -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWSecUser]$User,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/secUser/unlock'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWSecUser]$User = $_
        }
        [string]$User_id = $User.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($User_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [ANOWSecUser]$User = Get-AutomateNOWSecUser -Id $User_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWSecUser failed to check if the User [$User_id] already existed under Unlock-AutomateNOWSecUser due to [$Message]."
                Break
            }
            [boolean]$User_exists = ($User.Id.Length -gt 0)
            If ($User_exists -eq $false) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not a User named [$User_id] in the current domain [$current_domain]. Please check into this."
                Break
            }
            ## End warning ##
            [boolean]$UserLockStatus = $User.accountLocked
            If ($UserLockStatus -eq $false) {
                Write-Warning -Message "$User_id is already unlocked. There is no action required."
                Break
            }
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $User_id
            $BodyMetaData.'_operationType' = 'update'
            $BodyMetaData.'_operationId' = 'unlock'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_dataSource' = 'SecUserDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$User_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            [PSCustomObject]$results_response_data = $results.response.data
            If ($null -eq $results_response_data.defaultTimeZone) {
                [ANOWTimeZone]$defaultTimeZone = $anow_session.server_timezone
            }
            Else {
                [ANOWTimeZone]$defaultTimeZone = Get-AutomateNOWTimeZone -Id ($results_response_data.defaultTimeZone)
                [PSCustomObject]$results_response_data = $results_response_data | Select-Object -ExcludeProperty defaultTimeZone
            }
            $Error.Clear()
            Try {
                [ANOWSecRole[]]$secRoles = $results.response.data.secRoles.Id | Get-AutomateNOWSecurityRole
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWSecurityRole failed to add the required Security Roles under Unlock-AutomateNOWSecUser due to [$Message]."
                Break
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results_response_data | Add-Member -MemberType NoteProperty -Name defaultTimeZone -Value $defaultTimeZone
                [PSCustomObject]$results_response_data = $results_response_data | Select-Object -ExcludeProperty secRoles
                [PSCustomObject]$results_response_data | Add-Member -MemberType NoteProperty -Name secRoles -Value $secRoles
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Add-Member failed to add the required SecUser members under Unlock-AutomateNOWSecUser due to [$Message]."
                Break
            }
            $Error.Clear()
            Try {
                [ANOWSecUser]$UpdatedUser = $results_response_data
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to cast the updated user object into an [ANOWSecUser] object due to [$Message]."
                Break
            }
            If ($Quiet -ne $true) {
                Return $UpdatedUser
            }
        }
    }
    End {
    }
}

Function Export-AutomateNOWSecUser {
    <#
    .SYNOPSIS
    Exports the users from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the users from an instance of AutomateNOW! to a local .csv file

    .PARAMETER User
    Mandatory [ANOWSecUser] object (Use Get-AutomateNOWSecUser to retrieve them)

    .INPUTS
    ONLY [ANOWSecUser] objects from the pipeline are accepted. Strings are not accepted.

    .OUTPUTS
    The [ANOWSecUser] objects are exported to the local disk in CSV format

    .EXAMPLE
    Get-AutomateNOWSecUser | Export-AutomateNOWSecUser

    .NOTES
	You must present [ANOWSecUser] objects to the pipeline to use this function.
    #>

    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWSecUser]$User
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-Users-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWSecUser]$User = $_
        }
        $Error.Clear()
        Try {
            $User | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWSecUser] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function New-AutomateNOWSecUser {
    <#
    .SYNOPSIS
    Creates a User from an AutomateNOW! instance

    .DESCRIPTION
    Creates a User from an AutomateNOW! instance

    .PARAMETER Id
    A mandatory string representing the name of the user (Example: jsmith)

    .PARAMETER FirstName
    An optional string with the user's first name (given name)

    .PARAMETER LastName
    An optional string with the user's last name (surname)

    .PARAMETER Department
    An optional string with the user's department

    .PARAMETER OAuthClientId
    An optional string with the user's OAuth Client Id (not tested!)

    .PARAMETER Location
    An optional string with the user's location

    .PARAMETER Email
    An optional string with the user's email address (must be a valid email address)

    .PARAMETER PhoneNumber
    An optional int64 with the user's phone number. Digits only!

    .PARAMETER SecurePass
    A mandatory SecureString representing the password of the user. This must be at least 4 characters in length and consist of characters from two groups: upper and lower case, numbers and special characters

    .PARAMETER PasswordValidDays
    An optional integer indicating how long the account is valid for. Note that the default is 100 days!

    .PARAMETER AccountValidUntil
    A mandatory date string in this format --> 2030-12-31. The default is 100 days from the present day (per the server Java timezone). If you leave this blank, the default 100 days will be selected.

    .PARAMETER PasswordExpired
    An optional switch parameter that sets the password to expired (NOTE: THIS DOES NOT WORK IN ANOW 3.3.1.78 HF2)

    .PARAMETER Admin
    An optional switch parameter that enables administrative privileges.

    .PARAMETER skinThemeType
    An optional string representing the theme. Valid choice are: LIGHT, GRAY, DARK, CONTRAST_ULTRA

    .PARAMETER skinDensityType
    An optional string representing the theme. Valid choice are: DENSE, COMPACT, STANDARD, EXPANDED, SPACIOUS

    .PARAMETER Quiet
    Switch parameter that silences the output of the updated object.

    .INPUTS
    ONLY [ANOWSecUser] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWSecUser] object will be returned

    .EXAMPLE
    Creates a new admin user with all properties set and a non-expiring password

    New-AutomateNOWSecUser -Id 'TestUser1' -FirstName 'John' -LastName 'Smith' -Department 'Sanitation Engineering' -Location 'The basement' -Email 'jsmith@contoso.com' -PhoneNumber '8675309' -Pass 'AwesomePassword!11!' -PasswordValidDays 100 -AccountValidUntil '2030-12-31' -Admin -skinThemeType CONTRAST_ULTRA -skinDensityType COMPACT

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The console enforces that the phone number may only consist of digits. It is just a int64 value.

    #>
    [OutputType([ANOWSecUser])]
    [Cmdletbinding()]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $true)]
        [string]$Id,
        [ValidateLength(0, 255)]
        [Parameter(Mandatory = $false)]
        [string]$FirstName,
        [ValidateLength(0, 255)]
        [Parameter(Mandatory = $false)]
        [string]$LastName,
        [ValidateLength(0, 255)]
        [Parameter(Mandatory = $false)]
        [string]$Department,
        [Parameter(Mandatory = $false)]
        [string]$OAuthClientId,
        [ValidateLength(0, 255)]
        [Parameter(Mandatory = $false)]
        [string]$Location,
        [ValidateScript({ $_ -match '^[\w\.-]+@[a-zA-Z\d\.-]+\.[a-zA-Z]{2,}$' })]
        [Parameter(Mandatory = $false, HelpMessage = 'Enter a valid email address')]
        [string]$Email,
        [ValidateLength(0, 255)]
        [ValidateScript({ $_ -match '^[\d]{0,255}$' })]
        [Parameter(Mandatory = $false, HelpMessage = 'Enter numbers only')]
        [int64]$PhoneNumber,
        [Parameter(Mandatory = $true)]
        [SecureString]$SecurePass,
        [Parameter(Mandatory = $false)]
        [int32]$PasswordValidDays = 100,
        [ValidateScript({ $_ -match '[0-9]{4}-[0-9]{2}-[0-9]{2}' })]
        [Parameter(Mandatory = $false, HelpMessage = 'This must be in shortform ISO-8601 format. Example: 2031-12-31')]
        [string]$AccountValidUntil,
        [Parameter(Mandatory = $false)]
        [switch]$PasswordExpired,
        [Parameter(Mandatory = $false, HelpMessage = 'Set this to true to promote the user to full admin privileges')]
        [switch]$Admin,
        [Parameter(Mandatory = $false)]
        [ANOWSecUser_skinThemeType]$skinThemeType,
        [Parameter(Mandatory = $false)]
        [ANOWSecUser_skinDensityType]$skinDensityType,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    [boolean]$password_valid = Test-AutomateNOWSecUserPassword -SecurePass $SecurePass
    If ($password_valid -eq $false) {
        Write-Warning -Message "The password supplied is not valid. The password must be at least 4 characters and have at least 1 character from 2 of 4 groups (upper, lower, digits, special chars)"
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [boolean]$User_exists = ($null -ne (Get-AutomateNOWSecUser -Id $Id))
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWSecUser failed to check if the User [$Id] already existed (under New-AutomateNOWSecUser) due to [$Message]."
        Break
    }
    If ($User_exists -eq $true) {
        [string]$current_domain = $anow_session.header.domain
        Write-Warning -Message "There is already a User named [$Id] in [$current_domain]. Please check into this."
        Break
    }
    ## End warning ##
    [System.Collections.Specialized.OrderedDictionary]$ANOWSecUser = [System.Collections.Specialized.OrderedDictionary]@{}
    $ANOWSecUser.Add('id', $Id)
    If ($FirstName.Length -gt 0) {
        $ANOWSecUser.Add('firstName', $FirstName)
    }
    If ($LastName.Length -gt 0) {
        $ANOWSecUser.Add('lastName', $LastName)
    }
    If ($Department.Length -gt 0) {
        $ANOWSecUser.Add('department', $Department)
    }
    If ($OAuthClientId.Length -gt 0) {
        $ANOWSecUser.Add('clientId', $OAuthClientId)
    }
    If ($Location.Length -gt 0) {
        $ANOWSecUser.Add('location', $Location)
    }
    If ($Email.Length -gt 0) {
        $ANOWSecUser.Add('email', $Email)
    }
    If ($PhoneNumber.Length -gt 0) {
        $ANOWSecUser.Add('phone', $PhoneNumber)
    }
    If ($PSVersionTable.PSVersion.Major -ge 7) {
        [string]$Pass = $SecurePass | ConvertFrom-SecureString -AsPlainText -Force
    }
    Else {
        [string]$Pass = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto([System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecurePass))
    }
    $ANOWSecUser.Add('password', $Pass)
    $ANOWSecUser.Add('password2', $Pass) # [sic] Yes, the console really does pass a 'password2' parameter.
    $ANOWSecUser.Add('passwordValidDays', $PasswordValidDays)
    If ($AccountValidUntil.Length -eq 0) {
        [string]$AccountValidUntil = Get-Date -Date (Get-Date).ToUniversalTime().AddDays(100) -Format 'yyyy-MM-dd'
    }
    [string]$AccountValidUntil = New-AutomateNOWServerDayTimestamp -date $AccountValidUntil
    $ANOWSecUser.Add('accountValidUntil', $AccountValidUntil)
    If ($PasswordExpired -eq $true) {
        $ANOWSecUser.Add('passwordExpired', 'true')
    }
    Else {
        $ANOWSecUser.Add('passwordExpired', 'false')
    }
    If ($Admin -eq $true) {
        $ANOWSecUser.Add('admin', 'true')
    }
    Else {
        $ANOWSecUser.Add('admin', 'false')
    }
    If ($skinDensityType.Length -gt 0) {
        $ANOWSecUser.Add('skinDensityType', $skinDensityType)
    }
    If ($skinThemeType.Length -gt 0) {
        $ANOWSecUser.Add('skinThemeType', $skinThemeType)
    }
    [string]$BodyObject = ConvertTo-QueryString -InputObject $ANOWSecUser
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_operationType' = 'add'
    $BodyMetaData.'_oldValues' = ('{"accountValidUntil":"' + $AccountValidUntil + '","passwordValidDays":' + $PasswordValidDays + '}')
    $BodyMetaData.'_componentId' = 'SecUserCreateWindow_form'
    $BodyMetaData.'_dataSource' = 'SecUserDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$BodyMetaDataString = ConvertTo-QueryString -InputObject $BodyMetaData
    [string]$Body = ($BodyObject + '&' + $BodyMetaDataString)
    [string]$command = '/secUser/create'
    [hashtable]$parameters = @{}
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('Body', $Body)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWSecUser]$SecUser = $results.response.data | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to create [ANOWSecUser] object due to [$Message]."
        Break
    }
    If ($SecUser.id.Length -eq 0) {
        Write-Warning -Message "Somehow the newly created [ANOWSecUser] User is empty!"
        Break
    }
    If ($Quiet -ne $true) {
        Return $SecUser
    }
}

Function Remove-AutomateNOWSecUser {
    <#
    .SYNOPSIS
    Removes a User from an AutomateNOW! instance

    .DESCRIPTION
    Removes a User from an AutomateNOW! instance

    .PARAMETER User
    An [ANOWSecUser] object representing the User to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWSecUser] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Remove a single User by name

    Get-AutomateNOWSecUser -Id 'user01' | Remove-AutomateNOWSecUser

    .EXAMPLE
    Removes a series of User objects via input from the pipeline

    @( 'user01', 'user02', 'user03') | Remove-AutomateNOWSecUser

    .EXAMPLE
    Forcefully removes all User objects under a specified email address

    Get-AutomateNOWSecUser | Where-Object { $_.email -eq 'username@contoso.com'} | Remove-AutomateNOWSecUser -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWSecUser]$User,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/secUser/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWSecUser]$User = $_
        }
        [string]$User_id = $User.id
        If ($User_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($User_id)")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
            [string]$old_values = $User.CreateOldValues()
            $Body.Add('id', $User_id)
            $Body.Add('_oldValues', $old_values)
            $Body.Add('_operationType', 'remove')
            $Body.Add('_componentId', 'SecUserList')
            $Body.Add('_textMatchStyle', 'exact')
            $Body.Add('_dataSource', 'SecUserDataSource')
            $Body.Add('isc_metaDataPrefix', '_')
            $Body.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $Body
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$User_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "User [$User_id] successfully removed"
        }
    }
    End {

    }
}

Function Test-AutomateNOWSecUserPassword {
    [OutputType([boolean])]
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory = $true)]
        [SecureString]$SecurePassword
    )
    $Error.Clear()
    Try {
        If ($PSVersionTable.PSVersion.Major -ge 7) {
            If (($SecurePassword | ConvertFrom-SecureString -AsPlainText) -cmatch '(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z]).{4,}') {
                Write-Verbose -Message "A valid password was presented on PowerShell Core"
                Return $true
            }
            Else {
                Write-Verbose -Message "A valid password was not presented on PowerShell Core"
                Return $false
            }
        }
        Else {
            If (([System.Runtime.InteropServices.Marshal]::PtrToStringAuto([System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecurePassword))) -cmatch '(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z]).{4,}') {
                Write-Verbose -Message "A valid password was presented on Windows PowerShell"
                Return $true
            }
            Else {
                Write-Verbose -Message "A valid password was not presented on Windows PowerShell"
                Return $false
            }
        }
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "ConvertFrom-SecureString failed to convert the Secure String due to [$Message]"
        Break
    }
}

Function Set-AutomateNOWSecUserPassword {
    <#
    .SYNOPSIS
    Sets the password of the currently logged in user of an AutomateNOW! instance (local users only!)

    .DESCRIPTION
    Sets the password of the currently logged in user of an AutomateNOW! instance (local users only!) Not intended for ldap integrated user accounts.

    .PARAMETER OldSecurePassword
    Secure String representing the current password of the authenticated user

    .PARAMETER NewSecurePassword
    Secure String representing the new password of the authenticated user

    .INPUTS
    None. You cannot pipe objects to Set-AutomateNOWSecUserPassword.

    .OUTPUTS
    An informational message will be sent to the host.

    .EXAMPLE
    Set-AutomateNOWSecUserPassword -OldSecurePassword  -NewSecurePassword 'MyCoolPassword4#'

    .NOTES
    This function should ONLY be used in a development environment. This function is not ready for production use as it needs to be updated to receive a (pipelined) credential object.

    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>

    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true)]
        [SecureString]$OldSecurePass,
        [Parameter(Mandatory = $true)]
        [SecureString]$NewSecurePass
    )
    $Error.Clear()
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    [boolean]$new_password_valid = Test-AutomateNOWSecUserPassword -SecurePassword $NewSecurePass
    If ($new_password_valid -eq $false) {
        Write-Warning -Message "The new password does not appear to be valid. The password must be at least 4 characters and have at least 1 character from 2 of 4 groups (upper, lower, digits, special chars)"
        Break
    }
    [boolean]$old_password_valid = Test-AutomateNOWSecUserPassword -SecurePassword $OldSecurePass
    If ($old_password_valid -eq $false) {
        Write-Warning -Message "The old password does not appear to be valid. It should have at least 4 characters and have at least 1 character from 2 of 4 groups (upper, lower, digits, special chars). Continuing anyway..."
    }
    [hashtable]$parameters = @{}
    [string]$User = ($anow_session.User)
    If ($User.Length -eq 0) {
        Write-Warning -Message "Somehow the logged-in user name could not be extracted. Please look into this."
        Break
    }
    Write-Verbose -Message "About to set a new password for the currently logged user: $User"
    [string]$command = '/secUser/updatePassword'
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    $Error.Clear()
    Try {
        If ($PSVersionTable.PSVersion.Major -ge 7) {
            [string]$Body = ('id=' + $User + '&oldPassword=' + ([System.Net.WebUtility]::UrlEncode(($OldSecurePass | ConvertFrom-SecureString -AsPlainText))) + '&newPassword=' + ([System.Net.WebUtility]::UrlEncode(($NewSecurePass | ConvertFrom-SecureString -AsPlainText))) + '&repeatPassword=' + ([System.Net.WebUtility]::UrlEncode(($NewSecurePass | ConvertFrom-SecureString -AsPlainText))))
        }
        Else {
            [string]$Body = ('id=' + $User + '&oldPassword=' + ([System.Runtime.InteropServices.Marshal]::PtrToStringAuto([System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($OldSecurePass))) + '&newPassword=' + ([System.Net.WebUtility]::UrlEncode(([System.Runtime.InteropServices.Marshal]::PtrToStringAuto([System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($NewSecurePass))))) + '&repeatPassword=' + ([System.Runtime.InteropServices.Marshal]::PtrToStringAuto([System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($NewSecurePass))))
        }
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "There was an error formatting the payload under Set-AutomateNOWSecUserPassword due to [$Message]."
        Break
    }
    $parameters.Add('Body', $Body)
    Remove-Variable -Name Body -Force
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    Write-Verbose -Message $parameters_display
    Remove-Variable -Name parameters_display -Force
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] while running Set-AutomateNOWSecUserPassword due to [$Message]."
        Break
    }
    Remove-Variable -Name Parameters -Force
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    Write-Information -MessageData "Password successfully changed for $User"
}

#endregion

#Region - SecUser Roles

Function Read-AutomateNOWSecurityRoleUser {
    <#
    .SYNOPSIS
    Reads the Security Role User objects within a Security Role from an AutomateNOW! instance

    .DESCRIPTION
    Reads the Security Role User objects within a Security Role from an AutomateNOW! instance

    .PARAMETER Id
    An optional Id string representing the Security Role object to be read.

    .PARAMETER ItemId
    An optional Id string representing the Security User Role object to be read. Note: This is not supported by the console

    .PARAMETER SecurityRole
    An optional [ANOWSecRole] object representing the Security Role object to be read.

    .INPUTS
    ONLY [ANOWSecRole] objects are accepted (including from the pipeline)

    .OUTPUTS
    [ANOWSecUserRole] objects that represent the Security User Roles will be returned.

    .EXAMPLE
    Get the first page of User Roles within a Security Role

    $security_role = Get-AutomateNOWSecurityRole1 -Id 'SecurityRole1'
    $user_roles = $security_role | Read-AutomateNOWSecurityRoleUser

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWSecUserRole[]])]
    [Cmdletbinding( DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $true, ParameterSetName = 'Default', ValueFromPipeline = $true)]
        [ANOWSecRole]$SecurityRole,
        [Parameter(Mandatory = $true, ParameterSetName = 'ItemId')]
        [string]$ItemId,
        [Parameter(Mandatory = $False)]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False)]
        [int32]$endRow = 100
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0 -or $SecurityRole.Id.Length -gt 0) {
            If ($_.id.Length -gt 0) {
                [ANOWSecRole]$SecurityRole = $_
            }
            [string]$SecurityRole_id = $SecurityRole.Id
        }
        ElseIf ($_.Length -gt 0) {
            [string]$SecurityRole_id = $_
        }
        ElseIf ($Id.Length -gt 0) {
            [string]$SecurityRole_id = $Id
        }
        ElseIf ($ItemId.Length -gt 0) {
            If ($ItemId -notmatch '^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$') {
                Write-Warning -Message "Was expecting the Id of the destination SecurityRoleUser Id to match a 36-character GUID, instead received [$ItemId]. Please check into this."
                Break
            }
        }
        Else {
            Write-Warning -Message "Somehow was not able to determine the Id of the Security Role under Read-AutomateNOWSecurityRoleUser. Please look into this."
            Break
        }
        If ($null -eq $SecurityRole) {
            $Error.Clear()
            Try {
                [ANOWSecRole]$SecurityRole = Get-AutomateNOWSecurityRole -Id $SecurityRole_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWSecurityRole failed to retrieve the Security Role object for [$SecurityRole_id] under Read-AutomateNOWSecurityRoleUser due to [$Message]."
                Break
            }
        }
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($ItemId.Length -eq 0) {
            $BodyMetaData.Add('_constructor', 'AdvancedCriteria')
            $BodyMetaData.Add('operator', 'and')
            $BodyMetaData.Add('criteria1', '{"fieldName":"role","operator":"equals","value":"' + $SecurityRole_id + '"}')
            $BodyMetaData.Add('_startRow', $startRow)
            $BodyMetaData.Add('_endRow', $endRow)
            $BodyMetaData.Add('_textMatchStyle', 'substring')
            $BodyMetaData.Add('_componentId', 'SecRoleUserList')
        }
        Else {
            $BodyMetaData.Add('id', $ItemId)
            $BodyMetaData.Add('_operationId', 'read')
            $BodyMetaData.Add('_textMatchStyle', 'exactCase')
        }
        $BodyMetaData.Add('_operationType', 'fetch')
        $BodyMetaData.Add('_dataSource', 'SecUserRoleDataSource')
        $BodyMetaData.Add('isc_metaDataPrefix', '_')
        $BodyMetaData.Add('isc_dataFormat', 'json')
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        [string]$command = ('/secUserRole/read' + '?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.'Command' = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$SecurityRole_id] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        If ($results.response.data.count -gt 0) {
            $formatted_results = ForEach ($secRoleUser in $results.response.data) {
                [string]$user_id = $secRoleUser.user
                $Error.Clear()
                Try {
                    [ANOWSecUser]$user_object = Get-AutomateNOWSecUser -Id $user_id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWSecUser failed to retrieve information about $user_id under Read-AutomateNOWSecurityRoleUser due to [$Message]."
                    Break
                }
                $Error.Clear()
                Try {
                    $secRoleUser.role = $SecurityRole
                    $secRoleUser.user = $user_object
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to format the ANOWSecUserRole object under Read-AutomateNOWSecurityRoleUser due to [$Message]."
                    Break
                }
                $secRoleUser
            }
            $Error.Clear()
            Try {
                [ANOWSecUserRole[]]$userRoles = $formatted_results
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the User Roles from $SecurityRole_id into [ANOWSecUserRole] objects due to [$Message]"
                Break
            }
            Write-Verbose -Message "User Roles successfully read from $SecurityRole_id"
            If ($Quiet -ne $true) {
                Return $userRoles
            }
        }
        Else {
            Write-Verbose -Message "There were no User Roles within $SecurityRole_id"
        }
    }
    End {

    }
}

Function Export-AutomateNOWSecurityRoleUser {
    <#
    .SYNOPSIS
    Exports the Security Role User objects from a Security Role on an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Security Role User objects from a Security Role on an instance of AutomateNOW! to a local .csv file

    .Parameter SecUserRole
    Mandatory [ANOWSecUserRole] object representing the Security Role User that is to be exported.

    .INPUTS
    ONLY [ANOWSecUserRole] objects are accepted (including from the pipeline)

    .OUTPUTS
    The [ANOWSecUserRole] objects are exported to the local disk in CSV format

    .EXAMPLE
    Exports all of the User Roles from within a Security Role named 'SecurityRole1'

    $security_role = Get-AutomateNOWSecurityRole -Id 'SecurityRole1'
    $user_roles = $security_role | Read-AutomateNOWSecurityRoleUser
    $user_roles | Export-AutomateNOWSecurityRoleUser

    .NOTES
	
    #>

    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWSecUserRole]$SecUserRole
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = "Export-AutomateNOW-SecUserRole-" + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWSecUserRole]$SecUserRole = $_
        }
        [string]$SecUserRole_Name = $SecUserRole.user.id
        $Error.Clear()
        Try {
            $SecUserRole | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWSecUserRole] object $SecUserRole_Name due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function Add-AutomateNOWSecurityRoleUser {
    <#
    .SYNOPSIS
    Adds a User to a Security Role on an AutomateNOW! instance

    .DESCRIPTION
    Adds a User to a Security Role on an AutomateNOW! instance

    .PARAMETER SecurityRole
    Mandatory [ANOWSecRole] object representing the Security Role that will receive the User

    .Parameter User
    Mandatory [ANOWSecUser] object representing the User that will be added to the Security Role

    .PARAMETER Quiet
    Switch parameter to silence the emitted [ANOWSecUserRole] object

    .PARAMETER Force
    Force the addition of the object without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    An [ANOWSecRole] object must be presented along with [ANOWSecUser] objects which can be sent to the pipeline.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Forcefully adds a user named 'User1' to a Security Role named 'SecurityRole1' (multi-line format)

    [ANOWSecRole]$secRole = Get-AutomateNOWSecurityRole -Id 'SecurityRole1'
    [ANOWSecUser]$secUser = Get-AutomateNOWSecUser -Id 'User1'
    $secUser | Add-AutomateNOWSecurityRoleUser -SecurityRole $secRole -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWSecRoleDomain])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWSecRole]$SecurityRole,
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWSecUser]$User,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$SecurityRole_id = $SecurityRole.Id
        [string]$command = '/secUserRole/create'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWSecUser]$User = $_
        }
        [string]$User_id = $User.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Add $($User_id) to $($SecurityRole_id)")) -eq $true) {
            $Error.Clear()
            Try {
                [ANOWSecUserRole[]]$ExistingRoleUsers = Read-AutomateNOWSecurityRoleUser -SecurityRole $SecurityRole
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to extract the SecUserRoles from $SecurityRole_id due to [$Message]."
                Break
            }
            [int32]$ExistingRoleUsers_Count = $ExistingRoleUsers.Count
            If ($ExistingRoleUsers_Count -gt 0) {
                Write-Verbose -Message "$SecurityRole_id currently has $ExistingRoleUsers_Count users before any changes were made"
            }
            Else {
                Write-Verbose -Message "$SecurityRole_id does not have any users yet. $User_id will be the first user added to it."
            }
            If ( $User_id -in $ExistingRoleUsers.user.id) {
                Write-Warning -Message "$SecurityRole_id already contains $User_id!"
                Break
            }
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('user', $User_id )
            $BodyMetaData.Add('role', $SecurityRole_id )
            $BodyMetaData.Add('_operationType', 'add')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'SecUserRoleDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$SecurityRole_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            If ($results.response.data.count -gt 0) {
                $formatted_results = ForEach ($formatted_user in $results.response.data) {
                    If ($SecurityRole.id.Length -gt 0) {
                        $Error.Clear()
                        Try {
                            [ANOWSecRole]$SecurityRole = Get-AutomateNOWSecurityRole -Id $SecurityRole_id
                        }
                        Catch {
                            [string]$Message = $_.Exception.Message
                            Write-Warning -Message "Get-AutomateNOWSecurityRole failed to retrieve information about $SecurityRole_id under Add-AutomateNOWSecurityRoleUser due to [$Message]."
                            Break
                        }
                    }
                    [string]$user_id = $formatted_user.user
                    $Error.Clear()
                    Try {
                        [ANOWSecUser]$user_object = Get-AutomateNOWSecUser -Id $user_id
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Get-AutomateNOWSecUser failed to retrieve information about $user_id under Read-AutomateNOWSecurityRoleUser due to [$Message]."
                        Break
                    }
                    $formatted_user.role = $SecurityRole
                    $formatted_user.user = $user_object
                    $formatted_user
                }
                $Error.Clear()
                Try {
                    [ANOWSecUserRole]$userRole = $formatted_results
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to parse the [ANOWSecUserRole] object after adding $User_id to $SecurityRole_id due to [$Message]."
                    Break
                }
                If ($Quiet -ne $true) {
                    Write-Verbose -Message "$User_id was added to $SecurityRole_id"
                    Return $userRole
                }
            }
        }
    }
    End {

    }
}

Function Remove-AutomateNOWSecurityRoleUser {
    <#
    .SYNOPSIS
    Removes a SecurityRoleUser from a Security Role

    .DESCRIPTION
    Removes a SecurityRoleUser from a Security Role

    .PARAMETER SecurityRole
    Mandatory [ANOWSecRole] object representing the Security Role to be modified.

    .Parameter SecUserRole
    Mandatory [ANOWSecUserRole] object representing the SecurityRoleUser that is being removed from a Security Role. Use Read-AutomateNOWSecurityRoleUser to retrieve the SecurityRoleUsers from a Security Role.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    You must present a [ANOWSecUserRole] object to the -SecUserRole parameter (including from the pipeline).

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Forcibly removes a User Role for a user named 'User1' from within a Security Role named 'SecurityRole1' (multi-line format)

    [ANOWSecRole]$secRole = Get-AutomateNOWSecurityRole -Id 'SecurityRole1'
    [ANOWSecUserRole]$secUserRole = $secRole | Read-AutomateNOWSecurityRoleUser | Where-Object { $_.user.id -eq 'User1'}
    $secUserRole | Remove-AutomateNOWSecurityRoleUser -SecurityRole $secRole -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWSecRole]$SecurityRole,
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWSecUserRole]$SecUserRole,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/secUserRole/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
        [string]$SecurityRole_id = $SecurityRole.Id
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWSecUserRole]$SecUserRole = $_
        }
        [string]$SecUserRole_id = $SecUserRole.Id
        [string]$SecUserRole_name = $SecUserRole.User.id
        If ($SecUserRole_id.Length -eq 0) {
            Write-Warning -Message "Somehow the Id of the User object (embedded within the Security User Role object) is empty. Please look into this."
            Break
        }
        If ($SecUserRole_name.Length -eq 0) {
            Write-Warning -Message "Somehow the Name of the User object (embedded within the Security User Role object) is empty. Please look into this."
            Break
        }
        If ($SecUserRole_id -notmatch '^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$') {
            Write-Warning -Message "Was expecting the Id of the SecurityRoleUser Id for [$SecUserRole_name] to match a 36-character GUID, instead received [$SecUserRole_id]. Please check into this."
            Break
        }
        Else {
            Write-Verbose -Message "Received [$SecUserRole_id] for the Id of the SecurityRoleUser for [$SecUserRole_name] to be removed"
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($SecUserRole_name) from $($SecurityRole_Id)")) -eq $true) {
            $Error.Clear()
            Try {
                [PSCustomObject]$SecurityRoleUsers = Read-AutomateNOWSecurityRoleUser -Id $SecurityRole_Id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Read-AutomateNOWSecurityRoleUser failed to read the users from $SecurityRole_Id under Remove-AutomateNOWSecurityRoleUser due to [$Message]."
                Break
            }
            [int32]$SecurityRoleUsers_Count = $SecurityRoleUsers.Count
            If ($SecurityRoleUsers_Count -eq 0) {
                Write-Verbose -Message "$SecurityRole_Id does not have any SecurityRoleUsers added to it yet... Please check again."
                Break
            }
            If ($SecUserRole_id -notin ($SecurityRoleUsers.Id) ) {
                Write-Warning -Message "The SecurityRoleUser [$SecUserRole_name] ($SecUserRole_id) is not actually added to [$SecurityRole_Id]. Please check this."
                Break
            }
            [string]$old_values = $SecUserRole.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $SecUserRole_id )
            $BodyMetaData.Add('_oldValues', $old_values )
            $BodyMetaData.Add('_operationType', 'remove')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_componentId', 'SecRoleUserList')
            $BodyMetaData.Add('_dataSource', 'SecUserRoleDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$SecUserRole_name] ($SecUserRole_id) due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "SecurityRoleUser [$SecUserRole_name] ($SecUserRole_id) has been removed from $SecurityRole_Id"
        }
    }
    End {

    }
}

#endregion

#Region - Semaphores (RESOURCE)

Function Get-AutomateNOWSemaphore {
    <#
    .SYNOPSIS
    Gets the Semaphore objects from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Semaphore objects from an AutomateNOW! instance

    .PARAMETER Id
    Optional string containing the simple id of the Semaphore to fetch or you can pipeline a series of simple id strings. You may not enter an array here.

    .PARAMETER Detailed
    Switch parameter to provide the detailed properties of the [ANOWSemaphore] object. This may only be used in conjunction with -Id. Use this option to see the fully populated object.

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100. The console default hard limit is 10,000.

    .PARAMETER sortBy
    Optional string parameter to sort the results by (may not be used with the Id parameter). Valid choices are: {To be continued...}

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .PARAMETER Folder
    Optional string to filter by a particular Folder

    .PARAMETER Tags
    Optional string array of Tags to filter by. Note that the 'containsAny' operator will be used.

    .INPUTS
    Accepts a string representing the simple id of the Semaphore from the pipeline or individually (but not an array).

    .OUTPUTS
    Either one or more [ANOWSemaphore]

    .EXAMPLE
    Gets the first page of Semaphore objects

    Get-AutomateNOWSemaphore

    .EXAMPLE
    Gets the first 500 Semaphore objects

    Get-AutomateNOWSemaphore -startRow 0 -endRow 500

    .EXAMPLE
    Gets a single non-detailed Semaphore named 'Semaphore1'

    Get-AutomateNOWSemaphore -Id 'Semaphore1'

    .EXAMPLE
    Gets the detailed version of a Semaphore object named 'Semaphore1'

    Get-AutomateNOWSemaphore -Id 'Semaphore1' -Detailed

    .EXAMPLE
    Gets a series of Semaphore objects through the pipeline

    'Semaphore1', 'Semaphore2' | Get-AutomateNOWSemaphore

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(DefaultParameterSetName = 'Id')]
    Param(
        [Parameter(Mandatory = $False, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [Parameter(Mandatory = $True, ParameterSetName = 'Detailed', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'Detailed')]
        [switch]$Detailed,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [string]$sortBy = 'id',
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [switch]$Descending,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [string]$Folder,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [string[]]$Tags
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 ) {
            [string]$Semaphore_Id = $_
        }
        Else {
            [string]$Semaphore_Id = $Id
        }
        If ($Detailed -eq $true) {
            $Body.'id' = $Semaphore_Id
            [string]$textMatchStyle = 'exactCase'
            $Body.'_operationId' = 'readDetailed'
            [string]$Method = 'POST'
        }
        Else {
            $Body.'_constructor' = 'AdvancedCriteria'
            $Body.'operator' = 'and'
            $Body.'criteria1' = '{"fieldName":"resourceType","operator":"equals","value":"BINARY_SEMAPHORE"}'
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
            If ($Semaphore_Id.Length -gt 0) {
                $Body.'criteria2' = ('{"fieldName":"simpleId","operator":"equals","value":"' + $Semaphore_Id + '"}')
                [string]$textMatchStyle = 'exact'
            }
            Else {
                [string]$textMatchStyle = 'substring'
            }
            If ($Folder.Length -gt 0) {
                $Body.'criteria3' = ('{"fieldName":"folder","operator":"equals","value":"' + $Folder + '"}')
            }
            If ($Tags.Count -gt 0) {
                If ($Tags.Count -gt 1) {
                    $Error.Clear()
                    Try {
                        [string]$TagString = $Tags | ConvertTo-Json -Compress
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "ConvertTo-Json failed to convert the provided tag names under Get-AutomateNOWSemaphore due to [$Message]."
                        Break
                    }
                }
                Else {
                    [string]$TagString = $Tags
                }
                $Body.'criteria4' = ('{"fieldName":"tags","operator":"containsAny","value":' + $TagString + '}')
            }
            $Body.'_componentId' = 'ResourceList'
            If ($Descending -eq $true) {
                $Body.'_sortBy' = '-' + $sortBy
            }
            Else {
                $Body.'_sortBy' = $sortBy
            }
            [string]$Method = 'GET'
        }
        $Body.'_operationType' = 'fetch'
        $Body.'_textMatchStyle' = $textMatchStyle
        $Body.'_dataSource' = 'ResourceDataSource'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        If ($Detailed -eq $true) {
            [string]$command = ('/resource/readDetailed')
            If ($Null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            If ($null -eq $parameters["Command"]) {
                $parameters.Add('Command', $command)
            }
            Else {
                $parameters.Command = $command
            }
        }
        Else {
            [string]$command = ('/resource/read?' + $Body)
            $parameters.Command = $command
        }
        If ($null -eq $parameters.Method) {
            $parameters.Add('Method', $Method)
        }
        Else {
            $parameters.Method = $Method
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWSemaphore[]]$Semaphores = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWSemaphore failed to parse the results into [ANOWSemaphore] objects due to [$Message]."
            Break
        }
        If ($Semaphores.Count -gt 0) {
            Return $Semaphores
        }
    }
    End {

    }
}

Function Set-AutomateNOWSemaphore {
    <#
    .SYNOPSIS
    Changes the settings of an Semaphore on an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of an Semaphore on an AutomateNOW! instance

    .PARAMETER Semaphore
    An [ANOWSemaphore] object representing the Semaphore to be modified.

    .PARAMETER TurnOn
    Switch parameter to set the Semaphore to GO (green light) status (cannot be combined with `TurnOff`).

    .PARAMETER TurnOff
    Switch parameter to set the Semaphore to STOP (red light) status (cannot be combined with `TurnOn`).

    .PARAMETER UnsetDescription
    Optional switch that will remove the Description from the Semaphore object.

    .PARAMETER Description
    Optional string to set the description on the new Semaphore object.

    .PARAMETER UnsetFolder
    Optional switch that will remove the Folder assignment from the Semaphore object.

    .PARAMETER Folder
    Optional string to set a different folder on the Semaphore object.

    .PARAMETER UnsetTags
    Optional switch that will remove the Tags from the Semaphore object.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the new Semaphore object.

    .PARAMETER CodeRepository
    Optional Code Repository to place the Semaphore into. Use Get-AutomateNOWCodeRepository to fetch this object.

    .PARAMETER UnsetCodeRepository
    Switch parameter that will remove the the Semaphore from its Code Repository.

    .PARAMETER Quiet
    Switch parameter that silences the output of the updated object.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWSemaphore] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWSemaphore] object will be returned

    .EXAMPLE
    Changes the description of an Semaphore

    $Semaphore = Get-AutomateNOWSemaphore -Id 'Semaphore1'
    Set-AutomateNOWSemaphore -Semaphore $Semaphore -Description 'My Description'

    .EXAMPLE
    Sets a Semaphore status to GO (green light)

    $Semaphore = Get-AutomateNOWSemaphore -Id 'Semaphore1'
    Set-AutomateNOWSemaphore -Semaphore $Semaphore -TurnOn

    .EXAMPLE
    Forcibly sets a Semaphore status to STOP (red light)

    $Semaphore = Get-AutomateNOWSemaphore -Id 'Semaphore1'
    Set-AutomateNOWSemaphore -Semaphore $Semaphore -TurnOff -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The -TurnOn and -TurnOff parameters are isolated into their own parameter sets. Please try `Get-AutomateNOWSemaphore -?` for more information.

    #>
    [OutputType([ANOWSemaphore])]
    [Cmdletbinding(DefaultParameterSetName = 'Default', SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'Default', ValueFromPipeline = $True)]
        [Parameter(Mandatory = $true, ParameterSetName = 'TurnOn')]
        [Parameter(Mandatory = $true, ParameterSetName = 'TurnOff')]
        [ANOWSemaphore]$Semaphore,
        [Parameter(Mandatory = $true, ParameterSetName = 'TurnOn')]
        [switch]$TurnOn,
        [Parameter(Mandatory = $true, ParameterSetName = 'TurnOff')]
        [switch]$TurnOff,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [string[]]$Tags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [string]$Folder,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'TurnOn')]
        [Parameter(Mandatory = $false, ParameterSetName = 'TurnOff')]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'TurnOn')]
        [Parameter(Mandatory = $false, ParameterSetName = 'TurnOff')]
        [switch]$UnsetCodeRepository,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'TurnOn')]
        [Parameter(Mandatory = $false, ParameterSetName = 'TurnOff')]
        [switch]$Quiet,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'TurnOn')]
        [Parameter(Mandatory = $false, ParameterSetName = 'TurnOff')]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        $Error.Clear()
        Try {
            [ANOWResource_semaphoreState]$Semaphore_state = $Semaphore.semaphoreState
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to extract the current state of the Semaphore due to [$message]"
            Break
        }
        If ($Semaphore_state -eq 'ON' -and $TurnOn -eq $true) {
            Write-Warning -Message "This Semaphore is already in GO (green light) state. Disregarding this request."
            Break
        }
        ElseIf ($Semaphore_state -eq 'OFF' -and $TurnOff -eq $true) {
            Write-Warning -Message "This Semaphore is already in STOP (red light) state. Disregarding this request."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot set the Tags and unset them at the same time. Please choose one or the other. Tags from the source object will be carried over to the new object if you do not specify any tag-related parameters."
            Break
        }
        If ($UnsetCodeRepository -eq $true -and $CodeRepository.Id.Length -gt 0) {
            Write-Warning -Message "You cannot unset the Code Repository and set it at the same time. Please choose one or the other."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWSemaphore]$Semaphore = $_
        }
        [string]$Semaphore_id = $Semaphore.id
        [string]$Semaphore_simpleId = $Semaphore.simpleId
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Semaphore_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$Semaphore_exists = ($null -eq (Get-AutomateNOWSemaphore -Id $Semaphore_simpleId))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWSemaphore failed to check if the Semaphore [$Semaphore_simpleId] already existed due to [$Message]."
                Break
            }
            If ($Semaphore_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not an Semaphore named [$Semaphore_simpleId] in the [$current_domain] domain. Please check into this."
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $Semaphore_id
            If ($TurnOn -eq $true -or $TurnOff -eq $true) {
                [string]$operationType = 'custom'
                If ($TurnOn -eq $true) {
                    [string]$operationId = 'turnOn'
                }
                Else {
                    [string]$operationId = 'turnOff'
                }
                $BodyMetaData.'_operationId' = $operationId
                [string]$command = "/resource/$operationId"
            }
            Else {
                [string]$command = '/resource/update'
                [string]$operationType = 'update'
                If ($Description.Length -gt 0) {
                    $BodyMetaData.'description' = $Description
                }
                ElseIf ($UnsetDescription -eq $true) {
                    $BodyMetaData.'description' = $Null
                }
                Else {
                    If ($Semaphore.description.Length -gt 0) {
                        $BodyMetaData.'description' = $Semaphore.description
                    }
                }
                If ($UnsetFolder -eq $True) {
                    $BodyMetaData.'folder' = $Null
                }
                ElseIf ($Folder.Length -gt 0) {
                    $BodyMetaData.'folder' = $Folder
                }
                Else {
                    If ($Semaphore.folder.Length -gt 0) {
                        $BodyMetaData.'folder' = $Semaphore.folder
                    }
                }
                If ($Tags.Count -gt 0) {
                    [int32]$tag_count = 1
                    ForEach ($tag in $Tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
                ElseIf ($UnsetTags -eq $true) {
                    $BodyMetaData.'tags' = $Null
                }
                Else {
                    If ($Semaphore.Tags -gt 0) {
                        [int32]$tag_count = 1
                        ForEach ($tag in $Semaphore.tags) {
                            $BodyMetaData.('tags' + $tag_count ) = $tag
                            $tag_count++
                        }
                    }
                }
            }
            If ($CodeRepository.Id.Length -gt 0) {
                [string]$CodeRepository_Id = $CodeRepository.Id
                $Error.Clear()
                Try {
                    [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository_Id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository_Id] actually existed under Set-AutomateNOWSemaphore due to [$Message]"
                    Break
                }
                If ($code_repository_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository_Id] under Set-AutomateNOWSemaphore. Please check again."
                    Break
                }
                $BodyMetaData.'codeRepository' = $CodeRepository_Id
            }
            ElseIf ($UnsetCodeRepository -eq $true) {
                $BodyMetaData.'codeRepository' = $null
            }
            $BodyMetaData.'_operationType' = $operationType
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_dataSource' = 'ResourceDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $parameters.Add('Command', $command)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Semaphore_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Semaphore object [$Semaphore_id] was successfully updated"
            $Error.Clear()
            Try {
                [ANOWSemaphore]$UpdatedSemaphore = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the returned updated object to an [ANOWSemaphore] object due to [$Message]. The object was still updated though."
                Break
            }
            If ($Quiet -ne $true) {
                Return $UpdatedSemaphore
            }
        }
    }
    End {
    }
}

Function Export-AutomateNOWSemaphore {
    <#
    .SYNOPSIS
    Exports the Semaphore objects from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Semaphore objects from an instance of AutomateNOW! to a local .csv file

    .PARAMETER Semaphore
    Mandatory [ANOWSemaphore] object (Use Get-AutomateNOWSemaphore to retrieve them)

    .INPUTS
    ONLY [ANOWSemaphore] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWSemaphore] objects are exported to the local disk in CSV format

    .EXAMPLE
    Exports all of the Semaphore objects (up to 100 by default)

    Get-AutomateNOWSemaphore | Export-AutomateNOWSemaphore

    .EXAMPLE
    Exports 1 Semaphore by name

    Get-AutomateNOWSemaphore -Id 'Semaphore01' | Export-AutomateNOWSemaphore

    .EXAMPLE
    Exports a series of Semaphore objects by the pipeline

    @( 'Semaphore01', 'Semaphore02' ) | Get-AutomateNOWSemaphore | Export-AutomateNOWSemaphore

    .NOTES
	You must present [ANOWSemaphore] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWSemaphore]$Semaphore
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-Semaphores-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWSemaphore]$Semaphore = $_
        }
        $Error.Clear()
        Try {
            $Semaphore | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWSemaphore] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function New-AutomateNOWSemaphore {
    <#
    .SYNOPSIS
    Creates a Semaphore within an AutomateNOW! instance

    .DESCRIPTION
    Creates a Semaphore within an AutomateNOW! instance and returns back the newly created [ANOWSemaphore] object

    .PARAMETER Id
    The intended name of the Semaphore. For example: 'semaphore1'. This value may not contain the domain in brackets.

    .PARAMETER Description
    Optional description of the Semaphore (may not exceed 255 characters).

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new Semaphore. Do not pass [ANOWTag] objects here.

    .PARAMETER Folder
    Optional name of the folder to place the Semaphore into.

    .PARAMETER CodeRepository
    Optional name of the code repository to place the Semaphore into.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWSemaphore.

    .OUTPUTS
    An [ANOWSemaphore] object representing the newly created Semaphore

    .EXAMPLE
    New-AutomateNOWSemaphore -Id 'Semaphore01' -Type 'CAL_SELECT' -Description 'Description01' -Tags 'Tag01' -Folder 'Folder01'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The name (id) of the Semaphore must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    #>
    [OutputType([ANOWSemaphore])]
    [Cmdletbinding()]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $true)]
        [string]$Id,
        [ValidateScript({ $_.Length -le 255 })]
        [Parameter(Mandatory = $false, HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [string]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [boolean]$Semaphore_exists = ($null -ne (Get-AutomateNOWSemaphore -Id $Id))
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWSemaphore failed to check if the Semaphore [$Id] already existed due to [$Message]."
        Break
    }
    If ($Semaphore_exists -eq $true) {
        [string]$current_domain = $anow_session.header.domain
        Write-Warning -Message "There is already a Semaphore named [$Id] in [$current_domain]. Please check into this."
        Break
    }
    ## End warning ##
    [System.Collections.Specialized.OrderedDictionary]$ANOWSemaphore = [System.Collections.Specialized.OrderedDictionary]@{}
    $ANOWSemaphore.Add('id', $Id)
    If ($Description.Length -gt 0) {
        $ANOWSemaphore.Add('description', $Description)
    }
    If ($Tags.Count -gt 0) {
        [int32]$total_tags = $Tags.Count
        [int32]$current_tag = 1
        ForEach ($tag_id in $Tags) {
            $Error.Clear()
            Try {
                [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] running under New-AutomateNOWSemaphore due to [$message]"
                Break
            }
            If ($tag_object.simpleId.length -eq 0) {
                Throw "New-AutomateNOWSemaphore has detected that the tag [$tag_id] does not appear to exist. Please check again."
                Break
            }
            ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                [string]$tag_object_simpleId = $tag_object.simpleId
                Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                Break
            }
            [string]$tag_display = $tag_object | ConvertTo-Json -Compress
            Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
            [string]$tag_name_sequence = ('tags' + $current_tag)
            $ANOWSemaphore.Add($tag_name_sequence, $tag_id)
            $include_properties += $tag_name_sequence
            $current_tag++
        }
    }
    If ($Folder.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] existed under New-AutomateNOWSemaphore due to [$Message]"
            Break
        }
        If ($folder_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] under New-AutomateNOWSemaphore. Please check again."
            Break
        }
        [string]$folder_display = $folder_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding folder $folder_display to [ANOWSemaphore] [$Id]"
        $ANOWSemaphore.Add('folder', $Folder)
        $include_properties += 'folder'
    }
    If ($CodeRepository.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository] existed under New-AutomateNOWSemaphore due to [$Message]"
            Break
        }
        If ($code_repository_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository] under New-AutomateNOWSemaphore. Please check again."
            Break
        }
        [string]$code_repository_display = $code_repository_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding code repository $code_repository_display to [ANOWSemaphore] [$Id]"
        $ANOWSemaphore.Add('codeRepository', $CodeRepository)
        $include_properties += 'codeRepository'
    }
    $ANOWSemaphore.Add('title', 'Semaphore')
    $ANOWSemaphore.Add('icon', '[SKINIMG]/skin/traffic-light.png')
    $oldvalues = ('{"title":"Semaphore","resourceType":"BINARY_SEMAPHORE","icon":"[SKINIMG]/skin/traffic-light.png"}')
    [string]$BodyObject = ConvertTo-QueryString -InputObject $ANOWSemaphore -IncludeProperties id, description, title, icon, tags, folder, codeRepository
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    $BodyMetaData.'resourceType' = 'BINARY_SEMAPHORE'
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_operationType' = 'add'
    $BodyMetaData.'_oldValues' = $oldvalues
    $BodyMetaData.'_componentId' = 'ResourceCreateWindow_form'
    $BodyMetaData.'_dataSource' = 'ResourceDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$BodyMetaDataString = ConvertTo-QueryString -InputObject $BodyMetaData
    [string]$Body = ($BodyObject + '&' + $BodyMetaDataString)
    [string]$command = '/resource/create'
    [hashtable]$parameters = @{}
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('Body', $Body)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWSemaphore]$Semaphore = $results.response.data | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to create the [ANOWSemaphore] object due to [$Message]."
        Break
    }
    If ($Semaphore.id.Length -eq 0) {
        Write-Warning -Message "Somehow the newly created [ANOWSemaphore] Semaphore is empty!"
        Break
    }
    If ($Quiet -ne $true) {
        Return $Semaphore
    }
}

Function Remove-AutomateNOWSemaphore {
    <#
    .SYNOPSIS
    Removes a Semaphore from an AutomateNOW! instance

    .DESCRIPTION
    Removes a Semaphore from an AutomateNOW! instance

    .PARAMETER Semaphore
    An [ANOWSemaphore] object representing the Semaphore to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWSemaphore] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Remove a single Semaphore by name

    Get-AutomateNOWSemaphore -Id 'Semaphore01' | Remove-AutomateNOWSemaphore

    .EXAMPLE
    Removes a series of Semaphore objects via input from the pipeline

    @( 'Semaphore01', 'Semaphore02', 'Semaphore03') | Get-AutomateNOWSemaphore | Remove-AutomateNOWSemaphore

    .EXAMPLE
    Forcefully removes all Semaphore objects that have a timezone configured as UTC

    Get-AutomateNOWSemaphore | Where-Object { $_.timeZone -eq 'UTC'} | Remove-AutomateNOWSemaphore -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWSemaphore]$Semaphore,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/resource/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWSemaphore]$Semaphore = $_
        }
        [string]$Semaphore_id = $Semaphore.id
        If ($Semaphore_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Semaphore_id)")) -eq $true) {
            [string]$oldvalues = $Semaphore.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $Semaphore.id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'ResourceList'
            $BodyMetaData.'_dataSource' = 'ResourceDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Semaphore_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Semaphore [$Semaphore_id] successfully removed"
        }
    }
    End {

    }
}

Function Copy-AutomateNOWSemaphore {
    <#
    .SYNOPSIS
    Copies an Semaphore from an AutomateNOW! instance

    .DESCRIPTION
    Copies an Semaphore from an AutomateNOW! instance. AutomateNOW object id can never be changed, but we can copy the object to a new id and it will include all of the items therein.

    .PARAMETER Semaphore
    Mandatory [ANOWSemaphore] object to be copied.

    .PARAMETER NewId
    The name (Id) of the new Semaphore. The new Id must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    .PARAMETER UnsetDescription
    Optional switch that will ensure that the newly created Semaphore will not have a description set.

    .PARAMETER Description
    Optional description to set on the new Semaphore object. If you do not set this, the new Semaphore object will copy the Description of the source object.

    .PARAMETER UnsetFolder
    Optional switch that will ensure that the newly created Semaphore will not have a Folder set.

    .PARAMETER Folder
    Optional description to set a different folder on the new Semaphore object. If you do not set this, the new Semaphore object will use the same Folder of the source object.

    .PARAMETER UnsetTags
    Optional switch that will ensure that the newly created Semaphore will not have any Tags set.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the new Semaphore object. If you do not set this, the new Semaphore object will apply the same Tags of the source object.

    .PARAMETER Force
    Force the copy without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    ONLY [ANOWSemaphore] object is accepted. Pipeline support is intentionally unavailable.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Creates a copy of an Semaphore and changes the description (multi-line format)
    $Semaphore01 = Get-AutomateNOWSemaphore -Id 'Semaphore_01'
    Copy-AutomateNOWSemaphore -Semaphore $Semaphore01 -NewId 'Semaphore_01_production' -Description 'Semaphore 01 Production'

    .EXAMPLE
    Creates a copy of an Semaphore that omits the description (one-liner format)
    Copy-AutomateNOWSemaphore -Semaphore (Get-AutomateNOWSemaphore -Id 'Semaphore_01') -NewId 'Semaphore_01_production' -UnsetDescription -Tags 'Tag1', 'Tag2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWSemaphore]$Semaphore,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot set the Tags and unset them at the same time. Please choose one or the other. Tags from the source object will be carried over to the new object if you do not specify any tag-related parameters."
            Break
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$Semaphore_exists = ($null -ne (Get-AutomateNOWSemaphore -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWSemaphore failed to check if the Semaphore [$NewId] already existed due to [$Message]."
            Break
        }
        If ($Semaphore_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Semaphore named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End warning ##
        [string]$command = '/resource/copy'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            [string]$Semaphore_oldId = $Semaphore.id
            [string]$Semaphore_simpleId = $Semaphore.simpleId
            If ($Semaphore_oldId -eq $NewId) {
                Write-Warning -Message "The new id cannot be the same as the old id."
                Break
            }
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Copy the Semaphore $($Semaphore_simpleId) to $($NewId)?")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                If ($UnsetFolder -eq $True) {
                    $BodyMetaData.'folder' = $Null
                }
                ElseIf ($Folder.Length -gt 0) {
                    $BodyMetaData.'folder' = $Folder
                }
                Else {
                    If ($Semaphore.folder.Length -gt 0) {
                        $BodyMetaData.'folder' = $Semaphore.folder
                    }
                }
                If ($Tags.Count -gt 0) {
                    [int32]$tag_count = 1
                    ForEach ($tag in $Tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
                ElseIf ($UnsetTags -eq $true) {
                    $BodyMetaData.'tags' = $Null
                }
                Else {
                    If ($Semaphore.Tags -gt 0) {
                        [int32]$tag_count = 1
                        ForEach ($tag in $Semaphore.tags) {
                            $BodyMetaData.('tags' + $tag_count ) = $tag
                            $tag_count++
                        }
                    }
                }
                $BodyMetaData.'oldId' = $Semaphore_oldId
                $BodyMetaData.'domain' = $Semaphore.domain
                $BodyMetaData.'id' = $NewId
                If ($UnsetDescription -ne $true) {
                    If ($Description.Length -gt 0) {
                        $BodyMetaData.'description' = $Description
                    }
                    Else {
                        $BodyMetaData.'description' = $Semaphore.description
                    }
                }
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_operationId' = 'copy'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_dataSource' = 'ResourceDataSource'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties oldId, domain, NewId, description, folder, tags
                $parameters.Body = $Body
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Semaphore_oldId] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                $Error.Clear()
                Try {
                    [ANOWSemaphore]$NewSemaphore = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to create copied [ANOWSemaphore] object [$NewId] due to [$Message]."
                    Break
                }
                If ($NewSemaphore.id.Length -eq 0) {
                    Write-Warning -Message "Somehow the newly created (copied) [ANOWSemaphore] object [$NewId] is empty!"
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $NewSemaphore
                }
            }
        }
    }
    End {

    }
}

Function Rename-AutomateNOWSemaphore {
    <#
    .SYNOPSIS
    Renames a Semaphore on an AutomateNOW! instance

    .DESCRIPTION
    Performs a psuedo-rename operations of a Semaphore from an AutomateNOW! instance by copying it first and then deleting the source. This function merely combines Copy-AutomateNOWSemaphore and Remove-AutomateNOWSemaphore therefore it is to be considered destructive.

    .PARAMETER Semaphore
    An [ANOWSemaphore] object representing the Semaphore to be renamed.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the Semaphore. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER Force
    Force the renaming without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly renamed object.

    .INPUTS
    ONLY [ANOWSemaphore] objects are accepted. There is intentionally no support for the pipeline.

    .OUTPUTS
    The newly renamed [ANOWSemaphore] object will be returned.

    .EXAMPLE
    $Semaphore = Get-AutomateNOWSemaphore -Id 'Semaphore01'
    Rename-AutomateNOWSemaphore -Semaphore $Semaphore -NewId 'Semaphore_01'

    .EXAMPLE
    Rename-AutomateNOWSemaphore -Semaphore (Get-AutomateNOWSemaphore -Id 'Semaphore01') -NewId 'Semaphore_01'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    When renaming, you may only specify a different Id (name).

    This action will be bSemaphoreed if any existing referrals are found on the object.
    #>
    [OutputType([ANOWSemaphore])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWSemaphore]$Semaphore,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin standard warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$new_Semaphore_exists = ($null -ne (Get-AutomateNOWSemaphore -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWSemaphore failed to check if the Semaphore [$NewId] already existed due to [$Message]."
            Break
        }
        If ($new_Semaphore_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Semaphore named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        [string]$Semaphore_id = $Semaphore.simpleId
        $Error.Clear()
        Try {
            [boolean]$old_Semaphore_exists = ($null -ne (Get-AutomateNOWSemaphore -Id $Semaphore_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWSemaphore failed to check if the Semaphore [$Semaphore_id] already existed due to [$Message]."
            Break
        }
        If ($old_Semaphore_exists -eq $false) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not a Semaphore named [$Semaphore_id] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End standard warning ##
        ## Begin referrals warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [int32]$referrals_count = Find-AutomateNOWObjectReferral -Semaphore $Semaphore -Count | Select-Object -Expandproperty referrals
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Find-AutomateNOWObjectReferral failed to extract the referrals on Semaphore [$Semaphore_id] due to [$Message]."
            Break
        }
        If ($referrals_count -gt 0) {
            Write-Warning -Message "Unfortunately, you cannot rename a Semaphore that has referrals. This is because the rename is not actually renaming but copying anew and deleting the old. Please, use the Find-AutomateNOWObjectReferral function to identify referrals and remove them."
            Break
        }
        Else {
            Write-Verbose -Message "The Semaphore [$Semaphore_id] does not have any referrals. It is safe to proceed."
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Semaphore_id)")) -eq $true) {
                $Error.Clear()
                Try {
                    [ANOWSemaphore]$new_Semaphore = Copy-AutomateNOWSemaphore -Semaphore $Semaphore -NewId $NewId -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Copy-AutomateNOWSemaphore failed to create a new Semaphore [$NewId] as Part 1 of the renaming process due to [$Message]."
                    Break
                }
                If ($new_Semaphore.simpleId -eq $NewId) {
                    Write-Verbose -Message "Part 1: Semaphore [$Semaphore_id] successfully copied to [$NewId]"
                }
                Else {
                    Write-Warning -Message "Somehow the first phase (Copy-AutomateNOWSemaphore) failed. Please look into this."
                    Break
                }
                $Error.Clear()
                Try {
                    Remove-AutomateNOWSemaphore -Semaphore $Semaphore -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Remove-AutomateNOWSemaphore failed to remove [$Semaphore_id] as Part 2 of the renaming process due to [$Message]."
                    Break
                }
                Write-Verbose -Message "Part 2: Semaphore [$Semaphore_id] removed"
                Write-Verbose -Message "Task [$Semaphore_id] successfully renamed to [$NewId]"
                If ($Quiet -ne $true) {
                    Return $new_Semaphore
                }
            }
        }
        Else {
            Write-Warning -Message "No action was taken because either the source object didn't exist or the new object already existed"
        }
    }
    End {
    }
}

#endregion

#Region - Semaphore Timestamps

Function Get-AutomateNOWSemaphoreTimestamp {
    <#
    .SYNOPSIS
    Gets the Semaphore Timestamp objects from a Semaphore object in an AutomateNOW! instance

    .DESCRIPTION
    Gets the Semaphore Timestamp objects from a Semaphore object in an AutomateNOW! instance

    .PARAMETER Semaphore
    An [ANOWSemaphore] object representing the Semaphore to be queried for its Timestamps.

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100. The console default hard limit is 10,000.

    .PARAMETER sortBy
    Optional string parameter to sort the results by. The only known choice is timestamp so this parameter will most likely not have additional sorting options in the future.

    .PARAMETER Ascending
    Optional switch parameter to sort the results in ascending order (oldest to newest)

    .PARAMETER CurrentMonth
    Optional switch parameter to retrieve only the Semaphore Timestamp objects from the current month (according to the server Java timezone). Cannot be combined with -LastMonth or -NextMonth

    .PARAMETER LastMonth
    Optional switch parameter to retrieve only the Semaphore Timestamp objects from the previous month (according to the server Java timezone). Cannot be combined with -CurrentMonth or -NextMonth

    .PARAMETER NextMonth
    Optional switch parameter to retrieve only the Semaphore Timestamp objects from the next month (according to the server Java timezone). Cannot be combined with -LastMonth or -CurrentMonth

    .INPUTS
    Only [ANOWSemaphore] objects are accepted. Lack of pipeline capability is intentional.

    .OUTPUTS
    Either one or more [ANOWSemaphoreTimestamp] objects

    .EXAMPLE
    Gets all of the available Semaphore Timestamp objects from a specified Semaphore object

    $semaphore = Get-AutomateNOWSemaphore -id 'Semaphore1'
    Get-AutomateNOWSemaphoreTimeStamp -Semaphore $semaphore

    .EXAMPLE
    Gets the Semaphore Timestamp objects from a specified Semaphore object for the current month

    $semaphore = Get-AutomateNOWSemaphore -id 'Semaphore1'
    Get-AutomateNOWSemaphoreTimeStamp -Semaphore $semaphore -CurrentMonth

    .EXAMPLE
    Gets the Semaphore Timestamp objects from a specified Semaphore object for the following next month sorted in ascending order

    $semaphore = Get-AutomateNOWSemaphore -id 'Semaphore1'
    Get-AutomateNOWSemaphoreTimeStamp -Semaphore $semaphore -NextMonth -Ascending

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This is a case where objects are returned in descending order from the console by default. Thus this function has an -Ascending switch parameter instead of -Descending.

    #>
    [Cmdletbinding(DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $True, ParameterSetName = 'Default', ValueFromPipeline = $true)]
        [Parameter(Mandatory = $True, ParameterSetName = 'CurrentMonth', ValueFromPipeline = $true)]
        [Parameter(Mandatory = $True, ParameterSetName = 'NextMonth', ValueFromPipeline = $true)]
        [Parameter(Mandatory = $True, ParameterSetName = 'LastMonth', ValueFromPipeline = $true)]
        [ANOWSemaphore]$Semaphore,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'CurrentMonth')]
        [Parameter(Mandatory = $False, ParameterSetName = 'NextMonth')]
        [Parameter(Mandatory = $False, ParameterSetName = 'LastMonth')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'CurrentMonth')]
        [Parameter(Mandatory = $False, ParameterSetName = 'NextMonth')]
        [Parameter(Mandatory = $False, ParameterSetName = 'LastMonth')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'CurrentMonth')]
        [Parameter(Mandatory = $False, ParameterSetName = 'NextMonth')]
        [Parameter(Mandatory = $False, ParameterSetName = 'LastMonth')]
        [string]$sortBy = 'timestamp',
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'CurrentMonth')]
        [Parameter(Mandatory = $False, ParameterSetName = 'NextMonth')]
        [Parameter(Mandatory = $False, ParameterSetName = 'LastMonth')]
        [switch]$Ascending,
        [Parameter(Mandatory = $True, ParameterSetName = 'CurrentMonth')]
        [switch]$CurrentMonth,
        [Parameter(Mandatory = $True, ParameterSetName = 'NextMonth')]
        [switch]$NextMonth,
        [Parameter(Mandatory = $True, ParameterSetName = 'LastMonth')]
        [switch]$LastMonth
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        [string]$Method = 'GET'
        $parameters.Add('Method', $Method)
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0 ) {
            [ANOWSemaphore]$Semaphore = $_
        }
        [string]$Semaphore_Id = $Semaphore.Id
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($CurrentMonth -eq $true -or $NextMonth -eq $true -or $LastMonth -eq $true) {
            [string]$server_java_timezone = $anow_session.instance_info.licenseInfo.javaTimezone
            If ($server_java_timezone.Length -eq 0) {
                Write-Warning -Message "The server java timezone is not available in the global session variable. Please use Connect-AutomateNOW to establish your session."
                Break
            }
            $Error.Clear()
            Try {
                [ANOWTimeZone]$server_java_timezone_object = Get-AutomateNOWTimeZone -Id $server_java_timezone
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWTimeZone failed to create a timezone object under Get-AutomateNOWSemaphoreTimestamp due to [$Message]."
                Break
            }
            [int64]$rawOffset = $server_java_timezone_object.rawOffset
            If ($LastMonth -eq $true) {
                [string]$endOfSelectedMonth = Get-Date -Date ((Get-Date -Year (Get-Date -Date (Get-Date).ToUniversalTime()).Year -Month (Get-Date -Date (Get-Date).ToUniversalTime()).AddMonths(0).Month -Day 1 -Hour 0 -Minute 0 -Second 0 -Millisecond 0).AddMilliseconds(-1)).AddMilliseconds($rawOffset * -1) -Format 'yyyy-MM-ddTHH:mm:ss.fff'
                [string]$startOfSelectedMonth = Get-Date -Date ((Get-Date -Year (Get-Date -Date (Get-Date).ToUniversalTime()).Year -Month ((Get-Date -Date (Get-Date).ToUniversalTime()).Month - 1 ) -Day 1 -Hour 0 -Minute 0 -Second 0 -Millisecond 0)).AddMilliseconds($rawOffset * -1) -Format 'yyyy-MM-ddTHH:mm:ss.fff'
            }
            ElseIf ($CurrentMonth -eq $true) {
                [string]$endOfSelectedMonth = Get-Date -Date ((Get-Date -Year (Get-Date -Date (Get-Date).ToUniversalTime()).Year -Month (Get-Date -Date (Get-Date).ToUniversalTime()).AddMonths(1).Month -Day 1 -Hour 0 -Minute 0 -Second 0 -Millisecond 0).AddMilliseconds(-1)).AddMilliseconds($rawOffset * -1) -Format 'yyyy-MM-ddTHH:mm:ss.fff'
                [string]$startOfSelectedMonth = Get-Date -Date ((Get-Date -Year (Get-Date -Date (Get-Date).ToUniversalTime()).Year -Month ((Get-Date -Date (Get-Date).ToUniversalTime()).Month + 0 ) -Day 1 -Hour 0 -Minute 0 -Second 0 -Millisecond 0)).AddMilliseconds($rawOffset * -1) -Format 'yyyy-MM-ddTHH:mm:ss.fff'
            }
            Else {
                [string]$endOfSelectedMonth = Get-Date -Date ((Get-Date -Year (Get-Date -Date (Get-Date).ToUniversalTime()).Year -Month (Get-Date -Date (Get-Date).ToUniversalTime()).AddMonths(2).Month -Day 1 -Hour 0 -Minute 0 -Second 0 -Millisecond 0).AddMilliseconds(-1)).AddMilliseconds($rawOffset * -1) -Format 'yyyy-MM-ddTHH:mm:ss.fff'
                [string]$startOfSelectedMonth = Get-Date -Date ((Get-Date -Year (Get-Date -Date (Get-Date).ToUniversalTime()).Year -Month ((Get-Date -Date (Get-Date).ToUniversalTime()).Month + 1 ) -Day 1 -Hour 0 -Minute 0 -Second 0 -Millisecond 0)).AddMilliseconds($rawOffset * -1) -Format 'yyyy-MM-ddTHH:mm:ss.fff'
            }
            [string]$lessOrEqual = $endOfSelectedMonth
            [string]$greaterOrEqual = $startOfSelectedMonth
            Write-Verbose -Message "Calculating monthly timestamps: End of current month = $endOfCurrentMonth, Start of current month = $startOfCurrentMonth"
            $Body.'_constructor' = 'AdvancedCriteria'
            $Body.'operator' = 'and'
            $Body.'criteria1' = ('{"fieldName":"resource","operator":"equals","value":"' + $Semaphore_Id + '"}')
            $Body.'criteria2' = ('{"fieldName":"timestamp","operator":"lessOrEqual","value":"' + $lessOrEqual + '"}')
            $Body.'criteria3' = ('{"fieldName":"timestamp","operator":"greaterOrEqual","value":"' + $greaterOrEqual + '"}')
            [string]$componentId = 'ResourceMonthlyCalendar'
        }
        Else {
            $Body.'resource' = $Semaphore_Id
            [string]$componentId = 'ResourceTimestampStateList'
        }
        $Body.'_componentId' = $componentId
        $Body.'_startRow' = $startRow
        $Body.'_endRow' = $endRow
        If ($Ascending -eq $true) {
            $Body.'_sortBy' = $sortBy
        }
        Else {
            $Body.'_sortBy' = '-' + $sortBy
        }
        $Body.'_operationType' = 'fetch'
        $Body.'_textMatchStyle' = 'exact'
        $Body.'_dataSource' = 'ResourceTimestampStateDataSource'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/resourceTimestampState/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWSemaphoreTimestamp[]]$SemaphoreTimestamps = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWSemaphore failed to parse the results into [ANOWSemaphore] objects due to [$Message]."
            Break
        }
        If ($SemaphoreTimestamps.Count -eq 0) {
            Write-Warning -Message "Semaphore $Semaphore_Id has no Timestamps available to return (it's a blank slate)"
        }
        Else {
            Return $SemaphoreTimestamps
        }
    }
    End {

    }
}

Function Set-AutomateNOWSemaphoreTimestamp {
    <#
    .SYNOPSIS
    Sets a Semaphore timestate (On/Off state) for a *specific day*.

    .DESCRIPTION
    Sets a Semaphore timestate (On/Off state) for a *specific day*.

    .PARAMETER Semaphore
    An [ANOWSemaphore] object representing the Semaphore to be modified.

    .PARAMETER Date
    A string in ISO-8601 specifying the year, month and day to set the state of the Semaphore for (example: 2029-12-31). This is a simple 10 character date string without hours, minutes seconds. This function will make the neccessary adjustment to the timestamp based on the server Java timezone.

    .PARAMETER setStateOn
    Switch parameter to set the Semaphore to GO (green light) status for the date specified in the -Date parameter. Cannot be combined with -setStateOn.

    .PARAMETER setStateOff
    Switch parameter to set the Semaphore to STOP (red light) status for the date specified in the -Date parameter. Cannot be combined with -setStateOff.

    .PARAMETER Quiet
    Switch parameter that silences the output of the updated object.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWSemaphore] objects are accepted along with one (or more across the pipeline) -date strings.

    .OUTPUTS
    The updated [ANOWResourceTimestamp] object will be returned

    .EXAMPLE
    Sets a single day of a Semaphore object to Off

    $semaphore = Get-AutomateNOWSemaphore -Id 'Semaphore1'
    Set-AutomateNOWSemaphoreTimetamp -Semaphore $semaphore -setOff -Date '2029-06-02'

    .EXAMPLE
    Forcibly sets a series of dates to ON for a semaphore object using the pipeline

    $semaphore = Get-AutomateNOWSemaphore -Id 'Semaphore1'
    @('2029-06-01', '2029-06-02', '2029-06-03') | Set-AutomateNOWSemaphoreTimetamp -Semaphore $semaphore -setOn -Force

    .EXAMPLE
    Calculates and forcibly sets every day (individually) of the following month to ON (green light) in a Semaphore object.
    $semaphore = Get-AutomateNOWSemaphore -Id 'Semaphore1'
    $(For($i=1; $i -le ([datetime]::DaysInMonth(((Get-Date).ToUniversalTime()).AddMonths(1).Year, ((Get-Date).ToUniversalTime()).AddMonths(1).Month)); $i++) { [string](Get-Date).ToUniversalTime().AddMonths(1).Year  + "-" + [string]((Get-Date).ToUniversalTime().AddMonths(1).Month).ToString("00") + "-" + ($i.ToString("00")) }) | Set-AutomateNOWVariableTimestamp -Semaphore $semaphore -setOn -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Use Set-AutomateNOWSemaphore if you wish to change the entire ON/OFF state of the Semaphore. This function is only for setting the individual dates within a Semaphore object.

    The -setStateOn and -setStateOff parameters are isolated into their own parameter sets. Please try `Set-AutomateNOWSemaphoreTimetamp -?` for more information.

    #>
    [OutputType([ANOWResourceTimestampState])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'setOn', ValueFromPipeline = $True)]
        [Parameter(Mandatory = $true, ParameterSetName = 'setOff', ValueFromPipeline = $True)]
        [string]$date,
        [Parameter(Mandatory = $true, ParameterSetName = 'setOn')]
        [Parameter(Mandatory = $true, ParameterSetName = 'setOff')]
        [ANOWSemaphore]$Semaphore,
        [Parameter(Mandatory = $true, ParameterSetName = 'setOn')]
        [switch]$setOn,
        [Parameter(Mandatory = $true, ParameterSetName = 'setOff')]
        [switch]$setOff,
        [Parameter(Mandatory = $false, ParameterSetName = 'setOn')]
        [Parameter(Mandatory = $false, ParameterSetName = 'setOff')]
        [switch]$Quiet,
        [Parameter(Mandatory = $false, ParameterSetName = 'setOn')]
        [Parameter(Mandatory = $false, ParameterSetName = 'setOff')]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        [string]$command = "/resourceTimestampState/setState"
        [string]$method = 'POST'
        $parameters.Add('Method', $method)
        $parameters.Add('Command', $command)
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.Length -gt 0) {
            [string]$date = $_
        }
        [string]$Semaphore_id = $Semaphore.id
        [string]$Semaphore_simpleId = $Semaphore.simpleId
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Semaphore_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$Semaphore_exists = ($null -eq (Get-AutomateNOWSemaphore -Id $Semaphore_simpleId))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWSemaphore failed to check if the Semaphore [$Semaphore_simpleId] already existed due to [$Message]."
                Break
            }
            If ($Semaphore_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not an Semaphore named [$Semaphore_simpleId] in the [$current_domain] domain. Please check into this."
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'resource' = $Semaphore_id
            $BodyMetaData.'resourceType' = 'BINARY_SEMAPHORE'
            If ($setOn -eq $true ) {
                [string]$value = 'ON'
            }
            ElseIf ($setOff -eq $true ) {
                [string]$value = 'OFF'
            }
            Else {
                Write-Warning -Message "Somehow could not determine the on/off state in the request under Set-AutomateNOWSemaphoreTimetamp. Please look into this."
                Break
            }
            $BodyMetaData.'value' = $value
            $Error.Clear()
            Try {
                [string]$timestamp = New-AutomateNOWServerDayTimestamp -date $date
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "New-AutomateNOWServerDayTimestamp failed to convert [$date] due to [$Message]."
                Break
            }
            [string]$regex_daytimestamp_z = '^[2][0-9]{3}-(01|02|03|04|05|06|07|08|09|10|11|12)-(01|02|03|04|05|06|07|08|09|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31)T(00|01|02|03|04|05|06|07|08|09|10|11|12|13|14|15|16|17|18|19|20|21|22|23):[0-2]{1}[0-9]{1}.[0-6]{1}[0-9]{1}.[0-9]{3}$'
            # example timestamp for a server located in a +4 timezone: 2029-05-07T20:00:00.000 with a date string of 2030-05-08
            If ($timestamp -notmatch $regex_daytimestamp_z ) {
                Write-Warning -Message "Somehow the returned day timestamp [$timestamp] is invalid"
            }
            $BodyMetaData.'timestamp' = $timestamp
            $BodyMetaData.'_operationId' = 'setValue'
            $BodyMetaData.'_operationType' = 'custom'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_dataSource' = 'ResourceTimestampStateDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Semaphore_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            $Error.Clear()
            Try {
                [ANOWResourceTimestampState]$SemaphoreTimestamp = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to convert the response to a valid [ANOWSemaphoreTimestamp] object due to [$Message]."
                Break
            }
            Write-Verbose -Message "Semaphore object [$Semaphore_id] was successfully updated with a new timestamp"
            If ($Quiet -ne $true) {
                Return $SemaphoreTimestamp
            }
        }
    }
    End {
    }
}

Function Export-AutomateNOWSemaphoreTimestamp {
    <#
    .SYNOPSIS
    Exports the SemaphoreTimestamp objects from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the SemaphoreTimestamp objects from an instance of AutomateNOW! to a local .csv file

    .PARAMETER SemaphoreTimestamp
    Mandatory [ANOWSemaphoreTimestamp] object (Use Get-AutomateNOWSemaphoreTimestamp to retrieve them)

    .INPUTS
    ONLY [ANOWSemaphoreTimestamp] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWSemaphoreTimestamp] objects are exported to the local disk in CSV format

    .EXAMPLE
    Exports all of the SemaphoreTimestamp objects (up to 100 by default)

    Get-AutomateNOWSemaphoreTimestamp | Export-AutomateNOWSemaphoreTimestamp

    .EXAMPLE
    Exports 1 SemaphoreTimestamp by name

    Get-AutomateNOWSemaphoreTimestamp -Id 'SemaphoreTimestamp01' | Export-AutomateNOWSemaphoreTimestamp

    .EXAMPLE
    Exports a series of SemaphoreTimestamp objects by the pipeline

    @( 'SemaphoreTimestamp01', 'SemaphoreTimestamp02' ) | Get-AutomateNOWSemaphoreTimestamp | Export-AutomateNOWSemaphoreTimestamp

    .NOTES
	You must present [ANOWSemaphoreTimestamp] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWSemaphoreTimestamp]$SemaphoreTimestamp
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-SemaphoreTimestamps-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWSemaphoreTimestamp]$SemaphoreTimestamp = $_
        }
        $Error.Clear()
        Try {
            $SemaphoreTimestamp | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWSemaphoreTimestamp] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

#endregion

#Region - Server Nodes

Function Get-AutomateNOWServerNode {
    <#
    .SYNOPSIS
    Gets the nodes from an AutomateNOW! instance

    .DESCRIPTION
    Gets the nodes from an AutomateNOW! instance

    .PARAMETER Id
    Optional string containing the simple id of the node to fetch or you can pipeline a series of simple id strings. You may not enter an array here.

    .PARAMETER ChildNodes
    Optional string that must be combined with -Id to list out the child nodes of the specified Id.

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100. The console default hard limit is 10,000.

    .PARAMETER serverNodeType
    Optional string that to filter the results based on the type of server node. Cannot be combined with -Id or -ChildNodes.

    .PARAMETER AllLoadBalancers
    Optional switch that will return all nodes with the load balancer role. Cannot be combined with -Id or -ChildNodes.

    .PARAMETER AllChildNodes
    Optional switch that will return all nodes with the child node role. Cannot be combined with -Id or -ChildNodes.

    .PARAMETER Folder
    Optional string to filter by a particular Folder

    .PARAMETER Tags
    Optional string array of Tags to filter by. Note that the 'containsAny' operator will be used.

    .INPUTS
    Accepts a string representing the simple id of the node from the pipeline or individually (but not an array).

    .OUTPUTS
    An array of one or more [ANOWServerNode] class objects

    .EXAMPLE
    Gets the first page of Nodes
    Get-AutomateNOWServerNode

    .EXAMPLE
    Gets a single node named 'Node1'

    Get-AutomateNOWServerNode -Id 'Node1'

    .EXAMPLE
    Gets a series of Nodes through the pipelin

    'Node1', 'Node2' | Get-AutomateNOWServerNode

    .EXAMPLE
    Gets the first page of Nodes which have the Load Balancer role

    Get-AutomateNOW -AllLoadBalancers

    .EXAMPLE
    Gets the first page of Nodes which have the Child Node role

    Get-AutomateNOW -AllChildNodes

    .EXAMPLE
    Gets all of the child nodes of a Node Load Balancer named 'LoadBalancer1'

    Get-AutomateNOW -Id 'LoadBalancer1' -ChildNodes

    .EXAMPLE
    Gets the first 5 Nodes of type TERADATA

    Get-AutomateNOW -serverNodeType TERADATA -startRow 0 -endRow 5

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The -ChildNodes parameter must be combined with -Id.

    #>
    [OutputType([ANOWServerNode[]])]
    [Cmdletbinding(DefaultParameterSetName = 'All')]
    Param(
        [Parameter(Mandatory = $True, ParameterSetName = 'Single', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'Single')]
        [switch]$ChildNodes,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [ANOWServerNode_serverNodeType]$serverNodeType,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [switch]$AllLoadBalancers,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [switch]$AllChildNodes,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [string]$Folder,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [string[]]$Tags
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
        If ($AllLoadBalancers -eq $true -and $AllChildNodes -eq $true) {
            Write-Warning -Message "You can't request only load balancer and then only load balancer nodes in the same request. Please choose one or the other."
            Break
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If (($_.Length -gt 0 -or $Id.Length -gt 0) ) {
            If ($_.Length -gt 0) {
                $Body.'id' = $_
            }
            Else {
                $Body.'id' = $Id
            }
            If ($ChildNodes -eq $true) {
                $Body.'operator' = 'and'
                $Body.'_constructor' = 'AdvancedCriteria'
                $Body.'criteria1' = '{"fieldName":"parentLoadBalancer","operator":"equals","value":"' + $Id + '"}'
                $Body.'_componentId' = 'LoadBalancerNodeList'
                [string]$textMatchStyle = 'substring'
            }
            Else {
                [string]$textMatchStyle = 'exactCase'
                $Body.'_operationId' = 'read'
            }
        }
        Else {
            $Body.'operator' = 'and'
            $Body.'_constructor' = 'AdvancedCriteria'
            $Body.'_operationId' = 'ServerNodeDataSource_fetch'
            $Body.'_componentId' = 'ServerNodeList'
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
            [string]$textMatchStyle = 'substring'
            If ($AllLoadBalancers -eq $true) {
                $Body.'criteria1' = '{"fieldName":"loadBalancer","operator":"equals","value":true}'
                $Body.'criteria2' = '{"fieldName":"parentLoadBalancer","value":null,"operator":"equals"}'
            }
            ElseIf ($AllChildNodes -eq $true) {
                $Body.'criteria1' = '{"fieldName":"loadBalancer","operator":"equals","value":false}'
                $Body.'criteria2' = '{"fieldName":"parentLoadBalancer","value":null,"operator":"iNotEqual"}'
            }
            If ($serverNodeType.Length -gt 0) {
                $Body.'criteria3' = '{"fieldName":"serverNodeType","operator":"equals","value":"' + $serverNodeType + '"}'
            }
            If ($Folder.Length -gt 0) {
                $Body.'criteria4' = ('{"fieldName":"folder","operator":"equals","value":"' + $Folder + '"}')
            }
            If ($Tags.Count -gt 0) {
                If ($Tags.Count -gt 1) {
                    $Error.Clear()
                    Try {
                        [string]$TagString = $Tags | ConvertTo-Json -Compress
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "ConvertTo-Json failed to convert the provided tag names under Get-AutomateNOWServerNode due to [$Message]."
                        Break
                    }
                }
                Else {
                    [string]$TagString = $Tags
                }
                $Body.'criteria5' = ('{"fieldName":"tags","operator":"containsAny","value":' + $TagString + '}')
            }
        }
        $Body.'_operationType' = 'fetch'
        $Body.'_textMatchStyle' = $textMatchStyle
        $Body.'_dataSource' = 'ServerNodeDataSource'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/serverNode/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWServerNode[]]$ServerNodes = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWServerNode] objects due to [$Message]."
            Break
        }
        If ($ServerNodes.Count -gt 0) {
            Return $ServerNodes
        }
    }
    End {

    }
}

Function Set-AutomateNOWServerNode {
    <#
    .SYNOPSIS
    Changes the settings of a Server Node on an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of a Server Node on an AutomateNOW! instance

    .PARAMETER ServerNode
    An [ANOWServerNode] object representing the Server Node to be changed.

    .PARAMETER Description
    A text description between 1 and 255 characters. UTF-8 characters are allowed.

    .PARAMETER UnsetDescription
    Switch parameter that will remove the description.

    .PARAMETER Folder
    String that specifies the name of the folder to place the Server Node into.

    .PARAMETER UnsetFolder
    Switch parameter that will remove the Server Node from its current folder.

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new Server Node.

    .PARAMETER UnsetTags
    Switch parameter that will remove the tags from the Server Node.

    .PARAMETER CodeRepository
    Optional Code Repository to place the Semaphore into. Use Get-AutomateNOWCodeRepository to fetch this object.

    .PARAMETER UnsetCodeRepository
    Switch parameter that will remove the the Semaphore from its Code Repository.

    .PARAMETER Quiet
    Suppresses the return of the updated object.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWServerNode] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWServerNode] object will be returned

    .EXAMPLE
    Sets the folder, tags and code repository on a server node named 'ServerNode1' (one-liner)

    Get-AutomateNOWServerNode -Id 'ServerNode1' | Set-AutomateNOWServerNode -Folder 'Folder1' -Tags 'Tag1', 'Tag2' -CodeRepository (Get-AutomateNOWCodeRepository -Id 'CodeRepository1')

    .EXAMPLE
    Forcibly unsets (removes) the folder, tags and code repository on a server node named 'ServerNode1' (one-liner)

    Get-AutomateNOWServerNode -Id 'ServerNode1' | Set-AutomateNOWServerNode -UnsetFolder -UnsetTags -UnsetCodeRepository -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWServerNode])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWServerNode]$ServerNode,
        [ValidateScript({ $_.Length -le 255 })]
        [Parameter(Mandatory = $false, HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetCodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot unset the Description and set it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot unset the Folder and set it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot unset the Tags and set them at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetCodeRepository -eq $true -and $CodeRepository.Id.Length -gt 0) {
            Write-Warning -Message "You cannot unset the Code Repository and set it at the same time. Please choose one or the other."
            Break
        }
        [string]$command = '/serverNode/update'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWServerNode]$ServerNode = $_
        }
        [string]$ServerNode_id = $ServerNode.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$ServerNode_id")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$ServerNode_exists = ($null -eq (Get-AutomateNOWServerNode -Id $ServerNode_id))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWServerNode failed to check if the Server Node [$ServerNode_id] already existed due to [$Message]."
                Break
            }
            If ($ServerNode_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not a Server Node named [$ServerNode_id] in the current domain [$current_domain]. Please check into this."
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $ServerNode_id
            If ($Description.Length -gt 0) {
                $BodyMetaData.'description' = $Description
            }
            ElseIf ($UnsetDescription -eq $true) {
                $BodyMetaData.'description' = $null
            }
            If ($Tags.Count -gt 0) {
                [int32]$total_tags = $Tags.Count
                [int32]$current_tag = 1
                ForEach ($tag_id in $Tags) {
                    $Error.Clear()
                    Try {
                        [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] under Set-AutomateNOWServerNode due to [$message]"
                        Break
                    }
                    If ($tag_object.simpleId.length -eq 0) {
                        Throw "Set-AutomateNOWServerNode has detected that the tag [$tag_id] does not appear to exist. Please check again."
                        Break
                    }
                    ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                        [string]$tag_object_simpleId = $tag_object.simpleId
                        Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                        Break
                    }
                    [string]$tag_display = $tag_object | ConvertTo-Json -Compress
                    Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
                    [string]$tag_name_sequence = ('tags' + $current_tag)
                    $BodyMetaData.$tag_name_sequence = $tag_id
                    $current_tag++
                }
            }
            ElseIf ($UnsetTags -eq $true) {
                $BodyMetaData.'tags' = $null
            }
            If ($Folder.Length -gt 0) {
                $Error.Clear()
                Try {
                    [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] actually existed under Set-AutomateNOWServerNode due to [$Message]"
                    Break
                }
                If ($folder_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] under Set-AutomateNOWServerNode. Please check again."
                    Break
                }
                [string]$folder_display = $folder_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Adding folder $folder_display to [ANOWServerNode] [$Id]"
                $BodyMetaData.'folder' = $Folder
            }
            ElseIf ($UnsetFolder -eq $true) {
                $BodyMetaData.'folder' = $null
            }
            If ($CodeRepository.Id.Length -gt 0) {
                [string]$CodeRepository_Id = $CodeRepository.Id
                $Error.Clear()
                Try {
                    [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository_Id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository_Id] actually existed under Set-AutomateNOWServerNode due to [$Message]"
                    Break
                }
                If ($code_repository_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository_Id] under Set-AutomateNOWServerNode. Please check again."
                    Break
                }
                $BodyMetaData.'codeRepository' = $CodeRepository_Id
            }
            ElseIf ($UnsetCodeRepository -eq $true) {
                $BodyMetaData.'codeRepository' = $null
            }
            $BodyMetaData.'_operationType' = 'update'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_dataSource' = 'ServerNodeDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ServerNode_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Server Node $ServerNode_id was successfully updated"
            $Error.Clear()
            Try {
                [ANOWServerNode]$UpdatedServerNode = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the returned updated object to an [ANOWServerNode] object due to [$Message]. The object was still updated though."
                Break
            }
            If ($Quiet -ne $true) {
                Return $UpdatedServerNode
            }
        }
    }
    End {
    }
}

Function Export-AutomateNOWServerNode {
    <#
    .SYNOPSIS
    Exports the nodes from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the nodes from an instance of AutomateNOW! to a local .csv file

    .PARAMETER ServerNode
    Mandatory [ANOWServerNode] object (Use Get-AutomateNOWServerNode to retrieve them)

    .INPUTS
    ONLY [ANOWServerNode] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWServerNode] objects are exported to the local disk in CSV format

    .EXAMPLE
    Get-AutomateNOWServerNode | Export-AutomateNOWServerNode

    .EXAMPLE
    Get-AutomateNOWServerNode -Id 'ServerNode01' | Export-AutomateNOWServerNode

    .EXAMPLE
    'ServerNode01', 'ServerNode02' | Get-AutomateNOWServerNode | Export-AutomateNOWServerNode

    .EXAMPLE
    Get-AutomateNOWServerNode | Where-Object { $_.serverNodeType -eq 'LINUX' } | Export-AutomateNOWServerNode

    .NOTES
	You must present [ANOWServerNode] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWServerNode]$ServerNode
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-Nodes-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWServerNode]$ServerNode = $_
        }
        $Error.Clear()
        Try {
            $ServerNode | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWServerNode] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function New-AutomateNOWServerNode {
    <#
    .SYNOPSIS
    Creates a node within an AutomateNOW! instance

    .DESCRIPTION
    Creates a node within an AutomateNOW! instance and returns back the newly created [ANOWServerNode] object

    .PARAMETER Id
    The intended name of the node. For example: 'LinuxServerNode1'. This value may not contain the domain in brackets.

    .PARAMETER Type
    Required type of the node.

    .PARAMETER Description
    Optional description of the node (may not exceed 255 characters).

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new Node. Do not pass [ANOWTag] objects here.

    .PARAMETER Folder
    Optional name of the folder to place the node into.

    .PARAMETER CodeRepository
    Optional name of the code repository to place the node into.

    .PARAMETER WeightCapacity
    Optional integer to specify the total weight capacity of the node. Defaults to 50.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWServerNode.

    .OUTPUTS
    An [ANOWServerNode] object representing the newly created node

    .EXAMPLE
    Creats a new REST WEB node named 'NameOfNOde' that is assigned a tag 'Tag1' and placed into a folder 'Folder1'

    New-AutomateNOWServerNode -Id 'NameOfNode' -Type REST_WEB_SERVICE -Tags 'Tag1' -Folder 'Folder1'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The name (id) of the node must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    #>
    [OutputType([ANOWServerNode])]
    [Cmdletbinding()]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $true)]
        [string]$Id,
        [Parameter(Mandatory = $true)]
        [ANOWServerNode_serverNodeType]$Type,
        [Parameter(Mandatory = $false)]
        [int32]$WeightCapacity = 50,
        [Parameter(Mandatory = $false, HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [string]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [boolean]$ServerNode_exists = ($null -ne (Get-AutomateNOWServerNode -Id $Id))
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWServerNode failed to check if the node [$Id] already existed due to [$Message]."
        Break
    }
    If ($ServerNode_exists -eq $true) {
        [string]$current_domain = $anow_session.header.domain
        Write-Warning -Message "There is already a Node named [$Id] in [$current_domain]. Please check into this."
        Break
    }
    ## End warning ##
    [System.Collections.Specialized.OrderedDictionary]$ANOWServerNode = [System.Collections.Specialized.OrderedDictionary]@{}
    $ANOWServerNode.Add('id', $Id)
    $ANOWServerNode.Add('serverNodeType', $Type)
    $ANOWServerNode.Add('loadBalancer', $False)
    $ANOWServerNode.Add('totalWeightCapacity', $WeightCapacity)
    If ($Description.Length -gt 0) {
        $ANOWServerNode.Add('description', $Description)
    }
    If ($Tags.Count -gt 0) {
        [int32]$total_tags = $Tags.Count
        [int32]$current_tag = 1
        ForEach ($tag_id in $Tags) {
            $Error.Clear()
            Try {
                [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] running under New-AutomateNOWServerNode due to [$message]"
                Break
            }
            If ($tag_object.simpleId.length -eq 0) {
                Throw "New-AutomateNOWServerNode has detected that the tag [$tag_id] does not appear to exist. Please check again."
                Break
            }
            ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                [string]$tag_object_simpleId = $tag_object.simpleId
                Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                Break
            }
            [string]$tag_display = $tag_object | ConvertTo-Json -Compress
            Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
            [string]$tag_name_sequence = ('tags' + $current_tag)
            $ANOWServerNode.Add($tag_name_sequence, $tag_id)
            $include_properties += $tag_name_sequence
            $current_tag++
        }
    }
    If ($Folder.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] existed under New-AutomateNOWServerNode due to [$Message]"
            Break
        }
        If ($folder_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] under New-AutomateNOWServerNode. Please check again."
            Break
        }
        [string]$folder_display = $folder_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding folder $folder_display to [ANOWServerNode] [$Id]"
        $ANOWServerNode.Add('folder', $Folder)
        $include_properties += 'folder'
    }
    If ($CodeRepository.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository] existed under New-AutomateNOWServerNode due to [$Message]"
            Break
        }
        If ($code_repository_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository] under New-AutomateNOWServerNode. Please check again."
            Break
        }
        [string]$code_repository_display = $code_repository_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding code repository $code_repository_display to [ANOWServerNode] [$Id]"
        $ANOWServerNode.Add('codeRepository', $CodeRepository)
        $include_properties += 'codeRepository'
    }
    [string]$BodyObject = ConvertTo-QueryString -InputObject $ANOWServerNode -IncludeProperties id, serverNodeType, loadBalancer, totalWeightCapacity, description, tags, folder, codeRepository
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_operationType' = 'add'
    $BodyMetaData.'_oldValues' = ('{"serverNodeType":"' + $Type + '","loadBalancer":' + $LoadBalancer + ',"totalWeightCapacity":' + $WeightCapacity + '}')
    $BodyMetaData.'_componentId' = 'ServerNodeCreateWindow_form'
    $BodyMetaData.'_dataSource' = 'ServerNodeDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$BodyMetaDataString = ConvertTo-QueryString -InputObject $BodyMetaData
    [string]$Body = ($BodyObject + '&' + $BodyMetaDataString)
    [string]$command = '/serverNode/create'
    [hashtable]$parameters = @{}
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('Body', $Body)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWServerNode]$ServerNode = $results.response.data | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to create [ANOWServerNode] object due to [$Message]."
        Break
    }
    If ($ServerNode.id.Length -eq 0) {
        Write-Warning -Message "Somehow the newly created [ANOWServerNode] node is empty!"
        Break
    }
    If ($Quiet -ne $true) {
        Return $ServerNode
    }
}

Function Copy-AutomateNOWServerNode {
    <#
    .SYNOPSIS
    Copies a Node from an AutomateNOW! instance

    .DESCRIPTION
    Copies a Node from an AutomateNOW! instance. AutomateNOW object id can never be changed, but we can copy the object to a new id and it will include all of the items therein.

    .PARAMETER ServerNode
    Mandatory [ANOWServerNode] object to be copied.

    .PARAMETER NewId
    The name (Id) of the new Node. The new Id must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    .PARAMETER UnsetDescription
    Optional switch that will ensure that the newly created Node will not have a description set.

    .PARAMETER Description
    Optional description to set on the new Node object. If you do not set this, the new Node object will copy the Description of the source object.

    .PARAMETER UnsetFolder
    Optional switch that will ensure that the newly created Node will not have a Folder set.

    .PARAMETER Folder
    Optional description to set a different folder on the new Node object. If you do not set this, the new Node object will use the same Folder of the source object.

    .PARAMETER UnsetTags
    Optional switch that will ensure that the newly created Node will not have any Tags set.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the new Node object. If you do not set this, the new Node object will apply the same Tags of the source object.

    .PARAMETER Force
    Force the copy without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    ONLY [ANOWServerNode] object is accepted. Pipeline support is intentionally unavailable.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Creates a copy of a Server Node named 'ServerNode1' to 'ServerNode1_prod' and modifies the description (multi-line format)
    $server_node = Get-AutomateNOWServerNode -Id 'ServerNode1'
    Copy-AutomateNOWServerNode -ServerNode $server_node -NewId 'ServerNode1_prod' -Description 'Server Node 1 (Production)'

    .EXAMPLE
    Creates a copy of a Server Node named 'ServerNode1' to 'ServerNode1_prod' and omits the description (one-liner format)
    Copy-AutomateNOWServerNode -ServerNode (Get-AutomateNOWServerNode -Id 'ServerNode1') -NewId 'ServerNode1_prod' -UnsetDescription -Tags 'Tag1', 'Tag2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWServerNode]$ServerNode,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot set the Tags and unset them at the same time. Please choose one or the other. Tags from the source object will be carried over to the new object if you do not specify any tag-related parameters."
            Break
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$ServerNode_exists = ($null -ne (Get-AutomateNOWServerNode -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWServerNode failed to check if the Node [$NewId] already existed due to [$Message]."
            Break
        }
        If ($ServerNode_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Node named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End warning ##
        [string]$command = '/serverNode/copy'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            [string]$ServerNode_oldId = $ServerNode.id
            [string]$ServerNode_simpleId = $ServerNode.simpleId
            If ($ServerNode_oldId -eq $NewId) {
                Write-Warning -Message "The new id cannot be the same as the old id."
                Break
            }
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Copy the Node $($ServerNode_simpleId) to $($NewId)?")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                If ($UnsetFolder -eq $True) {
                    $BodyMetaData.'folder' = $Null
                }
                ElseIf ($Folder.Length -gt 0) {
                    $BodyMetaData.'folder' = $Folder
                }
                Else {
                    If ($ServerNode.folder.Length -gt 0) {
                        $BodyMetaData.'folder' = $ServerNode.folder
                    }
                }
                If ($Tags.Count -gt 0) {
                    [int32]$tag_count = 1
                    ForEach ($tag in $Tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
                ElseIf ($UnsetTags -eq $true) {
                    $BodyMetaData.'tags' = $Null
                }
                Else {
                    If ($ServerNode.Tags -gt 0) {
                        [int32]$tag_count = 1
                        ForEach ($tag in $ServerNode.tags) {
                            $BodyMetaData.('tags' + $tag_count ) = $tag
                            $tag_count++
                        }
                    }
                }
                $BodyMetaData.'oldId' = $ServerNode_oldId
                $BodyMetaData.'domain' = $ServerNode.domain
                $BodyMetaData.'id' = $NewId
                If ($UnsetDescription -ne $true) {
                    If ($Description.Length -gt 0) {
                        $BodyMetaData.'description' = $Description
                    }
                    Else {
                        $BodyMetaData.'description' = $ServerNode.description
                    }
                }
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_operationId' = 'copy'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_dataSource' = 'ServerNodeDataSource'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties oldId, domain, NewId, description, folder, tags
                $parameters.Body = $Body
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ServerNode_oldId] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                $Error.Clear()
                Try {
                    [ANOWServerNode]$NewNode = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to create copied [ANOWServerNode] object [$NewId] due to [$Message]."
                    Break
                }
                If ($NewNode.id.Length -eq 0) {
                    Write-Warning -Message "Somehow the newly created (copied) [ANOWServerNode] object [$NewId] is empty!"
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $NewNode
                }
            }
        }
    }
    End {

    }
}

Function Remove-AutomateNOWServerNode {
    <#
    .SYNOPSIS
    Removes a node from an AutomateNOW! instance

    .DESCRIPTION
    The `Remove-AutomateNOWServerNode` function removes a node from an AutomateNOW! instance

    .PARAMETER ServerNode
    An [ANOWServerNode] object representing the node to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWServerNode] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Get-AutomateNOWServerNode -Id 'ServerNode01' | Remove-AutomateNOWServerNode

    .EXAMPLE
    Get-AutomateNOWServerNode -Id 'ServerNode01', 'ServerNode02' | Remove-AutomateNOWServerNode

    .EXAMPLE
    @( 'ServerNode1', 'ServerNode2', 'ServerNode3') | Remove-AutomateNOWServerNode

    .EXAMPLE
    Get-AutomateNOWServerNode | ? { $_.serverNodeType -eq 'LINUX' } | Remove-AutomateNOWServerNode

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWServerNode]$ServerNode,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/serverNode/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWServerNode]$ServerNode = $_
        }
        [string]$ServerNode_id = $ServerNode.id
        If ($ServerNode_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ServerNode_id)")) -eq $true) {
            [string]$oldvalues = $ServerNode.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $ServerNode_id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'ServerNodeList'
            $BodyMetaData.'_dataSource' = 'ServerNodeDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ServerNode_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Node $ServerNode_id successfully removed"
        }
    }
    End {

    }
}

Function Rename-AutomateNOWServerNode {
    <#
    .SYNOPSIS
    Renames a Node on an AutomateNOW! instance

    .DESCRIPTION
    Performs a psuedo-rename operations of a Node from an AutomateNOW! instance by copying it first and then deleting the source. This function merely combines Copy-AutomateNOWServerNode and Remove-AutomateNOWServerNode therefore it is to be considered destructive.

    .PARAMETER ServerNode
    An [ANOWServerNode] object representing the Node to be renamed.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the Node. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER Force
    Force the renaming without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly renamed object.

    .INPUTS
    ONLY [ANOWServerNode] objects are accepted. There is intentionally no support for the pipeline.

    .OUTPUTS
    The newly renamed [ANOWServerNode] object will be returned.

    .EXAMPLE
    $ServerNode = Get-AutomateNOWServerNode -Id 'ServerNode01'
    Rename-AutomateNOWServerNode -ServerNode $ServerNode -NewId 'ServerNode_02'

    .EXAMPLE
    Rename-AutomateNOWServerNode -ServerNode (Get-AutomateNOWServerNode -Id 'ServerNode01') -NewId 'ServerNode_02'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    When renaming, you may only specify a different Id (name).

    This action will be denied if any existing referrals are found on the object.
    #>
    [OutputType([ANOWServerNode])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWServerNode]$ServerNode,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin standard warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$new_Node_exists = ($null -ne (Get-AutomateNOWServerNode -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWServerNode failed to check if the Node [$NewId] already existed due to [$Message]."
            Break
        }
        If ($new_Node_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Node named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        [string]$ServerNode_id = $ServerNode.simpleId
        $Error.Clear()
        Try {
            [boolean]$old_Node_exists = ($null -ne (Get-AutomateNOWServerNode -Id $ServerNode_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWServerNode failed to check if the Node [$ServerNode_id] already existed due to [$Message]."
            Break
        }
        If ($old_Node_exists -eq $false) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not a Node named [$ServerNode_id] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End standard warning ##
        ## Begin referrals warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [int32]$referrals_count = Find-AutomateNOWObjectReferral -ServerNode $ServerNode -Count | Select-Object -Expandproperty referrals
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Find-AutomateNOWObjectReferral failed to extract the referrals on Node [$ServerNode_id] due to [$Message]."
            Break
        }
        If ($referrals_count -gt 0) {
            Write-Warning -Message "Unfortunately, you cannot rename a Node that has referrals. This is because the rename is not actually renaming but copying anew and deleting the old. Please, use the Find-AutomateNOWObjectReferral function to identify referrals and remove them."
            Break
        }
        Else {
            Write-Verbose -Message "The Node [$ServerNode_id] does not have any referrals. It is safe to proceed."
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ServerNode_id)")) -eq $true) {
                $Error.Clear()
                Try {
                    [ANOWServerNode]$new_Node = Copy-AutomateNOWServerNode -ServerNode $ServerNode -NewId $NewId -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Copy-AutomateNOWServerNode failed to create a new Node [$NewId] as Part 1 of the renaming process due to [$Message]."
                    Break
                }
                If ($new_Node.simpleId -eq $NewId) {
                    Write-Verbose -Message "Part 1: Node [$ServerNode_id] successfully copied to [$NewId]"
                }
                Else {
                    Write-Warning -Message "Somehow the first phase (Copy-AutomateNOWServerNode) failed. Please look into this."
                    Break
                }
                $Error.Clear()
                Try {
                    Remove-AutomateNOWServerNode -ServerNode $ServerNode -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Remove-AutomateNOWServerNode failed to remove [$ServerNode_id] as Part 2 of the renaming process due to [$Message]."
                    Break
                }
                Write-Verbose -Message "Part 2: Node [$ServerNode_id] removed"
                Write-Verbose -Message "Task [$ServerNode_id] successfully renamed to [$NewId]"
                If ($Quiet -ne $true) {
                    Return $new_Node
                }
            }
        }
        Else {
            Write-Warning -Message "No action was taken because either the source object didn't exist or the new object already existed"
        }
    }
    End {
    }
}

Function Start-AutomateNOWServerNode {
    <#
    .SYNOPSIS
    Starts a Node from an AutomateNOW! instance

    .DESCRIPTION
    Starts a Node from an AutomateNOW! instance

    .PARAMETER ServerNode
    An [ANOWServerNode] object representing the Node to be started.

    .PARAMETER Quiet
    Switch parameter to silence the returned [ANOWServerNode] object

    .INPUTS
    ONLY [ANOWServerNode] objects are accepted (including from the pipeline)

    .OUTPUTS
    An [ANOWServerNode] object representing the started node will be returned.

    .EXAMPLE
    Starts a single node

    Get-AutomateNOWServerNode -Id 'ServerNode_01' | Start-AutomateNOWServerNode

    .EXAMPLE
    Starts a single node quietly

    Get-AutomateNOWServerNode -Id 'ServerNode_01' | Start-AutomateNOWServerNode -Quiet

    .EXAMPLE
    Starts a series of nodes quietly through the pipeline

    @('ServerNode01', 'ServerNode02') | Start-AutomateNOWServerNode -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWServerNode]$ServerNode,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/serverNode/start'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [string]$ServerNode_id = $_.id
            [string]$ServerNode_simpleId = $_.simpleId
        }
        Else {
            [string]$ServerNode_id = $ServerNode.id
            [string]$ServerNode_simpleId = $ServerNode.simpleId
        }
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        $BodyMetaData.Add('id', $ServerNode_id )
        $BodyMetaData.Add('_operationType', 'custom')
        $BodyMetaData.Add('_operationId', 'start')
        $BodyMetaData.Add('_textMatchStyle', 'exact')
        $BodyMetaData.Add('_dataSource', 'ServerNodeDataSource')
        $BodyMetaData.Add('isc_metaDataPrefix', '_')
        $BodyMetaData.Add('isc_dataFormat', 'json')
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        If ($null -eq $parameters.Body) {
            $parameters.Add('Body', $Body)
        }
        Else {
            $parameters.Body = $Body
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ServerNode_id] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        Write-Verbose -Message "Task $ServerNode_id successfully started"
        $Error.Clear()
        Try {
            [ANOWServerNode]$ANOWServerNode = $results.response.data | Select-Object -First 1
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Unable to create the [ANOWServerNode] object under Start-AutomateNOWServerNode from the response due to [$Message]."
            Break
        }
        If ($Quiet -ne $true) {
            Return $ANOWServerNode
        }
    }
    End {

    }
}

Function Stop-AutomateNOWServerNode {
    <#
    .SYNOPSIS
    Stops a Node on an AutomateNOW! instance

    .DESCRIPTION
    Stops a Node on an AutomateNOW! instance

    .PARAMETER ServerNode
    An [ANOWServerNode] object representing the Node to be stopped.

    .PARAMETER Kill
    Switch parameter to kill tasks running on the server instead of waiting for them to complete

    .PARAMETER Abort
    Switch parameter to abort tasks running on the server instead of waiting for them to complete

    .PARAMETER Quiet
    Switch parameter to silence the returned [ANOWServerNode] object

    .PARAMETER Force
    Force the stop action without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWServerNode] objects are accepted (including from the pipeline)

    .OUTPUTS
    An [ANOWServerNode] object representing the stopped node will be returned.

    .EXAMPLE
    Stops a single node

    Get-AutomateNOWServerNode -Id 'ServerNode_01' | Stop-AutomateNOWServerNode

    .EXAMPLE
    Stops a single node quietly

    Get-AutomateNOWServerNode -Id 'ServerNode_01' | Stop-AutomateNOWServerNode -Quiet

    .EXAMPLE
    Stops a series of nodes quietly through the pipeline

    @('ServerNode01', 'ServerNode02') | Stop-AutomateNOWServerNode -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The default behavior of this function is the 'Stop' option 'Wait for executing tasks to complete'. Use -Kill or -Abort to use one or the other of the two stop options. (Stop executing tasks is not added yet)

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High', DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'Default', ValueFromPipeline = $True)]
        [Parameter(Mandatory = $true, ParameterSetName = 'Kill', ValueFromPipeline = $True)]
        [Parameter(Mandatory = $true, ParameterSetName = 'Abort', ValueFromPipeline = $True)]
        [ANOWServerNode]$ServerNode,
        [Parameter(Mandatory = $true, ParameterSetName = 'Kill')]
        [switch]$Kill,
        [Parameter(Mandatory = $true, ParameterSetName = 'Abort')]
        [switch]$Abort,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Kill')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Abort')]
        [switch]$Quiet,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Kill')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Abort')]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($Kill -eq $true) {
            [string]$operation_id = 'stopKill'
            [string]$stop_message = 'stopped and killed'
        }
        ElseIf ($Abort -eq $true) {
            [string]$operation_id = 'stopAbort'
            [string]$stop_message = 'stopped and aborted'
        }
        Else {
            [string]$operation_id = 'stop'
            [string]$stop_message = 'stopped'
        }
        [string]$command = ('/serverNode/' + $operation_id)
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWServerNode]$ServerNode = $_
        }
        [string]$ServerNode_id = $ServerNode.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ServerNode_id)")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $ServerNode_id )
            $BodyMetaData.Add('_operationType', 'custom')
            $BodyMetaData.Add('_operationId', $operation_id)
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ServerNodeDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ServerNode_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Task $ServerNode_id successfully $stop_message"
            $Error.Clear()
            Try {
                [ANOWServerNode]$ANOWServerNode = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Unable to create the [ANOWServerNode] object under Stop-AutomateNOWServerNode (performing $operation_id) from the response due to [$Message]."
                Break
            }
            If ($Quiet -ne $true) {
                Return $ANOWServerNode
            }
        }
    }
    End {

    }
}

Function Suspend-AutomateNOWServerNode {
    <#
    .SYNOPSIS
    Suspends (holds) all activities within a specific Node on an AutomateNOW! instance.

    .DESCRIPTION
    Suspends (holds) all activities within a specific Node on an AutomateNOW! instance, ensuring a temporary freeze on all automated processes and workflows until further action is taken.

    .PARAMETER ServerNode
    An [ANOWServerNode] object representing the Node to be suspended (placed on hold)

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWServerNode] objects are accepted (including from the pipeline)

    .OUTPUTS
    A verbose information message will be sent indicating success

    .EXAMPLE
    Get-AutomateNOWServerNode -Id 'MyCoolNode' | Suspend-AutomateNOWServerNode -Force

    .EXAMPLE
    @( 'ServerNode1', 'ServerNode2' ) | Get-AutomateNOWServerNode | Suspend-AutomateNOWServerNode

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This function is equivalent to the "Hold" button.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWServerNode]$ServerNode,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/serverNode/hold'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWServerNode]$ServerNode = $_
        }
        [string]$ServerNode_id = $ServerNode.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Suspend the Node $($ServerNode_id)?")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [ANOWServerNode]$current_Node = Get-AutomateNOWServerNode -Id $ServerNode_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWServerNode failed to check if the Node [$ServerNode_id] existed under Resume-AutomateNOWServerNode due to [$Message]."
                Break
            }
            If ($current_Node.id.length -eq 0) {
                Write-Warning -Message "The Node you specified does not seem to exist (Resume-AutomateNOWServerNode)"
                Break
            }
            [boolean]$current_Node_hold_status = $current_Node.onHold
            If ($current_Node_hold_status -eq $true) {
                Write-Warning -Message "[$ServerNode_id] cannot be suspended (placed on hold) as it is already suspended (on hold)"
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $ServerNode_id )
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_operationId', 'hold')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ServerNodeDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ServerNode_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Node $ServerNode_id was successfully suspended (placed on hold)"
        }
    }
    End {

    }
}

Function Resume-AutomateNOWServerNode {
    <#
    .SYNOPSIS
    Removes the temporary freeze placed on a specific Node on an AutomateNOW! instance and allows it to resume.

    .DESCRIPTION
    Removes the temporary freeze placed on a specific Node on an AutomateNOW! instance and allows it to resume.

    .PARAMETER ServerNode
    An [ANOWServerNode] object representing the Node to be resumed

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWServerNode] objects are accepted (including from the pipeline)

    .OUTPUTS
    A verbose information message will be sent indicating success

    .EXAMPLE
    Get-AutomateNOWServerNode -Id 'MyCoolNode' | Resume-AutomateNOWServerNode -Force

    .EXAMPLE
    @( 'ServerNode1', 'ServerNode2' ) | Get-AutomateNOWServerNode | Resume-AutomateNOWServerNode

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWServerNode]$ServerNode,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/serverNode/resume'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWServerNode]$ServerNode = $_
        }
        [string]$ServerNode_id = $ServerNode.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Resume the Node $($ServerNode_id)?")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [ANOWServerNode]$current_Node = Get-AutomateNOWServerNode -Id $ServerNode_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWServerNode failed to check if the Node [$ServerNode_id] existed under Resume-AutomateNOWServerNode due to [$Message]."
                Break
            }
            If ($current_Node.id.length -eq 0) {
                Write-Warning -Message "The Node you specified does not seem to exist (Resume-AutomateNOWServerNode)"
                Break
            }
            [boolean]$current_Node_hold_status = $current_Node.onHold
            If ($current_Node_hold_status -eq $false) {
                Write-Warning -Message "[$ServerNode_id] cannot be resumed because it is not currently suspended (on hold)"
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $ServerNode_id )
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_operationId', 'resume')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'NodeDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ServerNode_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Node $ServerNode_id was successfully resumed (removed from hold)"
        }
    }
    End {

    }
}

Function Skip-AutomateNOWServerNode {
    <#
    .SYNOPSIS
    Sets or unsets the Skip flag on a Node on an AutomateNOW! instance

    .DESCRIPTION
    Sets or unsets the Skip flag on a Node on an AutomateNOW! instance

    .PARAMETER ServerNode
    An [ANOWServerNode] object representing the Node to be set to skipped or unskipped

    .PARAMETER UnSkip
    Removes the skip flag from a [ANOWServerNode] object. This is the opposite of the default behavior.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Switch parameter to silence the emitted [ANOWServerNode] object

    .INPUTS
    ONLY [ANOWServerNode] objects are accepted (including from the pipeline)

    .OUTPUTS
    The skipped/unskipped [ANOWServerNode] object will be returned

    .EXAMPLE
    Sets a Node to Skip (bypass)

    Get-AutomateNOWServerNode -Id 'ServerNode01' | Skip-AutomateNOWServerNode -Force

    .EXAMPLE
    Unsets the Skip (bypass) flag on a Node

    Get-AutomateNOWServerNode | Skip-AutomateNOWServerNode -UnSkip

    .EXAMPLE
    Sets an array of Node to Skip (bypass)

    @( 'Task1', 'Task2', 'Task3') | Skip-AutomateNOWServerNode

    .EXAMPLE
    Forcibly and quietly sets all Linux
    Get-AutomateNOWServerNode | ? { $_.serverNodeType -eq 'LINUX' } | Skip-AutomateNOWServerNode -UnSkip -Force -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWServerNode]$ServerNode,
        [Parameter(Mandatory = $false)]
        [switch]$UnSkip,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnSkip -ne $True) {
            [string]$skip_flag_status = 'On'
            [string]$operation_id = 'passBy'
            [string]$ProcessDescription = 'Add the Skip flag'
        }
        Else {
            [string]$skip_flag_status = 'Off'
            [string]$operation_id = 'passByOff'
            [string]$ProcessDescription = 'Remove the Skip flag'
        }
        [string]$command = ('/serverNode/' + $operation_id)
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWServerNode]$ServerNode = $_
        }
        [string]$ServerNode_id = $ServerNode.id
        If ($ServerNode.passBy -eq $true -and $UnSkip -ne $True) {
            Write-Warning -Message "Node $ServerNode_id already has the skip flag set. No action is required."
            Break
        }
        ElseIf ($ServerNode.passBy -eq $false -and $UnSkip -eq $True) {
            Write-Warning -Message "Node $ServerNode_id does not have the skip flag set. No action is required."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess($ServerNode_id, $ProcessDescription)) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $ServerNode_id )
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_operationId', $operation_id)
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ServerNodeDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ServerNode_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            $Error.Clear()
            Try {
                [ANOWServerNode]$skipped_task_template = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to create the [ANOWServerNode] object after setting the skip flag to [$skip_flag_status] on [$ServerNode_id] due to [$Message]."
                Break
            }
            Write-Verbose -Message "Successfully set the skip flag to [$skip_flag_status] on [$ServerNode_id]"
            If ($Quiet -ne $true) {
                Return $skipped_task_template
            }
        }
    }
    End {

    }
}

Function Push-AutomateNOWLoadBalancerNode {
    <#
    .SYNOPSIS
    Moves (pushes) a Load Balancer node to the top of the list (stack).

    .DESCRIPTION
    Moves (pushes) a Load Balancer node to the top of the list (stack).

    .PARAMETER ServerNode
    An [ANOWServerNode] object representing the Load Balancer Child Node to be moved (popped) to the bottom of the stack.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWServerNode] objects are accepted (including from the pipeline)

    .OUTPUTS
    A verbose information message will be sent indicating success

    .EXAMPLE
    Forcibly pops (moves to the bottom) a server node to the top of the list (stack) with a Load Balancer node.

    Get-AutomateNOWServerNode -Id 'MyNode' | Push-AutomateNOWServerNode -Force

    .EXAMPLE
    Forcibly arranges the sort order of a group of child nodes

    @( 'ServerNode3', 'ServerNode2', 'ServerNode1' ) | Get-AutomateNOWServerNode | Push-AutomateNOWServerNode -Force

    .EXAMPLE
    Forcibly re-arranges the sort order of the child nodes within a load balancer

    $ServerNode1 = Get-AutomateNOWServerNode -Id 'ServerNode1'
    $ServerNode2 = Get-AutomateNOWServerNode -Id 'ServerNode2'
    $ServerNode3 = Get-AutomateNOWServerNode -Id 'ServerNode3'
    $ServerNode4 = Get-AutomateNOWServerNode -Id 'ServerNode4'

    Push-AutomateNOWLoadBalancerNode -ServerNode $ServerNode4 -Force
    Push-AutomateNOWLoadBalancerNode -ServerNode $ServerNode3 -Force
    Push-AutomateNOWLoadBalancerNode -ServerNode $ServerNode2 -Force
    Push-AutomateNOWLoadBalancerNode -ServerNode $ServerNode1 -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This function is equivalent to selecting a Child Node and clicking 'Move Up' until it is at the top.

    This function will reset the sort order of the Load Balancer child nodes starting from 0

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [ValidateScript({ $_.parentLoadBalancer.Length -gt 0 })]
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWServerNode]$ServerNode,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/serverNode/update'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.Id.Length -gt 0) {
            [ANOWServerNode]$ServerNode = $_
        }
        [string]$ServerNode_id = $ServerNode.Id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ServerNode_id)?")) -eq $true) {
            [string]$parent_load_balancer_id = $ServerNode.parentLoadBalancer
            $Error.Clear()
            Try {
                [ANOWServerNode[]]$child_nodes = Get-AutomateNOWServerNode -Id $parent_load_balancer_id -ChildNodes
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWServerNode failed to parse the response into [ANOWServerNode] objects under Pop-AutomateNOWLoadBalancerNode due to [$Message]."
                Break
            }
            If ($child_nodes.count -eq 0) {
                Write-Warning -Message "Somehow the parent node does not have any child nodes. Please look into this."
                Break
            }
            [string]$old_values = $ServerNode.CreateOldValues()
            [PSCustomObject[]]$ServerNode_collection = ([PSCustomObject[]]($child_nodes | Where-Object { $_.Id -eq "$ServerNode_id" } | Select-Object -Property simpleId, sortOrder) + [PSCustomObject[]]($child_nodes | Sort-Object -Property sortOrder, simpleId | Where-Object { $_.Id -ne "$ServerNode_id" } | Select-Object -Property simpleId, sortOrder))
            [int32]$ServerNode_order_count = $ServerNode_collection.count
            Write-Verbose -Message "Discovered [$ServerNode_order_count] child nodes in load balancer $parent_load_balancer_id"
            [int32]$current_node = 0
            ForEach ($temp_node in $ServerNode_collection) {
                [string]$ServerNode_simple_id = $temp_node.simpleId
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                $BodyMetaData.Add('id', $ServerNode_simple_id )
                $BodyMetaData.Add('sortOrder', $current_node )
                $BodyMetaData.Add('_operationType', 'update')
                $BodyMetaData.Add('_operationId', 'hold')
                $BodyMetaData.Add('_textMatchStyle', 'exact')
                $BodyMetaData.Add('_oldValues', $old_values)
                $BodyMetaData.Add('_dataSource', 'ServerNodeDataSource')
                $BodyMetaData.Add('isc_metaDataPrefix', '_')
                $BodyMetaData.Add('isc_dataFormat', 'json')
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
                If ($null -eq $parameters.'Body') {
                    $parameters.Add('Body', $Body)
                }
                Else {
                    $parameters.'Body' = $Body
                }
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ServerNode_simple_id] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                Write-Verbose -Message "Node $ServerNode_simple_id was successfully set to sortOrder [$current_node]"
                $current_node++
            }
        }
    }
    End {

    }
}

Function Pop-AutomateNOWLoadBalancerNode {
    <#
    .SYNOPSIS
    Moves (pops) a Load Balancer node to the bottom of the list (stack).

    .DESCRIPTION
    Moves (pops) a Load Balancer node to the bottom of the list (stack).

    .PARAMETER ServerNode
    An [ANOWServerNode] object representing the Load Balancer Child Node to be moved (popped) to the bottom of the stack.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY child node [ANOWServerNode] objects are accepted (including from the pipeline).

    .OUTPUTS
    A verbose information message will be sent indicating success

    .EXAMPLE
    Forcibly pops (moves to the bottom) a server node to the bottom of the list (stack) within a Load Balancer node.

    Get-AutomateNOWServerNode -Id 'MyNode' | Pop-AutomateNOWServerNode -Force

    .EXAMPLE
    Forcibly arranges the sort order of a group of child nodes

    'ServerNode1', 'ServerNode2', 'ServerNode3' | Get-AutomateNOWServerNode | Pop-AutomateNOWServerNode -Force

    .EXAMPLE
    Forcibly re-arranges the sort order of the child nodes within a load balancer

    $ServerNode1 = Get-AutomateNOWServerNode -Id 'ServerNode1'
    $ServerNode2 = Get-AutomateNOWServerNode -Id 'ServerNode2'
    $ServerNode3 = Get-AutomateNOWServerNode -Id 'ServerNode3'
    $ServerNode4 = Get-AutomateNOWServerNode -Id 'ServerNode4'

    Pop-AutomateNOWLoadBalancerNode -ServerNode $ServerNode4 -Force
    Pop-AutomateNOWLoadBalancerNode -ServerNode $ServerNode3 -Force
    Pop-AutomateNOWLoadBalancerNode -ServerNode $ServerNode2 -Force
    Pop-AutomateNOWLoadBalancerNode -ServerNode $ServerNode1 -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This function is equivalent to selecting a Child Node and clicking 'Move Down' until it is at the bottom.

    This function will reset the sort order of the Load Balancer child nodes starting from 0

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [ValidateScript({ $_.parentLoadBalancer.Length -gt 0 })]
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWServerNode]$ServerNode,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/serverNode/update'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.Id.Length -gt 0) {
            [ANOWServerNode]$ServerNode = $_
        }
        [string]$ServerNode_id = $ServerNode.Id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ServerNode_id)?")) -eq $true) {
            [string]$parent_load_balancer_id = $ServerNode.parentLoadBalancer
            $Error.Clear()
            Try {
                [ANOWServerNode[]]$child_nodes = Get-AutomateNOWServerNode -Id $parent_load_balancer_id -ChildNodes
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWServerNode failed to parse the response into [ANOWServerNode] objects under Push-AutomateNOWLoadBalancerNode due to [$Message]."
                Break
            }
            If ($child_nodes.count -eq 0) {
                Write-Warning -Message "Somehow the parent node does not have any child nodes. Please look into this."
                Break
            }
            [string]$old_values = $ServerNode.CreateOldValues()
            [PSCustomObject[]]$ServerNode_collection = ([PSCustomObject[]]($child_nodes | Sort-Object -Property sortOrder, simpleId | Where-Object { $_.Id -ne "$ServerNode_id" } | Select-Object -Property simpleId, sortOrder) + [PSCustomObject[]]($child_nodes | Where-Object { $_.Id -eq "$ServerNode_id" } | Select-Object -Property simpleId, sortOrder))
            [int32]$ServerNode_order_count = $ServerNode_collection.count
            Write-Verbose -Message "Discovered [$ServerNode_order_count] child nodes in load balancer $parent_load_balancer_id"
            [int32]$current_node = 0
            ForEach ($temp_node in $ServerNode_collection) {
                [string]$ServerNode_simple_id = $temp_node.simpleId
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                $BodyMetaData.Add('id', $ServerNode_simple_id )
                $BodyMetaData.Add('sortOrder', $current_node )
                $BodyMetaData.Add('_operationType', 'update')
                $BodyMetaData.Add('_operationId', 'hold')
                $BodyMetaData.Add('_textMatchStyle', 'exact')
                $BodyMetaData.Add('_oldValues', $old_values)
                $BodyMetaData.Add('_dataSource', 'ServerNodeDataSource')
                $BodyMetaData.Add('isc_metaDataPrefix', '_')
                $BodyMetaData.Add('isc_dataFormat', 'json')
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
                If ($null -eq $parameters.'Body') {
                    $parameters.Add('Body', $Body)
                }
                Else {
                    $parameters.'Body' = $Body
                }
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ServerNode_simple_id] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                Write-Verbose -Message "Node $ServerNode_simple_id was successfully set to sortOrder [$current_node]"
                $current_node++
            }
        }
    }
    End {

    }
}

#endregion

#Region - Server Node Agents

Function Read-AutomateNOWServerNodeAgent {
    <#
    .SYNOPSIS
    Reads the Agents that a Server Node is attached to on an AutomateNOW! instance

    .DESCRIPTION
    Reads the Agents that a Server Node is attached to on an AutomateNOW! instance

    .PARAMETER ServerNode
    Mandatory [ANOWServerNode] object. Use Get-AutomateNOWServerNode to get this object.

    .PARAMETER startRow
    Integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER sortBy
    Optional string parameter to sort the results by (may not be used with the Id parameter). Valid choices are: sortOrder*, lastUpdatedBy, serverNode, endpointType, serverNodeType, defaultEndpoint, lastUpdated, endpoint, dateCreated, createdBy, id

    .PARAMETER Ascending
    Optional switch parameter which changes the sort order to ascending

    .INPUTS
    Accepts [ANOWServerNode] objects either individually or from the pipeline.

    .OUTPUTS
    An array of one or more [ANOWAgent] class objects that the provided [ANOWServerNode] object is attached to

    .EXAMPLE
    Returns the Agents that a Server Node named 'ServerNode1' is attached to

    Get-AutomateNOWServerNode -Id 'ServerNode1' | Read-AutomateNOWServerNodeAgent

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWAgent[]])]
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $True, ValueFromPipeline = $True)]
        [ANOWServerNode]$ServerNode,
        [Parameter(Mandatory = $False)]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False)]
        [int32]$endRow = 100,
        [ValidateSet('id', ignoreCase = $false)]
        [Parameter(Mandatory = $False)]
        [string]$sortBy = 'sortOrder'
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.Id.Length -gt 0) {
            [ANOWServerNode]$ServerNode = $_
            [string]$ServerNode_id = $ServerNode.id
        }
        If ($ServerNode.Id.Length -gt 0) {
            [string]$ServerNode_id = $ServerNode.id
        }
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        $Body.Add('id', $ServerNode_id)
        $Body.Add('_startRow', $startRow)
        $Body.Add('_endRow', $endRow)
        If ($Ascending -eq $true) {
            $Body.'_sortBy' = $sortBy
        }
        Else {
            $Body.'_sortBy' = '-' + $sortBy
        }
        $Body.Add('_textMatchStyle', 'exact')
        $Body.Add('_operationType', 'fetch')
        $Body.Add('_operationId', 'readServerNodeAgents')
        $Body.Add('_componentId', 'ServerNodeAgentList')
        $Body.Add('_dataSource', 'AgentDataSource')
        $Body.Add('isc_metaDataPrefix', '_')
        $Body.Add('isc_dataFormat', 'json')
        [string]$command = '/agent/readServerNodeAgents/?'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ($command + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        If ($results.response.data.count -gt 0) {
            $Error.Clear()
            Try {
                [ANOWAgent[]]$Agents = $results.response.data
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the response into a series of [ANOWAgent] objects due to [$Message]."
                Break
            }
            Return $Agents
        }
        Else {
            Write-Verbose -Message "Server Node $ServerNode_id did not have attachments to any Agents"
        }
    }
    End {

    }
}

#endregion

#Region - Server Node Endpoints

Function Read-AutomateNOWServerNodeEndpoint {
    <#
    .SYNOPSIS
    Reads the ServerNode Endpoints from an AutomateNOW! instance

    .DESCRIPTION
    Reads the ServerNode Endpoints from an AutomateNOW! instance

    .PARAMETER ServerNode
    Mandatory [ANOWServerNode] object. Use Get-AutomateNOWServerNode to get this object.

    .PARAMETER startRow
    Integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER Id
    36-character GUID of the ServerNodeEndpoint to read. This is normally intended for verifying that the ServerNodeEndpoint exists before deleting it. This parameter can only be used exclusively from the others.

    .PARAMETER sortBy
    Optional string parameter to sort the results by (may not be used with the Id parameter). Valid choices are: sortOrder*, lastUpdatedBy, serverNode, endpointType, serverNodeType, defaultEndpoint, lastUpdated, endpoint, dateCreated, createdBy, id

    .PARAMETER Ascending
    Optional switch parameter which changes the sort order to ascending

    .PARAMETER All
    Switch parameter that can only be used separately from -ServerNode. Reads all of the ServerNodeEndpoints (up to the first 50,000) without filtering on the associated [ANOWServerNode object]. Caution: This approach makes many subsequent API calls because [ANOWServerNodeEndpoint] object requires that the [ANOWServerNode] object is added, hence this really should only be used for auditing.

    .INPUTS
    Accepts [ANOWServerNode] objects either individually or from the pipeline. Also accepts 36-character GUID Id's from [ANOWServerNodeEndpoint] objects

    .OUTPUTS
    An array of one or more [ANOWServerNodeEndpoint] class objects that are linked to the provided [ANOWServerNode] object

    .EXAMPLE
    Simple format to get the first page of ServerNodeEndpoints associated with a ServerNode

    $serverNode = Get-AutomateNOWServerNode -Id 'ServerNode1'
    $serverNodeEndpoints = Read-AutomateNOWServerNodeEndpoint -ServerNode $serverNode

    .EXAMPLE
    Pipeline format to get the first page of ServerNodeEndpoints associated with a ServerNode
    Get-AutomateNOWServerNode -Id 'ServerNode1' | Read-AutomateNOWServerNodeEndpoint

    .EXAMPLE
    Gets the first page of all ServerNodeEndpoints regardless of the associated ServerNode
    Read-AutomateNOWServerNodeEndpoint -All

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Run this function with the -All parameter to retrieve all of the ServerNode Endpoints. Use with caution.

    #>
    [OutputType([ANOWServerNodeEndpoint[]])]
    [Cmdletbinding(DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $True, ParameterSetName = 'Default', ValueFromPipeline = $True)]
        [ANOWServerNode]$ServerNode,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [int32]$endRow = 100,
        [ValidateScript({ $_ -match '^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$' })]
        [Parameter(Mandatory = $True, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [string]$Id,
        [ValidateSet('sortOrder', 'lastUpdatedBy', 'serverNode', 'endpointType', 'serverNodeType', 'defaultEndpoint', 'lastUpdated', 'endpoint', 'dateCreated', 'createdBy', 'id', ignoreCase = $false)]
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [string]$sortBy = 'sortOrder',
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [switch]$All
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.Id.Length -gt 0) {
            [ANOWServerNode]$ServerNode = $_
            [string]$ServerNode_id = $ServerNode.id
        }
        If ($ServerNode.Id.Length -gt 0) {
            [string]$ServerNode_id = $ServerNode.id
        }
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        $Body.Add('_operationType', 'fetch')
        If ($All -eq $true) {
            $Body.Add('_startRow', 0)
            $Body.Add('_endRow', 50000)
            [string]$textMatchStyle = 'substring'
        }
        Else {
            $Body.Add('_startRow', $startRow)
            $Body.Add('_endRow', $endRow)
            If ($ServerNode_id.Length -gt 0 -or $Id.Length -eq 36) {
                [string]$textMatchStyle = 'exact'
                $Body.Add('_constructor', 'AdvancedCriteria')
                $Body.Add('operator', 'and')
                If ($Id.Length -eq 36) {
                    $Body.Add('criteria', '{"fieldName":"id","operator":"equals","value":"' + $Id + '","_constructor":"AdvancedCriteria"}')
                }
                Else {
                    $Body.Add('criteria', '{"fieldName":"serverNode","operator":"equals","value":"' + $ServerNode_id + '","_constructor":"AdvancedCriteria"}')
                }
            }
        }
        $Body.Add('_textMatchStyle', $textMatchStyle)
        [string]$command = '/serverNodeEndpoint/read?'
        If ($Ascending -eq $true) {
            $Body.'_sortBy' = $sortBy
        }
        Else {
            $Body.'_sortBy' = '-' + $sortBy
        }
        $Body.Add('_componentId', 'ServerNodeEndpointList')
        $Body.Add('_dataSource', 'ServerNodeEndpointDataSource')
        $Body.Add('isc_metaDataPrefix', '_')
        $Body.Add('isc_dataFormat', 'json')
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ($command + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        [int32]$ResultsCount = $results.response.data.count
        If ($ResultsCount -gt 50000) {
            Write-Warning -Message "This ServerNode object has over 50,000 endpoints added! This module does not support that yet."
            Break
        }
        If ($ResultsCount -gt 0) {
            If ($ResultsCount -gt 1 -and $Id.Length -gt 0) {
                Write-Warning -Message "Wait! There cannot be more then 1 result if the -Id parameter was specified. Something is wrong. Please look into this."
                Break
            }
            $Error.Clear()
            Try {
                [ANOWServerNodeEndpoint[]]$ServerNodeEndpoints = ForEach ($result in $results.response.data) {
                    If ($result.serverNode -eq $ServerNode_id) {
                        $result.serverNode = $ServerNode
                    }
                    ElseIf ($result.serverNode.Length -eq 0) {
                        Write-Host "Somehow an [ANOWServerNode] object has an empty serverNode! Please look into this"
                        Break
                    }
                    Else {
                        [string]$current_server_node_id = $result.serverNode
                        $Error.Clear()
                        Try {
                            [ANOWServerNode]$current_server_node = Get-AutomateNOWServerNode -Id $current_server_node_id
                        }
                        Catch {
                            [string]$Message = $_.Exception.Message
                            Write-Warning -Message "Get-AutomateNOWServerNode failed to read the ServerNode of the current ServerNodeEndpoint due to [$Message]."
                            Break
                        }
                        $result.serverNode = $current_server_node
                    }
                    $result
                }
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the response into a series of [ANOWServerNodeEndpoint] objects due to [$Message]."
                Break
            }
            If ($ServerNodeEndpoints.Count -gt 0) {
                Return $ServerNodeEndpoints
            }
            Else {
                Write-Verbose -Message "There are no endpoints added to ServerNode $ServerNode_id)"
            }
        }
    }
    End {

    }
}

Function Add-AutomateNOWServerNodeEndpoint {
    <#
    .SYNOPSIS
    Adds an Endpoint to a Server Node on an instance of AutomateNOW!

    .DESCRIPTION
    Adds an Endpoint to a Server Node on an instance of AutomateNOW! creating an [ANOWServerNodeEndpoint] object.

    .PARAMETER ServerNode
    Mandatory [ANOWServerNode] object representing the Server Node that will receive the new Endpoint.

    .Parameter Endpoint
    Mandatory [ANOWEndpoint] object representing the Endpoint that is being added to the Server Node.

    .PARAMETER sortOrder
    Optional int32 specifying the sort order. When not specified, the sort order will be LAST. If needed, use Read-AutomateNOWServerNodeEndpoint to obtain the current sort order of the Endpoints in the Server Node.

    .PARAMETER Quiet
    Switch parameter to silence the emitted [ANOWServerNodeEndpoint] object

    .PARAMETER Force
    Force the addition of the object without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    A single [ANOWServerNode] and multiple [ANOWEndpoint] objects. Endpoints can be sent across the pipeline.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Gently adds an Endpoint to a Server Node in an easy to debug format

    $endpoint = Get-AutomateNOWEndpoint -Id 'Endpoint1'
    $serverNode = Get-AutomateNOWServerNode -Id 'ServerNode1'
    Add-AutomateNOWServerNodeEndpoint -Endpoint $endpoint -ServerNode $serverNode

    .EXAMPLE
    Forcibly and quietly uses the pipeline to add two Endpoints named 'Endpoint1' and 'Endpoint2' to a Server Node named 'ServerNode1'

    @('Endpoint1', 'Endpoint2') | Get-AutomateNOWEndpoint | Add-AutomateNOWServerNodeEndpoint -ServerNode (Get-AutomateNOWServerNode -Id 'ServerNode1') -Force -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    WARNING: Unlike other similar functions, there is no lookup table to ensure that the provided endpoint type matches the server node type. Proceed with caution!

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWServerNode]$ServerNode,
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWEndpoint]$Endpoint,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$ServerNode_id = $ServerNode.Id
        [string]$command = '/serverNodeEndpoint/create'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWEndpoint]$Endpoint = $_
        }
        [string]$Endpoint_id = $Endpoint.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$Endpoint_id --> $($ServerNode_id)?")) -eq $true) {
            $Error.Clear()
            Try {
                [ANOWServerNodeEndpoint[]]$ServerNodeEndpoints = Read-AutomateNOWServerNodeEndpoint -ServerNode $ServerNode
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Read-AutomateNOWServerNodeEndpoint failed to Read $ServerNode_id under Add-AutomateNOWServerNodeEndpoint due to [$Message]."
                Break
            }
            [int32]$ServerNodeEndpoints_Count = $ServerNodeEndpoints.Count
            If ($ServerNodeEndpoints_Count -gt 0) {
                Write-Verbose -Message "$ServerNode_id currently has $ServerNodeEndpoints_Count items before any changes were made"
                [int32]$last_item_order = ($ServerNodeEndpoints | Sort-Object -Property sortOrder | Select-Object -Last 1 | Select-Object -ExpandProperty sortOrder) + 1
            }
            Else {
                Write-Verbose -Message "$ServerNode_id does not have any Endpoints yet. This will be the first Endpoint added to it."
                [int32]$last_item_order = 0
            }
            [ANOWServerNode_serverNodeType]$serverNodeType = $ServerNode.serverNodeType
            [ANOWEndpoint_endpointType]$endpointType = $Endpoint.endpointType
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('serverNode', $ServerNode_id )
            $BodyMetaData.Add('serverNodeType', $serverNodeType )
            $BodyMetaData.Add('endpoint', $Endpoint_id )
            $BodyMetaData.Add('endpointType', $endpointType )
            $BodyMetaData.Add('sortOrder', $last_item_order )
            $BodyMetaData.Add('_operationType', 'add')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_componentId', 'ServerNodeEndpointList')
            $BodyMetaData.Add('_dataSource', 'ServerNodeEndpointDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ServerNode_id] with [$Endpoint_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            [string]$servernode_endpoint_id = $results.response.data.id
            If ($servernode_endpoint_id -notmatch '^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$') {
                Write-Warning -Message "Somehow the returned Id of the newly added Server Node Endpoint did not match the expected format of a Server Node Endpoint which is that of a 36-character GUID. Instead, [$servernode_endpoint_id] was received. Please look into this."
            }
            Write-Verbose -Message "Endpoint $Endpoint_id ($endpointType) was added to $ServerNode_id (as $servernode_endpoint_id)"
            If ($results.response.data.count -eq 1) {
                $Error.Clear()
                Try {
                    $results.response.data = $results.response.data | Select-Object -ExcludeProperty serverNode | Add-Member -MemberType NoteProperty -Name serverNode -Value $ServerNode
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Add-Member failed to replace the serverNode property of $Endpoint_id after adding it to $ServerNode_id (as $servernode_endpoint_id) due to [$Message]"
                    Break
                }
                $Error.Clear()
                Try {
                    [ANOWServerNodeEndpoint]$ServerNodeEndpoint = $results.response.data
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to parse the returned Server Node Endpoint object (that was added to $ServerNode_id) into an [ANOWServerNodeEndpoint] object due to [$Message]"
                    Break
                }
                Write-Verbose -Message "Server Node Endpoint successfully added to $ServerNode_id (order: $last_item_order)"
                If ($Quiet -ne $true) {
                    Return $ServerNodeEndpoint
                }
            }
            Else {
                Write-Warning -Message "There was no data from the successful response under Add-AutomateNOWServerNodeEndpoint. Please look into this."
            }
        }
    }
    End {

    }
}

Function Remove-AutomateNOWServerNodeEndpoint {
    <#
    .SYNOPSIS
    Removes a "ServerNodeEndpoint" object from a Server Node

    .DESCRIPTION
    Removes a "ServerNodeEndpoint" object from a Server Node which is created whenever you add an Endpoint to a Server Node.

    .PARAMETER ServerNodeEndpoint
    Mandatory [ANOWServerEndpoint] object that will be deleted (removed) from the Server Node. Note that this does not delete the Endpoint. A ServerNodeEndpoint is similar to a Task after it has been added to a Workflow or a Schedule, it becomes an "item" of that object.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    You must present a [ANOWServerEndpoint] object. There is no need to specify the [ANOWServerNode]

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Forcibly uses the pipeline to remove all of the ServerNodeEndpoints from a ServerNode
    Get-AutomateNOWServerNode -Id 'ServerNode1' | Read-AutomateNOWServerNodeEndpoint | Remove-AutomateNOWServerNodeEndpoint -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Note that this function does not delete an Endpoint, it deletes a ServerNodeEndpoint. This is like an "item" on a WorkflowTemplate.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWServerNodeEndpoint]$ServerNodeEndpoint,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/serverNodeEndpoint/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWServerNodeEndpoint]$ServerNodeEndpoint = $_
        }
        [string]$ServerNodeEndpoint_id = $ServerNodeEndpoint.id
        If ($ServerNodeEndpoint_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If ($ServerNodeEndpoint_id -notmatch '^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$') {
            Write-Warning -Message "Was expecting the Id of the ServerNodeEndpoint to match a 36-character GUID, instead received [$ServerNodeEndpoint_id]. Please check into this."
            Break
        }
        Else {
            Write-Verbose -Message "Received [$ServerNodeEndpoint_id] for the Id of the ServerNodeEndpoint to be removed"
        }
        $Error.Clear()
        Try {
            [ANOWServerNode]$ServerNode = $ServerNodeEndpoint.serverNode
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the serverNode object within $ServerNodeEndpoint_id under Remove-AutomateNOWServerNodeEndpoint due to [$Message]."
            Break
        }
        [string]$ServerNode_id = $ServerNode.Id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ServerNodeEndpoint_id)")) -eq $true) {
            $Error.Clear()
            Try {
                [ANOWServerNodeEndpoint]$confirm_ServerNodeEndpoint = Read-AutomateNOWServerNodeEndpoint -Id $ServerNodeEndpoint_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Read-AutomateNOWServerNodeEndpoint failed to Read [$ServerNodeEndpoint_id] (within $ServerNode_id) under Remove-AutomateNOWServerNodeEndpoint due to [$Message]."
                Break
            }
            [int32]$ServerNodeEndpoints_Count = $confirm_ServerNodeEndpoint.Count
            If ($ServerNodeEndpoints_Count -eq 0) {
                Write-Verbose -Message "$ServerNodeEndpoint_id does not exist so it cannot be deleted... Please check again."
                Break
            }
            ElseIf ($ServerNodeEndpoint_id -cne $confirm_ServerNodeEndpoint.Id) {
                Write-Warning -Message "Somehow the Id of the ServerNodeEndpoint failed a basic check against the console. Please only send real objects."
                Break
            }
            [string]$old_values = $ServerNodeEndpoint.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $ServerNodeEndpoint_id )
            $BodyMetaData.Add('_oldValues', $old_values )
            $BodyMetaData.Add('_operationType', 'remove')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_componentId', 'ServerNodeEndpointList')
            $BodyMetaData.Add('_dataSource', 'ServerNodeEndpointDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ServerNodeEndpoint_id] (under $ServerNode_id) due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Server Node Endpoint $ServerNodeEndpoint_id was successfully removed from $ServerNode_id"
        }
    }
    End {

    }
}

Function Export-AutomateNOWServerNodeEndpoint {
    <#
    .SYNOPSIS
    Exports the ServerNode Endpoints from a Server Node on an instance of AutomateNOW!

    .DESCRIPTION
    Exports the ServerNode Endpoints from a Server Node on an instance of AutomateNOW!

    .Parameter ServerNode
    Mandatory [ANOWServerNode] object representing the Server Node that is to be exported.

    .INPUTS
    ONLY [ANOWServerNode] objects are accepted (including from the pipeline)

    .OUTPUTS
    The [ANOWServerNode] objects are exported to the local disk in CSV format

    .EXAMPLE
    Exports all of the ServerNode Endpoints from within a Security Node named 'SecurityNode1'

    $server_node = Get-AutomateNOWServerNode -Id 'SecurityNode1'
    $server_node_endpoints = $security_node | Read-AutomateNOWServerNodeEndpoint
    $server_node_endpoints | Export-AutomateNOWServerNodeEndpoint

    .NOTES
	
    #>
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWServerNodeEndpoint]$ServerNodeEndpoint
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = "Export-AutomateNOW-ServerNodeEndpoints-" + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWServerNodeEndpoint]$ServerNodeEndpoint = $_
        }
        [string]$ServerNode_Name = $ServerNodeEndpoint.serverNode.id
        $Error.Clear()
        Try {
            $ServerNodeEndpoint | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWServerNodeEndpoint] objects $ServerNode_Name due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function Set-AutomateNOWServerNodeEndpoint {
    <#
    .SYNOPSIS
    Changes the settings of a ServerNode Endpoint on an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of a ServerNode Endpoint on an AutomateNOW! instance

    .PARAMETER ServerNodeEndpoint
    An [ANOWServerNodeEndpoint] object representing the ServerNode Endpoint to be modified.

    .PARAMETER SetAsDefault
    A [boolean] parameter indicating if the Default status of the ServerNode Endpoint should be true or false.

    .PARAMETER Quiet
    An optional switch parameter that silences the output of this function

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWServerNodeEndpoint] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWServerNodeEndpoint] object will be returned

    .EXAMPLE
    Forcibly and quietly sets a ServerNode Endpoint named after its Endpoint 'Endpoint1' within a Server Node named 'ServerNode1' to the default ServerNode Endpoint for that Server Node (multi-line format)

    $node = Get-AutomateNOWServerNode -Id 'ServerNode1'
    $servernode_endpoint = $node | Read-AutomateNOWServerNodeEndpoint | Where-Object { $_.endpoint -eq 'Endpoint1'}
    $servernode_endpoint | Set-AutomateNOWServerNodeEndpoint -SetAsDefault $true -Force -Quiet

    .EXAMPLE
    Forcibly and quietly unsets a ServerNode Endpoint named after its Endpoint 'Endpoint1' within a Server Node named 'ServerNode1' to the default ServerNode Endpoint for that Server Node (one-liner format)

    Get-AutomateNOWServerNode -Id 'ServerNode1' | Read-AutomateNOWServerNodeEndpoint | Where-Object { $_.endpoint -eq 'Endpoint1'} | Set-AutomateNOWServerNodeEndpoint -SetAsDefault $false -Force -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    A Server Node does not actually require that a default ServerNode Endpoint be set. It is optional.

    The only setting that can be changed with this function is the default status. Also, there can only be 1 ServerNode Endpoint per Endpoint per Server Node.

    Refer to Pop-AutomateNOWServerNodePoint and Push-AutomateNOWServerNodePoint for changing the sort order of the ServerNode Endpoints within a Server Node.

    #>
    [OutputType([ANOWServerNodeEndpoint])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWServerNodeEndpoint]$ServerNodeEndpoint,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$SetAsDefault,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        [string]$command = '/serverNodeEndpoint/update'
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWServerNodeEndpoint]$ServerNodeEndpoint = $_
        }
        [string]$ServerNodeEndpoint_id = $ServerNodeEndpoint.id
        [string]$ServerNodeEndpoint_name = $ServerNodeEndpoint.endpoint
        [boolean]$ServerNodeEndpoint_default_endpoint = $ServerNodeEndpoint.defaultEndpoint
        [ANOWServerNode]$ServerNode = $ServerNodeEndpoint.serverNode
        [string]$ServerNode_id = $ServerNode.id
        If ($SetAsDefault -eq $true -and $ServerNodeEndpoint_default_endpoint -eq $true) {
            Write-Warning -Message "$ServerNodeEndpoint_name is already the default ServerNode Endpoint for $ServerNode_id. No action is required."
            Break
        }
        ElseIf ($SetAsDefault -eq $false -and $ServerNodeEndpoint_default_endpoint -eq $false) {
            Write-Warning -Message "$ServerNodeEndpoint_name is already not the default ServerNode Endpoint for $ServerNode_id. No action is required."
        }
        ElseIf ($null -eq $SetAsDefault) {
            Write-Warning -Message "There is nothing to change. No action is required."
            Break
        }
        Write-Verbose -Message "Detected that Endpoint $ServerNodeEndpoint_name is added to $ServerNode_id with default ServerNode Endpoint status set to $ServerNodeEndpoint_default_endpoint as ($ServerNodeEndpoint_id)"
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$ServerNodeEndpoint_name on $ServerNode_id")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$ServerNodeEndpoint_exists = ($null -eq (Read-AutomateNOWServerNodeEndpoint -Id $ServerNodeEndpoint_id))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Read-AutomateNOWServerNodeEndpoint failed to check if the ServerNodeEndpoint [$ServerNodeEndpoint_name] under Set-AutomateNOWServerNodeEndpoint already existed due to [$Message]."
                Break
            }
            If ($ServerNodeEndpoint_exists -eq $true) {
                Write-Warning -Message "There is not a ServerNode Endpoint named [$ServerNodeEndpoint_name] added to $ServerNode_id so it can't be modified. Please check into this."
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            If ($SetAsDefault -eq $true) {
                $BodyMetaData.'defaultEndpoint' = 'true'
            }
            ElseIf ($SetAsDefault -eq $false) {
                $BodyMetaData.'defaultEndpoint' = 'false'
            }
            $BodyMetaData.'id' = $ServerNodeEndpoint_id
            $BodyMetaData.'_operationType' = 'update'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_componentId' = 'ServerNodeEndpointList'
            $BodyMetaData.'_dataSource' = 'ServerNodeEndpointDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ServerNodeEndpoint_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "ServerNode Endpoint object [$ServerNodeEndpoint_id] was successfully updated"
            $Error.Clear()
            $results.response.data[0].serverNode = $ServerNode
            Try {
                [ANOWServerNodeEndpoint]$UpdatedServerNodeEndpoint = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the successful result of Set-AutomateNOWServerNodeEndpoint to an [ANOWServerNodeEndpoint] object due to [$Message]."
                Break
            }
            If ($Quiet -ne $true) {
                Return $UpdatedServerNodeEndpoint
            }
        }
    }
    End {
    }
}

Function Push-AutomateNOWServerNodeEndpoint {
    <#
    .SYNOPSIS
    Moves (pushes) a Server Node Endpoint to the top of the list (stack) within a Server Node.

    .DESCRIPTION
    Moves (pushes) a Server Node Endpoint to the top of the list (stack) within a Server Node.

    .PARAMETER ServerNodeEndpoint
    An [ANOWServerNodeEndpoint] object representing the Server Node Endpoint to be moved (popped) to the top of the list (stack).

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWServerNodeEndpoint] objects are accepted (including from the pipeline)

    .OUTPUTS
    A verbose information message will be sent indicating success

    .EXAMPLE
    Forcibly pushes a Server Node Endpoint named 'ServerNodeEndpoint1' to the top of the stack (list) within a Server Node named 'ServerNode1' (one-liner format)

    Get-AutomateNOWServerNode -Id 'ServerNode1' | Read-AutomateNOWServerNodeEndpoint | Where-Object { $_.endpoint -eq 'ServerNodeEndpoint1'} | Push-AutomateNOWServerNodeEndpoint -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This function is equivalent to selecting a Server Node Endpoint and clicking 'Move Up' until it is at the top.

    This function will reset the sort order of the Server Node Endpoints starting from 0

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWServerNodeEndpoint]$ServerNodeEndpoint,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/serverNodeEndpoint/update'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.Id.Length -gt 0) {
            [ANOWServerNodeEndpoint]$ServerNodeEndpoint = $_
        }
        [string]$ServerNodeEndpoint_id = $ServerNodeEndpoint.id
        [string]$ServerNodeEndpoint_name = $ServerNodeEndpoint.endpoint
        [ANOWServerNode]$ServerNode = $ServerNodeEndpoint.serverNode
        [string]$ServerNode_id = $ServerNode.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$ServerNodeEndpoint_name to the top of $ServerNode_id's stack?")) -eq $true) {
            $Error.Clear()
            Try {
                [ANOWServerNodeEndpoint[]]$ServerNode_Endpoints = Read-AutomateNOWServerNodeEndpoint -ServerNode $ServerNode
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Read-AutomateNOWServerNodeEndpoint failed to parse the response into [ANOWServerNodeEndpoint] objects under Push-AutomateNOWServerNodeEndpoint due to [$Message]."
                Break
            }
            If ($ServerNode_Endpoints.count -eq 0) {
                Write-Warning -Message "Somehow the Server Node does not have any ServerNode Endpoints. Please look into this."
                Break
            }
            [string]$old_values = $ServerNodeEndpoint.CreateOldValues()
            [PSCustomObject[]]$ServerNodeEndpoint_collection = ([PSCustomObject[]]($ServerNode_Endpoints | Where-Object { $_.Id -eq $ServerNodeEndpoint_id } | Select-Object -Property endpoint, Id, sortOrder) + [PSCustomObject[]]($ServerNode_Endpoints | Sort-Object -Property sortOrder, Id | Where-Object { $_.Id -ne $ServerNodeEndpoint_id } | Select-Object -Property endpoint, Id, sortOrder))
            [int32]$ServerNodeEndpoint_order_count = $ServerNodeEndpoint_collection.count
            Write-Verbose -Message "Discovered [$ServerNodeEndpoint_order_count] Server Node Endpoints within $ServerNode_id"
            [int32]$current_endpoint = 0
            ForEach ($temp_endpoint in $ServerNodeEndpoint_collection) {
                [string]$ServerNodeEndpoint_id = $temp_endpoint.id
                [string]$ServerNodeEndpoint_name = $temp_endpoint.endpoint
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                $BodyMetaData.Add('id', $ServerNodeEndpoint_id )
                $BodyMetaData.Add('sortOrder', $current_endpoint )
                $BodyMetaData.Add('_operationType', 'update')
                $BodyMetaData.Add('_textMatchStyle', 'exact')
                $BodyMetaData.Add('_oldValues', $old_values)
                $BodyMetaData.Add('_componentId', 'ServerNodeEndpointList')
                $BodyMetaData.Add('_dataSource', 'ServerNodeEndpointDataSource')
                $BodyMetaData.Add('isc_metaDataPrefix', '_')
                $BodyMetaData.Add('isc_dataFormat', 'json')
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
                If ($null -eq $parameters.'Body') {
                    $parameters.Add('Body', $Body)
                }
                Else {
                    $parameters.'Body' = $Body
                }
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on ($ServerNodeEndpoint_name / $ServerNode_id) due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                Write-Verbose -Message "ServerNode Endpoint ($ServerNodeEndpoint_name / $ServerNode_id) was successfully set to sortOrder [$current_endpoint]"
                $current_endpoint++
            }
        }
    }
    End {

    }
}

Function Pop-AutomateNOWServerNodeEndpoint {
    <#
    .SYNOPSIS
    Moves (pops) a Server Node Endpoint to the bottom of the list (stack) within a Server Node.

    .DESCRIPTION
    Moves (pops) a Server Node Endpoint to the bottom of the list (stack) within a Server Node.

    .PARAMETER ServerNodeEndpoint
    An [ANOWServerNodeEndpoint] object representing the Server Node Endpoint to be moved (popped) to the bottom of the list (stack).

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWServerNodeEndpoint] objects are accepted (including from the pipeline)

    .OUTPUTS
    A verbose information message will be sent indicating success

    .EXAMPLE
    Forcibly pushes a Server Node Endpoint named 'ServerNodeEndpoint1' to the bottom of the stack (list) within a Server Node named 'ServerNode1' (one-liner format)

    Get-AutomateNOWServerNode -Id 'ServerNode1' | Read-AutomateNOWServerNodeEndpoint | Where-Object { $_.endpoint -eq 'ServerNodeEndpoint1'} | Pop-AutomateNOWServerNodeEndpoint -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This function is equivalent to selecting a Server Node Endpoint and clicking 'Move Down' until it is at the bottom.

    This function will reset the sort order of the Server Node Endpoints starting from 0

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWServerNodeEndpoint]$ServerNodeEndpoint,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/serverNodeEndpoint/update'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.Id.Length -gt 0) {
            [ANOWServerNodeEndpoint]$ServerNodeEndpoint = $_
        }
        [string]$ServerNodeEndpoint_id = $ServerNodeEndpoint.id
        [string]$ServerNodeEndpoint_name = $ServerNodeEndpoint.endpoint
        [ANOWServerNode]$ServerNode = $ServerNodeEndpoint.serverNode
        [string]$ServerNode_id = $ServerNode.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$ServerNodeEndpoint_name to the bottom of $ServerNode_id's stack?")) -eq $true) {
            $Error.Clear()
            Try {
                [ANOWServerNodeEndpoint[]]$ServerNode_Endpoints = Read-AutomateNOWServerNodeEndpoint -ServerNode $ServerNode
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Read-AutomateNOWServerNodeEndpoint failed to parse the response into [ANOWServerNodeEndpoint] objects under Push-AutomateNOWServerNodeEndpoint due to [$Message]."
                Break
            }
            If ($ServerNode_Endpoints.count -eq 0) {
                Write-Warning -Message "Somehow the Server Node does not have any ServerNode Endpoints. Please look into this."
                Break
            }
            [string]$old_values = $ServerNodeEndpoint.CreateOldValues()
            [PSCustomObject[]]$ServerNodeEndpoint_collection = ([PSCustomObject[]]([PSCustomObject[]]($ServerNode_Endpoints | Sort-Object -Property sortOrder, Id | Where-Object { $_.Id -ne $ServerNodeEndpoint_id } | Select-Object -Property endpoint, Id, sortOrder) + ($ServerNode_Endpoints | Where-Object { $_.Id -eq $ServerNodeEndpoint_id } | Select-Object -Property endpoint, Id, sortOrder)))
            [int32]$ServerNodeEndpoint_order_count = $ServerNodeEndpoint_collection.count
            Write-Verbose -Message "Discovered [$ServerNodeEndpoint_order_count] Server Node Endpoints within $ServerNode_id"
            [int32]$current_endpoint = 0
            ForEach ($temp_endpoint in $ServerNodeEndpoint_collection) {
                [string]$ServerNodeEndpoint_id = $temp_endpoint.id
                [string]$ServerNodeEndpoint_name = $temp_endpoint.endpoint
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                $BodyMetaData.Add('id', $ServerNodeEndpoint_id )
                $BodyMetaData.Add('sortOrder', $current_endpoint )
                $BodyMetaData.Add('_operationType', 'update')
                $BodyMetaData.Add('_textMatchStyle', 'exact')
                $BodyMetaData.Add('_oldValues', $old_values)
                $BodyMetaData.Add('_componentId', 'ServerNodeEndpointList')
                $BodyMetaData.Add('_dataSource', 'ServerNodeEndpointDataSource')
                $BodyMetaData.Add('isc_metaDataPrefix', '_')
                $BodyMetaData.Add('isc_dataFormat', 'json')
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
                If ($null -eq $parameters.'Body') {
                    $parameters.Add('Body', $Body)
                }
                Else {
                    $parameters.'Body' = $Body
                }
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on ($ServerNodeEndpoint_name / $ServerNode_id) due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                Write-Verbose -Message "ServerNode Endpoint ($ServerNodeEndpoint_name / $ServerNode_id) was successfully set to sortOrder [$current_endpoint]"
                $current_endpoint++
            }
        }
    }
    End {

    }
}

#endregion

#Region - ServerNode Groups

Function Get-AutomateNOWServerNodeGroup {
    <#
    .SYNOPSIS
    Gets the Server Node Groups from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Server Node Groups from an AutomateNOW! instance

    .PARAMETER Id
    Optional string containing the simple id of the Server Node Group to fetch or you can pipeline a series of simple id strings. You may not enter an array here.

    .PARAMETER sortBy
    Optional string parameter to sort the results by. Valid choices are: id {To be continued...}

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER Folder
    Optional string to filter by a particular Folder

    .PARAMETER Tags
    Optional string array of Tags to filter by. Note that the 'containsAny' operator will be used.

    .INPUTS
    Accepts a string representing the simple id of the Server Node Group from the pipeline or individually (but not an array).

    .OUTPUTS
    An array of one or more [ANOWServerNodeGroup] class objects

    .EXAMPLE
    Gets the first page of Server Node Groups

    Get-AutomateNOWServerNodeGroup

    .EXAMPLE
    Gets a single Server Node Group

    Get-AutomateNOWServerNodeGroup -Id 'ServerNodeGroup1'

    .EXAMPLE
    Gets a series of Server Node Groups from a list of strings sent across the pipeline

    'ServerNodeGroup1', 'ServerNodeGroup2' | Get-AutomateNOWServerNodeGroup

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWServerNodeGroup[]])]
    [Cmdletbinding()]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $False, ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $False)]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False)]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False)]
        [string]$sortBy = 'id',
        [Parameter(Mandatory = $False)]
        [switch]$Descending,
        [Parameter(Mandatory = $False)]
        [string]$Folder,
        [Parameter(Mandatory = $False)]
        [string[]]$Tags
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 -or $Id.Length -gt 0) {
            If ($_.Length -gt 0 ) {
                [string]$ServerNodeGroupName = $_
            }
            Else {
                [string]$ServerNodeGroupName = $Id
            }
            [string]$textMatchStyle = 'exact'
            $Body.'id' = $ServerNodeGroupName
        }
        Else {
            [string]$textMatchStyle = 'substring'
            $Body.'_constructor' = 'AdvancedCriteria'
            $Body.'operator' = 'and'
            If ($Folder.Length -gt 0) {
                $Body.'criteria1' = ('{"fieldName":"folder","operator":"equals","value":"' + $Folder + '"}')
            }
            If ($Tags.Count -gt 0) {
                If ($Tags.Count -gt 1) {
                    $Error.Clear()
                    Try {
                        [string]$TagString = $Tags | ConvertTo-Json -Compress
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "ConvertTo-Json failed to convert the provided tag names under Get-AutomateNOWServerNodeGroup due to [$Message]."
                        Break
                    }
                }
                Else {
                    [string]$TagString = $Tags
                }
                $Body.'criteria2' = ('{"fieldName":"tags","operator":"containsAny","value":' + $TagString + '}')
            }
        }
        $Body.'_operationType' = 'fetch'
        $Body.'_startRow' = $startRow
        $Body.'_endRow' = $endRow
        $Body.'_textMatchStyle' = $textMatchStyle
        $Body.'_componentId' = 'ServerNodeGroupList'
        $Body.'_dataSource' = 'ServerNodeGroupDataSource'
        If ($Descending -eq $true) {
            $Body.'_sortBy' = '-' + $sortBy
        }
        Else {
            $Body.'_sortBy' = $sortBy
        }
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/serverNodeGroup/read?' + $Body)
        If ($null -ne $parameters.command) {
            $parameters.command = $command
        }
        Else {
            $parameters.Add('command', $command)
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWServerNodeGroup[]]$ServerNodeGroups = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWServerNodeGroup] objects due to [$Message]."
            Break
        }
        If ($ServerNodeGroups.Count -gt 0) {
            Return $ServerNodeGroups
        }
    }
    End {

    }
}

Function Set-AutomateNOWServerNodeGroup {
    <#
    .SYNOPSIS
    Changes the settings of a Server Node Group on an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of a Server Node Group on an AutomateNOW! instance

    .PARAMETER ServerNodeGroup
    An [ANOWServerNodeGroup] object representing the Server Node Group to be changed.

    .PARAMETER Description
    A text description of at least 1 character.

    .PARAMETER UnsetDescription
    Switch parameter that will remove the description.

    .PARAMETER Folder
    (This parameter does not presently work!) String that specifies the name of the folder to place the Server Node Group into.

    .PARAMETER UnsetFolder
    (This parameter does not presently work!) Switch parameter that will remove the Server Node Group from its current folder.

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new Server Node Group.

    .PARAMETER UnsetTags
    Switch parameter that will remove the tags from the Server Node Group.

    .PARAMETER CodeRepository
    Optional Code Repository to place the Server Node Group into. Use Get-AutomateNOWCodeRepository to fetch this object.

    .PARAMETER UnsetCodeRepository
    Switch parameter that will remove the the Server Node Group from its Code Repository.

    .PARAMETER Quiet
    Suppresses the return of the updated object.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWServerNodeGroup] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWServerNodeGroup] object will be returned

    .EXAMPLE
    Forcibly and quietly removes the Description, Folder and Tags from a Server Node Group named 'ServerNodeGroup1' (one-liner format)

    Get-AutomateNOWServerNodeGroup -id 'ServerNodeGroup1' | Set-AutomateNOWServerNodeGroup -UnsetDescription -UnsetTags -UnsetFolder -Force -Quiet

    .EXAMPLE
    Sets the Description, Folder and Tags for a Server Node Group named 'ServerNodeGroup1'

    $UpdatedServerNodeGroup = Get-AutomateNOWServerNodeGroup -id 'ServerNodeGroup1' | Set-AutomateNOWServerNodeGroup -Description 'New Description' -Tags 'Tag1', 'Tag2' -Folder 'Folder1'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    If you have three tags on a Server Node Group and wanted to remove one then use the -SetTags parameter to apply the 2 that you want to keep. If you want to remove all tags then use -UnsetTags.

    Refer to the *-AutomateNOWServerNodeItem functions to manage the Server Node Group Item objects within a Server Node Group.

    #>
    [OutputType([ANOWServerNodeGroup])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWServerNodeGroup]$ServerNodeGroup,
        [ValidateScript({ $_.Length -le 255 })]
        [Parameter(Mandatory = $false, HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetCodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot unset the Description and set it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot unset the Folder and set it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot unset the Tags and set them at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetCodeRepository -eq $true -and $CodeRepository.Id.Length -gt 0) {
            Write-Warning -Message "You cannot unset the Code Repository and set it at the same time. Please choose one or the other."
            Break
        }
        [string]$command = '/serverNodeGroup/update'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWServerNodeGroup]$ServerNodeGroup = $_
        }
        [string]$ServerNodeGroup_id = $ServerNodeGroup.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$ServerNodeGroup_id")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$ServerNodeGroup_exists = ($null -eq (Get-AutomateNOWServerNodeGroup -Id $ServerNodeGroup_id))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWServerNodeGroup failed to check if the Server Node Group [$ServerNodeGroup_id] already existed due to [$Message]."
                Break
            }
            If ($ServerNodeGroup_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not a Server Node Group named [$ServerNodeGroup_id] in the current domain [$current_domain]. Please check into this."
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $ServerNodeGroup_id
            If ($Description.Length -gt 0) {
                $BodyMetaData.'description' = $Description
            }
            ElseIf ($UnsetDescription -eq $true) {
                $BodyMetaData.'description' = $null
            }
            If ($Tags.Count -gt 0) {
                [int32]$total_tags = $Tags.Count
                [int32]$current_tag = 1
                ForEach ($tag_id in $Tags) {
                    $Error.Clear()
                    Try {
                        [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] under Set-AutomateNOWServerNodeGroup due to [$message]"
                        Break
                    }
                    If ($tag_object.simpleId.length -eq 0) {
                        Throw "Set-AutomateNOWServerNodeGroup has detected that the tag [$tag_id] does not appear to exist. Please check again."
                        Break
                    }
                    ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                        [string]$tag_object_simpleId = $tag_object.simpleId
                        Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                        Break
                    }
                    [string]$tag_display = $tag_object | ConvertTo-Json -Compress
                    Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
                    [string]$tag_name_sequence = ('tags' + $current_tag)
                    $BodyMetaData.$tag_name_sequence = $tag_id
                    $current_tag++
                }
            }
            ElseIf ($UnsetTags -eq $true) {
                $BodyMetaData.'tags' = $null
            }
            If ($Folder.Length -gt 0) {
                $Error.Clear()
                Try {
                    [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] actually existed under Set-AutomateNOWServerNodeGroup due to [$Message]"
                    Break
                }
                If ($folder_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] under Set-AutomateNOWServerNodeGroup. Please check again."
                    Break
                }
                [string]$folder_display = $folder_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Adding folder $folder_display to [ANOWServerNodeGroup] [$Id]"
                $BodyMetaData.'folder' = $Folder
            }
            ElseIf ($UnsetFolder -eq $true) {
                $BodyMetaData.'folder' = $null
            }
            If ($CodeRepository.Id.Length -gt 0) {
                [string]$CodeRepository_Id = $CodeRepository.Id
                $Error.Clear()
                Try {
                    [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository_Id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository_Id] actually existed under Set-AutomateNOWServerNodeGroup due to [$Message]"
                    Break
                }
                If ($code_repository_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository_Id] under Set-AutomateNOWServerNodeGroup. Please check again."
                    Break
                }
                $BodyMetaData.'codeRepository' = $CodeRepository_Id
            }
            ElseIf ($UnsetCodeRepository -eq $true) {
                $BodyMetaData.'codeRepository' = $null
            }
            $BodyMetaData.'_operationType' = 'update'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_dataSource' = 'ServerNodeGroupDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ServerNodeGroup_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Server Node Group $ServerNodeGroup_id was successfully updated"
            $Error.Clear()
            Try {
                [ANOWServerNodeGroup]$UpdatedServerNodeGroup = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the returned updated object to an [ANOWServerNodeGroup] object due to [$Message]. The object was still updated though."
                Break
            }
            If ($Quiet -ne $true) {
                Return $UpdatedServerNodeGroup
            }
        }
    }
    End {
    }
}

Function Export-AutomateNOWServerNodeGroup {
    <#
    .SYNOPSIS
    Exports the Server Node Groups from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Server Node Groups from an instance of AutomateNOW! to a local .csv file

    .PARAMETER ServerNodeGroup
    Mandatory [ANOWServerNodeGroup] object (Use Get-AutomateNOWServerNodeGroup to retrieve them)

    .INPUTS
    ONLY [ANOWServerNodeGroup] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWServerNodeGroup] objects are exported to the local disk in CSV format

    .EXAMPLE
    Get-AutomateNOWServerNodeGroup | Export-AutomateNOWServerNodeGroup

    .EXAMPLE
    Get-AutomateNOWServerNodeGroup -Id 'ServerNodeGroup01' | Export-AutomateNOWServerNodeGroup

    .EXAMPLE
    'ServerNodeGroup01', 'ServerNodeGroup02' | Get-AutomateNOWServerNodeGroup | Export-AutomateNOWServerNodeGroup

    .NOTES
	You must present [ANOWServerNodeGroup] objects to the pipeline to use this function.

    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWServerNodeGroup]$ServerNodeGroup
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-ServerNodeGroups-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWServerNodeGroup]$ServerNodeGroup = $_
        }
        $Error.Clear()
        Try {
            $ServerNodeGroup | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWServerNodeGroup] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function New-AutomateNOWServerNodeGroup {
    <#
    .SYNOPSIS
    Creates a Server Node Group within an AutomateNOW! instance

    .DESCRIPTION
    Creates a Server Node Group within an AutomateNOW! instance and returns back the newly created [ANOWServerNodeGroup] object

    .PARAMETER Id
    The intended name of the Server Node Group. For example: 'ServerNodeGroup1'. This value may not contain the domain in brackets.

    .PARAMETER ServerNodeType
    The type of server node that this group represents. Valid choices are: AZURE; AWS; GOOGLE_CLOUD; GOOGLE_DATA_FLOW; AZURE_DATABRICKS; INFORMATICA_CLOUD; UNIX; LINUX; WINDOWS; SOLARIS; HPUX; AIX; OPENVMS; MACOS; AS400; Z_OS; RAINCODE; CTRL_M; OPENTEXT; INFORMATICA; INFORMATICA_WS; SAS; SAS_VIYA; IBM_DATASTAGE; ODI; MS_SSIS; AB_INITIO; SAP_BODI; SKYVIA; TALEND; DBT; DBT_CORE; SAP; SAP_S4_HANA; SAP_S4_HANA_CLOUD; SAP_IBP; JD_EDWARDS; ORACLE_EBS; PEOPLESOFT; MICROSOFT_DYNAMICS; HIVE_QL; GOOGLE_BIG_QUERY; AZURE_SQL_DATA_WAREHOUSE; AZURE_SQL_DATABASE; DASHDB; DB2; MYSQL; NETEZZA; ORACLE; POSTGRESQL; SQL_SERVER; TERADATA; SINGLESTORE; SNOWFLAKE; VERTICA; PRESTO_DB; SYBASE; INFORMIX; H2; FILE_MANAGER; SNMP; HTTP; EMAIL; SOAP_WEB_SERVICE; REST_WEB_SERVICE; INTERNAL; IBM_MQ; RABBIT_MQ; SQS; ACTIVE_MQ; QPID; IBM_SIBUS; HORNETQ; SOLACE; JORAM_MQ; QMQ; ZERO_MQ; KAFKA; PULSAR; AMAZON_KINESIS; GOOGLE_CLOUD_PUB_SUB; MICROSOFT_AZURE_EVENT_HUB; AMQP; XMPP; STOMP; HDFS; REDIS; HADOOP; HIVE; IMPALA; SQOOP; YARN; SPARK; FLUME; FLINK; STORM; OOZIE; AMBARI; ELASTIC_SEARCH; CASSANDRA; SAP_HANA; MONGO_DB; COUCH_DB; COUCH_BASE; DYNAMO_DB; ARANGO_DB; NEO4J; ORIENT_DB; TITAN; ANDROID; IOS; WINDOWS_MOBILE; MICROSOFT_POWER_BI; TABLEAU; BLUE_PRISM; UI_PATH; AUTOMATION_ANYWHERE; WORK_FUSION; PEGA; ROBOT_FRAMEWORK; CONTROL_M; STONEBRANCH; CA_WLA; AUTOMIC_WLA; IBM_WLA; TIDAL; FACEBOOK; INSTAGRAM; TWITTER; YOUTUBE; LINKED_IN; TUMBLR; TIKTOK; REDDIT; TELEGRAM; WHATSAPP; TEAMS; JIRA; SERVICE_NOW; ORACLE_SERVICE_CENTER; BMC_REMEDY; CA_SERVICE_MANAGEMENT; IBM_CONTROL_DESK; HP_OPEN_VIEW_SERVICE_MANAGER; SAP_SOLUTION_MANAGER; AUTOMATE_NOW; APACHE_AIRFLOW; POWER_AUTOMATE; ANSIBLE;

    .PARAMETER Description
    Optional description of the Server Node Group (may not exceed 255 characters).

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new Server Node Group.

    .PARAMETER Folder
    Optional name of the folder to place the Server Node Group into.

    .PARAMETER CodeRepository
    Optional name of the code repository to place the Server Node Group into.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWServerNodeGroup.

    .OUTPUTS
    An [ANOWServerNodeGroup] object representing the newly created Server Node Group

    .EXAMPLE
    Creates a new Server Node Group named 'ServerNodeGroup1' of type Teradata along with a description, tags and a folder.

    New-AutomateNOWServerNodeGroup -Id 'ServerNodeGroup1' -Description 'Description!' -ServerNodeType TERADATA -Tags 'Tag1', 'Tag2' -Folder 'Folder1'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWServerNodeGroup])]
    [Cmdletbinding()]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $true)]
        [string]$Id,
        [Parameter(Mandatory = $true)]
        [ANOWServerNodeGroup_serverNodeType]$ServerNodeType,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [string]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [boolean]$ServerNodeGroup_exists = ($null -ne (Get-AutomateNOWServerNodeGroup -Id $Id))
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWServerNodeGroup failed to check if the Server Node Group [$Id] already existed due to [$Message]."
        Break
    }
    If ($ServerNodeGroup_exists -eq $true) {
        [string]$current_domain = $anow_session.header.domain
        Write-Warning -Message "There is already a Server Node Group named [$Id] in [$current_domain]. Please check into this."
        Break
    }
    ## End warning ##
    [System.Collections.Specialized.OrderedDictionary]$ANOWServerNodeGroup = [System.Collections.Specialized.OrderedDictionary]@{}
    $ANOWServerNodeGroup.Add('id', $Id)
    If ($Description.Length -gt 0) {
        $ANOWServerNodeGroup.Add('description', $Description)
    }
    If ($Tags.Count -gt 0) {
        [int32]$total_tags = $Tags.Count
        [int32]$current_tag = 1
        ForEach ($tag_id in $Tags) {
            $Error.Clear()
            Try {
                [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] under New-AutomateNOWServerNodeGroup due to [$message]"
                Break
            }
            If ($tag_object.simpleId.length -eq 0) {
                Throw "New-AutomateNOWServerNodeGroup has detected that the tag [$tag_id] does not appear to exist. Please check again."
                Break
            }
            ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                [string]$tag_object_simpleId = $tag_object.simpleId
                Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                Break
            }
            [string]$tag_display = $tag_object | ConvertTo-Json -Compress
            Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
            [string]$tag_name_sequence = ('tags' + $current_tag)
            $ANOWServerNodeGroup.Add($tag_name_sequence, $tag_id)
            $include_properties += $tag_name_sequence
            $current_tag++
        }
    }
    If ($Folder.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] actually existed under New-AutomateNOWServerNodeGroup due to [$Message]"
            Break
        }
        If ($folder_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] under New-AutomateNOWServerNodeGroup. Please check again."
            Break
        }
        [string]$folder_display = $folder_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding folder $folder_display to [ANOWServerNodeGroup] [$Id]"
        $ANOWServerNodeGroup.Add('folder', $Folder)
        $include_properties += 'folder'
    }
    If ($CodeRepository.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository] actually existed under New-AutomateNOWServerNodeGroup due to [$Message]"
            Break
        }
        If ($code_repository_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository] under New-AutomateNOWServerNodeGroup. Please check again."
            Break
        }
        [string]$code_repository_display = $code_repository_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding code repository $code_repository_display to [ANOWServerNodeGroup] [$Id]"
        $ANOWServerNodeGroup.Add('codeRepository', $CodeRepository)
        $include_properties += 'codeRepository'
    }
    [string]$BodyObject = ConvertTo-QueryString -InputObject $ANOWServerNodeGroup
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    $BodyMetaData.'serverNodeType' = $ServerNodeType
    $BodyMetaData.'_operationType' = 'add'
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_oldValues' = ('{"serverNodeType":"' + $ServerNodeType + '"}')
    $BodyMetaData.'_componentId' = 'ServerNodeGroupCreateWindow_form'
    $BodyMetaData.'_dataSource' = 'ServerNodeGroupDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$BodyMetaDataString = ConvertTo-QueryString -InputObject $BodyMetaData
    [string]$Body = ($BodyObject + '&' + $BodyMetaDataString)
    [string]$command = '/serverNodeGroup/create'
    [hashtable]$parameters = @{}
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('Body', $Body)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWServerNodeGroup]$ServerNodeGroup = $results.response.data | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to create a new [ANOWServerNodeGroup] object due to [$Message]."
        Break
    }
    If ($ServerNodeGroup.id.Length -eq 0) {
        Write-Warning -Message "Somehow the newly created [ANOWServerNodeGroup] object is empty!"
        Break
    }
    Return $ServerNodeGroup

}

Function Remove-AutomateNOWServerNodeGroup {
    <#
    .SYNOPSIS
    Removes a Server Node Group from an AutomateNOW! instance

    .DESCRIPTION
    Removes a Server Node Group from an AutomateNOW! instance

    .PARAMETER ServerNodeGroup
    An [ANOWServerNodeGroup] object representing the Server Node Group to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWServerNodeGroup] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Get-AutomateNOWServerNodeGroup -Id 'ServerNodeGroup01' | Remove-AutomateNOWServerNodeGroup

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWServerNodeGroup]$ServerNodeGroup,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/serverNodeGroup/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWServerNodeGroup]$ServerNodeGroup = $_
        }
        [string]$ServerNodeGroup_id = $ServerNodeGroup.id
        If ($ServerNodeGroup_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ServerNodeGroup_id)")) -eq $true) {
            [string]$oldvalues = $ServerNodeGroup.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $ServerNodeGroup_id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'ServerNodeGroupList'
            $BodyMetaData.'_dataSource' = 'ServerNodeGroupDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ServerNodeGroup_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Server Node Group $ServerNodeGroup_id successfully removed"
        }
    }
    End {

    }
}

Function Copy-AutomateNOWServerNodeGroup {
    <#
    .SYNOPSIS
    Copies a Server Node Group from an AutomateNOW! instance

    .DESCRIPTION
    Copies a Server Node Group from an AutomateNOW! instance. AutomateNOW object id can never be changed, but we can copy the Server Node Group to a new object with a new Id and it will include all of the settings but not the items.

    .PARAMETER ServerNodeGroup
    Mandatory [ANOWServerNodeGroup] object to be copied.

    .PARAMETER NewId
    The name (Id) of the new Server Node Group. The new Id must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    .PARAMETER UnsetDescription
    Optional switch that will ensure that the newly created Server Node Group will not have a description set.

    .PARAMETER Description
    Optional description to set on the new Server Node Group object. If you do not set this, the new Server Node Group object will copy the Description of the source object.

    .PARAMETER UnsetFolder
    Optional switch that will ensure that the newly created Server Node Group will not have a Folder set.

    .PARAMETER Folder
    Optional description to set a different folder on the new Server Node Group object. If you do not set this, the new Server Node Group object will use the same Folder of the source object.

    .PARAMETER UnsetTags
    Optional switch that will ensure that the newly created Server Node Group will not have any Tags set.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the new Server Node Group object. If you do not set this, the new Server Node Group object will apply the same Tags of the source object.

    .PARAMETER Force
    Force the copy without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    ONLY [ANOWServerNodeGroup] object is accepted. Pipeline support is intentionally unavailable.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Creates a copy of a Server Node Group named 'ServerNodeGroup1' and changes the description (multi-line format)
    $ServerNodeGroup1 = Get-AutomateNOWServerNodeGroup -Id 'ServerNodeGroup1'
    Copy-AutomateNOWServerNodeGroup -ServerNodeGroup $ServerNodeGroup1 -NewId 'ServerNodeGroup2' -Description 'ServerNodeGroup2 (Production)'

    .EXAMPLE
    Creates a copy of a Server Node Group named 'ServerNodeGroup1' where the description is omitted and different tags are set (one-liner format)
    Copy-AutomateNOWServerNodeGroup -ServerNodeGroup (Get-AutomateNOWServerNodeGroup -Id 'ServerNodeGroup1') -NewId 'ServerNodeGroup2' -UnsetDescription -Tags 'Tag1', 'Tag2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWServerNodeGroup]$ServerNodeGroup,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot set the Tags and unset them at the same time. Please choose one or the other. Tags from the source object will be carried over to the new object if you do not specify any tag-related parameters."
            Break
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$ServerNodeGroup_exists = ($null -ne (Get-AutomateNOWServerNodeGroup -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWServerNodeGroup failed to check if the Server Node Group [$NewId] already existed due to [$Message]."
            Break
        }
        If ($ServerNodeGroup_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Server Node Group named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End warning ##
        [string]$command = '/serverNodeGroup/copy'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            [string]$ServerNodeGroup_oldId = $ServerNodeGroup.id
            [string]$ServerNodeGroup_simpleId = $ServerNodeGroup.simpleId
            If ($ServerNodeGroup_oldId -eq $NewId) {
                Write-Warning -Message "The new id cannot be the same as the old id."
                Break
            }
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Copy the ServerNodeGroup $($ServerNodeGroup_simpleId) to $($NewId)?")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                If ($UnsetFolder -eq $True) {
                    $BodyMetaData.'folder' = $Null
                }
                ElseIf ($Folder.Length -gt 0) {
                    $BodyMetaData.'folder' = $Folder
                }
                Else {
                    If ($ServerNodeGroup.folder.Length -gt 0) {
                        $BodyMetaData.'folder' = $ServerNodeGroup.folder
                    }
                }
                If ($Tags.Count -gt 0) {
                    [int32]$tag_count = 1
                    ForEach ($tag in $Tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
                ElseIf ($UnsetTags -eq $true) {
                    $BodyMetaData.'tags' = $Null
                }
                Else {
                    If ($ServerNodeGroup.Tags -gt 0) {
                        [int32]$tag_count = 1
                        ForEach ($tag in $ServerNodeGroup.tags) {
                            $BodyMetaData.('tags' + $tag_count ) = $tag
                            $tag_count++
                        }
                    }
                }
                $BodyMetaData.'oldId' = $ServerNodeGroup_oldId
                $BodyMetaData.'domain' = $ServerNodeGroup.domain
                $BodyMetaData.'id' = $NewId
                If ($UnsetDescription -ne $true) {
                    If ($Description.Length -gt 0) {
                        $BodyMetaData.'description' = $Description
                    }
                    Else {
                        $BodyMetaData.'description' = $ServerNodeGroup.description
                    }
                }
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_operationId' = 'copy'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_dataSource' = 'ServerNodeGroupDataSource'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties oldId, domain, NewId, description, folder, tags
                $parameters.Body = $Body
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ServerNodeGroup_oldId] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                $Error.Clear()
                Try {
                    [ANOWServerNodeGroup]$NewServerNodeGroup = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to create copied [ANOWServerNodeGroup] object [$NewId] due to [$Message]."
                    Break
                }
                If ($NewServerNodeGroup.id.Length -eq 0) {
                    Write-Warning -Message "Somehow the newly created (copied) [ANOWServerNodeGroup] object [$NewId] is empty!"
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $NewServerNodeGroup
                }
            }
        }
    }
    End {

    }
}

Function Rename-AutomateNOWServerNodeGroup {
    <#
    .SYNOPSIS
    Renames a Server Node Group on an AutomateNOW! instance

    .DESCRIPTION
    Performs a psuedo-rename operations of a Server Node Group from an AutomateNOW! instance by copying it first and then deleting the source. This function merely combines Copy-AutomateNOWServer Node Group and Remove-AutomateNOWServerNodeGroup therefore it is to be considered destructive.

    .PARAMETER ServerNodeGroup
    An [ANOWServerNodeGroup] object representing the Server Node Group to be renamed.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the Server Node Group. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER Force
    Force the renaming without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly renamed object.

    .INPUTS
    ONLY [ANOWServerNodeGroup] objects are accepted. There is intentionally no support for the pipeline.

    .OUTPUTS
    The newly renamed [ANOWServerNodeGroup] object will be returned.

    .EXAMPLE
    $ServerNodeGroup = Get-AutomateNOWServerNodeGroup -Id 'ServerNodeGroup1'
    Rename-AutomateNOWServerNodeGroup -ServerNodeGroup $ServerNodeGroup -NewId 'ServerNodeGroup2'

    .EXAMPLE
    Rename-AutomateNOWServerNodeGroup -ServerNodeGroup (Get-AutomateNOWServerNodeGroup -Id 'ServerNodeGroup1') -NewId 'ServerNodeGroup2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    When renaming, you may only specify a different Id (name).

    This action will be blocked if any existing referrals are found on the object.
    #>
    [OutputType([ANOWServerNodeGroup])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWServerNodeGroup]$ServerNodeGroup,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin standard warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$new_ServerNodeGroup_exists = ($null -ne (Get-AutomateNOWServerNodeGroup -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWServerNodeGroup failed to check if the Server Node Group [$NewId] already existed due to [$Message]."
            Break
        }
        If ($new_ServerNodeGroup_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Server Node Group named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        #[string]$ServerNodeGroup_id = $ServerNodeGroup.id
        [string]$ServerNodeGroup_id = $ServerNodeGroup.simpleId
        $Error.Clear()
        Try {
            [boolean]$old_ServerNodeGroup_exists = ($null -ne (Get-AutomateNOWServerNodeGroup -Id $ServerNodeGroup_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWServerNodeGroup failed to check if the Server Node Group [$ServerNodeGroup_id] already existed due to [$Message]."
            Break
        }
        If ($old_ServerNodeGroup_exists -eq $false) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not a Server Node Group named [$ServerNodeGroup_id] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End standard warning ##
        ## Begin referrals warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [int32]$referrals_count = Find-AutomateNOWObjectReferral -ServerNodeGroup $ServerNodeGroup -Count | Select-Object -Expandproperty referrals
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Find-AutomateNOWObjectReferral failed to extract the referrals on Server Node Group [$ServerNodeGroup_id] due to [$Message]."
            Break
        }
        If ($referrals_count -gt 0) {
            Write-Warning -Message "Unfortunately, you cannot rename a Server Node Group that has referrals. This is because the rename is not actually renaming but copying anew and deleting the old. Please, use the Find-AutomateNOWObjectReferral function to identify referrals and remove them."
            Break
        }
        Else {
            Write-Verbose -Message "The Server Node Group [$ServerNodeGroup_id] does not have any referrals. It is safe to proceed."
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ServerNodeGroup_id)")) -eq $true) {
                $Error.Clear()
                Try {
                    [ANOWServerNodeGroup]$new_ServerNodeGroup = Copy-AutomateNOWServerNodeGroup -ServerNodeGroup $ServerNodeGroup -NewId $NewId -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Copy-AutomateNOWServerNodeGroup failed to create a new Server Node Group [$NewId] as Part 1 of the renaming process due to [$Message]."
                    Break
                }
                If ($new_ServerNodeGroup.simpleId -eq $NewId) {
                    Write-Verbose -Message "Part 1: Server Node Group [$ServerNodeGroup_id] successfully copied to [$NewId]"
                }
                Else {
                    Write-Warning -Message "Somehow the first phase (Copy-AutomateNOWServerNodeGroup) failed. Please look into this."
                    Break
                }
                $Error.Clear()
                Try {
                    Remove-AutomateNOWServerNodeGroup -ServerNodeGroup $ServerNodeGroup -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Remove-AutomateNOWServerNodeGroup failed to remove [$ServerNodeGroup_id] as Part 2 of the renaming process due to [$Message]."
                    Break
                }
                Write-Verbose -Message "Part 2: Server Node Group [$ServerNodeGroup_id] removed"
                Write-Verbose -Message "Task [$ServerNodeGroup_id] successfully renamed to [$NewId]"
                If ($Quiet -ne $true) {
                    Return $new_ServerNodeGroup
                }
            }
        }
        Else {
            Write-Warning -Message "No action was taken because either the source object didn't exist or the new object already existed"
        }
    }
    End {
    }
}

#endregion

#Region - ServerNode Group Items

Function Read-AutomateNOWServerNodeGroupItem {
    <#
    .SYNOPSIS
    Reads the items in a Server Node Group on an AutomateNOW! instance

    .DESCRIPTION
    Reads the items in a Server Node Group on an AutomateNOW! instance

    .PARAMETER ServerNodeGroup
    Mandatory [ANOWServerNodeGroup] object representing the Server Node Group to be read.

    .PARAMETER sortBy
    Optional string parameter to sort the results by. Valid choices are: sortOrder*, id, ServerNodeGroup, dateCreated, lastUpdatedBy, lastUpdated

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER ServerNode
    Optional [ANOWServerNode] object to filter the results by. This parameter is exclusive from the others.

    .PARAMETER Id
    Optional GUID Id string of the Server Node Group Item to filter the results by. This parameter is exclusive from the others.

    .INPUTS
    ONLY [ANOWServerNodeGroup] objects are accepted (including from the pipeline)

    .OUTPUTS
    [ANOWServerNodeGroupItem] objects will be returned.

    .EXAMPLE
    Gets the first page of Server Node Group Items from a Server Node Group named 'ServerNodeGroup1' via the pipeline (one-liner format)

    Get-AutomateNOWServerNodeGroup -Id 'ServerNodeGroup1' | Read-AutomateNOWServerNodeGroupItem

    .EXAMPLE
    Gets a specific Server Node Group Item with an Id of '1a232f1c-b72b-44e0-ab0a-a2f3d32d2172' from a Server Node Group Named 'ServerNodeGroup1' (one-liner format)

    Get-AutomateNOWServerNodeGroup -id 'ServerNodeGroup1' | Read-AutomateNOWServerNodeGroupItem -Id '1a232f1c-b72b-44e0-ab0a-a2f3d32d2172'

    .EXAMPLE
    Gets a specific Server Node Group Item that is associated with a Server Node named 'ServerNode1' from a Server Node Group Named 'ServerNodeGroup1' (one-liner format)

    Get-AutomateNOWServerNodeGroup -id 'ServerNodeGroup1' | Read-AutomateNOWServerNodeGroupItem -ServerNode (Get-AutomateNOWServerNode -Id 'ServerNode1')

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWServerNodeGroupItem[]])]
    [Cmdletbinding( DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWServerNodeGroup]$ServerNodeGroup,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100,
        [ValidateSet( 'sortOrder', 'id', 'ServerNodeGroup', 'dateCreated', 'lastUpdatedBy', 'lastUpdated', ignoreCase = $false)]
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$sortBy = 'sortOrder',
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$Descending,
        [Parameter(Mandatory = $False, ParameterSetName = 'ServerNode')]
        [ANOWServerNode]$ServerNode,
        [Parameter(Mandatory = $False, ParameterSetName = 'Id')]
        [ValidateScript({ $_ -match '[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}' })]
        [string]$Id
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWServerNodeGroup]$ServerNodeGroup = $_
        }
        [string]$ServerNodeGroup_id = $ServerNodeGroup.Id
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        $BodyMetaData.Add('_operationType', 'fetch')

        If ($Id.Length -gt 0) {
            $BodyMetaData.Add('id', $Id)
            [string]$textMatchStyle = 'exactCase'
        }
        ElseIf ($ServerNode.Id.Length -gt 0) {
            [string]$ServerNodeId = $ServerNode.simpleId
            $BodyMetaData.Add('serverNode', $ServerNodeId)
            [string]$textMatchStyle = 'exactCase'
        }
        Else {
            $BodyMetaData.Add('serverNodeGroup', $ServerNodeGroup_id)
            $BodyMetaData.Add('_startRow', $startRow)
            $BodyMetaData.Add('_endRow', $endRow)
            If ($Descending -eq $true) {
                $BodyMetaData.'_sortBy' = '-' + $sortBy
            }
            Else {
                $BodyMetaData.'_sortBy' = $sortBy
            }
            [string]$textMatchStyle = 'exact'
        }
        $BodyMetaData.Add('_textMatchStyle', $textMatchStyle)
        $BodyMetaData.Add('_componentId', 'ServerNodeGroupItemList')
        $BodyMetaData.Add('_dataSource', 'ServerNodeGroupItemDataSource')
        $BodyMetaData.Add('isc_metaDataPrefix', '_')
        $BodyMetaData.Add('isc_dataFormat', 'json')
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        [string]$command = ('/serverNodeGroupItem/read' + '?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.'Command' = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ScheduleTemplate_id] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        If ($results.response.data.count -gt 0) {
            [PSCustomObject[]]$temp_results = ForEach ($result in $results.response.data) {
                [PSCustomObject]$result = $result | Select-Object -ExcludeProperty serverNodeGroup
                $result | Add-Member -MemberType NoteProperty -Name serverNodeGroup -Value $ServerNodeGroup -TypeName ANOWServerNodeGroup -Force
                $result
            }
            $Error.Clear()
            Try {
                [ANOWServerNodeGroupItem[]]$ServerNodeGroupItems = $temp_results
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the Server Node Group Items from $ServerNodeGroup_id into [ANOWServerNodeGroupItem] objects due to [$Message]"
                Break
            }
            Write-Verbose -Message "Server Node Group Items successfully read from $ServerNodeGroup_id"
            If ($ServerNodeGroupItems.Count -gt 0) {
                Return $ServerNodeGroupItems
            }
        }
        Else {
            Write-Verbose -Message "There were no Server Node Group Items within $ServerNodeGroup_id"
        }
    }
    End {

    }
}

Function Add-AutomateNOWServerNodeGroupItem {
    <#
    .SYNOPSIS
    Adds a Server Node to a Server Node Group within an AutomateNOW! instance

    .DESCRIPTION
    Adds a Server Node to a Server Node Group within an AutomateNOW! instance

    .PARAMETER ServerNode
    Mandatory [ANOWServerNode] object. Use Get-AutomateNOWServerNode to get this object.

    .PARAMETER ServerNodeGroup
    Mandatory [ANOWServerNodeGroup] object. Use Get-AutomateNOWServerNodeGroup to get this object.

    .PARAMETER ServerNode
    Mandatory [ANOWServerNode] object to be added to the Server Node Group. Use Get-AutomateNOWServerNode to get this object.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object

    .PARAMETER Force
    Force the addition of the object without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    An [ANOWServerNode] object and an [ANOWServerNodeGroup] object.

    .OUTPUTS
    An [ANOWServerNodeGroupItem] object representing the newly created Server Node Group Item

    .EXAMPLE
    Forcefully and quietly adds all Windows nodes to a Server Node Group named 'ServerNodeGroup1' (multi-line format)

    $ServerNodeGroup = Get-AutomateNOWServerNodeGroup -id 'ServerNodeGroup1'
    $ServerNodes = Get-AutomateNOWServerNode -serverNodeType WINDOWS
    $ServerNodes | Add-AutomateNOWServerNodeGroupItem -ServerNodeGroup $ServerNodeGroup -Force -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The sort order is calculated for you automatically.

    #>
    [OutputType([ANOWDataSourceItem])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWServerNode]$ServerNode,
        [Parameter(Mandatory = $true)]
        [ANOWServerNodeGroup]$ServerNodeGroup,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        [string]$ServerNodeGroup_Id = $ServerNodeGroup.Id
        $Error.Clear()
        Try {
            [ANOWServerNodeGroupItem[]]$ServerNodeGroup_Items = $ServerNodeGroup | Read-AutomateNOWServerNodeGroupItem
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Read-AutomateNOWServerNodeGroupItem failed to read the Server Node Group Items within $ServerNodeGroup_Id under Add-AutomateNOWServerNodeGroupItem due to [$Message]."
            Break
        }
        If ($ServerNodeGroup_Items.Count -gt 0) {
            [int32]$global:last_sort_order = ($ServerNodeGroup_Items.sortOrder | Measure-Object -Maximum | Select-Object -ExpandProperty Maximum) + 1
        }
        Else {
            [int32]$global:last_sort_order = 0
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Command', '/serverNodeGroupItem/create')
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWServerNode]$ServerNode = $_
        }
        [string]$ServerNode_id = $ServerNode.simpleId
        If ($ServerNodeGroup_Items.serverNode -contains $ServerNode_id) {
            Write-Warning -Message "$ServerNodeGroup_Id already contains $ServerNode_id"
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Add $ServerNode_id to $($ServerNodeGroup_Id) under sort order [$global:last_sort_order]?")) -eq $true) {
            $BodyMetaData.'serverNodeGroup' = $ServerNodeGroup_Id
            $BodyMetaData.'serverNode' = $ServerNode_id
            $BodyMetaData.'sortOrder' = $global:last_sort_order
            $BodyMetaData.'_operationType' = 'add'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_componentId' = 'ServerNodeGroupItemList'
            $BodyMetaData.'_dataSource' = 'ServerNodeGroupItemDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            [string]$parameters_display = $parameters | ConvertTo-Json -Compress
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Server Node $ServerNode_id was added to Server Node Group $ServerNodeGroup_Id as sort order $global:last_sort_order"
            $Error.Clear()
            Try {
                [ANOWServerNodeGroupItem]$ServerNodeGroupItem = $results.response.data | Select-Object -First 1 | Select-Object -ExcludeProperty serverNodeGroup | Add-Member -MemberType NoteProperty -Name serverNodeGroup -Value $ServerNodeGroup -TypeName ANOWServerNodeGroup
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the returned object into an [ANOWServerNodeGroupItem] object due to [$Message]."
                Break
            }
            $global:last_sort_order++
            If ($Quiet -ne $true) {
                Return $ServerNodeGroupItem
            }
        }
    }
    End {

    }
}

Function Remove-AutomateNOWServerNodeGroupItem {
    <#
    .SYNOPSIS
    Removes (deletes) an item from a Server Node Group in an AutomateNOW! instance

    .DESCRIPTION
    Removes (deletes) an item from a Server Node Group in an AutomateNOW! instance

    .PARAMETER ServerNodeGroupItem
    Mandatory [ANOWServerNodeGroupItems] object to be removed from a Server Node Group. Use Read-AutomateNOWServerNodeGroupItem to retrieve them.

    .PARAMETER Force
    Force the removal of the object without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the display of the results

    .INPUTS
    You must pass [ANOWServerNodeGroupItems] objects. The pipeline may be used.

    .OUTPUTS
    The object that was removed from the Server Node Group will be returned

    .EXAMPLE
    Forcibly removes the first page of Server Node Group Items from a Server Node Group named 'ServerNodeGroup1' via the pipeline (one-liner format)

    Get-AutomateNOWServerNodeGroup -Id 'ServerNodeGroup1' | Read-AutomateNOWServerNodeGroupItem | Remove-AutomateNOWServerNodeGroupItem -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([PSCustomObject])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWServerNodeGroupItem]$ServerNodeGroupItem,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('Command', '/serverNodeGroupItem/delete')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Id.Length -gt 0 ) {
            [ANOWServerNodeGroupItem]$ServerNodeGroupItem = $_
        }
        [string]$Item_id = $ServerNodeGroupItem.id
        [ANOWServerNodeGroup]$ServerNodeGroup = $ServerNodeGroupItem.serverNodeGroup
        [string]$ServerNodeGroup_Id = $ServerNodeGroup.id
        If ($Item_id.Length -eq 0) {
            Write-Warning -Message "Somehow a Server Node Group Item with an empty Id was passed to Remove-AutomateNOWServerNodeGroupItem. Please look into this."
            Break
        }
        [string]$Item_Domain = $ServerNodeGroupItem.domain
        If ($Item_Domain.Length -eq 0) {
            Write-Warning -Message "Somehow a Server Node Group Item with an empty domain was passed to Remove-AutomateNOWServerNodeGroupItem. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$Item_id")) -eq $true) {
            [string]$old_values = $ServerNodeGroupItem.CreateOldValues()
            $Body.'serverNodeGroup' = $ServerNodeGroup_Id
            $Body.'_operationType' = 'remove'
            $Body.'id' = $Item_id
            $Body.'_oldValues' = $old_values
            $Body.'_textMatchStyle' = 'exact'
            $Body.'_componentId' = 'ServerNodeGroupItemList'
            $Body.'_dataSource' = 'ServerNodeGroupItemDataSource'
            $Body.'isc_metaDataPrefix' = '_'
            $Body.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $Body
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "$Item_id was removed from its Server Node Group"
        }
    }
    End {

    }
}

Function Push-AutomateNOWServerNodeGroupItem {
    <#
    .SYNOPSIS
    Moves (pushes) a Server Node Group Item to the top of the list (stack) within a Server Node Group.

    .DESCRIPTION
    Moves (pushes) a Server Node Group Item to the top of the list (stack) within a Server Node Group.

    .PARAMETER ServerNodeGroupItem
    An [ANOWServerNodeGroupItem] object representing the Server Node Group Item to be moved (popped) to the top of the list (stack).

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWServerNodeGroupItem] objects are accepted (including from the pipeline)

    .OUTPUTS
    A verbose information message will be sent indicating success

    .EXAMPLE
    Forcibly pushes a Server Node Group Item representing the Server Node named 'ServerNode1' to the top of the list of the Server Node Group named 'ServerNodeGroup1'

    Get-AutomateNOWServerNodeGroup -id 'ServerNodeGroup1' | Read-AutomateNOWServerNodeGroupItem | Where-Object { $_.serverNode -ceq 'ServerNode1' } | Push-AutomateNOWServerNodeGroupItem -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This function is equivalent to selecting a Server Node Group Item and clicking 'Move Up' until it is at the top of the Server Node Group.

    This function will reset the sort order of the Server Node Group Items starting from 0

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWServerNodeGroupItem]$ServerNodeGroupItem,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/serverNodeGroupItem/update'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.Id.Length -gt 0) {
            [ANOWServerNodeGroupItem]$ServerNodeGroupItem = $_
        }
        [string]$ServerNodeGroupItem_id = $ServerNodeGroupItem.id
        [string]$ServerNodeGroupItem_name = $ServerNodeGroupItem.serverNode
        [ANOWServerNodeGroup]$ServerNodeGroup = $ServerNodeGroupItem.serverNodeGroup
        [string]$ServerNodeGroup_id = $ServerNodeGroup.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$ServerNodeGroupItem_name to the top of $ServerNodeGroup_id's stack?")) -eq $true) {
            $Error.Clear()
            Try {
                [ANOWServerNodeGroupItem[]]$ServerNodeGroupItems = Read-AutomateNOWServerNodeGroupItem -ServerNodeGroup $ServerNodeGroup
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Read-AutomateNOWServerNodeGroupItem failed to parse the response into [ANOWServerNodeGroupItem] objects under Push-AutomateNOWServerNodeGroupItem due to [$Message]."
                Break
            }
            If ($ServerNodeGroupItems.count -eq 0) {
                Write-Warning -Message "Somehow the Server Node Group does not have any Server Node Group Items. Please look into this."
                Break
            }
            [string]$old_values = $ServerNodeGroupItem.CreateOldValues()
            [PSCustomObject[]]$ServerNodeGroupItem_collection = ([PSCustomObject[]]($ServerNodeGroupItems | Where-Object { $_.Id -eq $ServerNodeGroupItem_id } | Select-Object -Property endpoint, Id, sortOrder) + [PSCustomObject[]]($ServerNodeGroupItems | Sort-Object -Property sortOrder, Id | Where-Object { $_.Id -ne $ServerNodeGroupItem_id } | Select-Object -Property endpoint, Id, sortOrder))
            [int32]$ServerNodeGroupItem_order_count = $ServerNodeGroupItem_collection.count
            Write-Verbose -Message "Discovered [$ServerNodeGroupItem_order_count] Server Node Group Items within $ServerNodeGroup_id"
            [int32]$current_server_node = 0
            ForEach ($temp_server_node_group in $ServerNodeGroupItem_collection) {
                [string]$ServerNodeGroupItem_id = $temp_server_node_group.id
                [string]$ServerNodeGroupItem_name = $temp_server_node_group.serverNode
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                $BodyMetaData.Add('id', $ServerNodeGroupItem_id )
                $BodyMetaData.Add('sortOrder', $current_server_node )
                $BodyMetaData.Add('_operationType', 'update')
                $BodyMetaData.Add('_textMatchStyle', 'exact')
                $BodyMetaData.Add('_oldValues', $old_values)
                $BodyMetaData.Add('_componentId', 'ServerNodeGroupItemList')
                $BodyMetaData.Add('_dataSource', 'ServerNodeGroupItemDataSource')
                $BodyMetaData.Add('isc_metaDataPrefix', '_')
                $BodyMetaData.Add('isc_dataFormat', 'json')
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
                If ($null -eq $parameters.'Body') {
                    $parameters.Add('Body', $Body)
                }
                Else {
                    $parameters.'Body' = $Body
                }
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on ($ServerNodeGroupItem_name / $ServerNodeGroup_id) due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                Write-Verbose -Message "Server Node Group Item ($ServerNodeGroupItem_name / $ServerNodeGroup_id) was successfully set to sortOrder [$current_server_node]"
                $current_server_node++
            }
        }
    }
    End {

    }
}

Function Pop-AutomateNOWServerNodeGroupItem {
    <#
    .SYNOPSIS
    Moves (pops) a Server Node Group Item to the bottom of the list (stack) within a Server Node Group.

    .DESCRIPTION
    Moves (pops) a Server Node Group Item to the bottom of the list (stack) within a Server Node Group.

    .PARAMETER ServerNodeGroupItem
    An [ANOWServerNodeGroupItem] object representing the Server Node Group Item to be moved (popped) to the top of the list (stack).

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWServerNodeGroupItem] objects are accepted (including from the pipeline)

    .OUTPUTS
    A verbose information message will be sent indicating success

    .EXAMPLE
    Forcibly pops a Server Node Group Item representing the Server Node named 'ServerNode1' to the bottom of the list of the Server Node Group named 'ServerNodeGroup1'

    Get-AutomateNOWServerNodeGroup -id 'ServerNodeGroup1' | Read-AutomateNOWServerNodeGroupItem | Where-Object { $_.serverNode -ceq 'ServerNode1' } | Pop-AutomateNOWServerNodeGroupItem -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This function is equivalent to selecting a Server Node Group Item and clicking 'Move Down' until it is at the bottom of the Server Node Group.

    This function will reset the sort order of the Server Node Group Items starting from 0

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWServerNodeGroupItem]$ServerNodeGroupItem,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/serverNodeGroupItem/update'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.Id.Length -gt 0) {
            [ANOWServerNodeGroupItem]$ServerNodeGroupItem = $_
        }
        [string]$ServerNodeGroupItem_id = $ServerNodeGroupItem.id
        [string]$ServerNodeGroupItem_name = $ServerNodeGroupItem.serverNode
        [ANOWServerNodeGroup]$ServerNodeGroup = $ServerNodeGroupItem.serverNodeGroup
        [string]$ServerNodeGroup_id = $ServerNodeGroup.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$ServerNodeGroupItem_name to the bottom of $ServerNodeGroup_id's stack?")) -eq $true) {
            $Error.Clear()
            Try {
                [ANOWServerNodeGroupItem[]]$ServerNodeGroupItems = Read-AutomateNOWServerNodeGroupItem -ServerNodeGroup $ServerNodeGroup
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Read-AutomateNOWServerNodeGroupItem failed to parse the response into [ANOWServerNodeGroupItem] objects under Push-AutomateNOWServerNodeGroupItem due to [$Message]."
                Break
            }
            If ($ServerNodeGroupItems.count -eq 0) {
                Write-Warning -Message "Somehow the Server Node Group does not have any Server Node Group Items. Please look into this."
                Break
            }
            [string]$old_values = $ServerNodeGroupItem.CreateOldValues()
            [PSCustomObject[]]$ServerNodeGroupItem_collection = ([PSCustomObject[]]($ServerNodeGroupItems | Sort-Object -Property sortOrder, Id | Where-Object { $_.Id -ne $ServerNodeGroupItem_id } | Select-Object -Property endpoint, Id, sortOrder) + [PSCustomObject[]]($ServerNodeGroupItems | Where-Object { $_.Id -eq $ServerNodeGroupItem_id } | Select-Object -Property endpoint, Id, sortOrder))
            [int32]$ServerNodeGroupItem_order_count = $ServerNodeGroupItem_collection.count
            Write-Verbose -Message "Discovered [$ServerNodeGroupItem_order_count] Server Node Group Items within $ServerNodeGroup_id"
            [int32]$current_server_node = 0
            ForEach ($temp_server_node_group in $ServerNodeGroupItem_collection) {
                [string]$ServerNodeGroupItem_id = $temp_server_node_group.id
                [string]$ServerNodeGroupItem_name = $temp_server_node_group.serverNode
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                $BodyMetaData.Add('id', $ServerNodeGroupItem_id )
                $BodyMetaData.Add('sortOrder', $current_server_node )
                $BodyMetaData.Add('_operationType', 'update')
                $BodyMetaData.Add('_textMatchStyle', 'exact')
                $BodyMetaData.Add('_oldValues', $old_values)
                $BodyMetaData.Add('_componentId', 'ServerNodeGroupItemList')
                $BodyMetaData.Add('_dataSource', 'ServerNodeGroupItemDataSource')
                $BodyMetaData.Add('isc_metaDataPrefix', '_')
                $BodyMetaData.Add('isc_dataFormat', 'json')
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
                If ($null -eq $parameters.'Body') {
                    $parameters.Add('Body', $Body)
                }
                Else {
                    $parameters.'Body' = $Body
                }
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on ($ServerNodeGroupItem_name / $ServerNodeGroup_id) due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                Write-Verbose -Message "Server Node Group Item ($ServerNodeGroupItem_name / $ServerNodeGroup_id) was successfully set to sortOrder [$current_server_node]"
                $current_server_node++
            }
        }
    }
    End {

    }
}

#endregion

#Region - Service Managers (PROCESSING)

Function Get-AutomateNOWServiceManager {
    <#
    .SYNOPSIS
    Gets the ServiceManagers from an AutomateNOW! instance

    .DESCRIPTION
    Gets the ServiceManagers from an AutomateNOW! instance

    .PARAMETER Id
    A single int64 containing the NUMERICAL id of the Service Manager to fetch (a.k.a. RunId)

    .PARAMETER launchedById
    Optional [int64] RunId of the ServiceManager that you wish to search for based on the launchedById property.

    .PARAMETER ServiceManagerTemplate
    Optional [ANOWServiceManagerTemplate] object by which to filter results by.

    .PARAMETER Type
    Optional string containing the type of ServiceManager. Valid choices are SLA_SERVICE_MANAGER or PROCESSING_DEADLINE_MONITOR

    .PARAMETER processingStatus
    Optional 'processing status' to filterby. You can only choose one. Valid choices are: WAITING, READY, EXECUTING, COMPLETED, FAILED

    .PARAMETER ItemsOnly
    Optional switch parameter that modifies the -Id parameter set to provide the executed child Items within the ServiceManager. This switch completely changes the output of this function and may only be used in conjuntion with the -Id parameter.

    .PARAMETER startRow
    Integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER sortBy
    Optional string parameter to sort the results by (may not be used with the Id parameter). Valid choices are: {To be continued...}

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .PARAMETER IncludeArchived
    Optional switch parameter removes the filter for archived items thus both archived and non-archived items will be returned.

    .PARAMETER OnlyArchived
    Optional switch parameter filters out non-archived items thus only archived items will be returned.

    .PARAMETER Folder
    Optional string to filter by a particular Folder

    .PARAMETER Tags
    Optional string array of Tags to filter by. Note that the 'containsAny' operator will be used.

    .INPUTS
    Accepts a string representing the simple id of the ServiceManager from the pipeline or individually (but not an array).

    .OUTPUTS
    An array of one or more [ANOWServiceManager] class objects

    .EXAMPLE
    Gets the first page of ServiceManagers
    Get-AutomateNOWServiceManager

    .EXAMPLE
    Gets a single ServiceManager by name (Id)
    Get-AutomateNOWServiceManager -Id 'ServiceManager1'

    .EXAMPLE
    Gets the first page of ServiceManager (type: SLA Service Manager)
    Get-AutomateNOWServiceManager -ServiceManagerType SLA_SERVICE_MANAGER

    .EXAMPLE
    Uses the pipeline to fetch a series of ServiceManagers based on their RunId
    15709211, 15708911, 15709210 | Get-AutomateNOWServiceManager

    .EXAMPLE
    Gets the first page of ServiceManagers that failed
    Get-AutomateNOWServiceManager -processingStatus FAILED

    .EXAMPLE
    Gets the first 1000 ServiceManagers that were exected from a ServiceManager Template named 'ServiceManagerTemplate1'
    Get-AutomateNOWServiceManager -ServiceManagerTemplate 'ServiceManagerTemplate1' -startRow 0 -endRow 1000

    .EXAMPLE
    Gets the first 1000 ServiceManagers that were exected from a ServiceManager Template named 'ServiceManagerTemplate1' including archived
    Get-AutomateNOWServiceManager -ServiceManagerTemplate 'ServiceManagerTemplate1' -startRow 0 -endRow 1000 -IncludeArchived

    .EXAMPLE
    Gets the first 1000 archived ServiceManagers that were exected from a ServiceManager Template named 'ServiceManagerTemplate1'
    Get-AutomateNOWServiceManager -ServiceManagerTemplate 'ServiceManagerTemplate1' -startRow 0 -endRow 1000 -OnlyArchived

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Use Get-AutomateServiceManagerTemplate if you are looking for Service Manager Templates

    #>
    [Cmdletbinding(DefaultParameterSetName = 'All')]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $True, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [int64]$Id,
        [Parameter(Mandatory = $True, ParameterSetName = 'launchedById')]
        [int64]$launchedById,
        [Parameter(Mandatory = $False, ValueFromPipeline = $true, ParameterSetName = 'All')]
        [ANOWServiceManagerTemplate]$ServiceManagerTemplate,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [ANOWProcessingTemplateCustom_ServiceManagers]$Type,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [ANOWProcessing_processingStatus]$ProcessingStatus,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Id')]
        [Parameter(Mandatory = $false, ParameterSetName = 'launchedById')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Id')]
        [Parameter(Mandatory = $false, ParameterSetName = 'launchedById')]
        [int32]$endRow = 100,
        [ValidateSet('dateCreated', 'id', 'firstStartTime', 'startTime', 'endTime', ignoreCase = $false)]
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [Parameter(Mandatory = $false, ParameterSetName = 'launchedById')]
        [string]$sortBy = 'dateCreated',
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [Parameter(Mandatory = $false, ParameterSetName = 'launchedById')]
        [switch]$Descending,
        [Parameter(Mandatory = $false, ParameterSetName = 'Id')]
        [switch]$ItemsOnly,
        [Parameter(Mandatory = $false, ParameterSetName = 'All')]
        [Parameter(Mandatory = $false, ParameterSetName = 'launchedById')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Id')]
        [switch]$IncludeArchived,
        [Parameter(Mandatory = $false, ParameterSetName = 'All')]
        [Parameter(Mandatory = $false, ParameterSetName = 'launchedById')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Id')]
        [switch]$OnlyArchived,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Id')]
        [Parameter(Mandatory = $false, ParameterSetName = 'launchedById')]
        [string]$Folder,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Id')]
        [Parameter(Mandatory = $false, ParameterSetName = 'launchedById')]
        [string[]]$Tags
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [string]$command = ('/processing/read')
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWServiceManagerTemplate]$ServiceManagerTemplate = $_
        }
        ElseIf ($_ -gt 0) {
            [int64]$Id = $_
        }
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($Id -gt 0 -and $ItemsOnly -ne $true) {
            $BodyMetaData.'id' = $Id
            [string]$textMatchStyle = 'exactCase'
            $BodyMetaData.'_operationId' = 'read'
        }
        Else {
            $BodyMetaData.'_constructor' = 'AdvancedCriteria'
            $BodyMetaData.'operator' = 'and'
            If ($OnlyArchived -eq $true) {
                $BodyMetaData.'criteria1' = '{"fieldName":"archived","operator":"equals","value":true}'
            }
            ElseIf ($IncludeArchived -ne $true) {
                $BodyMetaData.'criteria1' = '{"fieldName":"archived","operator":"equals","value":false}'
            }
            If (($Type.Length -gt 0)) {
                $BodyMetaData.'criteria2' = '{"fieldName":"itemType","operator":"equals","value":"' + $Type + '"}'
            }
            ElseIf ($ItemsOnly -eq $true -and $Id -gt 0) {
                $BodyMetaData.'criteria2' = '{"fieldName":"parent","value":"' + $Id + '","operator":"equals"}'
            }
            ElseIf ($ServiceManagerTemplate.Id.Length -gt 0) {
                $BodyMetaData.'criteria2' = ('{"fieldName":"template","operator":"equals","value":"' + $ServiceManagerTemplate.Id + '"}')
            }
            ElseIf ($launchedById -gt 0) {
                $BodyMetaData.'criteria2' = '{"fieldName":"parent","value":null,"operator":"equals"}'
                $BodyMetaData.'criteria3' = ('{"fieldName":"launchedById","operator":"equals","value":"' + $launchedById + '"}')
                $BodyMetaData.'criteria4' = '{"fieldName":"isRoot","operator":"equals","value":true}'
            }
            Else {
                $Error.Clear()
                Try {
                    [string]$all_ServiceManager_types = ([ANOWProcessing_ServiceManagerType].GetEnumNames() | ForEach-Object { '"' + $_ + '"' }) -join ','
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWServiceManager was unable to enumerate the object class [ANOWProcessing_ServiceManagerType] due to [$Message]."
                    Break
                }
                $BodyMetaData.'criteria5' = '{"fieldName":"itemType","operator":"inSet","value":[' + $all_ServiceManager_types + ']}'
                $BodyMetaData.'criteria6' = '{"fieldName":"isProcessing","operator":"equals","value":true}'
            }
            If ($ProcessingStatus.Length -gt 0) {
                [string]$ProcessingStatus = $ProcessingStatus.ToString()
                $BodyMetaData.'criteria7' = ('{"fieldName":"processingStatus","operator":"inSet","value":["' + $ProcessingStatus + '"]}')
            }
            $BodyMetaData.'_componentId' = 'ProcessingList'
            $BodyMetaData.'_operationId' = 'ProcessingDataSource_fetch'
            $BodyMetaData.'_startRow' = $startRow
            $BodyMetaData.'_endRow' = $endRow
            If ($Descending -eq $true) {
                $BodyMetaData.'_sortBy' = '-' + $sortBy
            }
            Else {
                $BodyMetaData.'_sortBy' = $sortBy
            }
            If ($Folder.Length -gt 0) {
                $BodyMetaData.'criteria8' = ('{"fieldName":"folder","operator":"equals","value":"' + $Folder + '"}')
            }
            If ($Tags.Count -gt 0) {
                If ($Tags.Count -gt 1) {
                    $Error.Clear()
                    Try {
                        [string]$TagString = $Tags | ConvertTo-Json -Compress
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "ConvertTo-Json failed to convert the provided tag names under Get-AutomateNOWServiceManager due to [$Message]."
                        Break
                    }
                }
                Else {
                    [string]$TagString = $Tags
                }
                $BodyMetaData.'criteria9' = ('{"fieldName":"tags","operator":"containsAny","value":' + $TagString + '}')
            }
            [string]$textMatchStyle = 'substring'
        }
        $BodyMetaData.'_operationType' = 'fetch'
        $BodyMetaData.'_textMatchStyle' = $textMatchStyle
        $BodyMetaData.'_dataSource' = 'ProcessingDataSource'
        $BodyMetaData.'isc_metaDataPrefix' = '_'
        $BodyMetaData.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        If ($null -eq $parameters.Body) {
            $parameters.Add('Body', $Body)
        }
        Else {
            $parameters.Body = $Body
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWServiceManager[]]$ServiceManagers = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWServiceManager] objects due to [$Message]."
            Break
        }
        If ($ServiceManagers.Count -gt 0) {
            Return $ServiceManagers
        }
    }
    End {

    }
}

Function Export-AutomateNOWServiceManager {
    <#
    .SYNOPSIS
    Exports the ServiceManagers from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the ServiceManagers from an instance of AutomateNOW! to a local .csv file

    .PARAMETER ServiceManager
    Mandatory [ANOWServiceManager] object (Use Get-AutomateNOWServiceManager to retrieve them)

    .PARAMETER Type
    Mandatory string containing the type of ServiceManager. Valid choices are STANDARD, BROADCAST, FOR_EACH, TIME_SERIES, SWITCH, CYCLE

    .INPUTS
    ONLY [ANOWServiceManager] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWServiceManager] objects are exported to the local disk in CSV format

    .EXAMPLE
    Get-AutomateNOWServiceManager | Export-AutomateNOWServiceManager -Type STANDARD

    .EXAMPLE
    Get-AutomateNOWServiceManager -Type STANDARD | Export-AutomateNOWServiceManager -Type STANDARD

    .EXAMPLE
    Get-AutomateNOWServiceManager -Id 'ServiceManager01' | Export-AutomateNOWServiceManager -Type FOR_EACH

    .EXAMPLE
    @( 'ServiceManager01', 'ServiceManager02', 'ServiceManager03' ) | Get-AutomateNOWServiceManager | Export-AutomateNOWServiceManager -Type STANDARD

    .EXAMPLE
    Get-AutomateNOWServiceManager | Where-Object { $_.id -like '*MyServiceManager*' } | Export-AutomateNOWServiceManager -Type STANDARD

    .NOTES
	You must present [ANOWServiceManager] objects to the pipeline to use this function.

    The -Type parameter is mandatory here!
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWServiceManager]$ServiceManager,
        [Parameter(Mandatory = $False)]
        [ANOWProcessing_ServiceManagerType]$Type
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-ServiceManagers-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWServiceManager]$ServiceManager_ = $_
        }
        $Error.Clear()
        Try {
            $ServiceManager_ | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWServiceManager] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function Remove-AutomateNOWServiceManager {
    <#
    .SYNOPSIS
    Archives a ServiceManager from an AutomateNOW! instance

    .DESCRIPTION
    Archives a ServiceManager from an AutomateNOW! instance

    .PARAMETER ServiceManager
    An [ANOWServiceManager] object representing the ServiceManager Template to be archived.

    .PARAMETER Force
    Force the archiving without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWServiceManager] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Archives a single ServiceManager

    Get-AutomateNOWServiceManager -Id 'ServiceManager01' | Remove-AutomateNOWServiceManager

    .EXAMPLE
    Archives a series of ServiceManagers without prompting

    @( 'ServiceManager1', 'ServiceManager2', 'ServiceManager3') | Remove-AutomateNOWServiceManager -Force

    .EXAMPLE
    Archives all For_Each ServiceManagers

    Get-AutomateNOWServiceManager | ? { $_.serverServiceManagerType -eq 'FOR_EACH' } | Remove-AutomateNOWServiceManager

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The term Remove and Archive are synonymous from the API perspective. In ANOW parlance, Templates are 'Deleted' and ServiceManagers are 'Archived'.
    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWServiceManager]$ServiceManager,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processing/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWServiceManager]$ServiceManager = $_
        }
        [int64]$ServiceManager_id = $ServiceManager.id
        If ($ServiceManager_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess($ServiceManager_id, 'Archive')) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
            $Body.Add('id', $ServiceManager_id)
            $Body.Add('_operationType', 'remove')
            $Body.Add('_operationId', 'delete')
            $Body.Add('_textMatchStyle', 'exact')
            $Body.Add('_dataSource', 'ProcessingDataSource')
            $Body.Add('isc_metaDataPrefix', '_')
            $Body.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $Body
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ServiceManager_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "ServiceManager $ServiceManager_id successfully archived"
        }
    }
    End {

    }
}

Function Restart-AutomateNOWServiceManager {
    <#
    .SYNOPSIS
    Restarts a ServiceManager from an AutomateNOW! instance

    .DESCRIPTION
    Restarts a ServiceManager from an AutomateNOW! instance

    .PARAMETER ServiceManager
    An [ANOWServiceManager] object representing the ServiceManager to be restarted

    .PARAMETER Quiet
    Switch parameter to omit the informational message if the Restart was successful

    .PARAMETER Force
    Force the restart without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWServiceManager] objects are accepted (including from the pipeline)

    .OUTPUTS
    An informational message is written to the screen unless -Quiet is used

    .EXAMPLE
    Restarts a single ServiceManager

    Get-AutomateNOWServiceManager -Id 'ServiceManager_01' | Restart-AutomateNOWServiceManager

    .EXAMPLE
    Quietly restarts multiple ServiceManagers

    @('ServiceManager1', 'ServiceManager2') | Get-AutomateNOWServiceManager | Restart-AutomateNOWServiceManager -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWServiceManager]$ServiceManager,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processing/restart'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id -gt 0) {
            [int64]$ServiceManager_id = $_.id
        }
        Else {
            [int64]$ServiceManager_id = $ServiceManager.id
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ServiceManager_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [ANOWServiceManager]$current_ServiceManager = Get-AutomateNOWServiceManager -Id $ServiceManager_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWServiceManager failed to check if the ServiceManager [$ServiceManager_id] existed under Restart-AutomateNOWServiceManager due to [$Message]."
                Break
            }
            If ($current_ServiceManager.id.length -eq 0) {
                Write-Warning -Message "The ServiceManager you specified does not seem to exist (Restart-AutomateNOWServiceManager)"
                Break
            }
            [string]$current_ServiceManager_status = $current_ServiceManager.processingStatus
            If ($current_ServiceManager_status -notin [ANOWProcessing_processingStatus].GetEnumNames()) {
                Write-Warning -Message "Somehow the processing status of the ServiceManager [$ServiceManager_id] cannot be read (Restart-AutomateNOWServiceManager)"
                Break
            }
            If ($current_ServiceManager_status -notin @('COMPLETED', 'FAILED')) {
                Write-Warning -Message "[$ServiceManager_id] cannot be restarted as it currently in [$current_ServiceManager_status] processing status"
                Break
            }
            Else {
                Write-Verbose -Message "[$ServiceManager_id] had a status of $current_ServiceManager_status"
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('restartType', 'RESTART_FROM_BEGINNING')
            $BodyMetaData.Add('restartFailedOnly', 'false' ) # Note this value is currently not available in the console
            $BodyMetaData.Add('id', $ServiceManager_id )
            $BodyMetaData.Add('_operationType', 'custom')
            $BodyMetaData.Add('_operationId', 'restart')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ServiceManager_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            If ($Quiet -ne $true) {
                Write-Information -MessageData "ServiceManager $ServiceManager_id was successfully restarted"
            }
        }
    }
    End {

    }
}

Function Stop-AutomateNOWServiceManager {
    <#
    .SYNOPSIS
    Stops a ServiceManager on an AutomateNOW! instance

    .DESCRIPTION
    Stops a ServiceManager on an AutomateNOW! instance with either a soft or hard stop

    .PARAMETER ServiceManager
    An [ANOWServiceManager] object representing the ServiceManager to be stopped

    .PARAMETER Kill
    Switch parameter to indicate 'Hard kill' of the ServiceManager. You must include either this parameter or -Abort

    .PARAMETER Abort
    Switch parameter to indicate 'Soft abort' of the ServiceManager. You must include either this parameter or -Kill

    .PARAMETER Force
    Force the stoppage without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWServiceManager] objects are accepted (including from the pipeline)

    .OUTPUTS
    An informational message is written to the screen unless -Quiet is used

    .EXAMPLE
    Stops a single ServiceManager

    Get-AutomateNOWServiceManager -Id 'ServiceManager_01' | Stop-AutomateNOWServiceManager -Abort

    .EXAMPLE
    Quietly stops multiple ServiceManagers

    @('ServiceManager1', 'ServiceManager2') | Get-AutomateNOWServiceManager | Stop-AutomateNOWServiceManager -Kill -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWServiceManager]$ServiceManager,
        [Parameter(Mandatory = $true, ParameterSetName = 'Kill')]
        [switch]$Kill,
        [Parameter(Mandatory = $true, ParameterSetName = 'Abort')]
        [switch]$Abort,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($Kill -eq $true) {
            [string]$operation_id = 'kill'
        }
        Else {
            [string]$operation_id = 'abort'
        }
        [string]$command = ('/processing/' + $operation_id)
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id -gt 0) {
            [int64]$ServiceManager_id = $_.id
        }
        Else {
            [int64]$ServiceManager_id = $ServiceManager.id
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ServiceManager_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [ANOWServiceManager]$current_ServiceManager = Get-AutomateNOWServiceManager -Id $ServiceManager_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWServiceManager failed to check if the ServiceManager [$ServiceManager_id] existed under Restart-AutomateNOWServiceManager due to [$Message]."
                Break
            }
            If ($current_ServiceManager.id.length -eq 0) {
                Write-Warning -Message "The ServiceManager you specified does not seem to exist (Stop-AutomateNOWServiceManager)"
                Break
            }
            [string]$current_ServiceManager_status = $current_ServiceManager.processingStatus
            If ($current_ServiceManager_status -notin [ANOWProcessing_processingStatus].GetEnumNames()) {
                Write-Warning -Message "Somehow the processing status of the ServiceManager [$ServiceManager_id] cannot be read (Stop-AutomateNOWServiceManager)"
                Break
            }
            If ($current_ServiceManager_status -in @('COMPLETED', 'FAILED')) {
                Write-Warning -Message "[$ServiceManager_id] cannot be stopped as it currently in [$current_ServiceManager_status] processing status"
                Break
            }
            Else {
                Write-Verbose -Message "[$ServiceManager_id] had a status of $current_ServiceManager_status"
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $ServiceManager_id )
            $BodyMetaData.Add('_operationType', 'custom')
            $BodyMetaData.Add('_operationId', $operation_id)
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ServiceManager_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            If ($Quiet -ne $true) {
                Write-Information -MessageData "ServiceManager $ServiceManager_id was successfully stopped"
            }
        }
    }
    End {

    }
}

Function Resume-AutomateNOWServiceManager {
    <#
    .SYNOPSIS
    Resumes a ServiceManager that is on hold (suspended) on an AutomateNOW! instance

    .DESCRIPTION
    Resumes a ServiceManager that is on hold (suspended) on an AutomateNOW! instance

    .PARAMETER ServiceManager
    An [ANOWServiceManager] object representing the ServiceManager to be resumed

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWServiceManager] objects are accepted (including from the pipeline)

    .OUTPUTS
    A verbose information message will be sent indicating success

    .EXAMPLE
    Get-AutomateNOWServiceManager -Id 'ServiceManager01' | Resume-AutomateNOWServiceManager -Force

    .EXAMPLE
    Get-AutomateNOWServiceManager -Id 'ServiceManager01', 'ServiceManager02' | Resume-AutomateNOWServiceManager

    .EXAMPLE
    @( 'ServiceManager1', 'ServiceManager2', 'ServiceManager3') | Resume-AutomateNOWServiceManager

    .EXAMPLE
    Get-AutomateNOWServiceManager | ? { $_.serverServiceManagerType -eq 'LINUX' } | Resume-AutomateNOWServiceManager

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $True, ValueFromPipeline = $True)]
        [ANOWServiceManager]$ServiceManager,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processing/resume'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWServiceManager]$ServiceManager = $_
        }
        [int64]$ServiceManager_id = $ServiceManager.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ServiceManager_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [ANOWServiceManager]$current_ServiceManager = Get-AutomateNOWServiceManager -Id $ServiceManager_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWServiceManager failed to check if the ServiceManager [$ServiceManager_id] existed under Resume-AutomateNOWServiceManager due to [$Message]."
                Break
            }
            If ($current_ServiceManager.id.length -eq 0) {
                Write-Warning -Message "The ServiceManager you specified does not seem to exist (Resume-AutomateNOWServiceManager)"
                Break
            }
            [boolean]$current_ServiceManager_hold_status = $current_ServiceManager.onHold
            If ($current_ServiceManager_hold_status -eq $false) {
                Write-Warning -Message "[$ServiceManager_id] cannot be resumed as it is not currently suspended (on hold)"
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $ServiceManager_id )
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_operationId', 'resume')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ServiceManager_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "ServiceManager $ServiceManager_id successfully resumed"
        }
    }
    End {

    }
}

Function Suspend-AutomateNOWServiceManager {
    <#
    .SYNOPSIS
    Places a ServiceManager on hold (suspend) from execution on an AutomateNOW! instance

    .DESCRIPTION
    Places a ServiceManager on hold (suspend) from execution on an AutomateNOW! instance

    .PARAMETER ServiceManager
    An [ANOWServiceManager] object representing the ServiceManager to be suspended (placed on hold)

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWServiceManager] objects are accepted (including from the pipeline)

    .OUTPUTS
    A verbose information message will be sent indicating success

    .EXAMPLE
    Get-AutomateNOWServiceManager -Id 'ServiceManager01' | Suspend-AutomateNOWServiceManager -Force

    .EXAMPLE
    Get-AutomateNOWServiceManager -Id 'ServiceManager01', 'ServiceManager02' | Suspend-AutomateNOWServiceManager

    .EXAMPLE
    @( 'ServiceManager1', 'ServiceManager2', 'ServiceManager3') | Suspend-AutomateNOWServiceManager

    .EXAMPLE
    Get-AutomateNOWServiceManager | ? { $_.serverServiceManagerType -eq 'LINUX' } | Suspend-AutomateNOWServiceManager

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWServiceManager]$ServiceManager,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processing/hold'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWServiceManager]$ServiceManager = $_
        }
        [string]$ServiceManager_id = $ServiceManager.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ServiceManager_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [ANOWServiceManager]$current_ServiceManager = Get-AutomateNOWServiceManager -Id $ServiceManager_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWServiceManager failed to check if the ServiceManager [$ServiceManager_id] existed under Resume-AutomateNOWServiceManager due to [$Message]."
                Break
            }
            If ($current_ServiceManager.id.length -eq 0) {
                Write-Warning -Message "The ServiceManager you specified does not seem to exist (Resume-AutomateNOWServiceManager)"
                Break
            }
            [boolean]$current_ServiceManager_hold_status = $current_ServiceManager.onHold
            If ($current_ServiceManager_hold_status -eq $true) {
                Write-Warning -Message "[$ServiceManager_id] cannot be suspended (placed on hold) as it is already suspended (on hold)"
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $ServiceManager_id )
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_operationId', 'hold')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ServiceManager_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "ServiceManager $ServiceManager_id successfully suspended (placed on hold)"
        }
    }
    End {

    }
}

Function Skip-AutomateNOWServiceManager {
    <#
    .SYNOPSIS
    Sets or unsets the Skip flag on a ServiceManager on an AutomateNOW! instance

    .DESCRIPTION
    Sets or unsets the Skip flag on a ServiceManager on an AutomateNOW! instance

    .PARAMETER ServiceManager
    An [ANOWServiceManager] object representing the ServiceManager to be set to skipped or unskipped

    .PARAMETER UnSkip
    Removes the skip flag from an [ANOWServiceManager] object. This is the opposite of the default behavior.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Switch parameter to silence the emitted [ANOWServiceManager] object

    .INPUTS
    ONLY [ANOWServiceManager] objects are accepted (including from the pipeline)

    .OUTPUTS
    The skipped/unskipped [ANOWServiceManager] object will be returned

    .EXAMPLE
    Sets a ServiceManager to Skip (bypass)

    Get-AutomateNOWServiceManager -Id 'ServiceManager01' | Skip-AutomateNOWServiceManager -Force

    .EXAMPLE
    Unsets the Skip (bypass) flag on a ServiceManager

    Get-AutomateNOWServiceManager -Id 123456 | Skip-AutomateNOWServiceManager -UnSkip

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWServiceManager]$ServiceManager,
        [Parameter(Mandatory = $false)]
        [switch]$UnSkip,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnSkip -ne $True) {
            [string]$skip_flag_status = 'On'
            [string]$operation_id = 'passByOn'
            [string]$ProcessDescription = 'Add the Skip flag'
        }
        Else {
            [string]$skip_flag_status = 'Off'
            [string]$operation_id = 'passByOff'
            [string]$ProcessDescription = 'Remove the Skip flag'
        }
        [string]$command = ('/processing/' + $operation_id)
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWServiceManager]$ServiceManager = $_
        }
        [string]$ServiceManager_id = $ServiceManager.id
        If ($ServiceManager.passBy -eq $true -and $UnSkip -ne $True) {
            Write-Warning -Message "ServiceManager $ServiceManager_id already has the skip flag set. No action is required."
            Break
        }
        ElseIf ($ServiceManager.passBy -eq $false -and $UnSkip -eq $True) {
            Write-Warning -Message "ServiceManager $ServiceManager_id does not have the skip flag set. No action is required."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess($ServiceManager_id, $ProcessDescription)) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $ServiceManager_id )
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_operationId', $operation_id)
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ServiceManager_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Successfully set the skip flag to [$skip_flag_status] on [$ServiceManager_id]"
        }
    }
    End {

    }
}

#endregion

#Region - Service ManagerTemplates (PROCESSING_TEMPLATE)

Function Get-AutomateNOWServiceManagerTemplate {
    <#
    .SYNOPSIS
    Gets the ServiceManager Templates from an AutomateNOW! instance

    .DESCRIPTION
    Gets the ServiceManager Templates from an AutomateNOW! instance

    .PARAMETER Id
    Mandatory string containing the simple id of the ServiceManager Template to fetch or you can pipeline a series of simple id strings. You may not enter an array here.

    .PARAMETER Type
    Mandatory string containing the type of ServiceManager Template. Valid choices are SLA_SERVICE_MANAGER, PROCESSING_DEADLINE_MONITOR. Note this is a custom class!

    .PARAMETER sortBy
    Optional string parameter to sort the results by. Valid choices are: id {To be continued...}

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER Folder
    Optional string to filter by a particular Folder

    .PARAMETER Tags
    Optional string array of Tags to filter by. Note that the 'containsAny' operator will be used.

    .INPUTS
    Accepts a string representing the simple id of the ServiceManager Template from the pipeline or individually (but not an array).

    .OUTPUTS
    An array of one or more [ANOWServiceManagerTemplate] class objects

    .EXAMPLE
    Gets the first page of Service Manager Templates
    Get-AutomateNOWServiceManagerTemplate

    .EXAMPLE
    Gets a specific Server Manager Template by Id
    Get-AutomateNOWServiceManagerTemplate -Id 'ServiceManager1'

    .EXAMPLE
    Gets the first page of Service Level Agreement Template objects
    Get-AutomateNOWServiceManagerTemplate -Type SLA_SERVICE_MANAGER

    .EXAMPLE
    Gets the first page of Processing Deadline Monitor Template objects
    Get-AutomateNOWServiceManagerTemplate -Type PROCESSING_DEADLINE_MONITOR

    .EXAMPLE
    Uses the pipeline to send two names to fetch the Service Manager Templates by Id.
    @( 'ServiceManager1', 'ServiceManager2' ) | Get-AutomateNOWServiceManagerTemplate

    .EXAMPLE
    Gets all ServiceManager Templates that are tagged with 'Tag1'
    Get-AutomateNOWServiceManagerTemplate -Tags 'Tag1'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWServiceManagerTemplate[]])]
    [Cmdletbinding()]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $False, ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $False)]
        [ANOWProcessingTemplateCustom_ServiceManagers]$Type,
        [Parameter(Mandatory = $False)]
        [string]$sortBy = 'id',
        [Parameter(Mandatory = $False)]
        [switch]$Descending,
        [Parameter(Mandatory = $False)]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False)]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False)]
        [string[]]$Tags,
        [Parameter(Mandatory = $False)]
        [string]$Folder
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        $Body.'_constructor' = 'AdvancedCriteria'
        $Body.'operator' = 'and'
        $Body.'_operationType' = 'fetch'
        $Body.'_startRow' = $startRow
        $Body.'_endRow' = $endRow
        $Body.'_componentId' = 'ProcessingTemplateList'
        $Body.'_dataSource' = 'ProcessingTemplateDataSource'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        If ($Descending -eq $true) {
            $Body.'_sortBy' = '-' + $sortBy
        }
        Else {
            $Body.'_sortBy' = $sortBy
        }
        If ($_.Length -gt 0 -or $Id.Length -gt 0) {
            If ($_.Length -gt 0 ) {
                $Body.'id' = $_
            }
            Else {
                $Body.'id' = $Id
            }
            [string]$textMatchStyle = 'exactCase'
        }
        Else {
            [string]$textMatchStyle = 'substring'
            If ( $Type.length -eq 0) {
                $Body.'criteria1' = '{"_constructor":"AdvancedCriteria","operator":"or","criteria":[{"fieldName":"monitorType","operator":"inSet","value":["PROCESSING_DEADLINE_MONITOR"]},{"fieldName":"serviceManagerType","operator":"inSet","value":["SLA_SERVICE_MANAGER"]}]}'
            }
            Else {
                If ($Type -eq 'SLA_SERVICE_MANAGER') {
                    $Body.'criteria1' = ('{"fieldName":"serviceManagerType","operator":"equals","value":["SLA_SERVICE_MANAGER"]}')
                }
                ElseIf ($Type -eq 'PROCESSING_DEADLINE_MONITOR') {
                    $Body.'criteria1' = ('{"fieldName":"monitorType","operator":"equals","value":["PROCESSING_DEADLINE_MONITOR"]}')
                }
                Else {
                    Write-Warning -Message "Unable to determine the type of Service Manager Template being requested."
                    Break
                }
            }
            If ($Folder.Length -gt 0) {
                $Body.'criteria2' = ('{"fieldName":"folder","operator":"equals","value":"' + $Folder + '"}')
            }
            If ($Tags.Count -gt 0) {
                If ($Tags.Count -gt 1) {
                    $Error.Clear()
                    Try {
                        [string]$TagString = $Tags | ConvertTo-Json -Compress
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "ConvertTo-Json failed to convert the provided tag names under Get-AutomateNOWServiceManagerTemplate due to [$Message]."
                        Break
                    }
                }
                Else {
                    [string]$TagString = $Tags
                }
                $Body.'criteria3' = ('{"fieldName":"tags","operator":"containsAny","value":' + $TagString + '}')
            }
        }
        $Body.'_textMatchStyle' = $textMatchStyle
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/processingTemplate/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWServiceManagerTemplate[]]$ServiceManagerTemplates = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWServiceManagerTemplate] objects due to [$Message]."
            Break
        }
        If ($ServiceManagerTemplates.Count -gt 0) {
            ForEach ($ServiceManagerTemplate in $ServiceManagerTemplates) {
                If ($ServiceManagerTemplates.processingType -ne 'SERVICE') {
                    [string]$processingType = $ServiceManagerTemplates.processingType
                    If ($processingType -in @('TASK')) {
                        Write-Warning -Message "$Id is actually a Task Template. Please use Get-AutomateNOWTaskTemplate to retrieve this item."
                    }
                    ElseIf ($processingType -eq 'WORKFLOW') {
                        Write-Warning -Message "$Id is actually a Workflow Template. Please use Get-AutomateNOWWorkflowTemplate to retrieve this item."
                    }
                    ElseIf ($processingType -eq 'TRIGGER') {
                        Write-Warning -Message "$Id is actually a Schedule Template. Please use Get-AutomateNOWScheduleTemplate to retrieve this item."
                    }
                    Else {
                        Write-Warning -Message "Could not identify what type of template object [$processingType] is. Please look into this..."
                    }
                    Break
                }
            }
            Return $ServiceManagerTemplates
        }
    }
    End {

    }
}

Function Set-AutomateNOWServiceManagerTemplate {
    <#
    .SYNOPSIS
    Changes the settings of a ServiceManager Template on an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of a ServiceManager Template on an AutomateNOW! instance

    .PARAMETER ServiceManagerTemplate
    An [ANOWServiceManagerTemplate] object representing the ServiceManager Template to be changed.

    .PARAMETER Description
    Optional description of the ServiceManager Template (may not exceed 255 characters).

    .PARAMETER UnsetDescription
    Optional switch that will remove the Description from the ServiceManager Template object.

    .PARAMETER Folder
    A string representing the name of the Folder to move the ServiceManager Template into.

    .PARAMETER UnsetFolder
    A switch parameter that will move the ServiceManager Template out of its current folder.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to include with this object.

    .PARAMETER UnsetTags
    A switch parameter that will remove the Tags from the ServiceManager Template

    .PARAMETER CodeRepository
    Optional Code Repository to place the Service Manager Template into. Use Get-AutomateNOWCodeRepository to fetch this object.

    .PARAMETER UnsetCodeRepository
    Switch parameter that will remove the the Service Manager Template from its Code Repository.

    .PARAMETER Title
    A string representing the "alias" of the ServiceManager Template (this property needs a better explanation)

    .PARAMETER ResultMapping
    An [ResultMapping] object representing the Result Mapping object to set on the ServiceManager Template.

    .PARAMETER UnsetResultMapping
    A switch parameter that will remove the Result Mapping assignment from the ServiceManager Template.

    .PARAMETER Calendar
    A [ANOWCalendar] object representing the Calendar object to set on the Service Manager Template. Use Get-AutomateNOWCalendar to fetch one of these.

    .PARAMETER UnsetCalendar
    A switch parameter that will remove the Calendar assignment from the ServiceManager Template.

    .PARAMETER DelayedStartTime
    Optional string that allows processing items to start on a specific date or time or delay the execution for a period ranging from days to seconds. Example 1: 2029-12-31, Example 2: 2029-12-31 23:59:59, Example 3: 23:59:59

    .PARAMETER UnsetDelayedStartTime
    A switch parameter that will remove the Delayed Start Time from the ServiceManager Template.

    .PARAMETER TimeZone
    Optional [ANOWTimeZone] object that modifies (it is unknown exactly what this property modifies since it is not defined in the documentation yet)

    .PARAMETER UnsetTimeZone
    A switch parameter that will remove the Time Zone from the ServiceManager Template.

    .PARAMETER Approval
    A [ANOWApproval] object representing the Approval object to set on the ServiceManager Template.

    .PARAMETER UnsetApproval
    A switch parameter that will remove the Approval assignment from the ServiceManager Template.

    .PARAMETER Priority
    An integer representing the items priority which determines the order when queuing for resources (Stock and Locks) and [for] being executed by Server Nodes. Default Priority is 0. Minimal Priority is 0.

    .PARAMETER Weight
    An integer representing a logical measure of resources required to process the item by the Server Node. Each Server Node has [a] maximum weight capacity[.] Weight determines [the] number of parallel processes that can run simultaneously. Default processing Weight is 1. Minimal Weight is 0.

    .PARAMETER OnHold
    A boolean to put the ServiceManager Template on Hold status. You must specify $true or $false here. When $true, it's the same as the Suspend-AutomateNOWServiceManagerTemplate function. When $false, Resume-AutomateNOWServiceManagerTemplate function.

    .PARAMETER Skip
    A boolean to put the ServiceManager Template on Skip status. You must specify $true or $false here. When $true, it's the same as the Skip-AutomateNOWServiceManagerTemplate function. When $false, Skip-AutomateNOWServiceManagerTemplate with -UnSkip parameter.

    .PARAMETER VerboseMode
    A boolean setting that enables Verbose Mode on the Task. You must specify $true or $false here.

    .PARAMETER AutoArchive
    A boolean that causes the ServiceManagers from this ServiceManager Template to be archived immediately after execution. You must specify $true or $false here.

    .PARAMETER KeepResources
    A boolean that indicates if the ServiceManager Template should keep its Resources (Stocks and Locks) even if it fails to execute.

    .PARAMETER UseScripts
    A boolean that indicates if the ServiceManagers from this ServiceManager Template should ?

    .PARAMETER EagerScriptExecution
    A boolean that indicates if the scripts from the ServiceManagers from this ServiceManager Template should use "Eager" load strategy. In order to use this parameter, you must include -UseScripts $true.

    .PARAMETER Owner
    A string which appears to represent the user who owns the object. In practice, it is just a string. This particular property does not appear to be explained anywhere in the documentation.

    .PARAMETER statisticalDuration
    A int64 number in milliseconds of the expected duration of the Task Template. The minimum/maximum is 1000/31536000000 (1 second/1 year). The default is 60000 (1 minute).

    .PARAMETER Quiet
    Switch parameter that silences the output of the updated object.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWServiceManagerTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWServiceManagerTemplate] object will be returned

    .EXAMPLE

    $service_manager_template = Get-AutomateNOWServiceManagerTemplate -Id 'ServiceManager1'
    Set-AutomateNOWWorkflowTemplate -WorkflowTemplate $service_manager_template -Description 'Description!' -Force
    Set-AutomateNOWWorkflowTemplate -WorkflowTemplate $service_manager_template -UnsetDescription -Force
    Set-AutomateNOWWorkflowTemplate -WorkflowTemplate $service_manager_template -Title 'title!' -Force
    Set-AutomateNOWWorkflowTemplate -WorkflowTemplate $service_manager_template -UnsetTags -Force
    Set-AutomateNOWWorkflowTemplate -WorkflowTemplate $service_manager_template -Tags 'Tag1' -Force
    Set-AutomateNOWWorkflowTemplate -WorkflowTemplate $service_manager_template -UnsetFolder -Force
    Set-AutomateNOWWorkflowTemplate -WorkflowTemplate $service_manager_template -Folder 'Folder1' -Force
    Set-AutomateNOWWorkflowTemplate -WorkflowTemplate $service_manager_template -title 'Title1' -Force
    Set-AutomateNOWWorkflowTemplate -WorkflowTemplate $service_manager_template -ResultMapping (Get-AutomateNOWResultMapping -Id 'result_mapping1') -Force
    Set-AutomateNOWWorkflowTemplate -WorkflowTemplate $service_manager_template -UnsetResultMapping -Force
    Set-AutomateNOWWorkflowTemplate -WorkflowTemplate $service_manager_template -Calendar (Get-AutomateNOWCalendar -Id 'calendar1') -Force
    Set-AutomateNOWWorkflowTemplate -WorkflowTemplate $service_manager_template -UnsetCalendar -Force
    Set-AutomateNOWWorkflowTemplate -WorkflowTemplate $service_manager_template -Approval (Get-AutomateNOWApproval -Id 'approval1') -Force
    Set-AutomateNOWWorkflowTemplate -WorkflowTemplate $service_manager_template -UnsetApproval -Force
    Set-AutomateNOWWorkflowTemplate -WorkflowTemplate $service_manager_template -Priority 1 -Weight 1 -LazyLoad $true -OnHold $true -Skip $true -AutoArchive $true -PassResources $true -PassActions $true -KeepREsources $true -UseScripts $true -EagerScriptExecution $true -Owner 'owner' -Force

    .NOTES

    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWServiceManagerTemplate])]
    [Cmdletbinding(SupportsShouldProcess, DefaultParameterSetName = 'Default', ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWServiceManagerTemplate]$ServiceManagerTemplate,
        [ValidateScript({ $_.Length -le 255 })]
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [string]$Description,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false, ParameterSetName = 'SetFolder')]
        [string]$Folder,
        [Parameter(Mandatory = $false, ParameterSetName = 'SetFolder')]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [string[]]$Tags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetCodeRepository,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [string]$Title,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetTitle,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [ANOWResultMapping]$ResultMapping,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetResultMapping,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [ANOWCalendar]$Calendar,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetCalendar,
        [ValidateScript({ $_ -match '([0-9]{4}-[0-9]{2}-[0-9]{2}){0,}( {0,}[0-9]{2}:[0-9]{2}:[0-9]{2}){0,}' })]
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [string]$DelayedStartTime,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetDelayedStartTime,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [ANOWTimeZone]$TimeZone,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetTimeZone,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [ANOWApproval]$Approval,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetApproval,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [int32]$Priority,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [int32]$Weight,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Nullable[boolean]]$OnHold = $null,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Nullable[boolean]]$Skip = $null,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Nullable[boolean]]$VerboseMode,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Nullable[boolean]]$AutoArchive = $null,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Nullable[boolean]]$KeepResources = $null,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Nullable[boolean]]$UseScripts = $null,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Nullable[boolean]]$EagerScriptExecution = $null,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [string]$Owner,
        [ValidateRange(1000, 31536000000)]
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [int64]$statisticalDuration,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($Description.Length -gt 0 -and $UnsetDescription -eq $true) {
            Write-Warning -Message 'You cannot set the Description and unset it at the same time. Please choose one or the other.'
            Break
        }
        If ($Title.Length -gt 0 -and $UnsetTitle -eq $true) {
            Write-Warning -Message 'You cannot set the Title and unset it at the same time. Please choose one or the other.'
            Break
        }
        If ($EagerScriptExecution -eq $true -and $UseScripts -ne $true) {
            Write-Warning -Message 'To use -EagerScriptExecution, you must include -UseScripts $true'
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Exit
        }
        If ($Tags.count -gt 0 -and $UnsetTags -eq $true) {
            Write-Warning -Message "You cannot set the tags and unset them at the same time. Please choose one or the other."
        }
        If ($UnsetCodeRepository -eq $true -and $CodeRepository.Id.Length -gt 0) {
            Write-Warning -Message "You cannot unset the Code Repository and set it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetApproval -eq $true -and $Approval.id.Length -gt 0) {
            Write-Warning -Message "You cannot set the Approval and unset it at the same time. Please choose one or the other."
            Exit
        }
        If ($UnsetTimeZone -eq $true -and $TimeZone.Id.Length -gt 0) {
            Write-Warning -Message "You cannot set the Time Zone and unset it at the same time. Please choose one or the other."
            Exit
        }
        If ($UnsetDelayedStartTime -eq $true -and $DelayedStartTime.Length -gt 0) {
            Write-Warning -Message "You cannot set the Delayed Start Time and unset it at the same time. Please choose one or the other."
            Exit
        }
        If ($UnsetFolder -eq $true -or $Folder.Length -gt 0) {
            [string]$command = '/processingTemplate/setFolder'
            [string]$operationId = 'setFolder'
        }
        Else {
            [string]$command = '/processingTemplate/update'
            [string]$componentId = 'ProcessingTemplateValuesManager'
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWServiceManagerTemplate]$ServiceManagerTemplate = $_
        }
        [string]$ServiceManagerTemplate_id = $ServiceManagerTemplate.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ServiceManagerTemplate_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$ServiceManagerTemplate_exists = ($null -eq (Get-AutomateNOWServiceManagerTemplate -Id $ServiceManagerTemplate_id))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWServiceManagerTemplate failed to check if the ServiceManager Template [$ServiceManagerTemplate_id] already existed due to [$Message]."
                Break
            }
            If ($ServiceManagerTemplate_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not a ServiceManager Template named [$ServiceManagerTemplate_id] in the current domain [$current_domain]. Please check into this."
                Break
            }
            ## End warning ##
            [System.Collections.ArrayList]$include_properties = [System.Collections.ArrayList]@()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $ServiceManagerTemplate_id
            If ($Description.Length -gt 0) {
                $BodyMetaData.'description' = $Description
            }
            ElseIf ($UnsetDescription -eq $true) {
                $BodyMetaData.'description' = $null
                $include_properties += 'description'
            }
            If ($Folder.Length -gt 0) {
                $Error.Clear()
                Try {
                    [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the Folder [$Folder] actually existed while running under Set-AutomateNOWServiceManagerTemplate due to [$Message]"
                    Break
                }
                If ($folder_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] running under Set-AutomateNOWServiceManagerTemplate. Please check again."
                    Break
                }
                [string]$folder_display = $folder_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Adding Folder $folder_display to [ANOWServiceManagerTemplate] [$ServiceManagerTemplate_id]"
                $BodyMetaData.'folder' = $Folder
                $include_properties += 'folder'
            }
            ElseIf ($UnsetFolder -eq $true) {
                [string]$folder_display = $folder_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Removing [ANOWServiceManagerTemplate] [$ServiceManagerTemplate_id] from Folder $folder_display"
                $BodyMetaData.'folder' = $null
                $include_properties += 'folder'
            }
            If ($Tags.Count -gt 0) {
                [int32]$total_tags = $Tags.Count
                [int32]$current_tag = 1
                ForEach ($tag_id in $Tags) {
                    $Error.Clear()
                    Try {
                        [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] running under New-AutomateNOWServiceManagerTemplate due to [$message]"
                        Break
                    }
                    If ($tag_object.simpleId.length -eq 0) {
                        Throw "Set-AutomateNOWServiceManagerTemplate has detected that the tag [$tag_id] does not appear to exist. Please check again."
                        Break
                    }
                    ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                        [string]$tag_object_simpleId = $tag_object.simpleId
                        Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                        Break
                    }
                    [string]$tag_display = $tag_object | ConvertTo-Json -Compress
                    Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
                    [string]$tag_name_sequence = ('tags' + $current_tag)
                    $BodyMetaData.Add($tag_name_sequence, $tag_id)
                    $include_properties += $tag_name_sequence
                    $current_tag++
                }
            }
            ElseIf ($UnsetTags -eq $true) {
                [string]$tags_display = ($Calendar.tags) | ConvertTo-Json -Compress
                Write-Verbose -Message "Removing tags [$tags_display] from [$ServiceManagerTemplate_id]"
                $BodyMetaData.'tags' = $null
                $include_properties += 'tags'
            }
            If ($CodeRepository.Id.Length -gt 0) {
                [string]$CodeRepository_Id = $CodeRepository.Id
                $Error.Clear()
                Try {
                    [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository_Id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository_Id] actually existed under Set-AutomateNOWServiceManagerTemplate due to [$Message]"
                    Break
                }
                If ($code_repository_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository_Id] under Set-AutomateNOWServiceManagerTemplate. Please check again."
                    Break
                }
                $BodyMetaData.'codeRepository' = $CodeRepository_Id
            }
            ElseIf ($UnsetCodeRepository -eq $true) {
                $BodyMetaData.'codeRepository' = $null
            }
            If ($Title.Length -gt 0) {
                $BodyMetaData.'title' = $Title
            }
            ElseIf ( $UnsetTitle -eq $true) {
                $BodyMetaData.'title' = $null
            }
            If ($ResultMapping.simpleId.Length -gt 0) {
                [string]$ResultMapping_id = $ResultMapping.simpleId
                $Error.Clear()
                Try {
                    [ANOWResultMapping]$rm_object = Get-AutomateNOWResultMapping -Id $ResultMapping_id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWResultMapping failed to confirm that the Result Mapping [$ResultMapping_id] actually existed while running under Set-AutomateNOWServiceManagerTemplate due to [$Message]"
                    Break
                }
                If ($rm_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWResultMapping failed to locate the Result Mapping [$ResultMapping_id] running under Set-AutomateNOWServiceManagerTemplate. Please check again."
                    Break
                }
                [string]$rm_display = $rm_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Adding Result Mapping $rm_display to [ANOWServiceManagerTemplate] [$ServiceManagerTemplate_id]"
                $BodyMetaData.'resultMapping' = $ResultMapping_id
                $include_properties += 'resultMapping'
            }
            ElseIf ($UnsetResultMapping -eq $true) {
                [string]$rm_display = $rm_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Removing [ANOWServiceManagerTemplate] [$ResultMapping_id] from Result Mapping $rm_display"
                $BodyMetaData.'resultMapping' = $null
                $include_properties += 'resultMapping'
            }
            If ($Calendar.Id.Length -gt 0) {
                [string]$Calendar_id = $Calendar.simpleId
                $Error.Clear()
                Try {
                    [ANOWCalendar]$Calendar_object = Get-AutomateNOWCalendar -Id $Calendar_id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWCalendar failed to confirm that the Calendar object [$Calendar_id] actually existed while running under Set-AutomateNOWServiceManagerTemplate due to [$Message]"
                    Break
                }
                If ($Calendar_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWCalendar failed to locate the Calendar object [$Calendar_id] running under Set-AutomateNOWServiceManagerTemplate. Please check again."
                    Break
                }
                Write-Verbose -Message "Adding Calendar object [$Calendar_id] to [ANOWServiceManagerTemplate] [$ServiceManagerTemplate_id]"
                $BodyMetaData.'calendar' = $Calendar_id
                $include_properties += 'calendar'
            }
            ElseIf ($UnsetCalendar -eq $true) {
                [string]$Calendar_id = $Calendar.simpleId
                Write-Verbose -Message "Removing [ANOWCalendar] [$Calendar_id] from [ANOWServiceManagerTemplate] [$ServiceManagerTemplate_id]"
                $BodyMetaData.'calendar' = $null
                $include_properties += 'calendar'
            }
            If ($DelayedStartTime.Length -gt 0) {
                $BodyMetaData.Add('delayedStartTime', $DelayedStartTime)
            }
            ElseIf ( $UnsetDelayedStartTime -eq $true) {
                $BodyMetaData.Add('delayedStartTime', $null)
            }
            If ($TimeZone.id.Length -gt 0) {
                [string]$timezone_id = ($TimeZone.id)
                $BodyMetaData.Add('timeZone', $timezone_id )
            }
            ElseIf ($UnsetTimeZone -eq $true) {
                $BodyMetaData.Add('timeZone', $null )
            }
            If ($Approval.Id.Length -gt 0) {
                [string]$Approval_id = $Approval.simpleId
                $Error.Clear()
                Try {
                    [ANOWApproval]$Approval_object = Get-AutomateNOWApproval -Id $Approval_id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWApproval failed to confirm that the Approval object [$Approval_id] actually existed while running under Set-AutomateNOWServiceManagerTemplate due to [$Message]"
                    Break
                }
                If ($Approval_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWApproval failed to locate the Approval object [$Approval_id] running under Set-AutomateNOWServiceManagerTemplate. Please check again."
                    Break
                }
                Write-Verbose -Message "Adding Approval object [$Approval_id] to [ANOWServiceManagerTemplate] [$ServiceManagerTemplate_id]"
                $BodyMetaData.'approvalConfiguration' = $Approval_id
                $include_properties += 'approvalConfiguration'
            }
            ElseIf ($UnsetApproval -eq $true) {
                [string]$Approval_id = $Approval.simpleId
                Write-Verbose -Message "Removing [ANOWApproval] [$Approval_id] from [ANOWServiceManagerTemplate] [$ServiceManagerTemplate_id]"
                $BodyMetaData.'approvalConfiguration' = $null
                $include_properties += 'approvalConfiguration'
            }
            If ($Priority -ge 0) {
                $BodyMetaData.'priority' = $Priority
            }
            If ($Weight -ge 0) {
                $BodyMetaData.'weight' = $Weight
            }
            If ($OnHold -eq $false) {
                $BodyMetaData.'onHold' = 'false'
            }
            ElseIf ($OnHold -eq $true) {
                $BodyMetaData.'onHold' = 'true'
            }
            If ($Skip -eq $false) {
                $BodyMetaData.'passBy' = 'false'
            }
            ElseIf ($Skip -eq $true) {
                $BodyMetaData.'passBy' = 'true'
            }
            If ($VerboseMode -eq $true) {
                $BodyMetaData.'verboseMode' = 'true'
            }
            ElseIf ($VerboseMode -eq $false) {
                $BodyMetaData.'verboseMode' = 'false'
            }
            If ($AutoArchive -eq $false) {
                $BodyMetaData.'autoArchive' = 'false'
            }
            ElseIf ($Skip -eq $true) {
                $BodyMetaData.'autoArchive' = 'true'
            }
            If ($KeepResources -eq $false) {
                $BodyMetaData.'keepResourcesOnFailure' = 'false'
            }
            ElseIf ($KeepResources -eq $true) {
                $BodyMetaData.'keepResourcesOnFailure' = 'true'
            }
            If ($UseScripts -eq $false) {
                $BodyMetaData.'useScripts' = 'false'
            }
            ElseIf ($UseScripts -eq $true) {
                $BodyMetaData.'useScripts' = 'true'
            }
            If ($EagerScriptExecution -eq $false) {
                $BodyMetaData.'eagerScriptExecution' = 'false'
            }
            ElseIf ($EagerScriptExecution -eq $true) {
                $BodyMetaData.'eagerScriptExecution' = 'true'
            }
            If ($Owner.Length -gt 0) {
                $BodyMetaData.'owner' = $Owner
            }
            If ($statisticalDuration -ge 1000) {
                $BodyMetaData.'statisticalDuration' = $statisticalDuration
            }
            $BodyMetaData.'_operationType' = 'update'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_oldValues' = $ServiceManagerTemplate.CreateOldValues()
            If ($componentId.Length -gt 0) {
                $BodyMetaData.'_componentId' = $componentId
            }
            If ($operationId.Length -gt 0) {
                $BodyMetaData.'_operationId' = $operationId
            }
            $BodyMetaData.'_dataSource' = 'ProcessingTemplateDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties $include_properties
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ServiceManagerTemplate_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "ServiceManager Template $ServiceManagerTemplate_id was successfully updated"
            $Error.Clear()
            Try {
                [ANOWServiceManagerTemplate]$UpdatedServiceManagerTemplate = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the response into an [ANOWServiceManagerTemplate] object (under Set-AutomateNOWServiceManagerTemplate) due to [$Message]."
                Break
            }
            If ($Quiet -ne $true) {
                Return $UpdatedServiceManagerTemplate
            }
        }
    }
    End {
    }
}

Function Export-AutomateNOWServiceManagerTemplate {
    <#
    .SYNOPSIS
    Exports the ServiceManager Templates from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the ServiceManager Templates from an instance of AutomateNOW! to a local .csv file

    .PARAMETER ServiceManagerTemplate
    Mandatory [ANOWServiceManagerTemplate] object (Use Get-AutomateNOWServiceManagerTemplate to retrieve them)

    .PARAMETER Type
    Mandatory string containing the type of ServiceManager Template. Valid choices are STANDARD, BROADCAST, FOR_EACH, TIME_SERIES, SWITCH, CYCLE

    .INPUTS
    ONLY [ANOWServiceManagerTemplate] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWServiceManagerTemplate] objects are exported to the local disk in CSV format

    .EXAMPLE
    Get-AutomateNOWServiceManagerTemplate | Export-AutomateNOWServiceManagerTemplate -Type STANDARD

    .EXAMPLE
    Get-AutomateNOWServiceManagerTemplate -Type STANDARD | Export-AutomateNOWServiceManagerTemplate -Type STANDARD

    .EXAMPLE
    Get-AutomateNOWServiceManagerTemplate -Id 'ServiceManager01' | Export-AutomateNOWServiceManagerTemplate -Type FOR_EACH

    .EXAMPLE
    @( 'ServiceManager01', 'ServiceManager02', 'ServiceManager03' ) | Get-AutomateNOWServiceManagerTemplate | Export-AutomateNOWServiceManagerTemplate -Type STANDARD

    .EXAMPLE
    Get-AutomateNOWServiceManagerTemplate | Where-Object { $_.id -like '*MyServiceManager*' } | Export-AutomateNOWServiceManagerTemplate -Type STANDARD

    .NOTES
	You must present [ANOWServiceManagerTemplate] objects to the pipeline to use this function.

    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWServiceManagerTemplate]$ServiceManagerTemplate,
        [Parameter(Mandatory = $False)]
        [ANOWProcessingTemplate_ServiceManagerType]$Type
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-ServiceManagerTemplates-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWServiceManagerTemplate]$ServiceManagerTemplate = $_
        }
        $Error.Clear()
        Try {
            $ServiceManagerTemplate | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWServiceManagerTemplate] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function New-AutomateNOWServiceManagerTemplate {
    <#
    .SYNOPSIS
    Creates a ServiceManager Template within an AutomateNOW! instance

    .DESCRIPTION
    Creates a ServiceManager Template within an AutomateNOW! instance and returns back the newly created [ANOWServiceManagerTemplate] object

    .PARAMETER ServiceManagerType
    Required type of the ServiceManager Template.

    .PARAMETER Id
    Mandatory "name" of the ServiceManager Template. For example: 'ServiceManagerTemplate1'. This value may not contain the domain in brackets. This is the unique key of this object.

    .PARAMETER Description
    Optional description of the ServiceManager Template (may not exceed 255 characters).

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to include with this object.

    .PARAMETER Folder
    Optional string representing the Folder to place this object into.

    .PARAMETER DesignTemplate
    Optional string representing the Design Template to place this object into.

    .PARAMETER Workspace
    Optional string representing the Workspace to place this object into.

    .PARAMETER CodeRepository
    Optional name of the code repository to place the ServiceManager into.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWServiceManagerTemplate.

    .OUTPUTS
    An [ANOWServiceManagerTemplate] object representing the newly created ServiceManager Template. Use the -Quiet parameter to suppress this.

    .EXAMPLE

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The name (id) of the ServiceManager Template must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    #>
    [OutputType([ANOWServiceManagerTemplate])]
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWProcessingTemplateCustom_ServiceManagers]$Type,
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $true)]
        [string]$Id,
        [ValidateScript({ $_.Length -le 255 })]
        [Parameter(Mandatory = $false, HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [string]$DesignTemplate,
        [Parameter(Mandatory = $false)]
        [string]$Workspace,
        [Parameter(Mandatory = $false)]
        [string]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [boolean]$ServiceManagerTemplate_exists = ($null -ne (Get-AutomateNOWServiceManagerTemplate -Id $Id))
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWServiceManagerTemplate failed to check if the ServiceManager Template [$Id] already existed due to [$Message]."
        Break
    }
    If ($ServiceManagerTemplate_exists -eq $true) {
        [string]$current_domain = $anow_session.header.domain
        Write-Warning -Message "There is already a ServiceManager Template named [$Id] in [$current_domain]. Please check into this."
        Break
    }
    ## End warning ##
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    $BodyMetaData.Add('id', $Id)
    $BodyMetaData.Add('processingType', 'ServiceManager')
    $BodyMetaData.Add('ServiceManagerType', $ServiceManagerType)
    [string[]]$include_properties = 'id', 'processingType', 'ServiceManagerType'
    If ($Description.Length -gt 0) {
        $BodyMetaData.Add('description', $Description)
        $include_properties += 'description'
    }
    If ($Tags.Count -gt 0) {
        [int32]$total_tags = $Tags.Count
        [int32]$current_tag = 1
        ForEach ($tag_id in $Tags) {
            $Error.Clear()
            Try {
                [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] under New-AutomateNOWServiceManagerTemplate due to [$message]"
                Break
            }
            If ($tag_object.simpleId.length -eq 0) {
                Throw "New-AutomateNOWServiceManagerTemplate has detected that the tag [$tag_id] does not appear to exist. Please check again."
                Break
            }
            ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                [string]$tag_object_simpleId = $tag_object.simpleId
                Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                Break
            }
            [string]$tag_display = $tag_object | ConvertTo-Json -Compress
            Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
            [string]$tag_name_sequence = ('tags' + $current_tag)
            $BodyMetaData.Add($tag_name_sequence, $tag_id)
            $include_properties += $tag_name_sequence
            $current_tag++
        }
    }
    If ($Folder.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] actually existed while running under New-AutomateNOWServiceManagerTemplate due to [$Message]"
            Break
        }
        If ($folder_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] running under New-AutomateNOWServiceManagerTemplate. Please check again."
            Break
        }
        [string]$folder_display = $folder_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding folder $folder_display to [ANOWServiceManagerTemplate] [$Id]"
        $BodyMetaData.Add('folder', $Folder)
        $include_properties += 'folder'
    }
    If ($DesignTemplate.Length -gt 0) {
        $BodyMetaData.Add('designTemplate', $DesignTemplate)
        $include_properties += 'designTemplate'
    }
    If ($Workspace.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWWorkspace]$workspace_object = Get-AutomateNOWWorkspace -Id $Workspace
        }
        Catch {
            [string]$Message = $_.Exception.Message
            [string]$Workspace_id = $Workspace.Id
            Write-Warning -Message "Get-AutomateNOWWorkspace failed to confirm that the workspace [$Workspace_id] actually existed while running under New-AutomateNOWServiceManagerTemplate due to [$Message]"
            Break
        }
        If ($workspace_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWWorkspace failed to locate the Workspace [$Workspace] running under New-AutomateNOWServiceManagerTemplate. Please check again."
            Break
        }
        [string]$workspace_display = $workspace_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding workspace $workspace_display to [ANOWServiceManagerTemplate] [$Id]"
        $BodyMetaData.Add('workspace', $Workspace)
        $include_properties += 'workspace'
    }
    If ($CodeRepository.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository] actually existed while running under New-AutomateNOWServiceManagerTemplate due to [$Message]"
            Break
        }
        If ($code_repository_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository] running under New-AutomateNOWServiceManagerTemplate. Please check again."
            Break
        }
        [string]$code_repository_display = $code_repository_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding code repository $code_repository_display to [ANOWServiceManagerTemplate] [$Id]"
        $BodyMetaData.Add('codeRepository', $CodeRepository)
        $include_properties += 'codeRepository'
    }
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_operationType' = 'add'
    $BodyMetaData.'_oldValues' = '{"processingType":"ServiceManager","ServiceManagerType":"' + $ServiceManagerType + '","workspace":null}'
    $BodyMetaData.'_componentId' = 'ProcessingTemplateCreateWindow_form'
    $BodyMetaData.'_dataSource' = 'ProcessingTemplateDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$BodyMetaDataString = ConvertTo-QueryString -InputObject $BodyMetaData
    [string]$Body = ($BodyObject + '&' + $BodyMetaDataString)
    [string]$command = '/processingTemplate/create'
    [hashtable]$parameters = @{}
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('Body', $Body)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWServiceManagerTemplate]$ServiceManagerTemplate = $results.response.data | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to create [ANOWServiceManagerTemplate] object due to [$Message]."
        Break
    }
    If ($ServiceManagerTemplate.id.Length -eq 0) {
        Write-Warning -Message "Somehow the newly created [ANOWServiceManagerTemplate] is empty!"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWServiceManagerTemplate]$ServiceManagerTemplate = Get-AutomateNOWServiceManagerTemplate -Id $Id
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWServiceManagerTemplate failed to confirm that the [ANOWServiceManagerTemplate] object [$Id] was created due to [$Message]."
        Break
    }
    If ($Quiet -ne $true) {
        Return $ServiceManagerTemplate
    }
}

Function Remove-AutomateNOWServiceManagerTemplate {
    <#
    .SYNOPSIS
    Removes a ServiceManager Template from an AutomateNOW! instance

    .DESCRIPTION
    Removes a ServiceManager Template from an AutomateNOW! instance

    .PARAMETER ServiceManagerTemplate
    An [ANOWServiceManagerTemplate] object representing the ServiceManager Template to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWServiceManagerTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Get-AutomateNOWServiceManagerTemplate -Id 'ServiceManager01' | Remove-AutomateNOWServiceManagerTemplate

    .EXAMPLE
    Get-AutomateNOWWorkTemplate -Id 'ServiceManager01', 'ServiceManager02' | Remove-AutomateNOWServiceManagerTemplate

    .EXAMPLE
    @( 'ServiceManager1', 'ServiceManager2', 'ServiceManager3') | Remove-AutomateNOWServiceManagerTemplate

    .EXAMPLE
    Get-AutomateNOWServiceManagerTemplate | ? { $_.ServiceManagerType -eq 'BROADCAST' } | Remove-AutomateNOWServiceManagerTemplate

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWServiceManagerTemplate]$ServiceManagerTemplate,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processingTemplate/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWServiceManagerTemplate]$ServiceManagerTemplate = $_
        }
        [string]$ServiceManagerTemplate_id = $ServiceManagerTemplate.id
        If ($ServiceManagerTemplate_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ServiceManagerTemplate_id)")) -eq $true) {
            [string]$oldvalues = $ServiceManagerTemplate.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $ServiceManagerTemplate_id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'ProcessingTemplateList'
            $BodyMetaData.'_dataSource' = 'ProcessingTemplateDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ServiceManagerTemplate_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$error_message = $results.response.data
                If ($error_message -match 'Object may still be in use') {
                    [string]$ServiceManagerTemplate_id_formatted = $ServiceManagerTemplate_id -split '\]' | Select-Object -Last 1
                    Write-Warning -Message "This object $ServiceManagerTemplate_id_formatted is still in use somewhere therefore it cannot be removed! Please use 'Find-AutomateNOWObjectReferral -Object $ServiceManagerTemplate_id_formatted' to list the references for this object and then remove them."
                }
                Else {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
            }
            Write-Verbose -Message "ServiceManager $ServiceManagerTemplate_id successfully removed"
        }
    }
    End {

    }
}

Function Copy-AutomateNOWServiceManagerTemplate {
    <#
    .SYNOPSIS
    Copies a ServiceManager Template from an AutomateNOW! instance

    .DESCRIPTION
    Copies a ServiceManager Template from an AutomateNOW! instance. AutomateNOW object id can never be changed, but we can copy the object to a new id and it will include all of the items therein.

    .PARAMETER ServiceManagerTemplate
    Mandatory [ANOWServiceManagerTemplate] object to be copied.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the ServiceManager Template. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER Description
    Optional description of the ServiceManager Template (may not exceed 255 characters). You may send an empty string here to ensure that the description is blanked out. Do not use this parameter if your intention is to keep the description from the previous ServiceManager Template.

    .PARAMETER UnsetDescription
    Optional switch that will ensure that the newly created ServiceManager Template will not carry over its previous description.

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new ServiceManager Template. The UnsetTags DOES NOT influence this parameter.

    .PARAMETER UnsetTags
    Optional switch that will purposely omit the previously existing tags on the new copy of the ServiceManager Template. You can still specify new tags with -Tags but the old previous ones will not be carried over. In the UI, this is accomplished by clicking the existing tags off.

    .PARAMETER Folder
    Optional name of the folder to place the ServiceManager Template into. The UnsetFolder parameter overrides this setting.

    .PARAMETER UnsetFolder
    Optional switch that will ensure that the newly created ServiceManager Template will not be placed in a folder.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .PARAMETER Force
    Force the copy without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWServiceManagerTemplate] objects are accepted. Pipeline support is intentionally unavailable.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    This is a safe standard example that is recommended

    $ServiceManager01 = Get-AutomateNOWServiceManagerTemplate -Id 'old_name_ServiceManager01'
    Copy-AutomateNOWServiceManagerTemplate -ServiceManagerTemplate $ServiceManager01 -NewId 'new_name_ServiceManager02'

    .EXAMPLE
    This is a one-liner approach

    Copy-AutomateNOWServiceManagerTemplate -ServiceManagerTemplate (Get-AutomateNOWServiceManagerTemplate -Id 'old_name_ServiceManager01') -NewId 'new_name_ServiceManager02'

    .EXAMPLE
    This approach users a For Each loop to iterate through a standard renaming pattern. This approach is not recommended.

    @( 'ServiceManager1', 'ServiceManager2', 'ServiceManager3') | Get-AutomateNOWServiceManagerTemplate | ForEachObject { Copy-AutomateNOWServiceManagerTemplate -ServiceManagerTemplate $_ -NewId ($_.simpleId -replace 'ServiceManager[0-9]', ()'ServiceManager-' + $_.simpleId[-1]))}

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The new id (name) of the ServiceManager Template must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.
    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWServiceManagerTemplate]$ServiceManagerTemplate,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$ServiceManager_template_exists = ($null -ne (Get-AutomateNOWServiceManagerTemplate -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWServiceManagerTemplate failed to check if the ServiceManager Template [$NewId] already existed due to [$Message]."
            Break
        }
        If ($ServiceManager_template_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a ServiceManager Template named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End warning ##
        [string]$command = '/processingTemplate/copy'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            [string]$ServiceManagerTemplate_oldId = $ServiceManagerTemplate.id
            [string]$ServiceManagerTemplate_simpleId = $ServiceManagerTemplate.simpleId
            If ($ServiceManagerTemplate_oldId -eq $NewId) {
                Write-Warning -Message "The new id cannot be the same as the old id."
                Break
            }
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Copy the ServiceManager Template $($ServiceManagerTemplate_simpleId) to $($NewId)?")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                $BodyMetaData.'oldId' = $ServiceManagerTemplate_oldId
                $BodyMetaData.'domain' = $ServiceManagerTemplate.domain
                $BodyMetaData.'id' = $NewId
                If ($UnsetDescription -ne $true) {
                    If ($Description.Length -gt 0) {
                        $BodyMetaData.'description' = $Description
                    }
                    Else {
                        $BodyMetaData.'description' = $ServiceManagerTemplate.description
                    }
                }
                If ($UnsetFolder -ne $True) {
                    If ($Folder.Length -gt 0) {
                        $BodyMetaData.'folder' = $Folder
                    }
                    Else {
                        $BodyMetaData.'folder' = $ServiceManagerTemplate.folder
                    }
                }
                [int32]$tag_count = 1
                If ($Tags.Count -gt 0) {
                    ForEach ($tag in $Tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
                If ($UnsetTags -ne $true) {
                    If ($ServiceManagerTemplate.tags -gt 0) {
                        ForEach ($tag in $ServiceManagerTemplate.tags) {
                            $BodyMetaData.('tags' + $tag_count ) = $tag
                            $tag_count++
                        }
                    }
                }
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_operationId' = 'copy'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_dataSource' = 'ProcessingTemplateDataSource'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData #-IncludeProperties oldId, domain, NewId, description, folder
                $Body = $Body -replace '&tags[0-9]{1,}', '&tags'
                $parameters.Body = $Body
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ServiceManagerTemplate_id] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                $Error.Clear()
                Try {
                    [ANOWServiceManagerTemplate]$ServiceManagerTemplate = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to create copied [ANOWServiceManagerTemplate] object due to [$Message]."
                    Break
                }
                If ($ServiceManagerTemplate.id.Length -eq 0) {
                    Write-Warning -Message "Somehow the newly created (copied) [ANOWServiceManagerTemplate] object is empty!"
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $ServiceManagerTemplate
                }
            }
        }
    }
    End {

    }
}

Function Rename-AutomateNOWServiceManagerTemplate {
    <#
    .SYNOPSIS
    Renames a ServiceManager Template from an AutomateNOW! instance

    .DESCRIPTION
    Performs a psuedo-rename operations of a ServiceManager Template from an AutomateNOW! instance by copying it first and then deleting the source. This function merely combines Copy-AutomateNOWServiceManagerTemplate and Remove-AutomateNOWServiceManagerTemplate therefore it is to be considered destructive.

    .PARAMETER ServiceManagerTemplate
    An [ANOWServiceManagerTemplate] object representing the ServiceManager Template to be renamed.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the ServiceManager Template. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER Force
    Force the renaming without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly renamed object.

    .INPUTS
    ONLY [ANOWServiceManagerTemplate] objects are accepted. There is intentionally no support for the pipeline.

    .OUTPUTS
    The newly renamed [ANOWServiceManagerTemplate] object will be returned.

    .EXAMPLE
    $ServiceManager_template = Get-AutomateNOWServiceManagerTemplate -Id 'ServiceManager01'
    Rename-AutomateNOWServiceManagerTemplate -ServiceManagerTemplate $ServiceManager_template -NewId 'ServiceManager_TEMPLATE_01'

    .EXAMPLE
    Rename-AutomateNOWServiceManagerTemplate -ServiceManagerTemplate (Get-AutomateNOWServiceManagerTemplate -Id 'ServiceManager01') -NewId 'ServiceManager_TEMPLATE_01'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    When renaming, you may only specify a different Id (name).

    This action will be blocked if any existing referrals are found on the object.
    #>
    [OutputType([ANOWServiceManagerTemplate])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWServiceManagerTemplate]$ServiceManagerTemplate,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin standard warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$new_ServiceManager_template_exists = ($null -ne (Get-AutomateNOWServiceManagerTemplate -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWServiceManagerTemplate failed to check if the ServiceManager Template [$NewId] already existed due to [$Message]."
            Break
        }
        If ($new_ServiceManager_template_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a ServiceManager Template named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        [string]$ServiceManagerTemplate_id = $ServiceManagerTemplate.id
        $Error.Clear()
        Try {
            [boolean]$old_ServiceManager_template_exists = ($null -ne (Get-AutomateNOWServiceManagerTemplate -Id $ServiceManagerTemplate_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWServiceManagerTemplate failed to check if the ServiceManager Template [$ServiceManagerTemplate_id] already existed due to [$Message]."
            Break
        }
        If ($old_ServiceManager_template_exists -eq $false) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not a ServiceManager Template named [$ServiceManagerTemplate_id] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End standard warning ##
        ## Begin referrals warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [int32]$referrals_count = Find-AutomateNOWObjectReferral -ServiceManagerTemplate $ServiceManagerTemplate -Count | Select-Object -Expandproperty referrals
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Find-AutomateNOWObjectReferral failed to extract the referrals on ServiceManager Template [$ServiceManagerTemplate_id] due to [$Message]."
            Break
        }
        If ($referrals_count -gt 0) {
            Write-Warning -Message "Unfortunately, you cannot rename a ServiceManager Template that has referrals. This is because the rename is not actually renaming but copying anew and deleting the old. Please, use the Find-AutomateNOWObjectReferral function to identify referrals and remove them."
            Break
        }
        Else {
            Write-Verbose -Message "The ServiceManager Template [$ServiceManagerTemplate_id] does not have any referrals. It is safe to proceed."
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ServiceManagerTemplate_id)")) -eq $true) {
                $Error.Clear()
                Try {
                    [ANOWServiceManagerTemplate]$new_ServiceManager_template = Copy-AutomateNOWServiceManagerTemplate -ServiceManagerTemplate $ServiceManagerTemplate -NewId $NewId -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Copy-AutomateNOWServiceManagerTemplate failed to create a new ServiceManager Template [$NewId] as Part 1 of the renaming process due to [$Message]."
                    Break
                }
                If ($new_ServiceManager_template.simpleId -eq $NewId) {
                    Write-Verbose -Message "Part 1: ServiceManager template [$ServiceManagerTemplate_id] successfully copied to [$NewId]"
                }
                Else {
                    Write-Warning -Message "Somehow the first phase (Copy-AutomateNOWServiceManagerTemplate) failed. Please look into this."
                    Break
                }
                $Error.Clear()
                Try {
                    Remove-AutomateNOWServiceManagerTemplate -ServiceManagerTemplate $ServiceManagerTemplate -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Remove-AutomateNOWServiceManagerTemplate failed to remove [$ServiceManagerTemplate_id] as Part 2 of the renaming process due to [$Message]."
                    Break
                }
                Write-Verbose -Message "Part 2: ServiceManager template [$ServiceManagerTemplate_id] removed"
                Write-Verbose -Message "ServiceManager [$ServiceManagerTemplate_id] successfully renamed to [$NewId]"
                If ($Quiet -ne $true) {
                    Return $new_ServiceManager_template
                }
            }
        }
        Else {
            Write-Warning -Message "No action was taken because either the source object didn't exist or the new object already existed"
        }
    }
    End {
    }
}

Function Start-AutomateNOWServiceManagerTemplate {
    <#
    .SYNOPSIS
    Starts a ServiceManager Template from an AutomateNOW! instance

    .DESCRIPTION
    Starts a ServiceManager Template from an AutomateNOW! instance

    .PARAMETER ServiceManagerTemplate
    An [ANOWServiceManagerTemplate] object representing the ServiceManager Template to be started.

    .PARAMETER ServiceManagerTemplateId
    A string representing the Id of the ServiceManager Template. Do not include the domain prefix.

    .Parameter ServiceManagerParameters
    An optional [hashtable] containing the parameters to start the Task Template with. Example: @{"parameter1"="ABC";"parameter2"="123";}

    .PARAMETER UseAutomaticName
    A switch parameter that is ENABLED BY DEFAULT. You do not need to enable this as it is defaulted to on. This parameter simulates the default format of the executed ServiceManager name (see 'Name' below)

    .PARAMETER Name
    A string representing the name of the running executed ServiceManager. Only use this if you want to OVERRIDE the default naming standard that the console suggests when executing a ServiceManager. The console defaults to a format of "Manual Execution - [ServiceManager name] - [date utc]".

    .PARAMETER Description
    Optional description of the executed ServiceManager (may not exceed 255 characters).

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new ServiceManager.

    .PARAMETER Folder
    Optional name of the folder to place the executed Service Manager into.

    .PARAMETER ProcessingTimestamp
    This parameter is -disabled- for now. Instead, the default timestamp will be used to ensure uniqueness. The documentation is unclear or mistaken around this parameter.

    .PARAMETER DelayedStartTime
    Optional string that allows processing items to start on a specific date or time or delay the execution for a period ranging from days to seconds. Example 1: 2029-12-31, Example 2: 2029-12-31 23:59:59, Example 3: 23:59:59

    .PARAMETER TimeZone
    Optional [ANOWTimeZone] object that modifies (it is unknown exactly what this property modifies since it is not defined in the documentation yet)

    .PARAMETER Priority
    Optional integer between 0 and 1000 to specify the priority of the executed ServiceManager. Defaults to 0.

    .PARAMETER Hold
    Optional switch to set the 'On Hold' property of the executed ServiceManager to enabled. This is $false by default but in the console the checkbox is enabled.

    .PARAMETER VerboseMode
    Optional switch that will cause the Workflow to "produce more events with minor performance impact"

    .PARAMETER ForceLoad
    Optional switch that overrides any 'Ignore Condition' that might exist on the ServiceManager Template

    .PARAMETER Quiet
    Switch parameter to silence the newly created [ANOWServiceManager] object

    .INPUTS
    ONLY [ANOWServiceManagerTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    An [ANOWServiceManager] object representing the started ServiceManager will be returned.

    .EXAMPLE
    Starts a ServiceManager Template named 'ServiceManagerTemplate1'

    Get-AutomateNOWServiceManagerTemplate -Id 'ServiceManagerTemplate1' | Start-AutomateNOWServiceManagerTemplate

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Avoid using the -Name parameter unless you really need to use it. If -Name is not supplied, the parameter set will use -UseAutomaticName instead, which simulates the behavior of the console.

    As of Patch 88, there is a bug where the Folder is not recognized (included) when executing a Service Manager Template.

    #>
    [Cmdletbinding(DefaultParameterSetName = 'UseAutomaticName')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'Object', ValueFromPipeline = $True)]
        [ANOWServiceManagerTemplate]$ServiceManagerTemplate,
        [Parameter(Mandatory = $true, ParameterSetName = 'Id')]
        [string]$ServiceManagerTemplateId,
        [Parameter(Mandatory = $false)]
        [hashtable]$ServiceManagerParameters,
        [Parameter(Mandatory = $false, ParameterSetName = 'UseAutomaticName')]
        [boolean]$UseAutomaticName = $true,
        [Parameter(Mandatory = $true, ParameterSetName = 'SpecifyNameManually')]
        [string]$Name,
        [Parameter(Mandatory = $false, HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [string]$Folder = '',
        [ValidateScript({ $_ -match '([0-9]{4}-[0-9]{2}-[0-9]{2}){0,}( {0,}[0-9]{2}:[0-9]{2}:[0-9]{2}){0,}' })]
        [Parameter(Mandatory = $false)]
        [string]$DelayedStartTime,
        [Parameter(Mandatory = $false)]
        [ANOWTimeZone]$TimeZone,
        [ValidateRange(0, 1000)]
        [Parameter(Mandatory = $false)]
        [int32]$Priority = 0,
        [Parameter(Mandatory = $false)]
        [switch]$Hold,
        [Parameter(Mandatory = $false)]
        [switch]$VerboseMode,
        [Parameter(Mandatory = $false)]
        [switch]$ForceLoad,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processing/executeNow'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [string]$domain = $anow_session.current_domain
        If ($_.id.Length -gt 0) {
            [string]$ServiceManagerTemplate_id = $_.id
        }
        ElseIf ($ServiceManagerTemplateId.Length -gt 0) {
            [string]$ServiceManagerTemplate_Id = ('[' + $domain + ']' + $ServiceManagerTemplateId )
        }
        ElseIf ($Id.Length -gt 0) {
            [string]$ServiceManagerTemplate_Id = ('[' + $domain + ']' + $Id )
        }
        Else {
            [string]$ServiceManagerTemplate_id = $ServiceManagerTemplate.id
        }
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        $BodyMetaData.Add('id', $ServiceManagerTemplate_id )
        $BodyMetaData.Add('runId', $ServiceManagerTemplate_id )
        $BodyMetaData.Add('priority', $priority )
        $BodyMetaData.Add('processingTimestamp', [string](Get-Date -Date ((Get-Date).ToUniversalTime()) -Format 'yyyy-MM-ddTHH:mm:ss.fff'))
        If ($DelayedStartTime.Length -gt 0) {
            $BodyMetaData.Add('delayedStartTime', $DelayedStartTime)
        }
        If ($null -ne $TimeZone) {
            [string]$timezone_id = ($TimeZone.id)
            $BodyMetaData.Add('timeZone', $timezone_id )
        }
        [string[]]$include_properties = 'id', 'runId', 'priority', 'processingTimestamp', 'hold', 'forceLoad', 'name'
        If ($Tags.Count -gt 0) {
            [int32]$total_tags = $Tags.Count
            [int32]$current_tag = 1
            ForEach ($tag_id in $Tags) {
                $Error.Clear()
                Try {
                    [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] under Start-AutomateNOWServiceManagerTemplate due to [$message]"
                    Break
                }
                If ($tag_object.simpleId.length -eq 0) {
                    Throw "Start-AutomateNOWServiceManagerTemplate has detected that the tag [$tag_id] does not appear to exist. Please check again."
                    Break
                }
                ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                    [string]$tag_object_simpleId = $tag_object.simpleId
                    Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                    Break
                }
                [string]$tag_display = $tag_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
                [string]$tag_name_sequence = ('tags' + $current_tag)
                $BodyMetaData.Add($tag_name_sequence, $tag_id)
                $include_properties += $tag_name_sequence
                $current_tag++
            }
        }
        If ($folder.Length -gt 0) {
            $Error.Clear()
            Try {
                [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWFolder had an error while retrieving the folder [$folder] running under Start-AutomateNOWServiceManagerTemplate due to [$message]"
                Break
            }
            If ($folder_object.simpleId.Length -eq 0) {
                Throw "Start-AutomateNOWServiceManagerTemplate has detected that the folder [$folder] does not appear to exist. Please check again."
                Break
            }
            $BodyMetaData.Add('folder', $folder)
            $include_properties += $folder
        }
        If ($hold -ne $true) {
            $BodyMetaData.Add('hold', 'false')
        }
        Else {
            $BodyMetaData.Add('hold', 'true')
        }
        If ($forceLoad -ne $true) {
            $BodyMetaData.Add('forceLoad', 'false')
        }
        Else {
            $BodyMetaData.Add('forceLoad', 'true')
        }
        If ($VerboseMode -ne $true) {
            $BodyMetaData.Add('verboseMode', 'true')
        }
        Else {
            $BodyMetaData.Add('verboseMode', 'true')
        }
        If ($ServiceManagerParameters.Count -gt 0) {
            $Error.Clear()
            Try {
                [string]$task_parameters_json = $ServiceManagerParameters | ConvertTo-Json -Compress
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "ConvertTo-Json failed to execute the provided parameters to Start-AutomateNOWServiceManagerTemplate due to [$Message]."
                Break
            }
            $BodyMetaData.Add('parameters', $task_parameters_json)
        }
        Else {
            $BodyMetaData.Add('parameters', '{}')
        }
        If ($Name.Length -gt 0) {
            $BodyMetaData.Add('name', $Name)
        }
        ElseIf ($UseAutomaticName -eq $true) {
            [string]$Name = New-AutomateNOWDefaultProcessingTitle -simpleId $ServiceManagerTemplate_simpleId
            Write-Verbose -Message "Generated automatic name [$Name] for this ServiceManager"
            $BodyMetaData.Add('name', $Name)
        }
        Else {
            Write-Warning -Message "Unable to determine how to name this ServiceManager that needs to be started"
            Break
        }
        $BodyMetaData.Add('_operationType', 'add')
        $BodyMetaData.Add('_operationId', 'executeNow')
        $BodyMetaData.Add('_textMatchStyle', 'exact')
        $BodyMetaData.Add('_dataSource', 'ProcessingDataSource')
        $BodyMetaData.Add('isc_metaDataPrefix', '_')
        $BodyMetaData.Add('isc_dataFormat', 'json')
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        If ($null -eq $parameters.Body) {
            $parameters.Add('Body', $Body)
        }
        Else {
            $parameters.Body = $Body
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ServiceManagerTemplate_id] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        Write-Verbose -Message "ServiceManager $ServiceManagerTemplate_id successfully started as [$Name]"
        $Error.Clear()
        Try {
            [ANOWServiceManager]$ServiceManager = $results.response.data | Select-Object -First 1
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Unable to create the [ANOWServiceManager] object under Start-AutomateNOWServiceManagerTemplate from the response due to [$Message]."
            Break
        }
        If ($Quiet -ne $true) {
            Return $ServiceManager
        }
    }
    End {

    }
}

Function Resume-AutomateNOWServiceManagerTemplate {
    <#
    .SYNOPSIS
    Resumes a ServiceManager Template that is on hold (suspended) on an AutomateNOW! instance

    .DESCRIPTION
    Resumes a ServiceManager Template that is on hold (suspended) on an AutomateNOW! instance

    .PARAMETER ServiceManagerTemplate
    An [ANOWServiceManagerTemplate] object representing the ServiceManager Template to be resumed

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Switch parameter to silence the emitted [ANOWServiceManagerTemplate] object

    .INPUTS
    ONLY [ANOWServiceManagerTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    The resumed [ANOWServiceManagerTemplate] object will be returned

    .EXAMPLE
    Get-AutomateNOWServiceManagerTemplate -Id 'ServiceManagerTemplate01' | Resume-AutomateNOWServiceManagerTemplate -Force

    .EXAMPLE
    Get-AutomateNOWServiceManagerTemplate -Id 'ServiceManagerTemplate01', 'ServiceManagerTemplate02' | Resume-AutomateNOWServiceManagerTemplate

    .EXAMPLE
    @( 'ServiceManagerTemplate1', 'ServiceManagerTemplate2', 'ServiceManagerTemplate3') | Resume-AutomateNOWServiceManagerTemplate

    .EXAMPLE
    Get-AutomateNOWServiceManagerTemplate | ? { $_.ServiceManagerType -eq 'FOR_EACH' } | Resume-AutomateNOWServiceManagerTemplate

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.
    #>

    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWServiceManagerTemplate]$ServiceManagerTemplate,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processingTemplate/resume'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWServiceManagerTemplate]$ServiceManagerTemplate = $_
        }
        [string]$ServiceManagerTemplate_id = $ServiceManagerTemplate.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ServiceManagerTemplate_id)")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $ServiceManagerTemplate_id )
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_operationId', 'resume')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingTemplateDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ServiceManagerTemplate_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            $Error.Clear()
            Try {
                [ANOWServiceManagerTemplate]$resumed_ServiceManager_template = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to create the [ANOWServiceManagerTemplate] object after resuming [$ServiceManagerTemplate_id] due to [$Message]."
                Break
            }
            Write-Verbose -Message "ServiceManager $ServiceManagerTemplate_id successfully resumed"
            If ($Quiet -ne $true) {
                Return $resumed_ServiceManager_template
            }
        }
    }
    End {

    }
}

Function Suspend-AutomateNOWServiceManagerTemplate {
    <#
    .SYNOPSIS
    Places a ServiceManager Template on hold (suspend) from execution on an AutomateNOW! instance

    .DESCRIPTION
    Places a ServiceManager Template on hold (suspend) from execution on an AutomateNOW! instance

    .PARAMETER ServiceManagerTemplate
    An [ANOWServiceManagerTemplate] object representing the ServiceManager Template to be suspended (placed on hold)

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Switch parameter to silence the emitted [ANOWServiceManagerTemplate] object

    .INPUTS
    ONLY [ANOWServiceManagerTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    The suspended [ANOWServiceManagerTemplate] object will be returned

    .EXAMPLE
    Get-AutomateNOWServiceManagerTemplate -Id 'ServiceManager01' | Suspend-AutomateNOWServiceManagerTemplate -Force

    .EXAMPLE
    Get-AutomateNOWServiceManagerTemplate -Id 'ServiceManager01', 'ServiceManager02' | Suspend-AutomateNOWServiceManagerTemplate

    .EXAMPLE
    @( 'ServiceManager1', 'ServiceManager2', 'ServiceManager3') | Suspend-AutomateNOWServiceManagerTemplate

    .EXAMPLE
    Get-AutomateNOWServiceManagerTemplate | ? { $_.serverServiceManagerType -eq 'LINUX' } | Suspend-AutomateNOWServiceManagerTemplate

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWServiceManagerTemplate]$ServiceManagerTemplate,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processingTemplate/hold'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWServiceManagerTemplate]$ServiceManagerTemplate = $_
        }
        [string]$ServiceManagerTemplate_id = $ServiceManagerTemplate.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ServiceManagerTemplate_id)")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $ServiceManagerTemplate_id )
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_operationId', 'hold')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingTemplateDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ServiceManagerTemplate_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            $Error.Clear()
            Try {
                [ANOWServiceManagerTemplate]$suspended_ServiceManager_template = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to create the [ANOWServiceManagerTemplate] object after suspending [$ServiceManagerTemplate_id] due to [$Message]."
                Break
            }
            Write-Verbose -Message "ServiceManager $ServiceManagerTemplate_id successfully suspended (placed on hold)"
            If ($Quiet -ne $true) {
                Return $suspended_ServiceManager_template
            }
        }
    }
    End {

    }
}

Function Skip-AutomateNOWServiceManagerTemplate {
    <#
    .SYNOPSIS
    Sets or unsets the Skip flag on a ServiceManager Template on an AutomateNOW! instance

    .DESCRIPTION
    Sets or unsets the Skip flag on a ServiceManager Template on an AutomateNOW! instance

    .PARAMETER ServiceManagerTemplate
    An [ANOWServiceManagerTemplate] object representing the ServiceManager Template to be set to skipped or unskipped

    .PARAMETER UnSkip
    Removes the skip flag from an [ANOWServiceManagerTemplate] object. This is the opposite of the default behavior.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Switch parameter to silence the emitted [ANOWServiceManagerTemplate] object

    .INPUTS
    ONLY [ANOWServiceManagerTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    The skipped/unskipped [ANOWServiceManagerTemplate] object will be returned

    .EXAMPLE
    Sets a ServiceManager Template to Skip (bypass)

    Get-AutomateNOWServiceManagerTemplate -Id 'ServiceManagerTemplate01' | Skip-AutomateNOWServiceManagerTemplate -Force

    .EXAMPLE
    Unsets the Skip (bypass) flag on a ServiceManager Template

    Get-AutomateNOWServiceManagerTemplate | Skip-AutomateNOWServiceManagerTemplate -UnSkip

    .EXAMPLE
    Sets an array of ServiceManager Template to Skip (bypass)

    @( 'ServiceManagerTemplate1', 'ServiceManagerTemplate2', 'ServiceManagerTemplate3') | Skip-AutomateNOWServiceManagerTemplate

    .EXAMPLE
    Get-AutomateNOWServiceManagerTemplate | ? { $_.ServiceManagerType -eq 'FOR_EACH' } | Skip-AutomateNOWServiceManagerTemplate -UnSkip -Force -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWServiceManagerTemplate]$ServiceManagerTemplate,
        [Parameter(Mandatory = $false)]
        [switch]$UnSkip,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnSkip -ne $True) {
            [string]$skip_flag_status = 'On'
            [string]$operation_id = 'passByOn'
            [string]$ProcessDescription = 'Add the Skip flag'
        }
        Else {
            [string]$skip_flag_status = 'Off'
            [string]$operation_id = 'passByOff'
            [string]$ProcessDescription = 'Remove the Skip flag'
        }
        [string]$command = ('/processingTemplate/' + $operation_id)
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWServiceManagerTemplate]$ServiceManagerTemplate = $_
        }
        [string]$ServiceManagerTemplate_id = $ServiceManagerTemplate.id
        If ($ServiceManagerTemplate.passBy -eq $true -and $UnSkip -ne $True) {
            Write-Warning -Message "ServiceManager Template $ServiceManagerTemplate_id already has the skip flag set. No action is required."
            Break
        }
        ElseIf ($ServiceManagerTemplate.passBy -eq $false -and $UnSkip -eq $True) {
            Write-Warning -Message "ServiceManager Template $ServiceManagerTemplate_id does not have the skip flag set. No action is required."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess($ServiceManagerTemplate_id, $ProcessDescription)) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $ServiceManagerTemplate_id )
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_operationId', $operation_id)
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingTemplateDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ServiceManagerTemplate_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            $Error.Clear()
            Try {
                [ANOWServiceManagerTemplate]$skipped_ServiceManager_template = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to create the [ANOWServiceManagerTemplate] object after setting the skip flag to [$skip_flag_status] on [$ServiceManagerTemplate_id] due to [$Message]."
                Break
            }
            Write-Verbose -Message "Successfully set the skip flag to [$skip_flag_status] on [$ServiceManagerTemplate_id]"
            If ($Quiet -ne $true) {
                Return $skipped_ServiceManager_template
            }
        }
    }
    End {

    }
}

Function Confirm-AutomateNOWServiceManagerTemplate {
    <#
    .SYNOPSIS
    Validates (confirms) a ServiceManager Template on an AutomateNOW! instance

    .DESCRIPTION
    Validates (confirms) a ServiceManager Template on an AutomateNOW! instance

    .PARAMETER ServiceManagerTemplate
    An [ANOWServiceManagerTemplate] object representing the ServiceManager Template to be set to confirmed (verified)

    .PARAMETER Quiet
    Returns a boolean $true or $false based on the result of the validation check

    .INPUTS
    ONLY [ANOWServiceManagerTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    A string with the results from the API will returned.

    .EXAMPLE
    Validates a single ServiceManager Template

    Get-AutomateNOWServiceManagerTemplate -Id 'ServiceManagerTemplate01' | Confirm-AutomateNOWServiceManagerTemplate

    .EXAMPLE
    Validates a series of ServiceManager Templates

    @( 'ServiceManagerTemplate1', 'ServiceManagerTemplate2', 'ServiceManagerTemplate3') | Confirm-AutomateNOWServiceManagerTemplate

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWServiceManagerTemplate]$ServiceManagerTemplate,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [string]$ServiceManagerTemplate_id = $_.id
        }
        ElseIf ($ServiceManagerTemplate.id.Length -gt 0) {
            [string]$ServiceManagerTemplate_id = $ServiceManagerTemplate.id
        }
        Else {
            [string]$ServiceManagerTemplate_id = $Id
        }
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        $BodyMetaData.Add('id', $ServiceManagerTemplate_id )
        $BodyMetaData.Add('_operationType', 'custom')
        $BodyMetaData.Add('_operationId', 'validate')
        $BodyMetaData.Add('_textMatchStyle', 'exact')
        $BodyMetaData.Add('_dataSource', 'ProcessingTemplateDataSource')
        $BodyMetaData.Add('isc_metaDataPrefix', '_')
        $BodyMetaData.Add('isc_dataFormat', 'json')
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        [string]$command = ('/processingTemplate/validate?' + $Body)
        $parameters.Add('Command', $command)
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ServiceManagerTemplate_id] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            If ($Quiet -eq $true) {
                Return $false
            }
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "The response code was [$response_code] instead of 0. The ServiceManager Template $ServiceManagerTemplate_id is not validated. Please see the full response $full_response_display"
        }
        Else {
            If ($Quiet -eq $true) {
                Return $true
            }
            Else {
                Write-Information -MessageData "The ServiceManager Template $ServiceManagerTemplate_id is confirmed as valid."
            }
        }
    }
    End {

    }
}

#endregion

#Region - Service Manager Template Items (PROCESSING_TEMPLATE_ITEM)

Function Read-AutomateNOWServiceManagerTemplateItem {
    <#
    .SYNOPSIS
    Reads the processing items and their -sort order- within a ServiceManager Template from an AutomateNOW! instance

    .DESCRIPTION
    Reads the processing items and their -sort order- within a ServiceManager Template from an AutomateNOW! instance

    .PARAMETER ServiceManagerTemplate
    An [ANOWServiceManagerTemplate] object representing the ServiceManager Template to be read.

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .INPUTS
    ONLY [ANOWServiceManagerTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    [ANOWProcessingTemplateItem] objects that represent the processing template items will be returned.

    .EXAMPLE
    Get all of the items in a specified ServiceManager.

    $ServiceManager_template = Get-AutomateNOWServiceManagerTemplate -Id 'ServiceManagerTemplate1'
    $ServiceManager_template_items = $ServiceManager_template | Read-AutomateNOWServiceManagerTemplateItem

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The first item listed will be the ServiceManager itself which has a sort order of -1. The remaining child items will start at sort order 1 or above. There is no sort order of 0.

    #>
    [OutputType([ANOWProcessingTemplateItem[]])]
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWServiceManagerTemplate]$ServiceManagerTemplate,
        [Parameter(Mandatory = $False)]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False)]
        [int32]$endRow = 100
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWServiceManagerTemplate]$ServiceManagerTemplate = $_
        }
        [string]$ServiceManagerTemplate_id = $ServiceManagerTemplate.Id
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        $BodyMetaData.Add('workflow', $ServiceManagerTemplate_id )
        $BodyMetaData.Add('_operationType', 'fetch')
        $BodyMetaData.Add('_operationId', 'readWorkflow')
        $BodyMetaData.Add('_startRow', $startRow)
        $BodyMetaData.Add('_endRow', $endRow)
        $BodyMetaData.Add('_sortBy1', '-isMasterRecord')
        $BodyMetaData.Add('_sortBy2', 'sortOrder')
        $BodyMetaData.Add('_sortBy3', 'title')
        $BodyMetaData.Add('_textMatchStyle', 'exact')
        $BodyMetaData.Add('_componentId', 'ProcessingTemplateItemList')
        $BodyMetaData.Add('_dataSource', 'ProcessingTemplateItemDataSource')
        $BodyMetaData.Add('isc_metaDataPrefix', '_')
        $BodyMetaData.Add('isc_dataFormat', 'json')
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        [string]$command = ('/processingTemplateItem/read' + '?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.'Command' = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ServiceManagerTemplate_id] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        If ($results.response.data.count -gt 0) {
            $Error.Clear()
            Try {
                If ($null -eq $ServiceManagerTemplate) {
                    If ($results.response.data.count -ne 1) {
                        Write-Warning -Message "The expected number of Workflow Template Items in this scenario was 1. Please look into this."
                        Break
                    }
                    [string]$ServiceManagerTemplateItem_Id = $results.response.data.id
                    If ($results.response.data.workflow.Length -eq 0) {
                        Write-Warning -Message "The workflow property within Service Manager Template Item $ServiceManagerTemplateItem_Id was empty. Please look into this."
                        Break
                    }
                    [string]$ServiceManagerTemplate_simpleId = $results.response.data.workflow -split ']' | Select-Object -Last 1
                    [ANOWServiceManagerTemplate]$ServiceManagerTemplate = Get-AutomateNOWServiceManagerTemplate -Id $ServiceManagerTemplate_simpleId
                }
                [ANOWProcessingTemplateItem[]]$ProcessingTemplateItems = $results.response.data | Where-Object { $_.sortOrder -ge 0 } | ForEach-Object {
                    $_.workflow = $ServiceManagerTemplate
                    If ($_.processingType -eq 'TRIGGER' -or $_.parentProcessingType -eq 'TRIGGER') {
                        [ANOWScheduleTemplateItem]$_
                    }
                    ElseIf ($_.processingType -eq 'WORKFLOW' -or $_.parentProcessingType -eq 'WORKFLOW') {
                        [ANOWWorkflowTemplateItem]$_
                    }
                    ElseIf ($_.processingType -eq 'TASK' -or $_.parentProcessingType -eq 'TASK') {
                        [ANOWTaskTemplateItem]$_
                    }
                    ElseIf ($_.processingType -eq 'SERVICE' -or $_.parentProcessingType -eq 'SERVICE') {
                        [ANOWServiceManagerTemplateItem]$_
                    }
                    Else {
                        [string]$processingType = $_.processingType
                        [string]$parentProcessingType = $_.parentProcessingType
                        Write-Warning -Message "Unable to determine the type of Processing Template ($processingType / $parentProcessingType) under Read-AutomateNOWServiceManagerTemplateItem reading $ServiceManagerTemplateItem_Id. Please look into this."
                        Break
                    }
                }
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the Workflow Template Items from $ServiceManagerTemplateItem_Id due to [$Message]"
                Break
            }
            Write-Verbose -Message "Workflow Template Items successfully read from $ServiceManagerTemplateItem_Id"
            If ($Name.Length -gt 0) {
                [ANOWProcessingTemplateItem[]]$ProcessingTemplateItems = $ProcessingTemplateItems | Where-Object { $_.name -eq $Name } | Select-Object -First 1
            }
            Return $ProcessingTemplateItems
        }
        Else {
            Write-Verbose -Message "There were no Service Manager Template Items within $ServiceManagerTemplate_id"
        }
    }
    End {

    }
}

Function Add-AutomateNOWServiceManagerTemplateItem {
    <#
    .SYNOPSIS
    Adds a Processing Template to a ServiceManager Template

    .DESCRIPTION
    Adds a Processing Template (i.e. Task, ServiceManager, Service Manager or Integration) to a ServiceManager Template

    .PARAMETER ServiceManagerTemplate
    Mandatory [ANOWServiceManagerTemplate] object representing the ServiceManager Template that will receive the new Processing Template.

    .Parameter ProcessingTemplate
    Mandatory [PSObject] (either Task Template or ServiceManager Template) object representing the Processing Template that is being added to the ServiceManager Template.

    .PARAMETER sortOrder
    Optional int32 specifying the sort order. When not specified, the sort order will be LAST. If needed, use Read-AutomateNOWServiceManager to obtain the current sort order of the items in the ServiceManager.

    .PARAMETER Quiet
    Switch parameter to silence the emitted [ANOWServiceManagerTemplateItem] object

    .PARAMETER Force
    Force the addition of the object without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    Either [ANOWTaskTemplate] or [ANOWServiceManagerTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Forcibly adds a Task Template ($task_template1) and a ServiceManager Template ($ServiceManager_template1) to a ServiceManager Template ($ServiceManager_template2)

    $task_template1 = Get-AutomateNOWTaskTemplate -Id 'TaskTemplate01'
    $ServiceManager_template1 = Get-AutomateNOWTaskTemplate -Id 'ServiceManagerTemplate01'
    $ServiceManager_template2 = Get-AutomateNOWTaskTemplate -Id 'ServiceManagerTemplate02'

    @($task_template1, $ServiceManager_template1) | Add-AutomateNOWServiceManagerTemplateItem -ServiceManagerTemplate $ServiceManager_template2 -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Only Task Templates and ServiceManager Templates are supported. Service Managers and Integrations are not supported yet.

    The sort order cannot be changed yet through this module. All items are added as the last item.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWServiceManagerTemplate]$ServiceManagerTemplate,
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [PSObject]$ProcessingTemplate,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$ServiceManagerTemplate_id = $ServiceManagerTemplate.Id
        [string]$command = '/processingTemplateItem/create'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [PSObject]$ProcessingTemplate = $_
        }
        [string]$ProcessingTemplate_id = $ProcessingTemplate.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Add $($ProcessingTemplate_id) to $($ServiceManagerTemplate_id)")) -eq $true) {
            $Error.Clear()
            Try {
                [ANOWProcessingTemplateItem[]]$ServiceManagerTemplateItems = Read-AutomateNOWServiceManagerTemplateItem -ServiceManagerTemplate $ServiceManagerTemplate
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Read-AutomateNOWServiceManagerTemplateItem failed to Read $ServiceManagerTemplate_id under Add-AutomateNOWServiceManagerTemplateItem due to [$Message]."
                Break
            }
            [int32]$ServiceManagerTemplateItems_Count = $ServiceManagerTemplateItems.Count
            If ($ServiceManagerTemplateItems_Count -gt 0) {
                Write-Verbose -Message "$ServiceManagerTemplate_id currently has $ServiceManagerTemplateItems_Count items before any changes were made"
                [int32]$last_item_order = ($ServiceManagerTemplateItems | Sort-Object -Property sortOrder | Select-Object -Last 1 | Select-Object -ExpandProperty sortOrder) + 1
            }
            Else {
                Write-Verbose -Message "$ServiceManagerTemplate_id does not have any items yet. This will be the first item added to it."
                [int32]$last_item_order = 0
            }
            [ANOWProcessingTemplate_processingType]$processingType = $ProcessingTemplate.processingType
            # Note that the taskType property is still sent as an empty property when the Processing Template is a ServiceManager
            If ($null -ne $ProcessingTemplate.taskType) {
                [ANOWProcessingTemplate_taskType]$taskType = $ProcessingTemplate.taskType
            }
            Else {
                [string]$taskType = ''
            }
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('ServiceManager', $ServiceManagerTemplate_id )
            $BodyMetaData.Add('processingType', $processingType )
            $BodyMetaData.Add('processingTemplate', $processingTemplate_id )
            $BodyMetaData.Add('taskType', $taskType )
            $BodyMetaData.Add('sortOrder', $last_item_order )
            $BodyMetaData.Add('_operationType', 'add')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingTemplateItemDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties 'taskType'
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ServiceManagerTemplate_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            If ($results.response.data.count -gt 0) {
                $Error.Clear()
                Try {
                    [ANOWServiceManagerTemplateItem]$ProcessingTemplateItem = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to parse the returned Processing Template Item from $ServiceManagerTemplate_id into an [ANOWServiceManagerTemplateItem] object due to [$Message]"
                    Break
                }
                Write-Verbose -Message "ServiceManager Template Item $processingTemplate_id successfully added to $ServiceManagerTemplate_id"
                If ($Quiet -ne $true) {
                    Return $ProcessingTemplateItem
                }
            }
            Else {
                Write-Warning -Message "Somehow $processingTemplate_id was not added to $ServiceManagerTemplate_id. Please look into this."
            }
        }
    }
    End {

    }
}

Function Remove-AutomateNOWServiceManagerTemplateItem {
    <#
    .SYNOPSIS
    Removes a Processing Template from a ServiceManager Template

    .DESCRIPTION
    Removes a Processing Template Item (i.e. Task, ServiceManager, Service Manager or Integration) from a ServiceManager Template

    .PARAMETER ServiceManagerTemplate
    Mandatory [ANOWServiceManagerTemplate] object representing the ServiceManager Template that will lose a Processing Template.

    .Parameter ProcessingTemplateItem
    Mandatory [ANOWProcessingTemplateItem] (i.e. Task, ServiceManager, Service Manager or Integration) object representing the Processing Template Item that is being removed from the ServiceManager Template. Use Read-AutomateNOWServiceManagerTemplate to retrieve the Processing Template Items from a ServiceManager Template.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    You must present a [ANOWServiceManagerTemplate] object to the -ServiceManagerTemplate parameter along with [ANOWProcessingTemplateItem] objects to the -ProcessingTemplateItem parameter. The latter can be pipelined.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Removes a single Processing Template Item from a ServiceManager Template

    $ServiceManager_template = Get-AutomateNOWServiceManagerTemplate -Id 'ServiceManagerTemplate1'
    $processing_template_item = Read-AutomateNOWServiceManagerTemplateItem -ServiceManagerTemplate $ServiceManager_template | Where-Object { $_.Id -eq '3fc63622-5e87-468e-a71f-bd78450219e3'}
    Remove-AutomateNOWServiceManagerTemplateItem -ServiceManagerTemplate $ServiceManager_template -ProcessingTemplateItem $processing_template_item

    .EXAMPLE
    Forcibly removes all instances of a ServiceManager named 'ServiceManager1' that was added to a ServiceManager Template named 'ServiceManagerTemplate1'.

    $ServiceManager_template = Get-AutomateNOWServiceManagerTemplate -Id 'ServiceManagerTemplate1'
    $ServiceManager_items = Read-AutomateNOWServiceManagerTemplateItem -ServiceManagerTemplate $ServiceManager_template | Where-Object { $_.processingTemplate -eq 'ServiceManager1'}
    $ServiceManager_items | Remove-AutomateNOWServiceManagerTemplateItem -ServiceManagerTemplate $ServiceManager_template -Force

    .EXAMPLE
    Removes all Processing Template Items from a ServiceManager Template

    Read-AutomateNOWServiceManagerTemplateItem -ServiceManagerTemplate (Get-AutomateNOWServiceManagerTemplate -Id 'ServiceManagerTemplate1') | Remove-AutomateNOWServiceManagerTemplateItem -ServiceManagerTemplate (Get-AutomateNOWServiceManagerTemplate -Id 'ServiceManagerTemplate1')

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Only Task Templates and ServiceManager Templates are supported. Service Managers and Integrations are not supported yet.

    Remember that once a Processing Template is added to a ServiceManager Template or ServiceManager Template it becomes a Processing Template Item which have a 36-character GUID for the Id.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWServiceManagerTemplate]$ServiceManagerTemplate,
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWProcessingTemplateItem]$ProcessingTemplateItem,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$ServiceManagerTemplate_id = $ServiceManagerTemplate.Id
        [string]$command = '/processingTemplateItem/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWProcessingTemplateItem]$ProcessingTemplateItem = $_
        }
        [string]$ProcessingTemplateItem_id = $ProcessingTemplateItem.id
        If ($ProcessingTemplateItem_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If ($ProcessingTemplateItem_id -notmatch '^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$') {
            Write-Warning -Message "Was expecting the Id of the Processing Template Id to match a 36-character GUID, instead received [$ProcessingTemplateItem_id]. Please check into this."
            Break
        }
        Else {
            Write-Verbose -Message "Received [$ProcessingTemplateItem_id] for the Id of the Processing Template Item to be removed"
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ProcessingTemplateItem_id)")) -eq $true) {
            $Error.Clear()
            Try {
                [PSCustomObject]$ServiceManagerTemplateItems = Read-AutomateNOWServiceManagerTemplateItem -ServiceManagerTemplate $ServiceManagerTemplate
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Read-AutomateNOWServiceManagerTemplateItem failed to Read [$ServiceManagerTemplate_id] under Remove-AutomateNOWServiceManagerTemplateItem due to [$Message]."
                Break
            }
            [int32]$ServiceManagerTemplateItems_Count = $ServiceManagerTemplateItems.Count
            If ($ServiceManagerTemplateItems_Count -eq 0) {
                Write-Verbose -Message "$ServiceManagerTemplate_id does not have any Processing Template items added to it yet... Please check again."
                Break
            }
            If ($ProcessingTemplateItem_id -notin ($ServiceManagerTemplateItems.Id) ) {
                Write-Warning -Message "The Processing Template Item $ProcessingTemplateItem_id is not actually added to [$ServiceManagerTemplate_id]. Please check this."
                Break
            }
            [string]$old_values = $ProcessingTemplateItem.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $ProcessingTemplateItem_id )
            $BodyMetaData.Add('_oldValues', $old_values )
            $BodyMetaData.Add('_operationType', 'remove')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingTemplateItemDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ServiceManagerTemplate_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Processing Template $ProcessingTemplateItem_id ($processingType) was removed from $ServiceManagerTemplate_id"
        }
    }
    End {

    }
}

#endregion

#Region - Stocks (RESOURCE)

Function Get-AutomateNOWStock {
    <#
    .SYNOPSIS
    Gets the Stock objects from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Stock objects from an AutomateNOW! instance

    .PARAMETER Id
    Optional string containing the simple id of the Stock to fetch or you can pipeline a series of simple id strings. You may not enter an array here.

    .PARAMETER Detailed
    Switch parameter to provide the detailed properties of the [ANOWStock] object. This may only be used in conjunction with -Id. Use this option to see the fully populated object.

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100. The console default hard limit is 10,000.

    .PARAMETER sortBy
    Optional string parameter to sort the results by (may not be used with the Id parameter). Valid choices are: {To be continued...}

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .PARAMETER Folder
    Optional string to filter by a particular Folder

    .PARAMETER Tags
    Optional string array of Tags to filter by. Note that the 'containsAny' operator will be used.

    .INPUTS
    Accepts a string representing the simple id of the Stock from the pipeline or individually (but not an array).

    .OUTPUTS
    Either one or more [ANOWStock] objects

    .EXAMPLE
    Gets the first page of Stock objects

    Get-AutomateNOWStock

    .EXAMPLE
    Gets the first 500 Stock objects

    Get-AutomateNOWStock -startRow 0 -endRow 500

    .EXAMPLE
    Gets a single non-detailed Stock named 'Stock1'

    Get-AutomateNOWStock -Id 'Stock1'

    .EXAMPLE
    Gets the detailed version of a Stock named 'Stock1'

    Get-AutomateNOWStock -Id 'Stock1' -Detailed

    .EXAMPLE
    Gets a series of Stock objects through the pipeline

    'Stock1', 'Stock2' | Get-AutomateNOWStock

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(DefaultParameterSetName = 'Id')]
    Param(
        [Parameter(Mandatory = $False, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [Parameter(Mandatory = $False, ParameterSetName = 'Detailed', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'Detailed')]
        [switch]$Detailed,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [string]$sortBy = 'id',
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [switch]$Descending,
        [Parameter(Mandatory = $False)]
        [string]$Folder,
        [Parameter(Mandatory = $False)]
        [string[]]$Tags
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 ) {
            [string]$Stock_Id = $_
        }
        Else {
            [string]$Stock_Id = $Id
        }
        If ($Detailed -eq $true) {
            $Body.'id' = $Stock_Id
            [string]$textMatchStyle = 'exactCase'
            $Body.'_operationId' = 'readDetailed'
            [string]$Method = 'POST'
        }
        Else {
            $Body.'_constructor' = 'AdvancedCriteria'
            $Body.'operator' = 'and'
            $Body.'criteria1' = '{"fieldName":"resourceType","operator":"equals","value":"STOCK"}'
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
            If ($Stock_Id.Length -gt 0) {
                $Body.'criteria2' = ('{"fieldName":"simpleId","operator":"equals","value":"' + $Stock_Id + '"}')
                [string]$textMatchStyle = 'exact'
            }
            Else {
                [string]$textMatchStyle = 'substring'
            }
            $Body.'_componentId' = 'ResourceList'
            If ($Descending -eq $true) {
                $Body.'_sortBy' = '-' + $sortBy
            }
            Else {
                $Body.'_sortBy' = $sortBy
            }
            If ($Folder.Length -gt 0) {
                $Body.'criteria3' = ('{"fieldName":"folder","operator":"equals","value":"' + $Folder + '"}')
            }
            If ($Tags.Count -gt 0) {
                If ($Tags.Count -gt 1) {
                    $Error.Clear()
                    Try {
                        [string]$TagString = $Tags | ConvertTo-Json -Compress
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "ConvertTo-Json failed to convert the provided tag names under Get-AutomateNOWStock due to [$Message]."
                        Break
                    }
                }
                Else {
                    [string]$TagString = $Tags
                }
                $Body.'criteria4' = ('{"fieldName":"tags","operator":"containsAny","value":' + $TagString + '}')
            }
            [string]$Method = 'GET'
        }
        $Body.'_operationType' = 'fetch'
        $Body.'_textMatchStyle' = $textMatchStyle
        $Body.'_dataSource' = 'ResourceDataSource'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        If ($Detailed -eq $true) {
            [string]$command = ('/resource/readDetailed')
            If ($Null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            If ($null -eq $parameters["Command"]) {
                $parameters.Add('Command', $command)
            }
            Else {
                $parameters.Command = $command
            }
        }
        Else {
            [string]$command = ('/resource/read?' + $Body)
            $parameters.Command = $command
        }
        If ($null -eq $parameters.Method) {
            $parameters.Add('Method', $Method)
        }
        Else {
            $parameters.Method = $Method
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWStock[]]$Stocks = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWStock failed to parse the results into [ANOWStock] objects due to [$Message]."
            Break
        }
        If ($Stocks.Count -gt 0) {
            Return $Stocks
        }
    }
    End {

    }
}

Function Set-AutomateNOWStock {
    <#
    .SYNOPSIS
    Changes the settings of an Stock on an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of an Stock on an AutomateNOW! instance

    .PARAMETER Stock
    An [ANOWStock] object representing the Stock to be modified.

    .PARAMETER TotalPermits
    Integer to set the total permits. This value has a hard-limit of 1,000,000 in the UI but you can actually set it as high as 2,147,483,647 if you override the ValidateSet attribute for this parameter.

    .PARAMETER UnsetDescription
    Optional switch that will remove the Description from the Stock object.

    .PARAMETER Description
    Optional string to set the description on the new Stock object.

    .PARAMETER UnsetFolder
    Optional switch that will remove the Folder assignment from the Stock object.

    .PARAMETER Folder
    Optional string to set a different folder on the Stock object.

    .PARAMETER UnsetTags
    Optional switch that will remove the Tags from the Stock object.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the new Stock object.

    .PARAMETER CodeRepository
    Optional Code Repository to place the Stock into. Use Get-AutomateNOWCodeRepository to fetch this object.

    .PARAMETER UnsetCodeRepository
    Switch parameter that will remove the the Stock from its Code Repository.

    .PARAMETER Quiet
    Switch parameter that silences the output of the updated object.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWStock] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWStock] object will be returned

    .EXAMPLE
    Changes the description and folder, along with setting 2 tags on a Stock

    $Stock = Get-AutomateNOWStock -Id 'Stock1'
    Set-AutomateNOWStock -Description 'Awesome description!' -Tags 'Tag1', 'Tag2' -Folder 'Folder1'

    .EXAMPLE
    Forcibly changes the total permits of a Stock to 1000

    $Stock = Get-AutomateNOWStock -Id 'Stock1'
    Set-AutomateNOWStock -Stock $Stock -TotalPermits 1000 -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    If you remove the validation it is possible to set the stocks beyond 1,000,000

    #>
    [OutputType([ANOWStock])]
    [Cmdletbinding(SupportsShouldProcess, DefaultParameterSetName = 'Default', ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'Default', ValueFromPipeline = $True)]
        [Parameter(Mandatory = $true, ParameterSetName = 'TotalPermits', ValueFromPipeline = $True)]
        [ANOWStock]$Stock,
        [ValidateRange(0, 1000000)]
        [Parameter(Mandatory = $false, ParameterSetName = 'TotalPermits', HelpMessage = 'Enter a value between 0 and 1000000')]
        [int32]$TotalPermits,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [string[]]$Tags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [string]$Folder,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetCodeRepository,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'TotalPermits')]
        [switch]$Quiet,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'TotalPermits')]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot set the Tags and unset them at the same time. Please choose one or the other. Tags from the source object will be carried over to the new object if you do not specify any tag-related parameters."
            Break
        }
        If ($UnsetCodeRepository -eq $true -and $CodeRepository.Id.Length -gt 0) {
            Write-Warning -Message "You cannot unset the Code Repository and set it at the same time. Please choose one or the other."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWStock]$Stock = $_
        }
        [string]$Stock_id = $Stock.id
        [string]$Stock_simpleId = $Stock.simpleId
        [int32]$Stock_total_permits = $Stock.totalPermits
        Write-Verbose -Message "Detected [$Stock_total_permits] total permits in Stock [$Stock_simpleId]"
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Stock_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$Stock_exists = ($null -eq (Get-AutomateNOWStock -Id $Stock_simpleId))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWStock failed to check if the Stock [$Stock_simpleId] already existed due to [$Message]."
                Break
            }
            If ($Stock_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not an Stock named [$Stock_simpleId] in the [$current_domain] domain. Please check into this."
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $Stock_id
            If ($TotalPermits -gt 0 -and ($Stock_total_permits -ne $TotalPermits)) {
                If ($Stock_total_permits -gt $TotalPermits) {
                    Write-Verbose -Message "Decreasing total permits for [$Stock_simpleId] from [$Stock_total_permits] to [$TotalPermits]"
                }
                Else {
                    Write-Verbose -Message "Increasing total permits for [$Stock_simpleId] from [$Stock_total_permits] to [$TotalPermits]"
                }
                $BodyMetaData.'newTotalPermits' = $TotalPermits
                [string]$operationId = 'adjustStockPermits'
                [string]$operationType = 'custom'
                $BodyMetaData.'_operationId' = $operationId
                [string]$command = "/resource/$operationId"
            }
            ElseIf ($TotalPermits -gt 0 -and ($Stock_total_permits -eq $TotalPermits)) {
                Write-Warning -Message "No action is required. $Stock_id already has $Stock_total_permits total permits."
                Break
            }
            Else {
                [string]$command = '/resource/update'
                [string]$operationType = 'update'
                If ($Description.Length -gt 0) {
                    $BodyMetaData.'description' = $Description
                }
                ElseIf ($UnsetDescription -eq $true) {
                    $BodyMetaData.'description' = $Null
                }
                Else {
                    If ($Stock.description.Length -gt 0) {
                        $BodyMetaData.'description' = $Stock.description
                    }
                }
                If ($UnsetFolder -eq $True) {
                    $BodyMetaData.'folder' = $Null
                }
                ElseIf ($Folder.Length -gt 0) {
                    $BodyMetaData.'folder' = $Folder
                }
                Else {
                    If ($Stock.folder.Length -gt 0) {
                        $BodyMetaData.'folder' = $Stock.folder
                    }
                }
                If ($Tags.Count -gt 0) {
                    [int32]$tag_count = 1
                    ForEach ($tag in $Tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
                ElseIf ($UnsetTags -eq $true) {
                    $BodyMetaData.'tags' = $Null
                }
                Else {
                    If ($Stock.Tags -gt 0) {
                        [int32]$tag_count = 1
                        ForEach ($tag in $Stock.tags) {
                            $BodyMetaData.('tags' + $tag_count ) = $tag
                            $tag_count++
                        }
                    }
                }
            }
            If ($CodeRepository.Id.Length -gt 0) {
                [string]$CodeRepository_Id = $CodeRepository.Id
                $Error.Clear()
                Try {
                    [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository_Id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository_Id] actually existed under Set-AutomateNOWStock due to [$Message]"
                    Break
                }
                If ($code_repository_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository_Id] under Set-AutomateNOWStock. Please check again."
                    Break
                }
                $BodyMetaData.'codeRepository' = $CodeRepository_Id
            }
            ElseIf ($UnsetCodeRepository -eq $true) {
                $BodyMetaData.'codeRepository' = $null
            }
            $BodyMetaData.'_operationType' = $operationType
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_dataSource' = 'ResourceDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $parameters.Add('Command', $command)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Stock_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Stock [$Stock_id] was successfully updated"
            $Error.Clear()
            Try {
                [ANOWStock]$UpdatedStock = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the returned updated object to an [ANOWStock] object due to [$Message]. The object was still updated though."
                Break
            }
            If ($Quiet -ne $true) {
                Return $UpdatedStock
            }
        }
    }
    End {
    }
}

Function Export-AutomateNOWStock {
    <#
    .SYNOPSIS
    Exports the Stock objects from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Stock objects from an instance of AutomateNOW! to a local .csv file

    .PARAMETER Stock
    Mandatory [ANOWStock] object (Use Get-AutomateNOWStock to retrieve them)

    .INPUTS
    ONLY [ANOWStock] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWStock] objects are exported to the local disk in CSV format

    .EXAMPLE
    Exports all of the Stock objects (up to 100 by default)

    Get-AutomateNOWStock | Export-AutomateNOWStock

    .EXAMPLE
    Exports 1 Stock by name

    Get-AutomateNOWStock -Id 'Stock01' | Export-AutomateNOWStock

    .EXAMPLE
    Exports a series of Stock objects by the pipeline

    @( 'Stock01', 'Stock02' ) | Get-AutomateNOWStock | Export-AutomateNOWStock

    .NOTES
	You must present [ANOWStock] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWStock]$Stock
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-Stocks-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWStock]$Stock = $_
        }
        $Error.Clear()
        Try {
            $Stock | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWStock] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function New-AutomateNOWStock {
    <#
    .SYNOPSIS
    Creates a Stock within an AutomateNOW! instance

    .DESCRIPTION
    Creates a Stock within an AutomateNOW! instance and returns back the newly created [ANOWStock] object

    .PARAMETER Id
    The intended name of the Stock. For example: 'stock1'. This value may not contain the domain in brackets.

    .PARAMETER Description
    Optional description of the Stock (may not exceed 255 characters).

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new Stock. Do not pass [ANOWTag] objects here.

    .PARAMETER Folder
    Optional name of the folder to place the Stock into.

    .PARAMETER CodeRepository
    Optional name of the code repository to place the Stock into.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWStock.

    .OUTPUTS
    An [ANOWStock] object representing the newly created Stock

    .EXAMPLE
    New-AutomateNOWStock -Id 'Stock01' -Description 'Description01' -Tags 'Tag01' -Folder 'Folder01' -CodeRepository 'Repository01'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The name (id) of the Stock must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    #>
    [OutputType([ANOWStock])]
    [Cmdletbinding()]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $true)]
        [string]$Id,
        [ValidateScript({ $_.Length -le 255 })]
        [Parameter(Mandatory = $false, HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [string]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [boolean]$Stock_exists = ($null -ne (Get-AutomateNOWStock -Id $Id))
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWStock failed to check if the Stock [$Id] already existed due to [$Message]."
        Break
    }
    If ($Stock_exists -eq $true) {
        [string]$current_domain = $anow_session.header.domain
        Write-Warning -Message "There is already a Stock named [$Id] in [$current_domain]. Please check into this."
        Break
    }
    ## End warning ##
    [System.Collections.Specialized.OrderedDictionary]$ANOWStock = [System.Collections.Specialized.OrderedDictionary]@{}
    $ANOWStock.Add('id', $Id)
    If ($Description.Length -gt 0) {
        $ANOWStock.Add('description', $Description)
    }
    If ($Tags.Count -gt 0) {
        [int32]$total_tags = $Tags.Count
        [int32]$current_tag = 1
        ForEach ($tag_id in $Tags) {
            $Error.Clear()
            Try {
                [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] running under New-AutomateNOWStock due to [$message]"
                Break
            }
            If ($tag_object.simpleId.length -eq 0) {
                Throw "New-AutomateNOWStock has detected that the tag [$tag_id] does not appear to exist. Please check again."
                Break
            }
            ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                [string]$tag_object_simpleId = $tag_object.simpleId
                Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                Break
            }
            [string]$tag_display = $tag_object | ConvertTo-Json -Compress
            Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
            [string]$tag_name_sequence = ('tags' + $current_tag)
            $ANOWStock.Add($tag_name_sequence, $tag_id)
            $include_properties += $tag_name_sequence
            $current_tag++
        }
    }
    If ($Folder.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] existed under New-AutomateNOWStock due to [$Message]"
            Break
        }
        If ($folder_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] under New-AutomateNOWStock. Please check again."
            Break
        }
        [string]$folder_display = $folder_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding folder $folder_display to [ANOWStock] [$Id]"
        $ANOWStock.Add('folder', $Folder)
        $include_properties += 'folder'
    }
    If ($CodeRepository.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository] existed under New-AutomateNOWStock due to [$Message]"
            Break
        }
        If ($code_repository_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository] under New-AutomateNOWStock. Please check again."
            Break
        }
        [string]$code_repository_display = $code_repository_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding code repository $code_repository_display to [ANOWStock] [$Id]"
        $ANOWStock.Add('codeRepository', $CodeRepository)
        $include_properties += 'codeRepository'
    }
    $ANOWStock.Add('title', 'Stock')
    $ANOWStock.Add('icon', '[SKINIMG]/skin/stock.png')
    $oldvalues = ('{"title":"Stock","resourceType":"STOCK","icon":"[SKINIMG]/skin/stock.png"}')
    [string]$BodyObject = ConvertTo-QueryString -InputObject $ANOWStock -IncludeProperties id, description, title, icon, tags, folder, codeRepository
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    $BodyMetaData.'resourceType' = 'STOCK'
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_operationType' = 'add'
    $BodyMetaData.'_oldValues' = $oldvalues
    $BodyMetaData.'_componentId' = 'ResourceCreateWindow_form'
    $BodyMetaData.'_dataSource' = 'ResourceDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$BodyMetaDataString = ConvertTo-QueryString -InputObject $BodyMetaData
    [string]$Body = ($BodyObject + '&' + $BodyMetaDataString)
    [string]$command = '/resource/create'
    [hashtable]$parameters = @{}
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('Body', $Body)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWStock]$Stock = $results.response.data | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to parse the result of New-AutomateNOWStock into an [ANOWStock] object due to [$Message]."
        Break
    }
    If ($Stock.id.Length -eq 0) {
        Write-Warning -Message "Somehow the newly created [ANOWStock] object is empty!"
        Break
    }
    If ($Quiet -ne $true) {
        Return $Stock
    }
}

Function Remove-AutomateNOWStock {
    <#
    .SYNOPSIS
    Removes a Stock from an AutomateNOW! instance

    .DESCRIPTION
    Removes a Stock from an AutomateNOW! instance

    .PARAMETER Stock
    An [ANOWStock] object representing the Stock to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWStock] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Remove a single Stock by name

    Get-AutomateNOWStock -Id 'Stock01' | Remove-AutomateNOWStock

    .EXAMPLE
    Removes a series of Stock objects via input from the pipeline

    @( 'Stock01', 'Stock02', 'Stock03') | Get-AutomateNOWStock | Remove-AutomateNOWStock

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWStock]$Stock,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/resource/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWStock]$Stock = $_
        }
        [string]$Stock_id = $Stock.id
        If ($Stock_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Stock_id)")) -eq $true) {
            [string]$oldvalues = $Stock.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $Stock.id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'ResourceList'
            $BodyMetaData.'_dataSource' = 'ResourceDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Stock_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Stock [$Stock_id] successfully removed"
        }
    }
    End {

    }
}

Function Copy-AutomateNOWStock {
    <#
    .SYNOPSIS
    Copies an Stock from an AutomateNOW! instance

    .DESCRIPTION
    Copies an Stock from an AutomateNOW! instance. AutomateNOW object id can never be changed, but we can copy the object to a new id and it will include all of the items therein.

    .PARAMETER Stock
    Mandatory [ANOWStock] object to be copied.

    .PARAMETER NewId
    The name (Id) of the new Stock. The new Id must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    .PARAMETER UnsetDescription
    Optional switch that will ensure that the newly created Stock will not have a description set.

    .PARAMETER Description
    Optional description to set on the new Stock object. If you do not set this, the new Stock object will copy the Description of the source object.

    .PARAMETER UnsetFolder
    Optional switch that will ensure that the newly created Stock will not have a Folder set.

    .PARAMETER Folder
    Optional description to set a different folder on the new Stock object. If you do not set this, the new Stock object will use the same Folder of the source object.

    .PARAMETER UnsetTags
    Optional switch that will ensure that the newly created Stock will not have any Tags set.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the new Stock object. If you do not set this, the new Stock object will apply the same Tags of the source object.

    .PARAMETER Force
    Force the copy without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    ONLY [ANOWStock] object is accepted. Pipeline support is intentionally unavailable.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Creates a copy of an Stock and changes the description (multi-line format)
    $Stock01 = Get-AutomateNOWStock -Id 'Stock_01'
    Copy-AutomateNOWStock -Stock $Stock01 -NewId 'Stock_01_production' -Description 'Stock 01 Production'

    .EXAMPLE
    Creates a copy of an Stock that omits the description (one-liner format)
    Copy-AutomateNOWStock -Stock (Get-AutomateNOWStock -Id 'Stock_01') -NewId 'Stock_01_production' -UnsetDescription -Tags 'Tag1', 'Tag2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWStock]$Stock,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot set the Tags and unset them at the same time. Please choose one or the other. Tags from the source object will be carried over to the new object if you do not specify any tag-related parameters."
            Break
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$Stock_exists = ($null -ne (Get-AutomateNOWStock -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWStock failed to check if the Stock [$NewId] already existed due to [$Message]."
            Break
        }
        If ($Stock_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Stock named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End warning ##
        [string]$command = '/resource/copy'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            [string]$Stock_oldId = $Stock.id
            [string]$Stock_simpleId = $Stock.simpleId
            If ($Stock_oldId -eq $NewId) {
                Write-Warning -Message "The new id cannot be the same as the old id."
                Break
            }
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Copy the Stock $($Stock_simpleId) to $($NewId)?")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                If ($UnsetFolder -eq $True) {
                    $BodyMetaData.'folder' = $Null
                }
                ElseIf ($Folder.Length -gt 0) {
                    $BodyMetaData.'folder' = $Folder
                }
                Else {
                    If ($Stock.folder.Length -gt 0) {
                        $BodyMetaData.'folder' = $Stock.folder
                    }
                }
                If ($Tags.Count -gt 0) {
                    [int32]$tag_count = 1
                    ForEach ($tag in $Tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
                ElseIf ($UnsetTags -eq $true) {
                    $BodyMetaData.'tags' = $Null
                }
                Else {
                    If ($Stock.Tags -gt 0) {
                        [int32]$tag_count = 1
                        ForEach ($tag in $Stock.tags) {
                            $BodyMetaData.('tags' + $tag_count ) = $tag
                            $tag_count++
                        }
                    }
                }
                $BodyMetaData.'oldId' = $Stock_oldId
                $BodyMetaData.'domain' = $Stock.domain
                $BodyMetaData.'id' = $NewId
                If ($UnsetDescription -ne $true) {
                    If ($Description.Length -gt 0) {
                        $BodyMetaData.'description' = $Description
                    }
                    Else {
                        $BodyMetaData.'description' = $Stock.description
                    }
                }
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_operationId' = 'copy'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_dataSource' = 'ResourceDataSource'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties oldId, domain, NewId, description, folder, tags
                $parameters.Body = $Body
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Stock_oldId] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                $Error.Clear()
                Try {
                    [ANOWStock]$NewStock = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to create copied [ANOWStock] object [$NewId] due to [$Message]."
                    Break
                }
                If ($NewStock.id.Length -eq 0) {
                    Write-Warning -Message "Somehow the newly created (copied) [ANOWStock] object [$NewId] is empty!"
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $NewStock
                }
            }
        }
    }
    End {

    }
}

Function Rename-AutomateNOWStock {
    <#
    .SYNOPSIS
    Renames a Stock on an AutomateNOW! instance

    .DESCRIPTION
    Performs a psuedo-rename operations of a Stock from an AutomateNOW! instance by copying it first and then deleting the source. This function merely combines Copy-AutomateNOWStock and Remove-AutomateNOWStock therefore it is to be considered destructive.

    .PARAMETER Stock
    An [ANOWStock] object representing the Stock to be renamed.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the Stock. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER Force
    Force the renaming without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly renamed object.

    .INPUTS
    ONLY [ANOWStock] objects are accepted. There is intentionally no support for the pipeline.

    .OUTPUTS
    The newly renamed [ANOWStock] object will be returned.

    .EXAMPLE
    $Stock = Get-AutomateNOWStock -Id 'Stock01'
    Rename-AutomateNOWStock -Stock $Stock -NewId 'Stock_01'

    .EXAMPLE
    Rename-AutomateNOWStock -Stock (Get-AutomateNOWStock -Id 'Stock01') -NewId 'Stock_01'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    When renaming, you may only specify a different Id (name).

    This action will be blocked if any existing referrals are found on the object.
    #>
    [OutputType([ANOWStock])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWStock]$Stock,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin standard warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$new_Stock_exists = ($null -ne (Get-AutomateNOWStock -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWStock failed to check if the Stock [$NewId] already existed due to [$Message]."
            Break
        }
        If ($new_Stock_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Stock named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        #[string]$Stock_id = $Stock.id
        [string]$Stock_id = $Stock.simpleId
        $Error.Clear()
        Try {
            [boolean]$old_Stock_exists = ($null -ne (Get-AutomateNOWStock -Id $Stock_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWStock failed to check if the Stock [$Stock_id] already existed due to [$Message]."
            Break
        }
        If ($old_Stock_exists -eq $false) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not a Stock named [$Stock_id] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End standard warning ##
        ## Begin referrals warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [int32]$referrals_count = Find-AutomateNOWObjectReferral -Stock $Stock -Count | Select-Object -Expandproperty referrals
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Find-AutomateNOWObjectReferral failed to extract the referrals on Stock [$Stock_id] due to [$Message]."
            Break
        }
        If ($referrals_count -gt 0) {
            Write-Warning -Message "Unfortunately, you cannot rename a Stock that has referrals. This is because the rename is not actually renaming but copying anew and deleting the old. Please, use the Find-AutomateNOWObjectReferral function to identify referrals and remove them."
            Break
        }
        Else {
            Write-Verbose -Message "The Stock [$Stock_id] does not have any referrals. It is safe to proceed."
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Stock_id)")) -eq $true) {
                $Error.Clear()
                Try {
                    [ANOWStock]$new_Stock = Copy-AutomateNOWStock -Stock $Stock -NewId $NewId -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Copy-AutomateNOWStock failed to create a new Stock [$NewId] as Part 1 of the renaming process due to [$Message]."
                    Break
                }
                If ($new_Stock.simpleId -eq $NewId) {
                    Write-Verbose -Message "Part 1: Stock [$Stock_id] successfully copied to [$NewId]"
                }
                Else {
                    Write-Warning -Message "Somehow the first phase (Copy-AutomateNOWStock) failed. Please look into this."
                    Break
                }
                $Error.Clear()
                Try {
                    Remove-AutomateNOWStock -Stock $Stock -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Remove-AutomateNOWStock failed to remove [$Stock_id] as Part 2 of the renaming process due to [$Message]."
                    Break
                }
                Write-Verbose -Message "Part 2: Stock [$Stock_id] removed"
                Write-Verbose -Message "Task [$Stock_id] successfully renamed to [$NewId]"
                If ($Quiet -ne $true) {
                    Return $Stock
                }
            }
        }
        Else {
            Write-Warning -Message "No action was taken because either the source object didn't exist or the new object already existed"
        }
    }
    End {
    }
}

#endregion

#Region - Tags

Function Get-AutomateNOWTag {
    <#
    .SYNOPSIS
    Gets the Tags from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Tags from an AutomateNOW! instance

    .INPUTS
    Accepts a string input either individually with the -Id parameter or sent across the pipeline

    .OUTPUTS
    An array of [ANOWTag] objects

    .PARAMETER Id
    Mandatory case-sensitive string containing the id of the tag

    .PARAMETER startRow
    An optional int32 representing what row to start the download from. This is intended for multi-page transfers.

    .PARAMETER endRow
    An optional int32 representing how many rows of data to receive. The default is 100. This is ideal for testing when you only want a few items.

    .PARAMETER AllDomains
    An optional switch that will include tags from all domains.

    .EXAMPLE
    Gets the first page of Tags
    Get-AutomateNOWTag

    .EXAMPLE
    Gets a single Tag based on its Id (name)
    Get-AutomateNOWTag -Id 'Tag1'

    .EXAMPLE
    Gets a series of Tags based the names sent across the pipeline
    'Tag1', 'Tag2', 'Tag3' | Get-AutomateNOWTag

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWTag[]])]
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $False, ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$AllDomains
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$BodyObject = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 -or $Id.Length -gt 0) {
            If ($_.Length -gt 0 ) {
                $BodyObject.'id' = $_
            }
            Else {
                $BodyObject.'id' = $Id
                [string]$textMatchStyle = 'exactCase'
            }
        }
        Else {
            $BodyObject.'_startRow' = $startRow
            $BodyObject.'_endRow' = $endRow
            [string]$textMatchStyle = 'substring'
        }
        $BodyObject.'_operationType' = 'fetch'
        $BodyObject.'_textMatchStyle' = $textMatchStyle
        $BodyObject.'_componentId' = 'FolderSourceList'
        $BodyObject.'_dataSource' = 'FolderDataSource'
        $BodyObject.'isc_metaDataPrefix' = '_'
        $BodyObject.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $BodyObject
        If ( $AllDomains -eq $true) {
            [string]$command = '/tag/readAllDomains?'
        }
        Else {
            [string]$command = '/tag/read?'
        }
        [string]$command = ($command + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWTag[]]$Tags = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWTag] objects due to [$Message]"
            Break
        }
        If ($Tags.Count -gt 0) {
            Return $Tags
        }
        Else {
            Write-Verbose -Message "There are no tags yet in this domain"
        }
    }
    End {
    }
}

Function Set-AutomateNOWTag {
    <#
    .SYNOPSIS
    Changes the settings of a Tag from an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of a Tag from an AutomateNOW! instance

    .PARAMETER Tag
    An [ANOWTag] object representing the Tag to be changed.

    .PARAMETER description
    Optional description of the tag (may not exceed 255 characters).

    .PARAMETER unsetDescription
    A switch parameter that will remove the Description from the Tag.

    .PARAMETER CodeRepository
    Optional Code Repository to place the Tag into. Use Get-AutomateNOWCodeRepository to fetch this object.

    .PARAMETER UnsetCodeRepository
    Switch parameter that will remove the the Tag from its Code Repository.

    .PARAMETER iconSet
    Optional name of the icon library. Possible choices are: FAT_COW, FUGUE and FONT_AWESOME.

    .PARAMETER iconCode
    Mandatory (if -iconSet is used) name of the icon from the selected library. These are case-sensitive.

    .PARAMETER textColor
    Optional hex RGB for the foreground (text) color or you can select 'transparent'. Colors require the # character and it is case sensitive.

    .PARAMETER backgroundColor
    Optional hex RGB for the background color or you can select 'transparent'. Colors require the # character and it is case sensitive.

    .PARAMETER removeIcon
    A switch parameter that will remove the Icon from the Tag.

    .PARAMETER Quiet
    A switch parameter that will suppress the output of the updated Tag.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false.

    .INPUTS
    ONLY [ANOWTag] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWTag] object will be returned

    .EXAMPLE
    Forcibly and quietly sets the description, icon, text color, background color and code repository (named 'CodeRepository1') on a Tag named 'Tag1'

    Get-AutomateNOWTag -Id 'Tag1' | Set-AutomateNOWTag -Description 'my description' -iconSet FUGUE -iconCode abacus -textColor '#123456' -backgroundColor 'transparent' -CodeRepository (Get-AutomateNOWCodeRepository -Id 'CodeRepository1') -Force -Quiet

    .EXAMPLE
    Removes the Code Repository, Description and Icon from a Tag.

    Get-AutomateNOWTag -Id 'Tag1' | Set-AutomateNOWTag -UnsetCodeRepository -unsetDescription -RemoveIcon

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    If the -iconSet parameter is specified then -iconCode must also be specified. You cannot specify one without the other nor can you combine these with -RemoveIcon.

    #>
    [OutputType([ANOWTag])]
    [Cmdletbinding(SupportsShouldProcess = $true, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $true, ValueFromPipeline = $True, ParameterSetName = 'WithIcon')]
        [ANOWTag]$Tag,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default', HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon', HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [switch]$UnsetCodeRepository,
        [Parameter(Mandatory = $true, ParameterSetName = 'WithIcon')]
        [ANOWIcon_iconSet]$iconSet,
        [ValidateScript({ $_ -match '^[a-z0-9-_]{1,}$' })]
        [Parameter(Mandatory = $true, ParameterSetName = 'WithIcon')]
        [string]$iconCode,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default', HelpMessage = "Enter a hexadecimal RGB (#FF0000) or the word transparent in lower case")]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon', HelpMessage = "Enter a hexadecimal RGB (#FF0000) or the word transparent in lower case")]
        [ValidateScript( { $_ -cmatch '^#[0-9A-F]{6}$' -or $_ -cmatch '^transparent$' } ) ]
        [string]$textColor,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default', HelpMessage = "Enter a hexadecimal RGB (#FF0000) or the word transparent in lower case")]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon', HelpMessage = "Enter a hexadecimal RGB (#FF0000) or the word transparent in lower case")]
        [ValidateScript( { $_ -cmatch '^#[0-9A-F]{6}$' -or $_ -cmatch '^transparent$' } ) ]
        [string]$backgroundColor,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$RemoveIcon,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [switch]$Quiet,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($unsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the Description and unset it at the same time"
            Break
        }
        If ($unsetCodeRepository -eq $true -and $CodeRepository.Id.Length -gt 0) {
            Write-Warning -Message "You cannot set the Code Repository and unset it at the same time"
            Break
        }
        [string]$command = '/tag/update'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWTag]$Tag = $_
        }
        [string]$Tag_id = $Tag.simpleId
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Tag_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$tag_exists = ($null -eq (Get-AutomateNOWTag -Id $Tag_id))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWTag failed to check if the Tag [$Tag_id] already existed due to [$Message]."
                Break
            }
            If ($tag_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not a Tag named [$Tag_id] in the current domain [$current_domain]. Please check into this."
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $Tag.id
            If ($Description.Length -gt 0) {
                $BodyMetaData.'description' = $Description
            }
            ElseIf ($UnsetDescription -eq $true) {
                $BodyMetaData.'description' = $null
            }
            If ($CodeRepository.Id.Length -gt 0) {
                [string]$CodeRepository_Id = $CodeRepository.Id
                $Error.Clear()
                Try {
                    [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository_Id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository_Id] actually existed under Set-AutomateNOWTag due to [$Message]"
                    Break
                }
                If ($code_repository_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository_Id] under Set-AutomateNOWTag. Please check again."
                    Break
                }
                $BodyMetaData.'codeRepository' = $CodeRepository_Id
            }
            ElseIf ($UnsetCodeRepository -eq $true) {
                $BodyMetaData.'codeRepository' = $null
            }
            If ($textColor.Length -gt 0) {
                $BodyMetaData.'textColor' = $textColor
            }
            If ($backgroundColor.Length -gt 0) {
                $BodyMetaData.'backgroundColor' = $backgroundColor
            }
            If ($RemoveIcon -eq $true) {
                $BodyMetaData.'iconCode' = $null
                $BodyMetaData.'iconSet' = $null
            }
            If ($iconCode.Length -gt 0) {
                $BodyMetaData.'iconCode' = $iconCode
            }
            If ($iconSet.Length -gt 0) {
                $BodyMetaData.'iconSet' = $iconSet
            }
            [string]$old_values = $Tag.CreateOldValues()
            $BodyMetaData.'_oldValues' = $old_values
            $BodyMetaData.'_operationType' = 'update'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_componentId' = 'TagEditForm'
            $BodyMetaData.'_dataSource' = 'TagDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Tag_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Tag $Tag_id was successfully updated"
            $Error.Clear()
            Try {
                [ANOWTag]$UpdatedTag = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the returned updated object to an [ANOWTag] object due to [$Message]. The object was still updated though."
                Break
            }
            If ($Quiet -ne $true) {
                Return $UpdatedTag
            }
        }
    }
    End {
    }
}

Function Export-AutomateNOWTag {
    <#
    .SYNOPSIS
    Exports the tags from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the tags from an instance of AutomateNOW! to a local .csv file

    .INPUTS
    ONLY [ANOWTag] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWTag] objects are exported to the local disk in CSV format

    .EXAMPLE
    Get-AutomateNOWTag | Export-AutomateNOWTag

    .EXAMPLE
    Get-AutomateNOWTag -Id 'Tag01' | Export-AutomateNOWTag

    .EXAMPLE
    @( 'Tag01', 'Tag02', 'Tag03' ) | Get-AutomateNOWTag | Export-AutomateNOWTag

    .EXAMPLE
    Get-AutomateNOWTag | Where-Object { $_.simpleid -like 'Test-*' } | Export-AutomateNOWTag

    .NOTES
    You must present [ANOWTag] objects to the pipeline to use this function.
    #>
    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWTag]$Tag
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-Tags-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWTag]$Tag = $_
        }
        $Error.Clear()
        Try {
            $Tag | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWTag] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function New-AutomateNOWTag {
    <#
    .SYNOPSIS
    Creates a new tag on an AutomateNOW! instance

    .DESCRIPTION
    Creates a new tag on an AutomateNOW! instance and returns back the created [ANOWTag] object

    .PARAMETER Id
    The intended name of the tag. For example: 'MyCoolTag'. This value may not contain the domain in brackets.

    .PARAMETER description
    Optional description of the tag (may not exceed 255 characters).

    .PARAMETER iconSet
    The name of the icon library (if you choose to use one). Possible choices are: FAT_COW, FUGUE and FONT_AWESOME.

    .PARAMETER iconCode
    The name of the icon which matches the chosen library. Must be lower-case.

    .PARAMETER textColor
    The RGB in hex of the tag's foreground (text) color. You must include the # character and it is case sensitive. Example: #FF00FF

    .PARAMETER backgroundColor
    The RGB in hex of the tag's background color. You must include the # character and it is case sensitive. Example: #00FF00

    .PARAMETER CodeRepository
    Optional name of the code repository to place the Security Role into.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWTag.

    .OUTPUTS
    An [ANOWTag] object representing the newly created tag

    .EXAMPLE
    New-AutomateNOWTag -id 'MyCoolTag123' -description 'My tags description' -iconSet 'FUGUE' -IconCode 'abacus' -textColor '#0A0A0A' -backgroundColor 'transparent'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Note that transparent is an available option for either background or foreground color.

    The name (id) of the tag must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    The showIconOnly property is defined in the class object but has been deprecated.

    #>
    [OutputType([ANOWTag])]
    [Cmdletbinding(DefaultParameterSetName = 'Default')]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $true, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $true, ParameterSetName = 'WithIcon')]
        [string]$Id,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default', HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon', HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $true, ParameterSetName = 'WithIcon')]
        [ANOWIcon_iconSet]$iconSet,
        [ValidateScript({ $_ -match '^[a-z0-9-_]{1,}$' })]
        [Parameter(Mandatory = $true, ParameterSetName = 'WithIcon')]
        [string]$iconCode,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [ValidateScript( { $_ -cmatch '^#[0-9A-F]{6}$' -or $_ -cmatch '^transparent$' } ) ]
        [string]$textColor = '#FFFFFF',
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [ValidateScript( { $_ -cmatch '^#[0-9A-F]{6}$' -or $_ -cmatch '^transparent$' } ) ]
        [string]$backgroundColor = '#FF0000',
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [string]$CodeRepository,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is no global session token"
        Break
    }
    If (($iconSet.Length -gt 0) -and ($iconCode.Length -eq 0) -or ($iconSet.Length -eq 0) -and ($iconCode.Length -gt 0)) {
        Write-Warning -Message "If you specify an icon library then you must also specify an icon (and vice-versa)"
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [boolean]$tag_exists = ($null -ne (Get-AutomateNOWTag -Id $Id))
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWTag failed to check if the tag $Id already existed due to [$Message]."
        Break
    }
    If ($tag_exists -eq $true) {
        Write-Warning -Message "There is already a Tag named $Id. Please check into this."
        Break
    }
    ## End warning ##
    [string]$ContentType = 'application/x-www-form-urlencoded; charset=UTF-8'
    [string]$command = '/tag/create'
    [hashtable]$parameters = @{}
    $parameters.Add('Method', 'POST')
    $parameters.Add('ContentType', $ContentType)
    $parameters.Add('Command', $command)
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    $BodyMetaData.'id' = $id
    $BodyMetaData.'textColor' = $textColor
    $BodyMetaData.'backgroundColor' = $backgroundColor
    If ($description.Length -gt 0) {
        $BodyMetaData.'description' = $description
    }
    If ($iconSet.Length -gt 0) {
        $BodyMetaData.'iconSet' = $iconSet
        $BodyMetaData.'iconCode' = $iconCode
    }
    If ($CodeRepository.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository] existed under New-AutomateNOWTag due to [$Message]"
            Break
        }
        If ($code_repository_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository] under New-AutomateNOWTag. Please check again."
            Break
        }
        [string]$code_repository_id = $code_repository_object.Id
        Write-Verbose -Message "Adding Tag $Id to code repository $code_repository_id"
        $BodyMetaData.'codeRepository' = $codeRepository
    }
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_operationType' = 'add'
    $BodyMetaData.'_oldValues' = '{"textColor":"#FFFFFF","backgroundColor":"#FF0000"}'
    $BodyMetaData.'_componentId' = 'TagCreateWindow_form'
    $BodyMetaData.'_dataSource' = 'TagDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
    $parameters.Add('Body', $Body)
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed due to [$Message]"
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWTag]$tag = $results.response.data | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Unable to create an [ANOWTag] object due to [$message]"
        Break
    }
    [string]$tag_json = $tag | ConvertTo-Json -Compress
    Write-Verbose -Message "Created new tag $tag_json"
    If ($Quiet -ne $true) {
        Return $tag
    }
}

Function Remove-AutomateNOWTag {
    <#
    .SYNOPSIS
    Removes a tag from an AutomateNOW! instance

    .DESCRIPTION
    Removes a tag from an AutomateNOW! instance

    .PARAMETER Tag
    An [ANOWTag] object representing the tag to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    `Remove-AutomateNOWTag` accepts pipeline input on the Tag parameter or the Id by way of -Id

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Remove-AutomateNOWTag -Id 'Tag1'

    .EXAMPLE
    Remove-AutomateNOWTag -Id 'Tag1', 'Tag2'

    .EXAMPLE
    @( 'Tag1', 'Tag2', 'Tag3') | Remove-AutomateNOWTag

    .EXAMPLE
    Get-AutomateNOWTag | ? { $_.simpleid -like '*my_tag*' } | Remove-AutomateNOWTag

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWTag]$Tag,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ForEach ($current_id in $Id) {
            If ($current_id -match '^(\s.{1,}|.{1,}\s)$') {
                Write-Warning -Message "You seem to have whitespace characters in the beginning or end of [$Id]. Please fix this."
                Break
            }
            ElseIf ($curent_id -Match '[.{1,}].{1,}') {
                Write-Warning -Message "Do not include the Domain surrounded by brackets []. The -Id parameter actually requires the 'simple id':-)"
                Break
            }
        }
        [string]$command = '/tag/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWTag]$Tag = $_
        }
        [string]$tag_id = $Tag.id
        If ($tag_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($tag_id)")) -eq $true) {
            [string]$Body = 'id=' + $tag_id
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Tag $Id successfully removed"
        }
    }
    End {

    }
}

Function Copy-AutomateNOWTag {
    <#
    .SYNOPSIS
    Copies a Tag from an AutomateNOW! instance

    .DESCRIPTION
    Copies a Tag from an AutomateNOW! instance

    .PARAMETER Stock
    Mandatory [ANOWTag] object to be copied.

    .PARAMETER NewId
    The name (Id) of the new Tag. The new Id must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    .PARAMETER Force
    Force the copy without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    ONLY an [ANOWTag] object is accepted. Pipeline support is intentionally unavailable.

    .OUTPUTS
    The newly created [ANOWTag] object will be emitted.

    .EXAMPLE
    Forcefully and quietly creates a copy of a tag named 'Tag1' with a new Id of 'Tag2' (one-liner)

    Copy-AutomateNOWTag -Tag (Get-AutomateNOWTag -Id 'Tag1') -NewId 'Tag2' -Force -Quiet

    .EXAMPLE
    Creates a copy of a tag named 'Tag3' with a new Id of 'Tag4' (multi-line)

    $Tag = Get-AutomateNOWTag -Id 'Tag3'
    Copy-AutomateNOWTag -Tag $Tag -NewId 'Tag4'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Unlike other copy functions, this one is unofficial and does not support modifying other properties. Uset Set-AutomateNOWTag to modify the copied tag if needed.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWTag]$Tag,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$Tag_exists = ($null -ne (Get-AutomateNOWTag -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWTag failed to check if the Tag [$NewId] already existed due to [$Message]."
            Break
        }
        If ($Tag_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Tag named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End warning ##
        [string]$command = '/tag/copy'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            [string]$Tag_oldId = $Tag.id
            [string]$Tag_simpleId = $Tag.simpleId
            If ($Tag_oldId -eq $NewId) {
                Write-Warning -Message "The new id cannot be the same as the old id."
                Break
            }
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Tag_simpleId) to $($NewId)?")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                $BodyMetaData.'oldId' = $Tag_oldId
                $BodyMetaData.'domain' = $Tag.domain
                $BodyMetaData.'id' = $NewId
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_operationId' = 'copy'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_dataSource' = 'TagDataSource'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties oldId, domain, NewId, description, folder, tags
                $parameters.Body = $Body
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Tag_oldId] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                $Error.Clear()
                Try {
                    [ANOWTag]$NewTag = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to create copied [ANOWTag] object [$NewId] due to [$Message]."
                    Break
                }
                If ($NewTag.id.Length -eq 0) {
                    Write-Warning -Message "Somehow the newly created (copied) [ANOWTag] object [$NewId] is empty!"
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $NewTag
                }
            }
        }
    }
    End {

    }
}

#endregion

#Region - Tasks (PROCESSING)

Function Get-AutomateNOWTask {
    <#
    .SYNOPSIS
    Gets the tasks from an AutomateNOW! instance

    .DESCRIPTION
    Gets the tasks from an AutomateNOW! instance

    .PARAMETER Id
    A single int64 containing the NUMERICAL id of the Task to fetch (a.k.a. RunId)

    .PARAMETER TaskTemplate
    Optional [ANOWTaskTemplate] object by which to filter results by.

    .PARAMETER Internal
    Optional switch parameter that will return Internal Tasks instead of Tasks. This parameter cannot be combined with some parameters.

    .PARAMETER taskType
    Optional string representing the type of task to return. For example, a Shell Task template is SH. This parameter cannot be combined with -monitorType or -sensorType.

    .PARAMETER monitorType
    Optional string representing the type of monitor to return. For example, a python monitor is PYTHON_MONITOR. This parameter cannot be combined with -taskType or -sensorType.

    .PARAMETER sensorType
    Optional string representing the type of sensor to return. For example, a file sensor is FILE_SENSOR. This parameter cannot be combined with -monitorType or -taskType.

    .PARAMETER processingStatus
    Optional 'processing status' to filterby. You can only choose one. Valid choices are: WAITING, READY, EXECUTING, COMPLETED, FAILED

    .PARAMETER sortBy
    Optional string parameter to sort the results by (may not be used with the Id parameter). Valid choices are: {To be continued...}

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100. The console default hard limit is 10,000.

    .PARAMETER IncludeArchived
    Optional switch parameter removes the filter for archived items thus both archived and non-archived items will be returned.

    .PARAMETER OnlyArchived
    Optional switch parameter filters out non-archived items thus only archived items will be returned.

    .PARAMETER Folder
    Optional string to filter by a particular Folder

    .PARAMETER Tags
    Optional string array of Tags to filter by. Note that the 'containsAny' operator will be used.

    .INPUTS
    Accepts a string representing the simple id of the task template from the pipeline or individually (but not an array).

    .OUTPUTS
    An array of one or more [ANOWTask] class objects

    .EXAMPLE
    Gets the first page of Tasks
    Get-AutomateNOWTask

    .EXAMPLE
    Gets the first page of Tasks of type SH (Shell Task)

    Get-AutomateNOWTask -taskType 'SH'

    .EXAMPLE
    Gets a Task by its numerical Id. Note that this is also sometimes colloquially referred to as "Run Id"

    Get-AutomateNOWTask -Id 1738954

    .EXAMPLE
    Gets a series of Tasks based on their numerical ID
    1738954, 1738955 | Get-AutomateNOWTask

    .EXAMPLE
    Gets the first 1000 Tasks (or less) that have a processing status of EXECUTING
    Get-AutomateNOWTask -startRow 0 -endRow 1000 -processingStatus EXECUTING

    .EXAMPLE
    Gets the first 1000 archived Tasks
    Get-AutomateNOWTask -startRow 0 -endRow 1000 -OnlyArchived

    .EXAMPLE
    Gets the first 1000 archived and non-archived Tasks of a TaskTemplate named 'Template1'
    Get-AutomateNOWTask -TaskTemplate (Get-AutomateNOWTaskTemplate -Id 'Template1') -startRow 0 -endRow 1000 -OnlyArchived

    .EXAMPLE
    Gets the first page of Task Templates that contain a Tag named 'Tag1' or a Tag named 'Tag2'
    Get-AutomateNOWTask -Tags 'Tag1', 'Tag2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Use Get-AutomateNOWTaskTemplate if you are looking for Task Templates

    #>
    [OutputType([ANOWTask[]])]
    [Cmdletbinding(DefaultParameterSetName = 'Default' )]
    Param(
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Id')]
        [int64]$Id,
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Template')]
        [ANOWTaskTemplate]$TaskTemplate,
        [Parameter(Mandatory = $True, ParameterSetName = 'Internal')]
        [switch]$Internal,
        [Parameter(Mandatory = $True, ParameterSetName = 'taskType')]
        [ANOWProcessingTemplate_taskType]$taskType,
        [Parameter(Mandatory = $True, ParameterSetName = 'monitorType')]
        [ANOWProcessingTemplate_monitorType]$monitorType,
        [Parameter(Mandatory = $True, ParameterSetName = 'sensorType')]
        [ANOWProcessingTemplate_sensorType]$sensorType,
        [ValidateSet('dateCreated', 'id', 'firstStartTime', 'startTime', 'endTime', ignoreCase = $false)]
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'Template')]
        [Parameter(Mandatory = $False, ParameterSetName = 'Internal')]
        [Parameter(Mandatory = $False, ParameterSetName = 'taskType')]
        [Parameter(Mandatory = $False, ParameterSetName = 'monitorType')]
        [Parameter(Mandatory = $False, ParameterSetName = 'sensorType')]
        [string]$sortBy = 'dateCreated',
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'Template')]
        [Parameter(Mandatory = $False, ParameterSetName = 'Internal')]
        [Parameter(Mandatory = $False, ParameterSetName = 'taskType')]
        [Parameter(Mandatory = $False, ParameterSetName = 'monitorType')]
        [Parameter(Mandatory = $False, ParameterSetName = 'sensorType')]
        [switch]$Descending,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'Template')]
        [Parameter(Mandatory = $False, ParameterSetName = 'Internal')]
        [Parameter(Mandatory = $False, ParameterSetName = 'taskType')]
        [Parameter(Mandatory = $False, ParameterSetName = 'monitorType')]
        [Parameter(Mandatory = $False, ParameterSetName = 'sensorType')]
        [ANOWProcessing_processingStatus]$ProcessingStatus,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'Template')]
        [Parameter(Mandatory = $False, ParameterSetName = 'Internal')]
        [Parameter(Mandatory = $False, ParameterSetName = 'taskType')]
        [Parameter(Mandatory = $False, ParameterSetName = 'monitorType')]
        [Parameter(Mandatory = $False, ParameterSetName = 'sensorType')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'Template')]
        [Parameter(Mandatory = $False, ParameterSetName = 'Internal')]
        [Parameter(Mandatory = $False, ParameterSetName = 'taskType')]
        [Parameter(Mandatory = $False, ParameterSetName = 'monitorType')]
        [Parameter(Mandatory = $False, ParameterSetName = 'sensorType')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'Template')]
        [Parameter(Mandatory = $False, ParameterSetName = 'Internal')]
        [Parameter(Mandatory = $False, ParameterSetName = 'taskType')]
        [Parameter(Mandatory = $False, ParameterSetName = 'monitorType')]
        [Parameter(Mandatory = $False, ParameterSetName = 'sensorType')]
        [switch]$IncludeArchived,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'Template')]
        [Parameter(Mandatory = $False, ParameterSetName = 'Internal')]
        [Parameter(Mandatory = $False, ParameterSetName = 'taskType')]
        [Parameter(Mandatory = $False, ParameterSetName = 'monitorType')]
        [Parameter(Mandatory = $False, ParameterSetName = 'sensorType')]
        [switch]$OnlyArchived,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'Internal')]
        [Parameter(Mandatory = $False, ParameterSetName = 'taskType')]
        [Parameter(Mandatory = $False, ParameterSetName = 'monitorType')]
        [Parameter(Mandatory = $False, ParameterSetName = 'sensorType')]
        [string]$Folder,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'Template')]
        [Parameter(Mandatory = $False, ParameterSetName = 'Internal')]
        [Parameter(Mandatory = $False, ParameterSetName = 'taskType')]
        [Parameter(Mandatory = $False, ParameterSetName = 'monitorType')]
        [Parameter(Mandatory = $False, ParameterSetName = 'sensorType')]
        [string[]]$Tags
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [string]$command = ('/processing/read')
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWTaskTemplate]$TaskTemplate = $_
        }
        ElseIf ($_ -gt 0) {
            [int64]$Id = $_
        }
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($Id -gt 0) {
            $BodyMetaData.'id' = $Id
            $BodyMetaData.'_textMatchStyle' = 'exactCase'
            $BodyMetaData.'_operationId' = 'read'
        }
        Else {
            $BodyMetaData.'_constructor' = 'AdvancedCriteria'
            $BodyMetaData.'operator' = 'and'
            $BodyMetaData.'_startRow' = $startRow
            $BodyMetaData.'_endRow' = $endRow
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_componentId' = 'ProcessingList'
            If ($Descending -eq $true) {
                $BodyMetaData.'_sortBy' = '-' + $sortBy
            }
            Else {
                $BodyMetaData.'_sortBy' = $sortBy
            }
            If ($OnlyArchived -eq $true) {
                $BodyMetaData.'criteria1' = '{"fieldName":"archived","operator":"equals","value":true}'
            }
            ElseIf ($IncludeArchived -ne $true) {
                $BodyMetaData.'criteria1' = '{"fieldName":"archived","operator":"equals","value":false}'
            }
            $BodyMetaData.'criteria2' = '{"fieldName":"isProcessing","operator":"equals","value":true}'
            If ($null -ne $taskType) {
                $BodyMetaData.'criteria3' = '{"fieldName":"taskType","operator":"equals","value":"' + $taskType + '"}'
            }
            ElseIf ($null -ne $monitorType) {
                $BodyMetaData.'criteria3' = '{"fieldName":"monitorType","operator":"equals","value":"' + $monitorType + '"}'
            }
            ElseIf ($null -ne $sensorType) {
                $BodyMetaData.'criteria3' = '{"fieldName":"sensorType","operator":"equals","value":"' + $sensorType + '"}'
            }
            ElseIf ($TaskTemplate.Id.Length -gt 0) {
                $BodyMetaData.'criteria3' = ('{"fieldName":"template","operator":"equals","value":"' + $TaskTemplate.Id + '"}')
            }
            ElseIf ($Internal -eq $true) {
                $Error.Clear()
                Try {
                    [string]$all_internal_task_types = ([ANOWProcessingTemplateCustom_InternalTasks].GetEnumNames() | ForEach-Object { '"' + $_ + '"' }) -join ','
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWTask was unable to enumerate the *custom* object class [ANOWProcessingTemplateCustom_InternalTasks] due to [$Message]."
                    Break
                }
                $BodyMetaData.'criteria3' = '{"fieldName":"itemType","operator":"inSet","value":[' + $all_internal_task_types + ']}'
            }
            Else {
                $Error.Clear()
                Try {
                    [string]$all_task_types = ([ANOWProcessingTemplateCustom_Tasks].GetEnumNames() | ForEach-Object { '"' + $_ + '"' }) -join ','
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWTask was unable to enumerate the *custom* object class [ANOWProcessingTemplateCustom_Tasks] due to [$Message]."
                    Break
                }
                $BodyMetaData.'criteria3' = '{"fieldName":"itemType","operator":"inSet","value":[' + $all_task_types + ']}'
            }
            If ($ProcessingStatus.Length -gt 0) {
                [string]$ProcessingStatus = $ProcessingStatus.ToString()
                $BodyMetaData.'criteria4' = ('{"fieldName":"processingStatus","operator":"inSet","value":["' + $ProcessingStatus + '"]}')
            }
            If ($Folder.Length -gt 0) {
                $BodyMetaData.'criteria5' = ('{"fieldName":"folder","operator":"equals","value":"' + $Folder + '"}')
            }
            If ($Tags.Count -gt 0) {
                If ($Tags.Count -gt 1) {
                    $Error.Clear()
                    Try {
                        [string]$TagString = $Tags | ConvertTo-Json -Compress
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "ConvertTo-Json failed to convert the provided tag names under Get-AutomateNOWTask due to [$Message]."
                        Break
                    }
                }
                Else {
                    [string]$TagString = $Tags
                }
                $BodyMetaData.'criteria6' = ('{"fieldName":"tags","operator":"containsAny","value":' + $TagString + '}')
            }
        }
        $BodyMetaData.'_operationType' = 'fetch'
        $BodyMetaData.'_dataSource' = 'ProcessingDataSource'
        $BodyMetaData.'isc_metaDataPrefix' = '_'
        $BodyMetaData.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        If ($null -eq $parameters.Body) {
            $parameters.Add('Body', $Body)
        }
        Else {
            $parameters.Body = $Body
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWTask[]]$Tasks = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWTask] objects due to [$Message]."
            Break
        }
        If ($Tasks.Count -gt 0) {
            Return $Tasks
        }
    }
    End {

    }
}

Function Export-AutomateNOWTask {
    <#
    .SYNOPSIS
    Exports the Tasks from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Tasks from an instance of AutomateNOW! to a local .csv file

    .PARAMETER Task
    Mandatory [ANOWTask] object (Use Get-AutomateNOWTask to retrieve them)

    .INPUTS
    ONLY [ANOWTask] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWTask] objects are exported to the local disk in CSV format

    .EXAMPLE
    Get-AutomateNOWTask | Export-AutomateNOWTask

    .EXAMPLE
    Get-AutomateNOWTask -Id 'Task01' | Export-AutomateNOWTask

    .EXAMPLE
    @( 'Task01', 'Task02' ) | Get-AutomateNOWTask | Export-AutomateNOWTask

    .EXAMPLE
    Get-AutomateNOWTask | Where-Object { $_.taskType -eq 'PYTHON' } | Export-AutomateNOWTask

    .NOTES
	You must present [ANOWTask] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWTask]$Task
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-Tasks-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWTask]$Task = $_
        }
        $Error.Clear()
        Try {
            $Task | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWTaskTemplate] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function Remove-AutomateNOWTask {
    <#
    .SYNOPSIS
    Archives a Task from an AutomateNOW! instance

    .DESCRIPTION
    Archives a Task from an AutomateNOW! instance

    .PARAMETER Task
    An [ANOWTask] object representing the Task Template to be archived.

    .PARAMETER Force
    Force the archiving without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWTask] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Get-AutomateNOWTask -Id 'Task01' | Remove-AutomateNOWTask

    .EXAMPLE
    Get-AutomateNOWTask -Id 'Task01', 'Task02' | Remove-AutomateNOWTask

    .EXAMPLE
    @( 'Task1', 'Task2', 'Task3') | Remove-AutomateNOWTask

    .EXAMPLE
    Get-AutomateNOWTask | ? { $_.serverTaskType -eq 'LINUX' } | Remove-AutomateNOWTask

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The term Remove and Archive are synonymous from the API perspective. In ANOW parlance, Templates are 'Deleted' and Tasks are 'Archived'.
    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWTask]$Task,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processing/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWTask]$Task = $_
        }
        [string]$Task_id = $Task.id
        If ($Task_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess($Task_id, 'Archive')) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
            $Body.Add('id', $Task_id)
            $Body.Add('_operationType', 'remove')
            $Body.Add('_operationId', 'delete')
            $Body.Add('_textMatchStyle', 'exact')
            $Body.Add('_dataSource', 'ProcessingDataSource')
            $Body.Add('isc_metaDataPrefix', '_')
            $Body.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $Body
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Task_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Task $Task_id successfully archived"
        }
    }
    End {

    }
}

Function Restart-AutomateNOWTask {
    <#
    .SYNOPSIS
    Restarts a Task from an AutomateNOW! instance

    .DESCRIPTION
    Restarts a Task from an AutomateNOW! instance

    .PARAMETER Task
    An [ANOWTask] object representing the Task to be restarted

    .PARAMETER Quiet
    Switch parameter to omit the informational message if the Restart was successful

    .PARAMETER Force
    Force the restart without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWTask] objects are accepted (including from the pipeline)

    .OUTPUTS
    An informational message is written to the screen unless -Quiet is used

    .EXAMPLE
    Restarts a single Task

    Get-AutomateNOWTask -Id 'Task_01' | Restart-AutomateNOWTask

    .EXAMPLE
    Quietly restarts multiple Tasks

    @('Task1', 'Task2') | Get-AutomateNOWTask | Restart-AutomateNOWTask -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWTask]$Task,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processing/restart'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id -gt 0) {
            [ANOWTask]$Task = $_
        }
        [int64]$Task_id = $Task.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Task_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [ANOWTask]$current_task = Get-AutomateNOWTask -Id $Task_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWTask failed to check if the Task [$Task_id] existed under Restart-AutomateNOWTask due to [$Message]."
                Break
            }
            If ($current_task.id.length -eq 0) {
                Write-Warning -Message "The Task you specified does not seem to exist (Restart-AutomateNOWTask)"
                Break
            }
            [string]$current_task_status = $current_task.processingStatus
            If ($current_task_status -notin [ANOWProcessing_processingStatus].GetEnumNames()) {
                Write-Warning -Message "Somehow the processing status of the task [$Task_id] cannot be read (Restart-AutomateNOWTask)"
                Break
            }
            If ($current_task_status -notin @('COMPLETED', 'FAILED')) {
                Write-Warning -Message "[$Task_id] cannot be restarted as it currently in [$current_task_status] processing status"
                Break
            }
            Else {
                Write-Verbose -Message "[$Task_id] had a status of $current_task_status"
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('restartType', 'RESTART_FROM_BEGINNING')
            $BodyMetaData.Add('restartFailedOnly', 'false' ) # Note this value is currently not available in the console
            $BodyMetaData.Add('id', $Task_id )
            $BodyMetaData.Add('_operationType', 'custom')
            $BodyMetaData.Add('_operationId', 'restart')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Task_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            If ($Quiet -ne $true) {
                Write-Information -MessageData "Task $Task_id was successfully restarted"
            }
        }
    }
    End {

    }
}

Function Stop-AutomateNOWTask {
    <#
    .SYNOPSIS
    Stops a Task on an AutomateNOW! instance

    .DESCRIPTION
    Stops a Task on an AutomateNOW! instance with either a soft or hard stop

    .PARAMETER Task
    An [ANOWTask] object representing the Task to be stopped

    .PARAMETER Kill
    Switch parameter to indicate 'Hard kill' of the Task. You must include either this parameter or -Abort

    .PARAMETER Abort
    Switch parameter to indicate 'Soft abort' of the Task. You must include either this parameter or -Kill

    .PARAMETER Force
    Force the stoppage without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWTask] objects are accepted (including from the pipeline)

    .OUTPUTS
    An informational message is written to the screen unless -Quiet is used

    .EXAMPLE
    Stops a single Task

    Get-AutomateNOWTask -Id 'Task_01' | Stop-AutomateNOWTask -Abort

    .EXAMPLE
    Stops multiple Tasks

    @('Task1', 'Task2') | Get-AutomateNOWTask | Stop-AutomateNOWTask -Kill

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWTask]$Task,
        [Parameter(Mandatory = $true, ParameterSetName = 'Kill')]
        [switch]$Kill,
        [Parameter(Mandatory = $true, ParameterSetName = 'Abort')]
        [switch]$Abort,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($Kill -eq $true) {
            [string]$operation_id = 'kill'
        }
        Else {
            [string]$operation_id = 'abort'
        }
        [string]$command = ('/processing/' + $operation_id)
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id -gt 0) {
            [ANOWTask]$Task = $_
        }
        [int64]$Task_id = $Task.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Task_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [ANOWTask]$current_task = Get-AutomateNOWTask -Id $Task_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWTask failed to check if the Task [$Task_id] existed under Restart-AutomateNOWTask due to [$Message]."
                Break
            }
            If ($current_task.id.length -eq 0) {
                Write-Warning -Message "The Task you specified does not seem to exist (Stop-AutomateNOWTask)"
                Break
            }
            [string]$current_task_status = $current_task.processingStatus
            If ($current_task_status -notin [ANOWProcessing_processingStatus].GetEnumNames()) {
                Write-Warning -Message "Somehow the processing status of the task [$Task_id] cannot be read (Stop-AutomateNOWTask)"
                Break
            }
            If ($current_task_status -in @('COMPLETED', 'FAILED')) {
                Write-Warning -Message "[$Task_id] cannot be stopped as it currently in [$current_task_status] processing status"
                Break
            }
            Else {
                Write-Verbose -Message "[$Task_id] had a status of $current_task_status"
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $Task_id )
            $BodyMetaData.Add('_operationType', 'custom')
            $BodyMetaData.Add('_operationId', $operation_id)
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Task_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Task $Task_id was successfully stopped"
        }
    }
    End {

    }
}

Function Resume-AutomateNOWTask {
    <#
    .SYNOPSIS
    Resumes a Task that is on hold (suspended) on an AutomateNOW! instance

    .DESCRIPTION
    Resumes a Task that is on hold (suspended) on an AutomateNOW! instance

    .PARAMETER Task
    An [ANOWTask] object representing the Task to be resumed

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWTask] objects are accepted (including from the pipeline)

    .OUTPUTS
    A verbose information message will be sent indicating success

    .EXAMPLE
    Get-AutomateNOWTask -Id 'Task01' | Resume-AutomateNOWTask -Force

    .EXAMPLE
    Get-AutomateNOWTask -Id 'Task01', 'Task02' | Resume-AutomateNOWTask

    .EXAMPLE
    @( 'Task1', 'Task2', 'Task3') | Resume-AutomateNOWTask

    .EXAMPLE
    Get-AutomateNOWTask | ? { $_.serverTaskType -eq 'LINUX' } | Resume-AutomateNOWTask

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $True, ValueFromPipeline = $True)]
        [ANOWTask]$Task,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processing/resume'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWTask]$Task = $_.id
        }
        [int64]$Task_id = $Task.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Task_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [ANOWTask]$current_task = Get-AutomateNOWTask -Id $Task_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWTask failed to check if the Task [$Task_id] existed under Resume-AutomateNOWTask due to [$Message]."
                Break
            }
            If ($current_task.id.length -eq 0) {
                Write-Warning -Message "The Task you specified does not seem to exist (Resume-AutomateNOWTask)"
                Break
            }
            [boolean]$current_task_hold_status = $current_task.onHold
            If ($current_task_hold_status -eq $false) {
                Write-Warning -Message "[$Task_id] cannot be resumed as it is not currently suspended (on hold)"
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $Task_id )
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_operationId', 'resume')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Task_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Task $Task_id successfully resumed"
        }
    }
    End {

    }
}

Function Suspend-AutomateNOWTask {
    <#
    .SYNOPSIS
    Places a Task on hold (suspend) from execution on an AutomateNOW! instance

    .DESCRIPTION
    Places a Task on hold (suspend) from execution on an AutomateNOW! instance

    .PARAMETER Task
    An [ANOWTask] object representing the Task to be suspended (placed on hold)

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWTask] objects are accepted (including from the pipeline)

    .OUTPUTS
    A verbose information message will be sent indicating success

    .EXAMPLE
    Get-AutomateNOWTask -Id 'Task01' | Suspend-AutomateNOWTask -Force

    .EXAMPLE
    Get-AutomateNOWTask -Id 'Task01', 'Task02' | Suspend-AutomateNOWTask

    .EXAMPLE
    @( 'Task1', 'Task2', 'Task3') | Suspend-AutomateNOWTask

    .EXAMPLE
    Get-AutomateNOWTask | ? { $_.serverTaskType -eq 'LINUX' } | Suspend-AutomateNOWTask

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWTask]$Task,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processing/hold'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWTask]$Task = $_.id
        }
        [string]$Task_id = $Task.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Task_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [ANOWTask]$current_task = Get-AutomateNOWTask -Id $Task_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWTask failed to check if the Task [$Task_id] existed under Resume-AutomateNOWTask due to [$Message]."
                Break
            }
            If ($current_task.id.length -eq 0) {
                Write-Warning -Message "The Task you specified does not seem to exist (Resume-AutomateNOWTask)"
                Break
            }
            [boolean]$current_task_hold_status = $current_task.onHold
            If ($current_task_hold_status -eq $true) {
                Write-Warning -Message "[$Task_id] cannot be suspended (placed on hold) as it is already suspended (on hold)"
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $Task_id )
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_operationId', 'hold')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Task_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Task $Task_id successfully suspended (placed on hold)"
        }
    }
    End {

    }
}

Function Skip-AutomateNOWTask {
    <#
    .SYNOPSIS
    Sets or unsets the Skip flag on a Task on an AutomateNOW! instance

    .DESCRIPTION
    Sets or unsets the Skip flag on a Task on an AutomateNOW! instance

    .PARAMETER Task
    An [ANOWTask] object representing the Task to be set to skipped or unskipped

    .PARAMETER UnSkip
    Removes the skip flag from an [ANOWTask] object. This is the opposite of the default behavior.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Switch parameter to silence the emitted [ANOWTask] object

    .INPUTS
    ONLY [ANOWTask] objects are accepted (including from the pipeline)

    .OUTPUTS
    The skipped/unskipped [ANOWTask] object will be returned

    .EXAMPLE
    Sets a Task to Skip (bypass)

    Get-AutomateNOWTask -Id 1234567 | Skip-AutomateNOWTask -Force

    .EXAMPLE
    Unsets the Skip (bypass) flag on a Task

    12374894 | Get-AutomateNOWTask | Skip-AutomateNOWTask -UnSkip

    .EXAMPLE
    Sets an array of Task to Skip (bypass)

    @( 'Task1', 'Task2', 'Task3') | Skip-AutomateNOWTask

    .EXAMPLE
    Get-AutomateNOWTask | ? { $_.TaskType -eq 'FOR_EACH' } | Skip-AutomateNOWTask -UnSkip -Force -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWTask]$Task,
        [Parameter(Mandatory = $false)]
        [switch]$UnSkip,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnSkip -ne $True) {
            [string]$skip_flag_status = 'On'
            [string]$operation_id = 'passByOn'
            [string]$ProcessDescription = 'Add the Skip flag'
        }
        Else {
            [string]$skip_flag_status = 'Off'
            [string]$operation_id = 'passByOff'
            [string]$ProcessDescription = 'Remove the Skip flag'
        }
        [string]$command = ('/processing/' + $operation_id)
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWTask]$Task = $_
        }
        [string]$Task_id = $Task.id
        If ($Task.passBy -eq $true -and $UnSkip -ne $True) {
            Write-Warning -Message "Task $Task_id already has the skip flag set. No action is required."
            Break
        }
        ElseIf ($Task.passBy -eq $false -and $UnSkip -eq $True) {
            Write-Warning -Message "Task $Task_id does not have the skip flag set. No action is required."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess($Task_id, $ProcessDescription)) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $Task_id )
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_operationId', $operation_id)
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Task_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Successfully set the skip flag to [$skip_flag_status] on [$Task_id]"
        }
    }
    End {

    }
}

#endregion

#Region - Task Templates (PROCESSING_TEMPLATE)

Function Get-AutomateNOWTaskTemplate {
    <#
    .SYNOPSIS
    Gets the task templates from an AutomateNOW! instance

    .DESCRIPTION
    Gets the task templates from an AutomateNOW! instance

    .PARAMETER Id
    Optional string containing the simple id of the task template to fetch or you can pipeline a series of simple id strings. You may not enter an array here.

    .PARAMETER taskType
    Optional string representing the type of Task Template to return. For example, a Shell Task template is SH. This parameter cannot be combined with -monitorType or -sensorType.

    .PARAMETER monitorType
    Optional string representing the type of monitor to return. For example, a python monitor is PYTHON_MONITOR. This parameter cannot be combined with -taskType or -sensorType.

    .PARAMETER sensorType
    Optional string representing the type of sensor to return. For example, a file sensor is FILE_SENSOR. This parameter cannot be combined with -monitorType or -taskType.

    .PARAMETER sortBy
    Optional string parameter to sort the results by. Valid choices are: id*, processingType, simpleId, dateCreated, node, outOfSync, keepResourcesOnFailure, onHold, lastUpdated, highRisk, weight, taskType, userIp, createdBy, lazyLoad, passBy, lastUpdatedBy, durationSum, serverNodeType, eagerScriptExecution, passResourceDependenciesToChildren, owner, checkedOut, estimatedDuration, passActionsToChildren

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER Folder
    Optional string to filter by a particular Folder

    .PARAMETER Tags
    Optional string array of Tags to filter by. Note that the 'containsAny' operator will be used.

    .INPUTS
    Accepts a string representing the simple id of the Task Template from the pipeline or individually (but not an array).

    .OUTPUTS
    An array of one or more [ANOWTaskTemplate] class objects

    .EXAMPLE
    Gets the first page of Task Templates

    Get-AutomateNOWTaskTemplate

    .EXAMPLE
    Gets a specific Task Template named 'TaskTemplate1'

    Get-AutomateNOWTaskTemplate -Id 'TaskTemplate1'

    .EXAMPLE
    Gets the first page of Task Templates of type POWERSHELL

    Get-AutomateNOWTaskTemplate -taskType POWERSHELL

    .EXAMPLE
    Gets a series of Task Templates using the pipeline

    TaskTemplate1', 'TaskTemplate2' | Get-AutomateNOWTaskTemplate

    .EXAMPLE
    Gets all Task Templates that are tagged with 'Tag1' or 'Tag2'

    Get-AutomateNOWTaskTemplate -Tags 'Tag1', 'Tag2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Be aware that Task Templates are divided into --> 3 <-- types which is not directly illustrated in the console. Those 3 types are: Tasks, Monitors & Sensors.

    #>
    [OutputType([ANOWTaskTemplate[]])]
    [Cmdletbinding(DefaultParameterSetName = 'Default' )]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $False, ValueFromPipeline = $true, ParameterSetName = 'Default')]
        [string]$Id,
        [Parameter(Mandatory = $True, ParameterSetName = 'taskType')]
        [ANOWProcessingTemplate_taskType]$taskType,
        [Parameter(Mandatory = $True, ParameterSetName = 'monitorType')]
        [ANOWProcessingTemplate_monitorType]$monitorType,
        [Parameter(Mandatory = $True, ParameterSetName = 'sensorType')]
        [ANOWProcessingTemplate_sensorType]$sensorType,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'taskType')]
        [Parameter(Mandatory = $False, ParameterSetName = 'monitorType')]
        [Parameter(Mandatory = $False, ParameterSetName = 'sensorType')]
        [ValidateSet('id', 'processingType', 'simpleId', 'dateCreated', 'node', 'outOfSync', 'keepResourcesOnFailure', 'onHold', 'lastUpdated', 'highRisk', 'weight', 'taskType', 'userIp', 'createdBy', 'lazyLoad', 'passBy', 'lastUpdatedBy', 'durationSum', 'serverNodeType', 'eagerScriptExecution', 'passResourceDependenciesToChildren', 'owner', 'checkedOut', 'estimatedDuration', 'passActionsToChildren', ignoreCase = $false)]
        [string]$sortBy = 'id',
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'taskType')]
        [Parameter(Mandatory = $False, ParameterSetName = 'monitorType')]
        [Parameter(Mandatory = $False, ParameterSetName = 'sensorType')]
        [switch]$Descending,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'taskType')]
        [Parameter(Mandatory = $False, ParameterSetName = 'monitorType')]
        [Parameter(Mandatory = $False, ParameterSetName = 'sensorType')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'taskType')]
        [Parameter(Mandatory = $False, ParameterSetName = 'monitorType')]
        [Parameter(Mandatory = $False, ParameterSetName = 'sensorType')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'taskType')]
        [Parameter(Mandatory = $False, ParameterSetName = 'monitorType')]
        [Parameter(Mandatory = $False, ParameterSetName = 'sensorType')]
        [string[]]$Tags,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'taskType')]
        [Parameter(Mandatory = $False, ParameterSetName = 'monitorType')]
        [Parameter(Mandatory = $False, ParameterSetName = 'sensorType')]
        [string]$Folder
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        $Body.'_operationType' = 'fetch'
        If ($_.Length -gt 0 -or $Id.Length -gt 0) {
            If ($_.Length -gt 0 ) {
                $Body.'id' = $_
            }
            Else {
                $Body.'id' = $Id
            }
            $Body.'_textMatchStyle' = 'exactCase'
        }
        Else {
            $Body.'_constructor' = 'AdvancedCriteria'
            $Body.'operator' = 'and'
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
            $Body.'_textMatchStyle' = 'substring'
            $Body.'_componentId' = 'ProcessingTemplateList'
            If ($null -ne $taskType) {
                $Body.'criteria1' = ('{"fieldName":"taskType","operator":"equals","value":"' + $taskType + '"}')
            }
            ElseIf ($null -ne $monitorType) {
                $Body.'criteria1' = ('{"fieldName":"monitorType","operator":"equals","value":"' + $monitorType + '"}')
            }
            ElseIf ($null -ne $sensorType) {
                $Body.'criteria1' = ('{"fieldName":"sensorType","operator":"equals","value":"' + $sensorType + '"}')
            }
            Else {
                $Body.'criteria1' = '{"_constructor":"AdvancedCriteria","operator":"or","criteria":[{"fieldName":"processingType","operator":"equals","value":"TASK"},{"fieldName":"serviceType","operator":"equals","value":"SENSOR"},{"fieldName":"serviceType","operator":"equals","value":"MONITOR"}]}'
            }
            $Body.'criteria2' = '{"fieldName":"serverNodeType","operator":"notNull"}'
            If ($Tags.Count -gt 0) {
                ForEach ($tag_id in $Tags) {
                    $Error.Clear()
                    Try {
                        [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] running under Get-AutomateNOWTaskTemplate due to [$message]"
                        Break
                    }
                    If ($tag_object.simpleId.length -eq 0) {
                        Throw "Get-AutomateNOWTag has detected that the tag [$tag_id] does not appear to exist under Get-AutomateNOWTaskTemplate. Please check again."
                        Break
                    }
                    ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                        [string]$tag_object_simpleId = $tag_object.simpleId
                        Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                        Break
                    }
                    [string]$tags_json = $Tags | Sort-Object -Unique | ConvertTo-JSON -Compress
                    $Body.'criteria3' = ('{"fieldName":"tags","operator":"containsAny","value":' + $tags_json + '}')
                }
            }
            If ($Folder.Length -gt 0) {
                If ($null -eq (Get-AutomateNOWFolder -Id $Folder)) {
                    Write-Warning -Message "The folder [$Folder] does not appear to exist. Please only use existing Folders when filtering."
                    Break
                }
                $Body.'criteria4' = ('{"fieldName":"folder","operator":"equals","value":"' + $folder + '"}')
            }
        }
        $Body.'_dataSource' = 'ProcessingTemplateDataSource'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        If ($Descending -eq $true) {
            $Body.'_sortBy' = '-' + $sortBy
        }
        Else {
            $Body.'_sortBy' = $sortBy
        }
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/processingTemplate/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWTaskTemplate[]]$TaskTemplates = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWTaskTemplate] objects due to [$Message]."
            Break
        }
        If ($TaskTemplates.Count -gt 0) {
            If ($TaskTemplates.Count -eq 1 -and $TaskTemplates.processingType -notin @('TASK', 'SERVICE')) {
                [string]$processingType = $TaskTemplates.processingType
                If ($processingType -eq 'WORKFLOW') {
                    Write-Warning -Message "$Id is actually a Workflow Template. Please use Get-AutomateNOWWorkflowTemplate to retrieve this item."
                }
                ElseIf ($processingType -eq 'TRIGGER') {
                    Write-Warning -Message "$Id is actually a Schedule Template. Please use Get-AutomateNOWScheduleTemplate to retrieve this item."
                }
                Else {
                    Write-Warning -Message "Could not identify what type of template object [$processingType] is. Please look into this..."
                }
                Break
            }
            Return $TaskTemplates
        }
    }
    End {

    }
}

Function Set-AutomateNOWTaskTemplate {
    <#
    .SYNOPSIS
    Changes the settings of a Task Template on an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of a Task Template on an AutomateNOW! instance

    .PARAMETER TaskTemplate
    An [ANOWTaskTemplate] object representing the Task Template to be changed.

    .PARAMETER ProcessingCommand
    (Experimental) An optional hashtable containing the new ProcessingCommand (see examples)

    .PARAMETER Description
    Optional description of the Task Template (may not exceed 255 characters).

    .PARAMETER UnsetDescription
    Optional switch that will remove the Description from the Task Template object.

    .PARAMETER Folder
    A string representing the name of the Folder to move the Task Template into.

    .PARAMETER UnsetFolder
    A switch parameter that will move the Task Template out of its current folder.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to include with this object.

    .PARAMETER UnsetTags
    A switch parameter that will remove the Tags from the Task Template

    .PARAMETER CodeRepository
    Optional [ANOWCodeRepository] object to place the Task Template into.

    .PARAMETER UnsetCodeRepository
    A switch parameter that will remove the Task Template from its Code Repository.

    .PARAMETER Title
    A string representing the "alias" of the Task Template (this property needs a better explanation)

    .PARAMETER UnsetTitle
    A switch parameter that will remove the Title from the Task Template

    .PARAMETER ServerNode
    An [ANOWServerNode] object representing the node to connect to the Task Template. Note that load balancers are considered nodes in this context. Be careful with this as the lookup table which prevents mismatched server node / task types may not be perfectly correct. Always be sure that the node type matches the task type.

    .PARAMETER UnsetServerNode
    A switch parameter that will remove the Server Node from the Task Template.

    .PARAMETER Endpoint
    An [Endpoint] object representing the Endpoint object to assign to the Task Template. CAUTION: There is not yet any check to confirm if the endpoint type matches the expected type.

    .PARAMETER UnsetEndpoint
    A switch parameter that will remove the Endpoint assignment from the Task Template.

    .PARAMETER ResultMapping
    An [ResultMapping] object representing the Result Mapping object to set on the Task Template.

    .PARAMETER UnsetResultMapping
    A switch parameter that will remove the Result Mapping assignment from the Task Template.

    .PARAMETER Calendar
    A [ANOWCalendar] object representing the Calendar object to set on the Task Template. Use Get-AutomateNOWCalendar to fetch one of these.

    .PARAMETER UnsetCalendar
    A switch parameter that will remove the Calendar assignment from the Task Template.

    .PARAMETER DelayedStartTime
    Optional string that allows processing items to start on a specific date or time or delay the execution for a period ranging from days to seconds. Example 1: 2029-12-31, Example 2: 2029-12-31 23:59:59, Example 3: 23:59:59

    .PARAMETER UnsetDelayedStartTime
    A switch parameter that will remove the Delayed Start Time from the Workflow Template.

    .PARAMETER TimeZone
    Optional [ANOWTimeZone] object that modifies (it is unknown exactly what this property modifies since it is not defined in the documentation yet)

    .PARAMETER UnsetTimeZone
    A switch parameter that will remove the Time Zone from the Workflow Template.

    .PARAMETER Approval
    A [ANOWApproval] object representing the Approval object to set on the Task Template.

    .PARAMETER UnsetApproval
    A switch parameter that will remove the Approval assignment from the Task Template.

    .PARAMETER Priority
    An integer representing the items priority which determines the order when queuing for resources (Stock and Locks) and [for] being executed by Server Nodes. Default Priority is 0. Minimal Priority is 0.

    .PARAMETER Weight
    An integer representing a logical measure of resources required to process the item by the Server Node. Each Server Node has [a] maximum weight capacity[.] Weight determines [the] number of parallel processes that can run simultaneously. Default processing Weight is 1. Minimal Weight is 0.

    .PARAMETER OnHold
    A boolean to put the Task Template on Hold status. You must specify $true or $false here. When $true, it's the same as the Suspend-AutomateNOWTaskTemplate function. When $false, Resume-AutomateNOWTaskTemplate function.

    .PARAMETER Skip
    A boolean to put the Task Template on Skip status. You must specify $true or $false here. When $true, it's the same as the Skip-AutomateNOWTaskTemplate function. When $false, Skip-AutomateNOWTaskTemplate with -UnSkip parameter.

    .PARAMETER VerboseMode
    A boolean setting that enables Verbose Mode on the Task. You must specify $true or $false here.

    .PARAMETER AutoArchive
    A boolean that causes the Tasks from this Task Template to be archived immediately after execution. You must specify $true or $false here.

    .PARAMETER KeepResources
    A boolean that indicates if the Tasks from this Task Template should keep its resources (Stocks and Locks) and reuse them on the restart so that they are not consumed by other tasks or workflows. You must specify $true or $false here.

    .PARAMETER UseScripts
    A boolean that indicates if the Tasks from this Task Template should ?

    .PARAMETER EagerScriptExecution
    A boolean that indicates if the scripts from the Tasks from this Task Template should use "Eager" load strategy. In order to use this parameter, you must include -UseScripts $true.

    .PARAMETER Owner
    An optional decorational string to indicate who the owner of this object is.

    .PARAMETER statisticalDuration
    An int64 number in milliseconds of the expected duration of the Task Template. The minimum/maximum is 1000/31536000000 (1 second/1 year). The default is 60000 (1 minute).

    .PARAMETER Quiet
    Switch parameter that silences the output of the updated object.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWTaskTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWTaskTemplate] object will be returned

    .EXAMPLE
    Removes a Task Template from its current Folder
    Set-AutomateNOWTaskTemplate -TaskTemplate $task_template -Force -UnsetFolder

    .EXAMPLE
    Places a Task Template into a Folder
    Set-AutomateNOWTaskTemplate -TaskTemplate $task_template -Force -Folder 'Folder1'

    .EXAMPLE
    Sets all of the minor properties
    Set-AutomateNOWTaskTemplate -TaskTemplate $task_template -Description 'description' -Title 'title' -Weight 15 -Priority 5 -Owner 'the_owner' -OnHold $true -Skip $false -AutoArchive $true -KeepResources $false -UseScripts $true -EagerScriptExecution $true -Force

    .EXAMPLE
    Forcefully sets a Server Node on the Task Template
    Set-AutomateNOWTaskTemplate -TaskTemplate $task_template -Force -ServerNode $ServerNode

    .EXAMPLE
    Removes the Server Node from the Task Template
    Set-AutomateNOWTaskTemplate -TaskTemplate $task_template -UnsetServerNode

    .EXAMPLE
    Forcefully sets a Result Mapping on the Task Template
    Set-AutomateNOWTaskTemplate -TaskTemplate $task_template -Force -ResultMapping $result_mapping

    .EXAMPLE
    Removes the Result Mapping from the Task Template
    Set-AutomateNOWTaskTemplate -TaskTemplate $task_template -UnsetResultMapping

    .EXAMPLE
    Forcibly modifies the script (processingCommand) of a Shell Task

    $task = Get-AutomateNOWTaskTemplate -Id 'ShellTask1'
    $script = @{'script' = 'echo "Hello, World!"';}
    Set-AutomateNOWTaskTemplate -TaskTemplate $task -processingCommand $script -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    When using the -processingCommand parameter there is no need to convert any strings to JSON as that will happen automatically.

    #>
    [OutputType([ANOWTaskTemplate])]
    [Cmdletbinding(SupportsShouldProcess, DefaultParameterSetName = 'Default', ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWTaskTemplate]$TaskTemplate,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [hashtable]$ProcessingCommand,
        [ValidateScript({ $_.Length -le 255 })]
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [string]$Description,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false, ParameterSetName = 'Folder')]
        [string]$Folder,
        [Parameter(Mandatory = $false, ParameterSetName = 'Folder')]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [string[]]$Tags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetCodeRepository,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [string]$Title,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetTitle,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [ANOWServerNode]$ServerNode,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetServerNode,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [ANOWEndpoint]$Endpoint,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetEndpoint,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [ANOWResultMapping]$ResultMapping,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetResultMapping,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [ANOWCalendar]$Calendar,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetCalendar,
        [ValidateScript({ $_ -match '([0-9]{4}-[0-9]{2}-[0-9]{2}){0,}( {0,}[0-9]{2}:[0-9]{2}:[0-9]{2}){0,}' })]
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [string]$DelayedStartTime,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetDelayedStartTime,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [ANOWTimeZone]$TimeZone,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetTimeZone,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [ANOWApproval]$Approval,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetApproval,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [int32]$Priority,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [int32]$Weight,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Nullable[boolean]]$OnHold,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Nullable[boolean]]$Skip,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Nullable[boolean]]$VerboseMode,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Nullable[boolean]]$AutoArchive,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Nullable[boolean]]$KeepResources,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Nullable[boolean]]$UseScripts,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Nullable[boolean]]$EagerScriptExecution,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [string]$Owner,
        [ValidateRange(1000, 31536000000)]
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [int64]$statisticalDuration,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetFolder -eq $true -or $Folder.Length -gt 0) {
            [string]$command = '/processingTemplate/setFolder'
            [string]$operationId = 'setFolder'
        }
        Else {
            [string]$command = '/processingTemplate/update'
            [string]$componentId = 'ProcessingTemplateValuesManager'
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
        If ($Description.Length -gt 0 -and $UnsetDescription -eq $true) {
            Write-Warning -Message 'You cannot set the Description and unset it at the same time. Please choose one or the other.'
            Break
        }
        If ($Title.Length -gt 0 -and $UnsetTitle -eq $true) {
            Write-Warning -Message 'You cannot set the Title and unset it at the same time. Please choose one or the other.'
            Break
        }
        If ($EagerScriptExecution -eq $true -and $UseScripts -ne $true) {
            Write-Warning -Message 'To use -EagerScriptExecution, you must include -UseScripts $true'
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Exit
        }
        If ($UnsetServerNode -eq $true -and $ServerNode.Id.Length -gt 0) {
            Write-Warning -Message "You cannot set the Server Node and unset it at the same time. Please choose one or the other."
            Exit
        }
        If ($Tags.count -gt 0 -and $UnsetTags -eq $true) {
            Write-Warning -Message "You cannot set the tags and unset them at the same time. Please choose one or the other."
        }
        If ($UnsetCodeRepository -eq $true -and $CodeRepository.Id.Length -gt 0) {
            Write-Warning -Message "You cannot set the Code Repository and unset it at the same time. Please choose one or the other."
            Exit
        }
        If ($UnsetEndpoint -eq $true -and $Endpoint.id.Length -gt 0) {
            Write-Warning -Message "You cannot set the Endpoint and unset it at the same time. Please choose one or the other."
            Exit
        }
        If ($UnsetApproval -eq $true -and $Approval.id.Length -gt 0) {
            Write-Warning -Message "You cannot set the Approval and unset it at the same time. Please choose one or the other."
            Exit
        }
        If ($UnsetTimeZone -eq $true -and $TimeZone.Id.Length -gt 0) {
            Write-Warning -Message "You cannot set the Time Zone and unset it at the same time. Please choose one or the other."
            Exit
        }
        If ($UnsetDelayedStartTime -eq $true -and $DelayedStartTime.Length -gt 0) {
            Write-Warning -Message "You cannot set the Delayed Start Time and unset it at the same time. Please choose one or the other."
            Exit
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWTaskTemplate]$TaskTemplate = $_
        }
        [string]$TaskTemplate_id = $TaskTemplate.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($TaskTemplate_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$TaskTemplate_exists = ($null -eq (Get-AutomateNOWTaskTemplate -Id $TaskTemplate_id))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWTaskTemplate failed to check if the Task Template [$TaskTemplate_id] already existed due to [$Message]."
                Break
            }
            If ($TaskTemplate_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not a Task Template named [$TaskTemplate_id] in the current domain [$current_domain]. Please check into this."
                Break
            }
            ## End warning ##
            [System.Collections.ArrayList]$include_properties = [System.Collections.ArrayList]@()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $TaskTemplate_id
            If ($ProcessingCommand.Keys.count -gt 0) {
                [string]$ProcessingCommand_json = $ProcessingCommand | ConvertTo-JSON -Compress
                $BodyMetaData.'processingCommand' = $ProcessingCommand_json
                $include_properties += 'processingCommand'
            }
            If ($Description.Length -gt 0) {
                $BodyMetaData.'description' = $Description
            }
            ElseIf ($UnsetDescription -eq $true) {
                $BodyMetaData.'description' = $null
                $include_properties += 'description'
            }
            If ($Folder.Length -gt 0) {
                $Error.Clear()
                Try {
                    [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the Folder [$Folder] actually existed while running under Set-AutomateNOWTaskTemplate due to [$Message]"
                    Break
                }
                If ($folder_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] running under Set-AutomateNOWTaskTemplate. Please check again."
                    Break
                }
                [string]$folder_display = $folder_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Adding Folder $folder_display to [ANOWTaskTemplate] [$TaskTemplate_id]"
                $BodyMetaData.'folder' = $Folder
                $include_properties += 'folder'
            }
            ElseIf ($UnsetFolder -eq $true) {
                [string]$folder_display = $folder_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Removing [ANOWTaskTemplate] [$TaskTemplate_id] from Folder $folder_display"
                $BodyMetaData.'folder' = $null
                $include_properties += 'folder'
            }
            If ($Tags.Count -gt 0) {
                [int32]$total_tags = $Tags.Count
                [int32]$current_tag = 1
                ForEach ($tag_id in $Tags) {
                    $Error.Clear()
                    Try {
                        [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] running under Set-AutomateNOWTaskTemplate due to [$message]"
                        Break
                    }
                    If ($tag_object.simpleId.length -eq 0) {
                        Throw "Set-AutomateNOWTaskTemplate has detected that the tag [$tag_id] does not appear to exist. Please check again."
                        Break
                    }
                    ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                        [string]$tag_object_simpleId = $tag_object.simpleId
                        Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                        Break
                    }
                    [string]$tag_display = $tag_object | ConvertTo-Json -Compress
                    Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
                    [string]$tag_name_sequence = ('tags' + $current_tag)
                    $BodyMetaData.Add($tag_name_sequence, $tag_id)
                    $include_properties += $tag_name_sequence
                    $current_tag++
                }
            }
            ElseIf ($UnsetTags -eq $true) {
                [string]$tags_display = ($Calendar.tags) | ConvertTo-Json -Compress
                Write-Verbose -Message "Removing tags [$tags_display] from [$TaskTemplate_id]"
                $BodyMetaData.'tags' = $null
                $include_properties += 'tags'
            }
            If ($CodeRepository.Id.Length -gt 0) {
                [string]$CodeRepository_Id = $CodeRepository.Id
                $BodyMetaData.'codeRepository' = $CodeRepository_Id
            }
            ElseIf ($UnsetCodeRepository -eq $true) {
                $BodyMetaData.'codeRepository' = $null
            }
            If ($Title.Length -gt 0) {
                $BodyMetaData.'title' = $Title
            }
            ElseIf ( $UnsetTitle -eq $true) {
                $BodyMetaData.'title' = $null
            }
            If ($ServerNode.simpleId.Length -gt 0) {
                [string]$ServerNode_id = $ServerNode.simpleId
                $Error.Clear()
                Try {
                    [ANOWServerNode]$ServerNode_object = Get-AutomateNOWServerNode -Id $ServerNode_id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWServerNode failed to confirm that the Server Node [$ServerNode_id] actually existed while running under Set-AutomateNOWTaskTemplate due to [$Message]"
                    Break
                }
                If ($ServerNode_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWServerNode failed to locate the Server Node [$ServerNode_id] running under Set-AutomateNOWTaskTemplate. Please check again."
                    Break
                }
                [ANOWProcessingTemplate_taskType]$TaskType = $TaskTemplate.taskType
                [ANOWProcessingTemplate_serverNodeType]$ServerNodeType = $ServerNode.serverNodeType
                [string[]]$ValidServerNodeTypes = Resolve-AutomateNOWTaskType2ServerNodeType -TaskType $TaskType
                [int32]$ValidServerNodeTypesCount = $ValidServerNodeTypes.Count
                If ($ValidServerNodeTypesCount -eq 0) {
                    Write-Warning -Message "Somehow the TaskType2ServerNodeType lookup table has failed"
                    Break
                }
                Else {
                    If ($ServerNodeType -notin $ValidServerNodeTypes) {
                        [string]$ValidServerNodeTypesDisplay = $ValidServerNodeTypes -join ', '
                        Write-Warning -Message "[$ServerNodeType] is not a valid server node type for a [$TaskType] task (which $TaskTemplate_id is). Please use one of these instead: $ValidServerNodeTypesDisplay"
                        Break
                    }
                }
                [string]$ServerNode_display = $ServerNode_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Adding Server Node $ServerNode_display to [ANOWTaskTemplate] [$TaskTemplate_id]"
                $BodyMetaData.'node' = ($ServerNode.id)
                $include_properties += 'node'
            }
            ElseIf ($UnsetServerNode -eq $true) {
                [string]$ServerNode_display = $ServerNode_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Removing [ANOWTaskTemplate] [$TaskTemplate_id] from Server Node $ServerNode_display"
                $BodyMetaData.'node' = $null
                $include_properties += 'node'
            }
            If ($Endpoint.simpleId.Length -gt 0) {
                [string]$Endpoint_id = $Endpoint.simpleId
                $Error.Clear()
                Try {
                    [ANOWEndpoint]$endpoint_object = Get-AutomateNOWEndpoint -Id $Endpoint_id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWEndpoint failed to confirm that the Endpoint [$Endpoint_id] actually existed while running under Set-AutomateNOWTaskTemplate due to [$Message]"
                    Break
                }
                If ($endpoint_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWendpoint failed to locate the Endpoint [$Endpoint_id] running under Set-AutomateNOWTaskTemplate. Please check again."
                    Break
                }
                [string]$endpoint_display = $endpoint_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Adding Endpoint $endpoint_display to [ANOWTaskTemplate] [$TaskTemplate_id]"
                $BodyMetaData.'endpoint' = ($Endpoint.id)
                $BodyMetaData.'endpointType' = ($Endpoint.endpointType)
                $include_properties += 'endpoint'
            }
            ElseIf ($UnsetEndpoint -eq $true) {
                $BodyMetaData.'endpoint' = $null
                $BodyMetaData.'endpointType' = $null
                $include_properties += 'endpoint'
            }
            If ($ResultMapping.simpleId.Length -gt 0) {
                [string]$ResultMapping_id = $ResultMapping.simpleId
                $Error.Clear()
                Try {
                    [ANOWResultMapping]$rm_object = Get-AutomateNOWResultMapping -Id $ResultMapping_id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWResultMapping failed to confirm that the Result Mapping [$ResultMapping_id] actually existed while running under Set-AutomateNOWTaskTemplate due to [$Message]"
                    Break
                }
                If ($rm_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWResultMapping failed to locate the Result Mapping [$ResultMapping_id] running under Set-AutomateNOWTaskTemplate. Please check again."
                    Break
                }
                [string]$rm_display = $rm_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Adding Result Mapping $rm_display to [ANOWTaskTemplate] [$TaskTemplate_id]"
                $BodyMetaData.'resultMapping' = $ResultMapping_id
                $include_properties += 'resultMapping'
            }
            ElseIf ($UnsetResultMapping -eq $true) {
                [string]$rm_display = $rm_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Removing [ANOWTaskTemplate] [$ResultMapping_id] from Result Mapping $rm_display"
                $BodyMetaData.'resultMapping' = $null
                $include_properties += 'resultMapping'
            }
            If ($Calendar.Id.Length -gt 0) {
                [string]$Calendar_id = $Calendar.simpleId
                $Error.Clear()
                Try {
                    [ANOWCalendar]$Calendar_object = Get-AutomateNOWCalendar -Id $Calendar_id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWCalendar failed to confirm that the Calendar object [$Calendar_id] actually existed while running under Set-AutomateNOWTaskTemplate due to [$Message]"
                    Break
                }
                If ($Calendar_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWCalendar failed to locate the Calendar object [$Calendar_id] running under Set-AutomateNOWTaskTemplate. Please check again."
                    Break
                }
                Write-Verbose -Message "Adding Calendar object [$Calendar_id] to [ANOWTaskTemplate] [$TaskTemplate_id]"
                $BodyMetaData.'calendar' = $Calendar_id
                $include_properties += 'calendar'
            }
            ElseIf ($UnsetCalendar -eq $true) {
                [string]$Calendar_id = $Calendar.simpleId
                Write-Verbose -Message "Removing [ANOWCalendar] [$Calendar_id] from [ANOWTaskTemplate] [$TaskTemplate_id]"
                $BodyMetaData.'calendar' = $null
                $include_properties += 'calendar'
            }
            If ($DelayedStartTime.Length -gt 0) {
                $BodyMetaData.Add('delayedStartTime', $DelayedStartTime)
            }
            ElseIf ( $UnsetDelayedStartTime -eq $true) {
                $BodyMetaData.Add('delayedStartTime', $null)
            }
            If ($TimeZone.id.Length -gt 0) {
                [string]$timezone_id = ($TimeZone.id)
                $BodyMetaData.Add('timeZone', $timezone_id )
            }
            ElseIf ($UnsetTimeZone -eq $true) {
                $BodyMetaData.Add('timeZone', $null )
            }
            If ($Approval.Id.Length -gt 0) {
                [string]$Approval_id = $Approval.simpleId
                $Error.Clear()
                Try {
                    [ANOWApproval]$Approval_object = Get-AutomateNOWApproval -Id $Approval_id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWApproval failed to confirm that the Approval object [$Approval_id] actually existed while running under Set-AutomateNOWTaskTemplate due to [$Message]"
                    Break
                }
                If ($Approval_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWApproval failed to locate the Approval object [$Approval_id] running under Set-AutomateNOWTaskTemplate. Please check again."
                    Break
                }
                Write-Verbose -Message "Adding Approval object [$Approval_id] to [ANOWTaskTemplate] [$WorkflowTemplate_id]"
                $BodyMetaData.'approvalConfiguration' = $Approval_id
                $include_properties += 'approvalConfiguration'
            }
            ElseIf ($UnsetApproval -eq $true) {
                [string]$Approval_id = $Approval.simpleId
                Write-Verbose -Message "Removing [ANOWApproval] [$Approval_id] from [ANOWTaskTemplate] [$WorkflowTemplate_id]"
                $BodyMetaData.'approvalConfiguration' = $null
                $include_properties += 'approvalConfiguration'
            }
            If ($Priority -gt 0) {
                $BodyMetaData.'priority' = $Priority
            }
            If ($Weight -gt 0) {
                $BodyMetaData.'weight' = $Weight
            }
            If ($Null -ne $OnHold) {
                If ($OnHold -eq $false) {
                    $BodyMetaData.'onHold' = 'false'
                }
                Else {
                    $BodyMetaData.'onHold' = 'true'
                }
            }
            If ($Null -ne $Skip) {
                If ($Skip -eq $false) {
                    $BodyMetaData.'passBy' = 'false'
                }
                Else {
                    $BodyMetaData.'passBy' = 'true'
                }
            }
            If ($VerboseMode -eq $true) {
                $BodyMetaData.'verboseMode' = 'true'
            }
            ElseIf ($VerboseMode -eq $false) {
                $BodyMetaData.'verboseMode' = 'false'
            }
            If ($Null -ne $AutoArchive) {
                If ($AutoArchive -eq $false) {
                    $BodyMetaData.'autoArchive' = 'false'
                }
                Else {
                    $BodyMetaData.'autoArchive' = 'true'
                }
            }
            If ($Null -ne $KeepResources) {
                If ($KeepResources -eq $false) {
                    $BodyMetaData.'keepResourcesOnFailure' = 'false'
                }
                Else {
                    $BodyMetaData.'keepResourcesOnFailure' = 'true'
                }
            }
            If ($Null -ne $UseScripts) {
                If ($UseScripts -eq $false) {
                    $BodyMetaData.'useScripts' = 'false'
                }
                Else {
                    $BodyMetaData.'useScripts' = 'true'
                }
            }
            If ($Null -ne $EagerScriptExecution) {
                If ($EagerScriptExecution -eq $false) {
                    $BodyMetaData.'eagerScriptExecution' = 'false'
                }
                Else {
                    $BodyMetaData.'eagerScriptExecution' = 'true'
                }
            }
            If ($Owner.Length -gt 0) {
                $BodyMetaData.'owner' = $Owner
            }
            If ($statisticalDuration -ge 1000) {
                $BodyMetaData.'statisticalDuration' = $statisticalDuration
            }
            $BodyMetaData.'_operationType' = 'update'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_oldValues' = $TaskTemplate.CreateOldValues()
            If ($componentId.Length -gt 0) {
                $BodyMetaData.'_componentId' = $componentId
            }
            If ($operationId.Length -gt 0) {
                $BodyMetaData.'_operationId' = $operationId
            }
            $BodyMetaData.'_dataSource' = 'ProcessingTemplateDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties $include_properties
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$TaskTemplate_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Task Template $TaskTemplate_id was successfully updated"
            $Error.Clear()
            Try {
                [ANOWTaskTemplate]$UpdatedTaskTemplate = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the response into an [ANOWTaskTemplate] object (under Set-AutomateNOWTaskTemplate) due to [$Message]."
                Break
            }
            If ($Quiet -ne $true) {
                Return $UpdatedTaskTemplate
            }
        }
    }
    End {
    }
}

Function Export-AutomateNOWTaskTemplate {
    <#
    .SYNOPSIS
    Exports the Tasks from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Tasks from an instance of AutomateNOW! to a local .csv file

    .PARAMETER TaskTemplate
    Mandatory [ANOWTaskTemplate] object (Use Get-AutomateNOWTask to retrieve them)

    .INPUTS
    ONLY [ANOWTaskTemplate] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWTaskTemplate] objects are exported to the local disk in CSV format

    .EXAMPLE
    Get-AutomateNOWTaskTemplate | Export-AutomateNOWTaskTemplate

    .EXAMPLE
    Get-AutomateNOWTaskTemplate -Id 'TaskTemplate01' | Export-AutomateNOWTaskTemplate

    .EXAMPLE
    @( 'TaskTemplate01', 'TaskTemplate02' ) | Get-AutomateNOWTaskTemplate | Export-AutomateNOWTaskTemplate

    .EXAMPLE
    Get-AutomateNOWTaskTemplate | Where-Object { $_.taskType -eq 'PYTHON' } | Export-AutomateNOWTaskTemplate

    .NOTES
	You must present [ANOWTaskTemplate] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWTaskTemplate]$TaskTemplate
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-TaskTemplates-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWTaskTemplate]$TaskTemplate = $_
        }
        $Error.Clear()
        Try {
            $TaskTemplate | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWTaskTemplate] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function New-AutomateNOWTaskTemplate {
    <#
    .SYNOPSIS
    Creates a Task Template within an AutomateNOW! instance

    .DESCRIPTION
    Creates a Task Template within an AutomateNOW! instance and returns back the newly created [ANOWTaskTemplate] object

    .PARAMETER TaskType
    Type of the Task Template. Valid options are: AE_SHELL_SCRIPT, AMQP_SEND, ANSIBLE_PLAYBOOK, ANSIBLE_PLAYBOOK_PATH, APACHE_AIRFLOW_RUN_DAG, ARANGO_DB_INSERT, AS400_BATCH_JOB, AS400_COMMAND_CALL, AS400_PROGRAM_CALL, AUTOMATE_NOW_RUN_JOB, AUTOMATE_NOW_TRIGGER_EVENT, AUTOMATION_ANYWHERE, AUTOMATION_ANYWHERE_DEPLOY_ROBOT, AUTOMATION_ANYWHERE_START_ROBOT, AUTOMATION_ANYWHERE_STOP_ROBOT, AUTOMATION_ANYWHERE_UNDEPLOY_ROBOT, AUTOMIC_WLA_RUN_JOB, AWS_BATCH_JOB, AWS_EC2_DELETE_VOLUME, AWS_EC2_START_INSTANCE, AWS_EC2_STOP_INSTANCE, AWS_EC2_TERMINATE_INSTANCE, AWS_EMR_ADD_STEPS, AWS_EMR_API_COMMAND, AWS_EMR_CANCEL_STEPS, AWS_EMR_GET, AWS_EMR_PUT, AWS_EMR_START_NOTEBOOK_EXECUTION, AWS_EMR_STOP_NOTEBOOK_EXECUTION, AWS_EMR_TERMINATE_JOB_FLOW, AWS_EMR_WORKFLOW, AWS_GLUE_CRAWLER, AWS_GLUE_JOB, AWS_GLUE_TRIGGER, AWS_GLUE_WORKFLOW, AWS_LAMBDA_CREATE_FUNCTION, AWS_LAMBDA_DELETE_FUNCTION, AWS_LAMBDA_INVOKE, AWS_S3_COPY_OBJECT, AWS_S3_DELETE_OBJECT, AWS_S3_MOVE_OBJECT, AWS_S3_RENAME_OBJECT, AWS_SAGE_MAKER_ADD_MODEL, AWS_SAGE_MAKER_API_COMMAND, AWS_SAGE_MAKER_DELETE_MODEL, AWS_SAGE_MAKER_PROCESSING, AWS_SAGE_MAKER_TRAINING, AWS_SAGE_MAKER_TRANSFORM, AWS_SAGE_MAKER_TUNING, AWS_START_STEP_FUNCTION_STATE_MACHINE, AZURE_BATCH_JOB, AZURE_DATA_FACTORY_PIPELINE, AZURE_DATA_FACTORY_TRIGGER, AZURE_DATA_LAKE_JOB, AZURE_DATABRICKS_DELETE_CLUSTER, AZURE_DATABRICKS_JOB, AZURE_DATABRICKS_LIST_CLUSTERS, AZURE_DATABRICKS_START_CLUSTER, AZURE_DATABRICKS_TERMINATE_CLUSTER, AZURE_RUN_LOGIC_APP, BLUE_PRISM, BLUE_PRISM_DEPLOY_ROBOT, BLUE_PRISM_START_ROBOT, BLUE_PRISM_STOP_ROBOT, BLUE_PRISM_UNDEPLOY_ROBOT, BMC_REMEDY_INCIDENT, C, CA_SERVICE_MANAGEMENT_INCIDENT, CA_WLA_RUN_JOB, CASSANDRA_CQL_SCRIPT, CHECK_BARRIER_AVAILABLE_PERMITS, CHECK_BARRIER_TOTAL_PERMITS, CHECK_CALENDAR, CHECK_LOCK_STATE, CHECK_METRIC, CHECK_PHYSICAL_RESOURCE, CHECK_QUEUE, CHECK_SEMAPHORE_STATE, CHECK_STOCK_AVAILABLE_PERMITS, CHECK_STOCK_TOTAL_PERMITS, CHECK_TIME_WINDOW_STATE, CHECK_VARIABLE_VALUE, CLEAR_QUEUE, CONTROL_M_RUN_JOB, COUCH_BASE_INSERT, COUCH_DB_INSERT, CPP, CTRLM_ADD_CONDITION, CTRLM_CREATE_JOB, CTRLM_DELETE_CONDITION, CTRLM_ORDER_JOB, CTRLM_RESOURCE_TABLE_ADD, CTRLM_RESOURCE_TABLE_DELETE, CTRLM_RESOURCE_TABLE_UPDATE, DATASOURCE_DELETE_FILE, DATASOURCE_DOWNLOAD_FILE, DATASOURCE_UPLOAD_FILE, DBT_JOB, DYNAMO_DB_INSERT, EMAIL_CONFIRMATION, EMAIL_INPUT, EMAIL_SEND, FACEBOOK_POST, FILE_CHECK, FILE_TRANSFER, FILE_WATCHER, FLINK_JAR_DELETE, FLINK_JAR_UPLOAD, FLINK_RUN_JOB, GO, GOOGLE_DATA_FLOW_JOB, GROOVY, HDFS_APPEND_FILE, HDFS_CREATE_DIRECTORY, HDFS_DELETE_DIRECTORY, HDFS_DELETE_FILE, HDFS_DOWNLOAD_FILE, HDFS_RENAME, HDFS_UPLOAD_FILE, HP_OPEN_VIEW_SERVICE_MANAGER_INCIDENT, HTTP_REQUEST, IBM_CONTROL_DESK_INCIDENT, IBM_DATASTAGE, IBM_MQ_SEND, IBM_WLA_RUN_JOB, INFORMATICA_ASSIGNMENT, INFORMATICA_CLOUD_TASKFLOW, INFORMATICA_COMMAND, INFORMATICA_CONTROL, INFORMATICA_EMAIL, INFORMATICA_EVENT_RAISE, INFORMATICA_EVENT_WAIT, INFORMATICA_SESSION, INFORMATICA_START, INFORMATICA_TIMER, INFORMATICA_WORKFLOW, INFORMATICA_WS_WORKFLOW, INSTAGRAM_POST, JAVA, JAVASCRIPT, JIRA_ADD_ISSUE, JMS_SEND, KAFKA_SEND, KOTLIN, LINKED_IN_POST, MICROSOFT_POWER_BI_DATAFLOW_REFRESH, MICROSOFT_POWER_BI_DATASET_REFRESH, MONGO_DB_INSERT, MQTT_SEND, MS_SSIS, NEO4J_INSERT, ODI_LOAD_PLAN, ODI_SESSION, OPENTEXT_DYNAMIC_JCL, OPENTEXT_STORED_JCL, ORACLE_EBS_EXECUTE_PROGRAM, ORACLE_EBS_EXECUTE_REQUEST_SET, ORACLE_EBS_PROGRAM, ORACLE_EBS_REQUEST_SET, ORACLE_SERVICE_CENTER_CASE, PEGA_DEPLOY_ROBOT, PEGA_START_ROBOT, PEGA_STOP_ROBOT, PEGA_UNDEPLOY_ROBOT, PEOPLESOFT_APPLICATION_ENGINE_TASK, PEOPLESOFT_COBOL_SQL_TASK, PEOPLESOFT_CRW_ONLINE_TASK, PEOPLESOFT_CRYSTAL_REPORTS_TASK, PEOPLESOFT_CUBE_BUILDER_TASK, PEOPLESOFT_JOB_TASK, PEOPLESOFT_NVISION_TASK, PEOPLESOFT_SQR_PROCESS_TASK, PEOPLESOFT_SQR_REPORT_TASK, PEOPLESOFT_WINWORD_TASK, PERL, POP_FROM_QUEUE, POWERSHELL, PROCESSING_OBSERVER, PUSH_TO_QUEUE, PYTHON, RABBIT_MQ_SEND, RAINCODE_DYNAMIC_JCL, RAINCODE_STORED_JCL, RDBMS_SQL, RDBMS_SQL_STATEMENT, RDBMS_STORED_PROCEDURE, REDDIT_POST, REDIS_CLI, REDIS_DELETE, REDIS_GET, REDIS_SET, REST_WEB_SERVICE_CALL, RETRY, ROBOT_FRAMEWORK_DEPLOY_ROBOT, ROBOT_FRAMEWORK_START_ROBOT, ROBOT_FRAMEWORK_STOP_ROBOT, ROBOT_FRAMEWORK_UNDEPLOY_ROBOT, RUBY, RUST, SAP_4H_ARCHIVE, SAP_4H_BW_PROCESS_CHAIN, SAP_4H_CM_PROFILE_ACTIVATE, SAP_4H_CM_PROFILE_DEACTIVATE, SAP_4H_COPY_EXISTING_JOB, SAP_4H_EXPORT_CALENDAR, SAP_4H_EXPORT_JOB, SAP_4H_FUNCTION_MODULE_CALL, SAP_4H_GET_APPLICATION_LOG, SAP_4H_JOB, SAP_4H_JOB_INTERCEPTOR, SAP_4H_MODIFY_INTERCEPTION_CRITERIA, SAP_4H_MONITOR_EXISTING_JOB, SAP_4H_RAISE_EVENT, SAP_4H_READ_TABLE, SAP_4H_RELEASE_EXISTING_JOB, SAP_4H_START_SCHEDULED_JOB, SAP_4H_SWITCH_OPERATION_MODE, SAP_4H_VARIANT_COPY, SAP_4H_VARIANT_CREATE, SAP_4H_VARIANT_DELETE, SAP_4H_VARIANT_UPDATE, SAP_ARCHIVE, SAP_BW_PROCESS_CHAIN, SAP_CM_PROFILE_ACTIVATE, SAP_CM_PROFILE_DEACTIVATE, SAP_EXPORT_CALENDAR, SAP_EXPORT_JOB, SAP_FUNCTION_MODULE_CALL, SAP_GET_APPLICATION_LOG, SAP_IBP_CREATE_PROCESS, SAP_IBP_DELETE_PROCESS, SAP_IBP_JOB, SAP_IBP_SET_PROCESS_STEP_STATUS, SAP_MODIFY_INTERCEPTION_CRITERIA, SAP_ODATA_API_CALL, SAP_R3_COPY_EXISTING_JOB, SAP_R3_JOB, SAP_R3_JOB_INTERCEPTOR, SAP_R3_MONITOR_EXISTING_JOB, SAP_R3_RAISE_EVENT, SAP_R3_RELEASE_EXISTING_JOB, SAP_R3_START_SCHEDULED_JOB, SAP_R3_VARIANT_COPY, SAP_R3_VARIANT_CREATE, SAP_R3_VARIANT_DELETE, SAP_R3_VARIANT_UPDATE, SAP_READ_TABLE, SAP_SOLUTION_MANAGER_TICKET, SAP_SWITCH_OPERATION_MODE, SAS_4GL, SAS_DI, SAS_JOB, SAS_VIYA_JOB, SCALA, SERVER_NODE_SET_CONNECTION, SERVER_NODE_SET_PARAMETERS, SERVICE_NOW_CLOSE_INCIDENT, SERVICE_NOW_CREATE_INCIDENT, SERVICE_NOW_INCIDENT_STATUS_SENSOR, SERVICE_NOW_RESOLVE_INCIDENT, SERVICE_NOW_UPDATE_INCIDENT, SET_BARRIER_TOTAL_PERMITS, SET_METRIC, SET_PHYSICAL_RESOURCE, SET_PROCESSING_STATUS, SET_RESOURCES, SET_SEMAPHORE_STATE, SET_SEMAPHORE_TIMESTAMP_STATE, SET_SERVER_NODE, SET_STOCK_TOTAL_PERMITS, SET_TIME_WINDOW_STATE, SET_VARIABLE_TIMESTAMP_VALUE, SET_VARIABLE_VALUE, SH, SOAP_WEB_SERVICE_CALL, SPARK_JAVA, SPARK_PYTHON, SPARK_R, SPARK_RUN_JOB, SPARK_SCALA, SPARK_SQL, STOMP_SEND, STONEBRANCH_RUN_JOB, SWIFT, TALEND_JOB, TCL, TELEGRAM_MESSAGE, TERMA_RUN_JOB, TIDAL_RUN_JOB, TIKTOK_POST, TITAN_INSERT, TRIGGER_EVENT, TRIGGER_ITEM, TUMBLR_POST, TWITTER_POST, TYPESCRIPT, UI_PATH, UI_PATH_DEPLOY_ROBOT, UI_PATH_START_ROBOT, UI_PATH_STOP_ROBOT, UI_PATH_UNDEPLOY_ROBOT, VBSCRIPT, WHATSAPP_MESSAGE, WORK_FUSION_DEPLOY_ROBOT, WORK_FUSION_START_ROBOT, WORK_FUSION_STOP_ROBOT, WORK_FUSION_UNDEPLOY_ROBOT, XFTP_COMMAND, XMPP_SEND, YOUTUBE_POST, Z_OS_COMMAND, Z_OS_DYNAMIC_JCL, Z_OS_STORED_JCL

    .PARAMETER MonitorType
    Type of the Monitor Template. Valid options are: SYSTEM_MONITOR, SYSTEM_PROCESS_MONITOR, PROCESSING_MONITOR, PROCESSING_DEADLINE_MONITOR, PROCESSING_BASELINE_DEVIATION_MONITOR, SERVER_NODE_MONITOR, PING_MONITOR, HTTP_MONITOR, SH_MONITOR, PYTHON_MONITOR, PERL_MONITOR, POWERSHELL_MONITOR, TCL_MONITOR, RUBY_MONITOR, GROOVY_MONITOR, SAP_R3_JOB_MONITOR, SAP_IBP_JOB_MONITOR, SAP_IBP_PROCESS_MONITOR, SAP_IBP_PROCESS_FILTER_MONITOR, SAP_R3_INTERCEPTED_JOB_MONITOR, SAP_4H_JOB_MONITOR, SAP_4H_IBP_JOB_MONITOR, SAP_4H_IBP_PROCESS_MONITOR, SAP_4H_IBP_PROCESS_FILTER_MONITOR, SAP_4H_INTERCEPTED_JOB_MONITOR, AWS_EMR_CONTAINER_MONITOR, AWS_EMR_JOB_FLOW_MONITOR, AWS_EMR_STEP_MONITOR, AWS_EMR_NOTEBOOK_MONITOR, AZURE_DATABRICKS_CLUSTER_MONITOR

    .PARAMETER SensorType
    Type of the Sensor Template. Valid options are: FILE_SENSOR, SQL_SENSOR, EMAIL_SENSOR, JMS_SENSOR, AMQP_SENSOR, RABBIT_MQ_SENSOR, KAFKA_SENSOR, JIRA_ISSUE_SENSOR, MQTT_SENSOR, IBM_MQ_SENSOR, HTTP_SENSOR, SNMP_SENSOR, Z_OS_JES_JOB_SENSOR, SAP_R3_INTERCEPTED_JOB_SENSOR, SAP_R3_EVENT_SENSOR, SAP_IBP_PROCESS_SENSOR, SAP_4H_EVENT_SENSOR, SAP_4H_INTERCEPTED_JOB_SENSOR, SAP_4H_IBP_PROCESS_SENSOR, SERVICE_NOW_INCIDENT_STATUS_SENSOR

    .PARAMETER InternalTaskType
    Type of the Internal Task Template. Valid options are: ABORT, ADD_TAG, ADHOC_REPORT_SEND, AE_SCRIPT, ARCHIVE, ARCHIVE_CLEANUP, ARCHIVE_INTERVAL, CHECK_PROCESSING_STATE, CHECK_RESOURCE, CHECK_TIME, DESIGN_BACKUP, DESIGN_IMPORT, FORCE_COMPLETED, FORCE_FAILED, FORCE_READY, HOLD, KILL, NOTIFY_CHANNEL, NOTIFY_EMAIL, NOTIFY_GROUP, PROCESSING_ACTION_SKIP_OFF, PROCESSING_ACTION_SKIP_ON, PROCESSING_BASELINE_DEVIATION_MONITOR, PROCESSING_CLEAR_STATE_REGISTRY, PROCESSING_REGISTER_STATE, PROCESSING_RUN_NOW, PROCESSING_TEMPLATE_HOLD, PROCESSING_TEMPLATE_RESUME, PROCESSING_TEMPLATE_SKIP_OFF, PROCESSING_TEMPLATE_SKIP_ON, PROCESSING_UNREGISTER_STATE, RECALCULATE_STATISTICS, REMOVE_TAG, RESOURCE_ADD_TAG, RESOURCE_REMOVE_TAG, RESOURCE_SET_FOLDER, RESTART, RESUME, SERVER_NODE_ABORT_ALL, SERVER_NODE_ADD_TAG, SERVER_NODE_HOLD, SERVER_NODE_KILL_ALL, SERVER_NODE_REMOVE_TAG, SERVER_NODE_RESUME, SERVER_NODE_SET_FOLDER, SERVER_NODE_SET_TOTAL_WEIGHT_CAPACITY, SERVER_NODE_SKIP_OFF, SERVER_NODE_SKIP_ON, SERVER_NODE_STOP, SET_CONTEXT_VARIABLE_VALUE, SET_CONTEXT_VARIABLE_VALUES, SET_FOLDER, SET_PRIORITY, SET_RESOURCE, SET_STATUS_CODE, SKIP_OFF, SKIP_ON, USER_CONFIRM, USER_INPUT, WAIT

    .PARAMETER Id
    Mandatory "name" of the Task Template. For example: 'LinuxTaskTemplate1'. This value may not contain the domain in brackets. This is the unique key of this object.

    .PARAMETER Description
    Optional description of the Task Template (may not exceed 255 characters).

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to include with this object.

    .PARAMETER Folder
    Optional string representing the Folder to place this object into.

    .PARAMETER DesignTemplate
    Optional string representing the Design Template to place this object into.

    .PARAMETER Workspace
    Optional string representing the Workspace to place this object into.

    .PARAMETER CodeRepository
    Optional string representing the Code Repository to place this object into.

    .PARAMETER ServerNodeType
    Name of the Server Node Type that drives the Task Template. Use a string here! You cannot combine this parameter with -InternalTask. Valid options are: AZURE, AWS, GOOGLE_CLOUD, GOOGLE_DATA_FLOW, AZURE_DATABRICKS, INFORMATICA_CLOUD, UNIX, LINUX, WINDOWS, SOLARIS, HPUX, AIX, OPENVMS, MACOS, AS400, Z_OS, RAINCODE, CTRL_M, OPENTEXT, INFORMATICA, INFORMATICA_WS, SAS, SAS_VIYA, IBM_DATASTAGE, ODI, MS_SSIS, AB_INITIO, SAP_BODI, SKYVIA, TALEND, DBT, SAP, SAP_S4_HANA, SAP_S4_HANA_CLOUD, SAP_IBP, JD_EDWARDS, ORACLE_EBS, PEOPLESOFT, MICROSOFT_DYNAMICS, HIVE_QL, GOOGLE_BIG_QUERY, AZURE_SQL_DATA_WAREHOUSE, AZURE_SQL_DATABASE, DASHDB, DB2, MYSQL, NETEZZA, ORACLE, POSTGRESQL, SQL_SERVER, TERADATA, SINGLESTORE, SNOWFLAKE, VERTICA, PRESTO_DB, SYBASE, INFORMIX, H2, FILE_MANAGER, SNMP, HTTP, EMAIL, SOAP_WEB_SERVICE, REST_WEB_SERVICE, INTERNAL, IBM_MQ, RABBIT_MQ, SQS, ACTIVE_MQ, QPID, IBM_SIBUS, HORNETQ, SOLACE, JORAM_MQ, QMQ, ZERO_MQ, KAFKA, PULSAR, AMAZON_KINESIS, GOOGLE_CLOUD_PUB_SUB, MICROSOFT_AZURE_EVENT_HUB, AMQP, XMPP, STOMP, HDFS, REDIS, HADOOP, HIVE, IMPALA, SQOOP, YARN, SPARK, FLUME, FLINK, STORM, OOZIE, AMBARI, ELASTIC_SEARCH, CASSANDRA, SAP_HANA, MONGO_DB, COUCH_DB, COUCH_BASE, DYNAMO_DB, ARANGO_DB, NEO4J, ORIENT_DB, TITAN, ANDROID, IOS, WINDOWS_MOBILE, MICROSOFT_POWER_BI, BLUE_PRISM, UI_PATH, AUTOMATION_ANYWHERE, WORK_FUSION, PEGA, ROBOT_FRAMEWORK, CONTROL_M, STONEBRANCH, CA_WLA, AUTOMIC_WLA, IBM_WLA, TIDAL, FACEBOOK, INSTAGRAM, TWITTER, YOUTUBE, LINKED_IN, TUMBLR, TIKTOK, REDDIT, TELEGRAM, WHATSAPP, JIRA, SERVICE_NOW, ORACLE_SERVICE_CENTER, BMC_REMEDY, CA_SERVICE_MANAGEMENT, IBM_CONTROL_DESK, HP_OPEN_VIEW_SERVICE_MANAGER, SAP_SOLUTION_MANAGER, AUTOMATE_NOW, APACHE_AIRFLOW, ANSIBLE

    .PARAMETER InternalTask
    Switch to indicate the task is internal. You cannot combine this parameter with -ServerNodeType.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWTaskTemplate.

    .OUTPUTS
    An [ANOWTaskTemplate] object representing the newly created Task Template. Use the -Quiet parameter to suppress this.

    .EXAMPLE
    Quietly creates a new Shell Task Template with optional description, tags, folder, workspace and code repository set.

    New-AutomateNOWTaskTemplate -TaskType SH -ServerNodeType 'LINUX' -Id 'sh_task_template_01'   -Description 'Description text' -Tags 'Tag1', 'Tag2' -Folder 'Folder1' -Workspace 'Workspace1' -CodeRepository 'Repository1' -Quiet

    .EXAMPLE
    Quietly creates a new (internal) Wait Task Template with optional description, tags, folder, workspace and code repository set.

    New-AutomateNOWTaskTemplate -InternalTaskType 'WAIT' -Id 'wait_task_template_02' -Description 'Description text' -Tags 'Tag1', 'Tag2' -Folder 'Folder1' -Workspace 'Workspace1' -CodeRepository 'Repository1' -Quiet

    .EXAMPLE
    Quietly creates a new (monitor) PowerShell Monitor Task Template with optional description, tags, folder, workspace and code repository set.

    New-AutomateNOWTaskTemplate -MonitorType POWERSHELL_MONITOR -ServerNodeType 'WINDOWS' -Id 'powershell_monitor_03' -Description 'Description text' -Tags 'Tag1', 'Tag2' -Folder 'Folder1' -Workspace 'Workspace1' -CodeRepository 'Repository1' -Quiet

    .EXAMPLE
    Quietly creates a new (sensor) Email Sensor Task Template with optional description, tags, folder, workspace and code repository set.

    New-AutomateNOWTaskTemplate -SensorType 'EMAIL_SENSOR' -ServerNodeType 'EMAIL' -Id 'email_sensor_04' -Description 'Description text' -Tags 'Tag1', 'Tag2' -Folder 'Folder1' -Workspace 'Workspace1' -CodeRepository 'Repository1' -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The name (id) of the Task Template must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    You must specify one of the following parameters: -TaskType, -MonitorType, -SensorType or -InternalTaskType

    #>
    [OutputType([ANOWTaskTemplate])]
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'NodeTask')]
        [ANOWProcessingTemplateCustom_Tasks]$TaskType,
        [Parameter(Mandatory = $true, ParameterSetName = 'MonitorTask')]
        [ANOWProcessingTemplate_monitorType]$MonitorType,
        [Parameter(Mandatory = $true, ParameterSetName = 'SensorTask')]
        [ANOWProcessingTemplate_sensorType]$SensorType,
        [Parameter(Mandatory = $true, ParameterSetName = 'InternalTask')]
        [ANOWProcessingTemplateCustom_InternalTasks]$InternalTaskType,
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $true)]
        [string]$Id,
        [ValidateScript({ $_.Length -le 255 })]
        [Parameter(Mandatory = $false, HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [string]$DesignTemplate,
        [Parameter(Mandatory = $false)]
        [string]$Workspace,
        [Parameter(Mandatory = $false)]
        [string]$CodeRepository,
        [Parameter(Mandatory = $true, ParameterSetName = 'NodeTask')]
        [Parameter(Mandatory = $true, ParameterSetName = 'MonitorTask')]
        [Parameter(Mandatory = $true, ParameterSetName = 'SensorTask')]
        [ANOWProcessingTemplate_serverNodeType]$ServerNodeType,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [boolean]$TaskTemplate_exists = ($null -ne (Get-AutomateNOWTaskTemplate -Id $Id))
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWTaskTemplate failed to check if the Task Template [$Id] already existed due to [$Message]."
        Break
    }
    If ($TaskTemplate_exists -eq $true) {
        [string]$current_domain = $anow_session.header.domain
        Write-Warning -Message "There is already a Task Template named [$Id] in [$current_domain]. Please check into this."
        Break
    }
    ## End warning ##
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    $BodyMetaData.Add('id', $Id)
    If ($MonitorType.Length -gt 0) {
        [string[]]$ValidServerNodeTypes = Resolve-AutomateNOWMonitorType2ServerNodeType -MonitorType $MonitorType
        [string]$TaskType = $MonitorType
        [string]$processingType = 'SERVICE'
        [string]$old_values = ('{"processingType":"' + $processingType + '","monitorType":"' + $MonitorType + '","serverNodeType":"' + $ServerNodeType + '"}')
        $BodyMetaData.Add('serviceType', 'MONITOR')
        $BodyMetaData.Add('monitorType', $MonitorType)
    }
    ElseIf ($SensorType.Length -gt 0) {
        [string[]]$ValidServerNodeTypes = Resolve-AutomateNOWSensorType2ServerNodeType -SensorType $SensorType
        [string]$TaskType = $SensorType
        [string]$processingType = 'SERVICE'
        [string]$old_values = ('{"processingType":"' + $processingType + '","sensorType":"' + $SensorType + '","serverNodeType":"' + $ServerNodeType + '"}')
        $BodyMetaData.Add('serviceType', 'SENSOR')
        $BodyMetaData.Add('sensorType', $SensorType)
    }
    Else {
        [string]$processingType = 'TASK'
        [string]$old_values = ('{"processingType":"' + $processingType + '","taskType":"' + $TaskType + '","serverNodeType":"' + $ServerNodeType + '"}')
        If ($InternalTaskType.Length -gt 0) {
            [string]$TaskType = $InternalTaskType
            [string]$ServerNodeType = 'INTERNAL'
            [string[]]$ValidServerNodeTypes = @($ServerNodeType)
        }
        Else {
            [string]$TaskType = $TaskType
            [string[]]$ValidServerNodeTypes = Resolve-AutomateNOWTaskType2ServerNodeType -TaskType $TaskType
        }
        $BodyMetaData.Add('taskType', $TaskType)
    }
    [int32]$ValidServerNodeTypesCount = $ValidServerNodeTypes.Count
    If ($ValidServerNodeTypesCount -eq 0) {
        Write-Warning -Message "Somehow the ServerNodeType lookup failed!"
        Break
    }
    Else {
        If ($ServerNodeType -notin $ValidServerNodeTypes -and $InternalTaskType.Length -eq 0) {
            [string]$ValidServerNodeTypesDisplay = $ValidServerNodeTypes -join ', '
            Write-Warning -Message "[$ServerNodeType] is not a valid server node type for a [$TaskType] task. Please use one of these instead: $ValidServerNodeTypesDisplay"
            Break
        }
    }
    $BodyMetaData.Add('processingType', $processingType)
    $BodyMetaData.Add('serverNodeType', $ServerNodeType)
    [string[]]$include_properties = 'id', 'processingType', 'serverNodeType'
    If ($Description.Length -gt 0) {
        $BodyMetaData.Add('description', $Description)
        $include_properties += 'description'
    }
    If ($Tags.Count -gt 0) {
        [int32]$total_tags = $Tags.Count
        [int32]$current_tag = 1
        ForEach ($tag_id in $Tags) {
            $Error.Clear()
            Try {
                [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] running under New-AutomateNOWTaskTemplate due to [$message]"
                Break
            }
            If ($tag_object.simpleId.length -eq 0) {
                Throw "New-AutomateNOWTaskTemplate has detected that the tag [$tag_id] does not appear to exist. Please check again."
                Break
            }
            ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                [string]$tag_object_simpleId = $tag_object.simpleId
                Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                Break
            }
            [string]$tag_display = $tag_object | ConvertTo-Json -Compress
            Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
            [string]$tag_name_sequence = ('tags' + $current_tag)
            $BodyMetaData.Add($tag_name_sequence, $tag_id)
            $include_properties += $tag_name_sequence
            $current_tag++
        }
    }
    If ($Folder.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] actually existed while running under New-AutomateNOWTaskTemplate due to [$Message]"
            Break
        }
        If ($folder_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] running under New-AutomateNOWTaskTemplate. Please check again."
            Break
        }
        [string]$folder_display = $folder_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding folder $folder_display to [ANOWTaskTemplate] [$Id]"
        $BodyMetaData.Add('folder', $Folder)
        $include_properties += 'folder'
    }
    If ($DesignTemplate.Length -gt 0) {
        $BodyMetaData.Add('designTemplate', $DesignTemplate)
        $include_properties += 'designTemplate'
    }
    If ($Workspace.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWWorkspace]$workspace_object = Get-AutomateNOWWorkspace -Id $Workspace
        }
        Catch {
            [string]$Message = $_.Exception.Message
            [string]$Workspace_id = $Workspace.Id
            Write-Warning -Message "Get-AutomateNOWWorkspace failed to confirm that the workspace [$Workspace_id] actually existed while running under New-AutomateNOWTaskTemplate due to [$Message]"
            Break
        }
        If ($workspace_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWWorkspace failed to locate the Workspace [$Workspace] running under New-AutomateNOWTaskTemplate. Please check again."
            Break
        }
        [string]$workspace_display = $workspace_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding workspace $workspace_display to [ANOWTaskTemplate] [$Id]"
        $BodyMetaData.Add('workspace', $Workspace)
        $include_properties += 'workspace'
    }
    If ($CodeRepository.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository] actually existed while running under New-AutomateNOWTaskTemplate due to [$Message]"
            Break
        }
        If ($code_repository_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository] running under New-AutomateNOWTaskTemplate. Please check again."
            Break
        }
        [string]$code_repository_display = $code_repository_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding code repository $code_repository_display to [ANOWTaskTemplate] [$Id]"
        $BodyMetaData.Add('codeRepository', $CodeRepository)
        $include_properties += 'codeRepository'
    }
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_operationType' = 'add'
    $BodyMetaData.'_oldValues' = $old_values
    $BodyMetaData.'_componentId' = 'ProcessingTemplateCreateWindow_form'
    $BodyMetaData.'_dataSource' = 'ProcessingTemplateDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties $include_properties
    [hashtable]$parameters = @{}
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    [string]$command = '/processingTemplate/create'
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('Body', $Body)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWTaskTemplate]$TaskTemplate = $results.response.data | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to create [ANOWTaskTemplate] object due to [$Message]."
        Break
    }
    If ($TaskTemplate.id.Length -eq 0) {
        Write-Warning -Message "Somehow the newly created [ANOWTaskTemplate] is empty!"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWTaskTemplate]$TaskTemplate = Get-AutomateNOWTaskTemplate -Id $Id
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWTaskTemplate failed to confirm that the [ANOWTaskTemplate] object [$Id] was created due to [$Message]."
        Break
    }
    If ($Quiet -ne $true) {
        Return $TaskTemplate
    }
}

Function Remove-AutomateNOWTaskTemplate {
    <#
    .SYNOPSIS
    Removes a Task Template from an AutomateNOW! instance

    .DESCRIPTION
    Removes a Task Template from an AutomateNOW! instance

    .PARAMETER TaskTemplate
    An [ANOWTaskTemplate] object representing the Task Template to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWTaskTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Get-AutomateNOWTaskTemplate -Id 'TaskTemplate01' | Remove-AutomateNOWTaskTemplate

    .EXAMPLE
    Get-AutomateNOWTaskTemplate -Id 'TaskTemplate01', 'TaskTemplate02' | Remove-AutomateNOWTaskTemplate

    .EXAMPLE
    @( 'Task1', 'Task2', 'Task3') | Remove-AutomateNOWTaskTemplate

    .EXAMPLE
    Get-AutomateNOWTaskTemplate | ? { $_.serverTaskType -eq 'LINUX' } | Remove-AutomateNOWTaskTemplate

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWTaskTemplate]$TaskTemplate,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processingTemplate/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWTaskTemplate]$TaskTemplate = $_
        }
        [string]$TaskTemplate_id = $TaskTemplate.id
        If ($TaskTemplate_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($TaskTemplate_id)")) -eq $true) {
            [string]$oldvalues = $TaskTemplate.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $TaskTemplate_id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'ProcessingTemplateList'
            $BodyMetaData.'_dataSource' = 'ProcessingTemplateDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$TaskTemplate_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            [string]$error_message = $results.response.data
            If ($error_message -match 'Object may still be in use') {
                [string]$TaskTemplate_id_formatted = $TaskTemplate_id -split '\]' | Select-Object -Last 1
                Write-Warning -Message "This object $TaskTemplate_id_formatted is still in use somewhere therefore it cannot be removed! Please use 'Find-AutomateNOWObjectReferral -Object $TaskTemplate_id_formatted' to list the references for this object and then remove them."
            }
            Else {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Task $TaskTemplate_id successfully removed"
        }
    }
    End {

    }
}

Function Copy-AutomateNOWTaskTemplate {
    <#
    .SYNOPSIS
    Copies a Task Template from an AutomateNOW! instance

    .DESCRIPTION
    Copies a Task Template from an AutomateNOW! instance. AutomateNOW object id can never be changed, but we can copy the object to a new id and it will include all of the items therein.

    .PARAMETER TaskTemplate
    Mandatory [ANOWTaskTemplate] object to be copied.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the Task Template. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER UnsetTags
    Optional switch that will purposely omit the previously existing tags on the new copy of the Task Template. You can still specify new tags with -Tags but the old previous ones will not be carried over. In the UI, this is accomplished by clicking the existing tags off.

    .PARAMETER UnsetFolder
    Optional switch that will ensure that the newly created Task Template will not be placed in a folder.

    .PARAMETER UnsetDescription
    Optional switch that will ensure that the newly created Task Template will not carry over its previous description.

    .PARAMETER Description
    Optional description of the Task Template (may not exceed 255 characters). You may send an empty string here to ensure that the description is blanked out. Do not use this parameter if your intention is to keep the description from the previous Task Template.

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new Task Template.

    .PARAMETER Folder
    Optional name of the folder to place the Task Template into. The UnsetFolder parameter overrides this setting.

    .PARAMETER Force
    Force the copy without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    ONLY [ANOWTaskTemplate] objects are accepted. Pipeline support is intentionally unavailable.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    This is a safe standard example that is recommended

    $Task01 = Get-AutomateNOWTaskTemplate -Id 'old_name_Task01'
    Copy-AutomateNOWTaskTemplate -TaskTemplate $TaskTemplate01 -NewId 'new_name_TaskTemplate02'

    .EXAMPLE
    This is a one-liner approach

    Copy-AutomateNOWTaskTemplate -TaskTemplate (Get-AutomateNOWTaskTemplate -Id 'old_name_TaskTemplate01') -NewId 'new_name_TaskTemplate02'

    .EXAMPLE
    This approach users a For Each loop to iterate through a standard renaming pattern. This approach is not recommended.

    @( 'TaskTemplate1', 'TaskTemplate2', 'TaskTemplate3') | Get-AutomateNOWTaskTemplate | ForEachObject { Copy-AutomateNOWTaskTemplate -TaskTemplate $_ -NewId ($_.simpleId -replace 'Task[0-9]', ()'Task-' + $_.simpleId[-1]))}

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The new id (name) of the Task Template must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.
    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWTaskTemplate]$TaskTemplate,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$Task_template_exists = ($null -ne (Get-AutomateNOWTaskTemplate -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWTaskTemplate failed to check if the Task template [$NewId] already existed due to [$Message]."
            Break
        }
        If ($Task_template_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Task Template named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End warning ##
        [string]$command = '/processingTemplate/copy'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            [string]$TaskTemplate_oldId = $TaskTemplate.id
            [string]$TaskTemplate_simpleId = $TaskTemplate.simpleId
            If ($TaskTemplate_oldId -eq $NewId) {
                Write-Warning -Message "The new id cannot be the same as the old id."
                Break
            }
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Copy the Task Template $($TaskTemplate_simpleId) to $($NewId)?")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                $BodyMetaData.'oldId' = $TaskTemplate_oldId
                $BodyMetaData.'domain' = $TaskTemplate.domain
                $BodyMetaData.'id' = $NewId
                If ($UnsetDescription -ne $true) {
                    If ($Description.Length -gt 0) {
                        $BodyMetaData.'description' = $Description
                    }
                    Else {
                        $BodyMetaData.'description' = $TaskTemplate.description
                    }
                }
                If ($UnsetFolder -ne $True) {
                    If ($Folder.Length -gt 0) {
                        $BodyMetaData.'folder' = $Folder
                    }
                    Else {
                        $BodyMetaData.'folder' = $TaskTemplate.folder
                    }
                }
                [int32]$tag_count = 1
                If ($Tags.Count -gt 0) {
                    ForEach ($tag in $Tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
                If ($UnsetTags -ne $true) {
                    If ($TaskTemplate.tags -gt 0) {
                        ForEach ($tag in $TaskTemplate.tags) {
                            $BodyMetaData.('tags' + $tag_count ) = $tag
                            $tag_count++
                        }
                    }
                }
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_operationId' = 'copy'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_dataSource' = 'ProcessingTemplateDataSource'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties oldId, domain, NewId, description, folder
                $Body = $Body -replace '&tags[0-9]{1,}', '&tags'
                $parameters.Body = $Body
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$TaskTemplate_id] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                $Error.Clear()
                Try {
                    [ANOWTaskTemplate]$TaskTemplate = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to create copied [ANOWTaskTemplate] object due to [$Message]."
                    Break
                }
                If ($TaskTemplate.id.Length -eq 0) {
                    Write-Warning -Message "Somehow the newly created (copied) [ANOWTaskTemplate] object is empty!"
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $TaskTemplate
                }
            }
        }
    }
    End {

    }
}

Function Rename-AutomateNOWTaskTemplate {
    <#
    .SYNOPSIS
    Renames a Task Template from an AutomateNOW! instance

    .DESCRIPTION
    Performs a psuedo-rename operations of a Task Template from an AutomateNOW! instance by copying it first and then deleting the source. This function merely combines Copy-AutomateNOWTaskTemplate and Remove-AutomateNOWTaskTemplate therefore it is to be considered destructive.

    .PARAMETER TaskTemplate
    An [ANOWTaskTemplate] object representing the Task Template to be renamed.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the Task Template. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER Force
    Force the renaming without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly renamed object.

    .INPUTS
    ONLY [ANOWTaskTemplate] objects are accepted. There is intentionally no support for the pipeline.

    .OUTPUTS
    The newly renamed [ANOWTaskTemplate] object will be returned.

    .EXAMPLE
    $task_template = Get-AutomateNOWTaskTemplate -Id 'TaskTemplate01'
    Rename-AutomateNOWTaskTemplate -TaskTemplate $task_template -NewId 'Task_TEMPLATE_01'

    .EXAMPLE
    Rename-AutomateNOWTaskTemplate -TaskTemplate (Get-AutomateNOWTaskTemplate -Id 'TaskTemplate01') -NewId 'Task_TEMPLATE_01'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    When renaming, you may only specify a different Id (name).

    This action will be blocked if any existing referrals are found on the object.
    #>
    [OutputType([ANOWTaskTemplate])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWTaskTemplate]$TaskTemplate,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin standard warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$new_task_template_exists = ($null -ne (Get-AutomateNOWTaskTemplate -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWTaskTemplate failed to check if the Task Template [$NewId] already existed due to [$Message]."
            Break
        }
        If ($new_task_template_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Task Template named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        [string]$TaskTemplate_id = $TaskTemplate.id
        $Error.Clear()
        Try {
            [boolean]$old_Task_template_exists = ($null -ne (Get-AutomateNOWTaskTemplate -Id $TaskTemplate_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWTaskTemplate failed to check if the Task Template [$TaskTemplate_id] already existed due to [$Message]."
            Break
        }
        If ($old_Task_template_exists -eq $false) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not a Task Template named [$TaskTemplate_id] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End standard warning ##
        ## Begin referrals warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [int32]$referrals_count = Find-AutomateNOWObjectReferral -TaskTemplate $TaskTemplate -Count | Select-Object -Expandproperty referrals
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Find-AutomateNOWObjectReferral failed to extract the referrals on Task Template [$TaskTemplate_id] due to [$Message]."
            Break
        }
        If ($referrals_count -gt 0) {
            Write-Warning -Message "Unfortunately, you cannot rename a Task Template that has referrals. This is because the rename is not actually renaming but copying anew and deleting the old. Please, use the Find-AutomateNOWObjectReferral function to identify referrals and remove them."
            Break
        }
        Else {
            Write-Verbose -Message "The Task Template [$TaskTemplate_id] does not have any referrals. It is safe to proceed."
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($TaskTemplate_id)")) -eq $true) {
                $Error.Clear()
                Try {
                    [ANOWTaskTemplate]$new_task_template = Copy-AutomateNOWTaskTemplate -TaskTemplate $TaskTemplate -NewId $NewId -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Copy-AutomateNOWTaskTemplate failed to create a new Task Template [$NewId] as Part 1 of the renaming process due to [$Message]."
                    Break
                }
                If ($new_Task_template.simpleId -eq $NewId) {
                    Write-Verbose -Message "Part 1: Task Template [$TaskTemplate_id] successfully copied to [$NewId]"
                }
                Else {
                    Write-Warning -Message "Somehow the first phase (Copy-AutomateNOWTaskTemplate) failed. Please look into this."
                    Break
                }
                $Error.Clear()
                Try {
                    Remove-AutomateNOWTaskTemplate -TaskTemplate $TaskTemplate -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Remove-AutomateNOWTaskTemplate failed to remove [$TaskTemplate_id] as Part 2 of the renaming process due to [$Message]."
                    Break
                }
                Write-Verbose -Message "Part 2: Task Template [$TaskTemplate_id] removed"
                Write-Verbose -Message "Task [$TaskTemplate_id] successfully renamed to [$NewId]"
                If ($Quiet -ne $true) {
                    Return $new_task_template
                }
            }
        }
        Else {
            Write-Warning -Message "No action was taken because either the source object didn't exist or the new object already existed"
        }
    }
    End {
    }
}

Function Start-AutomateNOWTaskTemplate {
    <#
    .SYNOPSIS
    Starts a Task Template from an AutomateNOW! instance

    .DESCRIPTION
    Starts a Task Template from an AutomateNOW! instance

    .PARAMETER TaskTemplate
    An [ANOWTaskTemplate] object representing the Task Template to be started.

    .PARAMETER TaskTemplateId
    A string representing the Id of the Task Template. Do not include the domain prefix.

    .Parameter TaskParameters
    An optional [hashtable] containing the parameters to start the Task Template with. Example: @{"parameter1"="ABC";"parameter2"="123";}

    .PARAMETER UseAutomaticName
    A switch parameter that is ENABLED BY DEFAULT. You do not need to enable this as it is defaulted to on. This parameter simulates the default format of the executed task name (see 'Name' below)

    .PARAMETER Name
    A string representing the name of the running executed task. Only use this if you want to OVERRIDE the default naming standard that the console suggests when executing a task. The console defaults to a format of "Manual Execution - [task name] - [date utc]".

    .PARAMETER Description
    Optional description of the executed task (may not exceed 255 characters).

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new Task.

    .PARAMETER Folder
    Optional name of the folder to place the executed task into.

    .PARAMETER ProcessingTimestamp
    This parameter is -disabled- for now. Instead, the default timestamp will be used to ensure uniqueness. The documentation is unclear or mistaken around this parameter.

    .PARAMETER DelayedStartTime
    Optional string that allows processing items to start on a specific date or time or delay the execution for a period ranging from days to seconds. Example 1: 2029-12-31, Example 2: 2029-12-31 23:59:59, Example 3: 23:59:59

    .PARAMETER TimeZone
    Optional [ANOWTimeZone] object that modifies (it is unknown exactly what this property modifies since it is not defined in the documentation yet)

    .PARAMETER Priority
    Optional integer between 0 and 1000 to specify the priority of the executed task. Defaults to 0.

    .PARAMETER Hold
    Optional switch to set the 'On Hold' property of the executed task to enabled. This is $false by default but in the console the checkbox is enabled.

    .PARAMETER VerboseMode
    Optional switch that will cause the Workflow to "produce more events with minor performance impact"

    .PARAMETER ForceLoad
    Optional switch that overrides any 'Ignore Condition' that might exist on the Task Template

    .PARAMETER Quiet
    Switch parameter to silence the newly created [ANOWTask] object

    .INPUTS
    ONLY [ANOWTaskTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    An [ANOWTask] object representing the started task will be returned.

    .EXAMPLE
    Starts a Task Template by name

    Get-AutomateNOWTaskTemplate -Id 'TaskTemplate_01' | Start-AutomateNOWTaskTemplate

    .EXAMPLE
    Starts a Task Template by name with parameters

    Get-AutomateNOWTaskTemplate -Id 'TaskTemplate_01' | Start-AutomateNOWTaskTemplate -Parameters @{"parameter1"="ABC";"parameter2"="123";}

    .EXAMPLE
    Starts a Task Template by name with tags, a custom description and the Hold+ForceLoad flags enabled

    Get-AutomateNOWTaskTemplate -Id 'TaskTemplate_01' | Start-AutomateNOWTaskTemplate -Name 'Manual Execution - TaskTemplate_01' -Tags 'Tag1', 'Tag2' -ForceLoad -Hold -Priority 100 -Description 'My executed task'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Avoid using the -Name parameter unless you really need to use it and know what you're doing. If -Name is not supplied, the automatic name will be generated (i.e. -UseAutomaticName) which simulates the behavior of the console.

    #>
    [Cmdletbinding(DefaultParameterSetName = 'UseAutomaticName')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'Object', ValueFromPipeline = $True)]
        [ANOWTaskTemplate]$TaskTemplate,
        [Parameter(Mandatory = $true, ParameterSetName = 'Id')]
        [string]$TaskTemplateId,
        [Parameter(Mandatory = $false)]
        [hashtable]$TaskParameters,
        [Parameter(Mandatory = $false, ParameterSetName = 'UseAutomaticName')]
        [boolean]$UseAutomaticName = $true,
        [Parameter(Mandatory = $true, ParameterSetName = 'SpecifyNameManually')]
        [string]$Name,
        [Parameter(Mandatory = $false, HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [string]$Folder = '',
        [ValidateScript({ $_ -match '([0-9]{4}-[0-9]{2}-[0-9]{2}){0,}( {0,}[0-9]{2}:[0-9]{2}:[0-9]{2}){0,}' })]
        [Parameter(Mandatory = $false)]
        [string]$DelayedStartTime,
        [Parameter(Mandatory = $false)]
        [ANOWTimeZone]$TimeZone,
        [ValidateRange(0, 1000)]
        [Parameter(Mandatory = $false)]
        [int32]$Priority = 0,
        [Parameter(Mandatory = $false)]
        [switch]$Hold,
        [Parameter(Mandatory = $false)]
        [switch]$VerboseMode,
        [Parameter(Mandatory = $false)]
        [switch]$ForceLoad,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processing/executeNow'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [string]$domain = $anow_session.current_domain
        If ($_.id.Length -gt 0) {
            [string]$TaskTemplate_id = $_.id
        }
        ElseIf ($TaskTemplateId.Length -gt 0) {
            [string]$TaskTemplate_Id = ('[' + $domain + ']' + $TaskTemplateId )
        }
        ElseIf ($Id.Length -gt 0) {
            [string]$TaskTemplate_Id = ('[' + $domain + ']' + $Id )
        }
        Else {
            [string]$TaskTemplate_id = $TaskTemplate.id
        }
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        $BodyMetaData.Add('id', $TaskTemplate_id )
        $BodyMetaData.Add('runId', $TaskTemplate_id )
        $BodyMetaData.Add('priority', $priority )
        If ($null -ne $TimeZone) {
            [string]$timezone_id = ($TimeZone.id)
            $BodyMetaData.Add('timeZone', $timezone_id )
        }
        $BodyMetaData.Add('processingTimestamp', [string](Get-Date -Date ((Get-Date).ToUniversalTime()) -Format 'yyyy-MM-ddTHH:mm:ss.fff'))
        [string[]]$include_properties = 'id', 'runId', 'priority', 'processingTimestamp', 'hold', 'forceLoad', 'name'
        If ($Tags.Count -gt 0) {
            ForEach ($tag_id in $Tags) {
                $Error.Clear()
                Try {
                    [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] due to [$message]"
                    Break
                }
                If ($tag_object.simpleId.length -eq 0) {
                    Throw "Start-AutomateNOWTaskTemplate has detected that the tag [$tag_id] does not appear to exist. Please check again."
                    Break
                }
                ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                    [string]$tag_object_simpleId = $tag_object.simpleId
                    Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                    Break
                }
                [string]$tag_display = $tag_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Adding tag $tag_display"
            }
            $BodyMetaData.'tags' = $Tags
            $include_properties += 'tags'
        }
        If ($folder.Length -gt 0) {
            $Error.Clear()
            Try {
                [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWFolder had an error while retrieving the folder [$folder] under Start-AutomateNOWTaskTemplate due to [$message]"
                Break
            }
            If ($folder_object.simpleId.Length -eq 0) {
                Throw "Start-AutomateNOWTaskTemplate has detected that the folder [$folder] does not appear to exist. Please check again."
                Break
            }
            $BodyMetaData.Add('folder', $folder)
            $include_properties += $folder
        }
        If ($hold -ne $true) {
            $BodyMetaData.Add('hold', 'false')
        }
        Else {
            $BodyMetaData.Add('hold', 'true')
        }
        If ($forceLoad -ne $true) {
            $BodyMetaData.Add('forceLoad', 'false')
        }
        Else {
            $BodyMetaData.Add('forceLoad', 'true')
        }
        If ($VerboseMode -ne $true) {
            $BodyMetaData.Add('verboseMode', 'true')
        }
        Else {
            $BodyMetaData.Add('verboseMode', 'true')
        }
        If ($DelayedStartTime.Length -gt 0) {
            $BodyMetaData.Add('delayedStartTime', $DelayedStartTime)
        }
        If ($TaskParameters.Count -gt 0) {
            $Error.Clear()
            Try {
                [string]$task_parameters_json = $TaskParameters | ConvertTo-Json -Compress
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "ConvertTo-Json failed to execute the provided parameters to Start-AutomateNOWTaskTemplate due to [$Message]."
                Break
            }
            $BodyMetaData.Add('parameters', $task_parameters_json)
        }
        Else {
            $BodyMetaData.Add('parameters', '{}')
        }
        If ($Name.Length -gt 0) {
            $BodyMetaData.Add('name', $Name)
        }
        ElseIf ($UseAutomaticName -eq $true) {
            [string]$Name = New-AutomateNOWDefaultProcessingTitle -simpleId $TaskTemplate_simpleId
            Write-Verbose -Message "Generated automatic name [$Name] for this task"
        }
        Else {
            Write-Warning -Message "Unable to determine how to name this task that needs to be started"
            Break
        }
        $BodyMetaData.Add('_operationType', 'add')
        $BodyMetaData.Add('_operationId', 'executeNow')
        $BodyMetaData.Add('_textMatchStyle', 'exact')
        $BodyMetaData.Add('_dataSource', 'ProcessingDataSource')
        $BodyMetaData.Add('isc_metaDataPrefix', '_')
        $BodyMetaData.Add('isc_dataFormat', 'json')
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        If ($null -eq $parameters.Body) {
            $parameters.Add('Body', $Body)
        }
        Else {
            $parameters.Body = $Body
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$TaskTemplate_id] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        Write-Verbose -Message "Task $TaskTemplate_id successfully started"
        $Error.Clear()
        Try {
            [ANOWTask]$ANOWTask = $results.response.data | Select-Object -First 1
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Unable to create the [ANOWTask] object under Start-AutomateNOWTaskTemplate from the response due to [$Message]."
            Break
        }
        If ($Quiet -ne $true) {
            Return $ANOWTask
        }
    }
    End {

    }
}

Function Resume-AutomateNOWTaskTemplate {
    <#
    .SYNOPSIS
    Resumes a Task Template that is on hold (suspended) on an AutomateNOW! instance

    .DESCRIPTION
    Resumes a Task Template that is on hold (suspended) on an AutomateNOW! instance

    .PARAMETER TaskTemplate
    An [ANOWTaskTemplate] object representing the Task Template to be resumed

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Switch parameter to silence the emitted [ANOWTaskTemplate] object

    .INPUTS
    ONLY [ANOWTaskTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    The resumed [ANOWTaskTemplate] object will be returned

    .EXAMPLE
    Get-AutomateNOWTaskTemplate -Id 'TaskTemplate01' | Resume-AutomateNOWTaskTemplate -Force

    .EXAMPLE
    Get-AutomateNOWTaskTemplate -Id 'TaskTemplate01', 'TaskTemplate02' | Resume-AutomateNOWTaskTemplate

    .EXAMPLE
    @( 'Task1', 'Task2', 'Task3') | Resume-AutomateNOWTaskTemplate

    .EXAMPLE
    Get-AutomateNOWTaskTemplate | ? { $_.serverTaskType -eq 'LINUX' } | Resume-AutomateNOWTaskTemplate

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWTaskTemplate]$TaskTemplate,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processingTemplate/resume'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWTaskTemplate]$TaskTemplate = $_
        }
        [string]$TaskTemplate_id = $TaskTemplate.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($TaskTemplate_id)")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $TaskTemplate_id )
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_operationId', 'resume')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingTemplateDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$TaskTemplate_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            $Error.Clear()
            Try {
                [ANOWTaskTemplate]$resumed_task_template = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to create the [ANOWTaskTemplate] object after resuming [$TaskTemplate_id] due to [$Message]."
                Break
            }
            Write-Verbose -Message "Task $TaskTemplate_id successfully resumed"
            If ($Quiet -ne $true) {
                Return $resumed_task_template
            }
        }
    }
    End {

    }
}

Function Suspend-AutomateNOWTaskTemplate {
    <#
    .SYNOPSIS
    Places a Task Template on hold (suspend) from execution on an AutomateNOW! instance

    .DESCRIPTION
    Places a Task Template on hold (suspend) from execution on an AutomateNOW! instance

    .PARAMETER TaskTemplate
    An [ANOWTaskTemplate] object representing the Task Template to be suspended (placed on hold)

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Switch parameter to silence the emitted [ANOWTaskTemplate] object

    .INPUTS
    ONLY [ANOWTaskTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    The suspended [ANOWTaskTemplate] object will be returned

    .EXAMPLE
    Get-AutomateNOWTaskTemplate -Id 'TaskTemplate01' | Suspend-AutomateNOWTaskTemplate -Force

    .EXAMPLE
    Get-AutomateNOWTaskTemplate -Id 'TaskTemplate01', 'TaskTemplate02' | Suspend-AutomateNOWTaskTemplate

    .EXAMPLE
    @( 'Task1', 'Task2', 'Task3') | Suspend-AutomateNOWTaskTemplate

    .EXAMPLE
    Get-AutomateNOWTaskTemplate | ? { $_.serverTaskType -eq 'LINUX' } | Suspend-AutomateNOWTaskTemplate

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWTaskTemplate]$TaskTemplate,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processingTemplate/hold'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWTaskTemplate]$TaskTemplate = $_
        }
        [string]$TaskTemplate_id = $TaskTemplate.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($TaskTemplate_id)")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $TaskTemplate_id )
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_operationId', 'hold')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingTemplateDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$TaskTemplate_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            $Error.Clear()
            Try {
                [ANOWTaskTemplate]$suspended_task_template = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to create the [ANOWTaskTemplate] object after suspending [$TaskTemplate_id] due to [$Message]."
                Break
            }
            Write-Verbose -Message "Task $TaskTemplate_id successfully suspended (placed on hold)"
            If ($Quiet -ne $true) {
                Return $suspended_task_template
            }
        }
    }
    End {

    }
}

Function Skip-AutomateNOWTaskTemplate {
    <#
    .SYNOPSIS
    Sets or unsets the Skip flag on a Task Template on an AutomateNOW! instance

    .DESCRIPTION
    Sets or unsets the Skip flag on a Task Template on an AutomateNOW! instance

    .PARAMETER TaskTemplate
    An [ANOWTaskTemplate] object representing the Task Template to be set to skipped or unskipped

    .PARAMETER UnSkip
    Removes the skip flag from a [ANOWTaskTemplate] object. This is the opposite of the default behavior.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Switch parameter to silence the emitted [ANOWTaskTemplate] object

    .INPUTS
    ONLY [ANOWTaskTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    The skipped/unskipped [ANOWTaskTemplate] object will be returned

    .EXAMPLE
    Sets a Task Template to Skip (bypass)

    Get-AutomateNOWTaskTemplate -Id 'TaskTemplate01' | Skip-AutomateNOWTaskTemplate -Force

    .EXAMPLE
    Unsets the Skip (bypass) flag on a Task Template

    Get-AutomateNOWTaskTemplate | Skip-AutomateNOWTaskTemplate -UnSkip

    .EXAMPLE
    Sets an array of Task Template to Skip (bypass)

    @( 'Task1', 'Task2', 'Task3') | Skip-AutomateNOWTaskTemplate

    .EXAMPLE
    Get-AutomateNOWTaskTemplate | ? { $_.serverTaskType -eq 'LINUX' } | Skip-AutomateNOWTaskTemplate -UnSkip -Force -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWTaskTemplate]$TaskTemplate,
        [Parameter(Mandatory = $false)]
        [switch]$UnSkip,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnSkip -ne $True) {
            [string]$skip_flag_status = 'On'
            [string]$operation_id = 'passByOn'
            [string]$ProcessDescription = 'Add the Skip flag'
        }
        Else {
            [string]$skip_flag_status = 'Off'
            [string]$operation_id = 'passByOff'
            [string]$ProcessDescription = 'Remove the Skip flag'
        }
        [string]$command = ('/processingTemplate/' + $operation_id)
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWTaskTemplate]$TaskTemplate = $_
        }
        [string]$TaskTemplate_id = $TaskTemplate.id
        If ($TaskTemplate.passBy -eq $true -and $UnSkip -ne $True) {
            Write-Warning -Message "Task Template $TaskTemplate_id already has the skip flag set. No action is required."
            Break
        }
        ElseIf ($TaskTemplate.passBy -eq $false -and $UnSkip -eq $True) {
            Write-Warning -Message "Task Template $TaskTemplate_id does not have the skip flag set. No action is required."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess($TaskTemplate_id, $ProcessDescription)) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $TaskTemplate_id )
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_operationId', $operation_id)
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingTemplateDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$TaskTemplate_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            $Error.Clear()
            Try {
                [ANOWTaskTemplate]$skipped_task_template = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to create the [ANOWTaskTemplate] object after setting the skip flag to [$skip_flag_status] on [$TaskTemplate_id] due to [$Message]."
                Break
            }
            Write-Verbose -Message "Successfully set the skip flag to [$skip_flag_status] on [$TaskTemplate_id]"
            If ($Quiet -ne $true) {
                Return $skipped_task_template
            }
        }
    }
    End {

    }
}

Function Confirm-AutomateNOWTaskTemplate {
    <#
    .SYNOPSIS
    Validates (confirms) a Task Template on an AutomateNOW! instance

    .DESCRIPTION
    Validates (confirms) a Task Template on an AutomateNOW! instance

    .PARAMETER TaskTemplate
    An [ANOWTaskTemplate] object representing the Task Template to be set to confirmed (verified)

    .PARAMETER Quiet
    Returns a boolean $true or $false based on the result of the validation check

    .INPUTS
    ONLY [ANOWTaskTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    A string with the results from the API will returned.

    .EXAMPLE
    Validates a single Task Template

    Get-AutomateNOWTaskTemplate -Id 'TaskTemplate01' | Confirm-AutomateNOWTaskTemplate

    .EXAMPLE
    Validates a series of Task Templates

    @( 'TaskTemplate1', 'TaskTemplate2', 'TaskTemplate3') | Confirm-AutomateNOWTaskTemplate

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWTaskTemplate]$TaskTemplate,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [string]$TaskTemplate_id = $_.id
        }
        ElseIf ($TaskTemplate.id.Length -gt 0) {
            [string]$TaskTemplate_id = $TaskTemplate.id
        }
        Else {
            [string]$TaskTemplate_id = $Id
        }
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        $BodyMetaData.Add('id', $TaskTemplate_id )
        $BodyMetaData.Add('_operationType', 'custom')
        $BodyMetaData.Add('_operationId', 'validate')
        $BodyMetaData.Add('_textMatchStyle', 'exact')
        $BodyMetaData.Add('_dataSource', 'ProcessingTemplateDataSource')
        $BodyMetaData.Add('isc_metaDataPrefix', '_')
        $BodyMetaData.Add('isc_dataFormat', 'json')
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        [string]$command = ('/processingTemplate/validate?' + $Body)
        $parameters.Add('Command', $command)
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$TaskTemplate_id] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            If ($Quiet -eq $true) {
                Return $false
            }
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "The response code was [$response_code] instead of 0. The Task Template $TaskTemplate_id is not validated. Please see the full response $full_response_display"
        }
        Else {
            If ($Quiet -eq $true) {
                Return $true
            }
            Else {
                Write-Information -MessageData "The Task Template $TaskTemplate_id is confirmed as valid."
            }
        }
    }
    End {

    }
}

Function Show-AutomateNOWTaskTemplateType {
    <#
    .SYNOPSIS
    Shows all of the available task types for AutomateNOW! in human readable format

    .DESCRIPTION
    Shows all of the available task types for AutomateNOW! in human readable format (this was statically coded and will become outdated!)

    .PARAMETER JustGiveMeTheJSON
    Switch parameter that returns only the base unformatted JSON without the formatting.

    .INPUTS
    None. You cannot pipe objects to Show-AutomateNOWTaskType.

    .OUTPUTS
    An array of PSCustomObjects

    .EXAMPLE
    Show-AutomateNOWTaskType | Select-String -Pattern "PowerShell"

    .NOTES
    This is a stand-alone function which does not require connectivity to the AutomateNOW! console

    #>
    [Cmdletbinding()]
    Param(
        [switch]$JustGiveMeTheJSON
    )
    [PSCustomObject]$TaskTypesJson = '[{"processingType":"TASK","id":"TASK","name":"Task","icon":"skin/service.png","folder":true},{"folder":true,"id":"CODE","icon":"skin/terminal.gif","name":"Code","parent":"TASK"},{"id":"FILE_PROCESSING","name":"File Processing","icon":"skin/drive-network.png","folder":true,"processingType":"TASK","parent":"TASK"},{"folder":true,"id":"SQL","icon":"skin/database-sql.png","name":"SQL Database","parent":"TASK"},{"folder":true,"id":"NO_SQL","icon":"skin/database-gear.png","name":"NoSQL Database","parent":"TASK"},{"folder":true,"id":"MESSAGE_QUEUE","icon":"skin/queue.png","name":"Message Queue","parent":"TASK"},{"processingType":"TASK","taskType":"SH","id":"SH","icon":"skin/terminal.gif","name":"Shell Task","parent":"CODE"},{"processingType":"TASK","taskType":"AE_SHELL_SCRIPT","id":"AE_SHELL_SCRIPT","icon":"skin/terminal.gif","name":"AE Shell Task","parent":"CODE"},{"processingType":"TASK","taskType":"PYTHON","id":"PYTHON","icon":"skin/python.png","name":"Python Task","parent":"CODE"},{"processingType":"TASK","taskType":"PERL","id":"PERL","icon":"skin/perl.png","name":"Perl Task","parent":"CODE"},{"processingType":"TASK","taskType":"RUBY","id":"RUBY","icon":"skin/ruby.png","name":"Ruby Task","parent":"CODE"},{"processingType":"TASK","taskType":"GROOVY","id":"GROOVY","icon":"skin/groovy.png","name":"Groovy Task","parent":"CODE"},{"processingType":"TASK","taskType":"POWERSHELL","id":"POWERSHELL","icon":"skin/powershell.png","name":"PowerShell Task","parent":"CODE"},{"processingType":"TASK","id":"JAVA","taskType":"JAVA","name":"Java Task","icon":"skin/java.png","parent":"CODE"},{"processingType":"TASK","id":"SCALA","taskType":"SCALA","name":"Scala Task","icon":"skin/scala.png","parent":"CODE"},{"folder":true,"id":"IBM_SERIES","icon":"skin/ibm.png","name":"Mainframe/JCL","parent":"TASK"},{"folder":true,"id":"Z_OS","icon":"skin/zos.png","name":"z/OS","parent":"IBM_SERIES"},{"processingType":"TASK","taskType":"Z_OS_DYNAMIC_JCL","id":"Z_OS_DYNAMIC_JCL","icon":"skin/zos.png","name":"z/OS Dynamic JCL","parent":"Z_OS"},{"processingType":"TASK","taskType":"Z_OS_STORED_JCL","id":"Z_OS_STORED_JCL","icon":"skin/zos.png","name":"z/OS Stored JCL","parent":"Z_OS"},{"processingType":"TASK","taskType":"Z_OS_COMMAND","id":"Z_OS_COMMAND","icon":"skin/zos.png","name":"z/OS Command","parent":"Z_OS"},{"folder":true,"id":"RAINCODE_JCL","icon":"skin/raincode.ico","name":"Raincode JCL","parent":"IBM_SERIES"},{"processingType":"TASK","taskType":"RAINCODE_DYNAMIC_JCL","id":"RAINCODE_DYNAMIC_JCL","icon":"skin/raincode.ico","name":"Raincode Dynamic JCL","parent":"RAINCODE_JCL"},{"processingType":"TASK","taskType":"RAINCODE_STORED_JCL","id":"RAINCODE_STORED_JCL","icon":"skin/raincode.ico","name":"Raincode Stored JCL","parent":"RAINCODE_JCL"},{"folder":true,"id":"OPENTEXT","icon":"skin/microfocus.png","name":"OpenText JCL","parent":"IBM_SERIES"},{"processingType":"TASK","taskType":"OPENTEXT_DYNAMIC_JCL","id":"OPENTEXT_DYNAMIC_JCL","icon":"skin/microfocus.png","name":"OpenText Dynamic JCL","parent":"OPENTEXT"},{"processingType":"TASK","taskType":"OPENTEXT_STORED_JCL","id":"OPENTEXT_STORED_JCL","icon":"skin/microfocus.png","name":"OpenText Stored JCL","parent":"OPENTEXT"},{"folder":true,"id":"AS_400","icon":"skin/ibm_as400.gif","name":"IBM i","parent":"TASK"},{"processingType":"TASK","taskType":"AS400_BATCH_JOB","id":"AS400_BATCH_JOB","icon":"skin/ibm_as400.gif","name":"i Batch Job","parent":"AS_400"},{"processingType":"TASK","taskType":"AS400_PROGRAM_CALL","id":"AS400_PROGRAM_CALL","icon":"skin/ibm_as400.gif","name":"i Program Call","parent":"AS_400"},{"processingType":"TASK","taskType":"AS400_COMMAND_CALL","id":"AS400_COMMAND_CALL","icon":"skin/ibm_as400.gif","name":"i Control Language Command","parent":"AS_400"},{"processingType":"TASK","taskType":"AS400_RPA","id":"AS400_RPA","icon":"skin/ibm_as400.gif","name":"i RPA","parent":"AS_400"},{"processingType":"TASK","taskType":"RDBMS_STORED_PROCEDURE","id":"RDBMS_STORED_PROCEDURE","icon":"skin/database-gear.png","name":"Stored Procedure Call","parent":"SQL"},{"processingType":"TASK","taskType":"RDBMS_SQL_STATEMENT","id":"RDBMS_SQL_STATEMENT","icon":"skin/database_search.png","name":"RDBMS SQL Statement","parent":"SQL"},{"processingType":"TASK","taskType":"RDBMS_SQL","id":"RDBMS_SQL","icon":"skin/database-sql.png","name":"SQL Script","parent":"SQL"},{"folder":true,"id":"BIG_DATA","icon":"skin/database-gear.png","name":"Big Data","parent":"TASK"},{"folder":true,"id":"REDIS","icon":"skin/redis.png","name":"Redis","parent":"NO_SQL"},{"processingType":"TASK","taskType":"REDIS_SET","id":"REDIS_SET","icon":"skin/redis.png","name":"Redis Set","parent":"REDIS"},{"processingType":"TASK","taskType":"REDIS_GET","id":"REDIS_GET","icon":"skin/redis.png","name":"Redis Get","parent":"REDIS"},{"processingType":"TASK","taskType":"REDIS_DELETE","id":"REDIS_DELETE","icon":"skin/redis.png","name":"Redis Delete","parent":"REDIS"},{"processingType":"TASK","taskType":"REDIS_CLI","id":"REDIS_CLI","icon":"skin/redis.png","name":"Redis Command","parent":"REDIS"},{"processingType":"TASK","id":"HDFS","name":"HDFS","icon":"skin/hadoop.png","parent":"BIG_DATA","folder":true},{"processingType":"TASK","id":"HDFS_UPLOAD_FILE","taskType":"HDFS_UPLOAD_FILE","name":"HDFS Upload File","icon":"skin/hadoop.png","parent":"HDFS"},{"processingType":"TASK","id":"HDFS_APPEND_FILE","taskType":"HDFS_APPEND_FILE","name":"HDFS Append File","icon":"skin/hadoop.png","parent":"HDFS"},{"processingType":"TASK","id":"HDFS_DOWNLOAD_FILE","taskType":"HDFS_DOWNLOAD_FILE","name":"HDFS Download File","icon":"skin/hadoop.png","parent":"HDFS"},{"processingType":"TASK","id":"HDFS_DELETE_FILE","taskType":"HDFS_DELETE_FILE","name":"HDFS Delete File","icon":"skin/hadoop.png","parent":"HDFS"},{"processingType":"TASK","id":"HDFS_CREATE_DIRECTORY","taskType":"HDFS_CREATE_DIRECTORY","name":"HDFS Create Directory","icon":"skin/hadoop.png","parent":"HDFS"},{"processingType":"TASK","id":"HDFS_DELETE_DIRECTORY","taskType":"HDFS_DELETE_DIRECTORY","name":"HDFS Delete Directory","icon":"skin/hadoop.png","parent":"HDFS"},{"processingType":"TASK","id":"HDFS_RENAME","taskType":"HDFS_RENAME","name":"HDFS Rename","icon":"skin/hadoop.png","parent":"HDFS"},{"processingType":"TASK","id":"HIVE","name":"Hive","icon":"skin/hive.png","parent":"BIG_DATA","inactive":"hideInactiveFeatures"},{"processingType":"TASK","id":"IMPALA","name":"Impala","icon":"skin/impala.png","parent":"BIG_DATA","inactive":"hideInactiveFeatures"},{"processingType":"TASK","id":"SQOOP","name":"Sqoop","icon":"skin/sqoop.png","parent":"BIG_DATA","inactive":"hideInactiveFeatures"},{"processingType":"TASK","id":"YARN","name":"Yarn","icon":"skin/hadoop.png","parent":"BIG_DATA","inactive":"hideInactiveFeatures"},{"processingType":"TASK","id":"SPARK","name":"Spark","icon":"skin/spark.png","parent":"BIG_DATA","folder":"hideInactiveFeatures"},{"id":"SPARK_JAVA","taskType":"SPARK_JAVA","name":"Spark Java Job","icon":"skin/spark.png","parent":"SPARK","processingType":"TASK"},{"id":"SPARK_SCALA","taskType":"SPARK_SCALA","name":"Spark Scala Job","icon":"skin/spark.png","parent":"SPARK","processingType":"TASK"},{"id":"SPARK_PYTHON","taskType":"SPARK_PYTHON","name":"Spark Python Job","icon":"skin/spark.png","parent":"SPARK","processingType":"TASK"},{"id":"SPARK_R","taskType":"SPARK_R","name":"Spark R Job","icon":"skin/spark.png","parent":"SPARK","processingType":"TASK"},{"id":"SPARK_SQL","taskType":"SPARK_SQL","name":"Spark SQL Job","icon":"skin/spark.png","parent":"SPARK","processingType":"TASK"},{"processingType":"TASK","id":"FLUME","name":"Flume","icon":"skin/flume.png","parent":"BIG_DATA","inactive":"hideInactiveFeatures"},{"processingType":"TASK","id":"FLINK","name":"Flink","icon":"skin/flink.jpg ","parent":"BIG_DATA","folder":"hideInactiveFeatures"},{"processingType":"TASK","id":"FLINK_RUN_JOB","taskType":"FLINK_RUN_JOB","name":"Flink Run Job","icon":"skin/flink.jpg","parent":"FLINK"},{"processingType":"TASK","id":"FLINK_JAR_UPLOAD","taskType":"FLINK_JAR_UPLOAD","name":"Flink Upload Jar","icon":"skin/flink.jpg","parent":"FLINK"},{"processingType":"TASK","id":"FLINK_JAR_DELETE","taskType":"FLINK_JAR_DELETE","name":"Flink Delete Jar","icon":"skin/flink.jpg","parent":"FLINK"},{"id":"STORM","name":"Storm","icon":"skin/storm.png","parent":"BIG_DATA","inactive":"hideInactiveFeatures"},{"id":"OOZIE","name":"Oozie","icon":"skin/oozie.png","parent":"BIG_DATA","inactive":"hideInactiveFeatures"},{"id":"AMBARI","name":"Ambari","icon":"skin/ambari.png","parent":"BIG_DATA","inactive":"hideInactiveFeatures"},{"id":"MONGO_DB","name":"Mongo DB","icon":"skin/mongodb.gif","parent":"NO_SQL","folder":true},{"id":"MONGO_DB_INSERT","name":"Mongo DB Insert Document","icon":"skin/mongodb.gif","parent":"MONGO_DB","processingType":"TASK","taskType":"MONGO_DB_INSERT"},{"id":"IBM_MQ","icon":"skin/ibm_mq.png","name":"IBM MQ","parent":"MESSAGE_QUEUE"},{"processingType":"TASK","taskType":"IBM_MQ_SEND","id":"IBM_MQ_SEND","icon":"skin/ibm_mq.png","name":"Send IBM MQ Message","parent":"IBM_MQ"},{"processingType":"SERVICE","serviceType":"SENSOR","sensorType":"IBM_MQ_SENSOR","id":"IBM_MQ_SENSOR","icon":"skin/ibm_mq.png","name":"IBM MQ Sensor","parent":"IBM_MQ"},{"id":"RABBIT_MQ","name":"RabbitMQ","icon":"skin/rabbitmq.png","parent":"MESSAGE_QUEUE"},{"processingType":"TASK","taskType":"RABBIT_MQ_SEND","id":"RABBIT_MQ_SEND","name":"Send RabbitMQ Message","icon":"skin/rabbitmq.png","parent":"RABBIT_MQ"},{"processingType":"SERVICE","serviceType":"SENSOR","sensorType":"RABBIT_MQ_SENSOR","id":"RABBIT_MQ_SENSOR","icon":"skin/rabbitmq.png","name":"RabbitMQ Message Sensor","parent":"RABBIT_MQ"},{"id":"KAFKA","name":"Kafka","icon":"skin/kafka.png","parent":"MESSAGE_QUEUE"},{"processingType":"TASK","taskType":"KAFKA_SEND","id":"KAFKA_SEND","name":"Send Kafka Message","icon":"skin/kafka.png","parent":"KAFKA"},{"processingType":"SERVICE","serviceType":"SENSOR","sensorType":"KAFKA_SENSOR","id":"KAFKA_SENSOR","icon":"skin/kafka.png","name":"Kafka Message Sensor","parent":"KAFKA"},{"processingType":"TASK","taskType":"JMS","id":"JMS","icon":"skin/java.png","name":"JMS","parent":"MESSAGE_QUEUE","folder":true},{"processingType":"TASK","taskType":"JMS_SEND","id":"JMS_SEND","icon":"skin/java.png","name":"Send JMS Message","parent":"JMS"},{"processingType":"SERVICE","serviceType":"SENSOR","sensorType":"JMS_SENSOR","id":"JMS_SENSOR","icon":"skin/java.png","name":"JMS Sensor","parent":"JMS"},{"processingType":"TASK","id":"AMQP","icon":"skin/amqp.ico","name":"AMQP","parent":"MESSAGE_QUEUE","folder":true},{"processingType":"TASK","taskType":"AMQP_SEND","id":"AMQP_SEND","icon":"skin/amqp.ico","name":"Send AMQP Message","parent":"AMQP"},{"processingType":"TASK","id":"MQTT","icon":"skin/mqtt.png","name":"MQTT","parent":"MESSAGE_QUEUE","folder":true},{"processingType":"TASK","taskType":"MQTT_SEND","id":"MQTT_SEND","icon":"skin/mqtt.png","name":"Send MQTT Message","parent":"MQTT"},{"id":"XMPP","icon":"skin/xmpp.png","name":"XMPP","parent":"MESSAGE_QUEUE","folder":true},{"processingType":"TASK","taskType":"XMPP_SEND","id":"XMPP_SEND","icon":"skin/xmpp.png","name":"Send XMPP Message","parent":"XMPP"},{"id":"STOMP","icon":"skin/shoe.png","name":"STOMP","parent":"MESSAGE_QUEUE","folder":true},{"processingType":"TASK","taskType":"STOMP_SEND","id":"STOMP_SEND","icon":"skin/shoe.png","name":"Send STOMP Message","parent":"STOMP"},{"processingType":"TASK","taskType":"FILE_TRANSFER","id":"FILE_TRANSFER","icon":"skin/drive-network.png","name":"File Transfer","parent":"FILE_PROCESSING"},{"processingType":"TASK","taskType":"XFTP_COMMAND","id":"XFTP_COMMAND","icon":"skin/drive-network.png","name":"XFTP Command","parent":"FILE_PROCESSING"},{"id":"DATASOURCE_FILE","name":"Data Source","icon":"skin/drive-network.png","folder":true,"parent":"FILE_PROCESSING"},{"id":"DATASOURCE_UPLOAD_FILE","processingType":"TASK","taskType":"DATASOURCE_UPLOAD_FILE","name":"Upload File to Data Source","icon":"skin/drive-upload.png","parent":"DATASOURCE_FILE"},{"id":"DATASOURCE_DOWNLOAD_FILE","processingType":"TASK","taskType":"DATASOURCE_DOWNLOAD_FILE","name":"Download File from Data Source","icon":"skin/drive-download.png","parent":"DATASOURCE_FILE"},{"id":"DATASOURCE_DELETE_FILE","processingType":"TASK","taskType":"DATASOURCE_DELETE_FILE","name":"Delete File from Data Source","icon":"skin/drive_delete.png","parent":"DATASOURCE_FILE"},{"folder":true,"id":"WEB","icon":"skin/world.png","name":"Web","parent":"TASK"},{"folder":true,"id":"EMAIL","icon":"skin/mail.png","name":"Email","parent":"TASK"},{"processingType":"TASK","taskType":"HTTP_REQUEST","id":"HTTP_REQUEST","icon":"skin/http.png","name":"HTTP Request","parent":"WEB"},{"processingType":"TASK","taskType":"REST_WEB_SERVICE_CALL","id":"REST_WEB_SERVICE_CALL","icon":"skin/rest.png","name":"REST Web Service Call","parent":"WEB"},{"processingType":"TASK","taskType":"SOAP_WEB_SERVICE_CALL","id":"SOAP_WEB_SERVICE_CALL","icon":"skin/soap.png","name":"SOAP Web Service Call","parent":"WEB"},{"processingType":"TASK","taskType":"EMAIL_SEND","id":"EMAIL_SEND","icon":"skin/mail.png","name":"Send Email","parent":"EMAIL"},{"processingType":"TASK","taskType":"EMAIL_CONFIRMATION","id":"EMAIL_CONFIRMATION","icon":"skin/mail--pencil.png","name":"Email Confirmation","parent":"EMAIL"},{"processingType":"TASK","taskType":"EMAIL_INPUT","id":"EMAIL_INPUT","icon":"skin/mail-open-table.png","name":"Email Input","parent":"EMAIL"},{"processingType":"SERVICE","serviceType":"SENSOR","sensorType":"EMAIL_SENSOR","id":"EMAIL_SENSOR","icon":"skin/mail.png","name":"Email Sensor","parent":"EMAIL"},{"id":"CLOUD_SERVICES","name":"Cloud Services","icon":"skin/cloud.png","folder":true,"parent":"TASK"},{"id":"AWS","name":"Amazon Web Services","icon":"skin/aws.png","parent":"CLOUD_SERVICES","folder":true},{"id":"AWS_GLUE","name":"Amazon Glue","icon":"skin/aws.png","parent":"AWS","folder":true},{"id":"AWS_GLUE_WORKFLOW","processingType":"TASK","taskType":"AWS_GLUE_WORKFLOW","name":"AWS Glue Workflow","icon":"skin/aws.png","parent":"AWS_GLUE"},{"id":"AWS_GLUE_TRIGGER","processingType":"TASK","taskType":"AWS_GLUE_TRIGGER","name":"AWS Glue Trigger","icon":"skin/aws.png","parent":"AWS_GLUE"},{"id":"AWS_GLUE_CRAWLER","processingType":"TASK","taskType":"AWS_GLUE_CRAWLER","name":"AWS Glue Crawler","icon":"skin/aws.png","parent":"AWS_GLUE"},{"id":"AWS_GLUE_JOB","processingType":"TASK","taskType":"AWS_GLUE_JOB","name":"AWS Glue Job","icon":"skin/aws.png","parent":"AWS_GLUE"},{"id":"AWS_EMR","name":"Amazon EMR","icon":"skin/aws.png","parent":"AWS","folder":true},{"id":"AWS_EMR_WORKFLOW","processingType":"TASK","taskType":"AWS_EMR_WORKFLOW","name":"AWS EMR Workflow","icon":"skin/aws.png","parent":"AWS_EMR"},{"id":"AWS_EMR_ADD_STEPS","processingType":"TASK","taskType":"AWS_EMR_ADD_STEPS","name":"AWS EMR Add Steps","icon":"skin/aws.png","parent":"AWS_EMR"},{"id":"AWS_EMR_CANCEL_STEPS","processingType":"TASK","taskType":"AWS_EMR_CANCEL_STEPS","name":"AWS EMR Cancel Steps","icon":"skin/aws.png","parent":"AWS_EMR"},{"id":"AWS_EMR_TERMINATE_JOB_FLOW","processingType":"TASK","taskType":"AWS_EMR_TERMINATE_JOB_FLOW","name":"AWS EMR Terminate Job Flow","icon":"skin/aws.png","parent":"AWS_EMR"},{"id":"AWS_EMR_CONTAINER_MONITOR","processingType":"SERVICE","serviceType":"MONITOR","monitorType":"AWS_EMR_CONTAINER_MONITOR","name":"AWS EMR Container Monitor","icon":"skin/aws.png","parent":"AWS_EMR"},{"id":"AWS_EMR_JOB_FLOW_MONITOR","processingType":"SERVICE","serviceType":"MONITOR","monitorType":"AWS_EMR_JOB_FLOW_MONITOR","name":"AWS EMR Job Flow Monitor","icon":"skin/aws.png","parent":"AWS_EMR"},{"id":"AWS_EMR_STEP_MONITOR","processingType":"SERVICE","serviceType":"MONITOR","monitorType":"AWS_EMR_STEP_MONITOR","name":"AWS EMR Step Monitor","icon":"skin/aws.png","parent":"AWS_EMR"},{"id":"AWS_EMR_NOTEBOOK_MONITOR","processingType":"SERVICE","serviceType":"MONITOR","monitorType":"AWS_EMR_NOTEBOOK_MONITOR","name":"AWS EMR Notebook Monitor","icon":"skin/aws.png","parent":"AWS_EMR"},{"id":"AWS_EMR_PUT","processingType":"TASK","taskType":"AWS_EMR_PUT","name":"AWS EMR Put","icon":"skin/aws.png","parent":"AWS_EMR"},{"id":"AWS_EMR_GET","processingType":"TASK","taskType":"AWS_EMR_GET","name":"AWS EMR Get","icon":"skin/aws.png","parent":"AWS_EMR"},{"id":"AWS_EMR_START_NOTEBOOK_EXECUTION","processingType":"TASK","taskType":"AWS_EMR_START_NOTEBOOK_EXECUTION","name":"AWS EMR Start Notebook Execution","icon":"skin/aws.png","parent":"AWS_EMR"},{"id":"AWS_EMR_STOP_NOTEBOOK_EXECUTION","processingType":"TASK","taskType":"AWS_EMR_STOP_NOTEBOOK_EXECUTION","name":"AWS EMR Stop Notebook Execution","icon":"skin/aws.png","parent":"AWS_EMR"},{"id":"AWS_EMR_API_COMMAND","processingType":"TASK","taskType":"AWS_EMR_API_COMMAND","name":"AWS EMR API Command","icon":"skin/aws.png","parent":"AWS_EMR"},{"id":"AWS_SAGE_MAKER","name":"Amazon SageMaker","icon":"skin/aws.png","parent":"AWS","folder":true},{"id":"AWS_SAGE_MAKER_ADD_MODEL","processingType":"TASK","taskType":"AWS_SAGE_MAKER_ADD_MODEL","name":"AWS SageMaker Add Model","icon":"skin/aws.png","parent":"AWS_SAGE_MAKER"},{"id":"AWS_SAGE_MAKER_DELETE_MODEL","processingType":"TASK","taskType":"AWS_SAGE_MAKER_DELETE_MODEL","name":"AWS SageMaker Delete Model","icon":"skin/aws.png","parent":"AWS_SAGE_MAKER"},{"id":"AWS_SAGE_MAKER_PROCESSING","processingType":"TASK","taskType":"AWS_SAGE_MAKER_PROCESSING","name":"AWS SageMaker Processing","icon":"skin/aws.png","parent":"AWS_SAGE_MAKER"},{"id":"AWS_SAGE_MAKER_TRAINING","processingType":"TASK","taskType":"AWS_SAGE_MAKER_TRAINING","name":"AWS SageMaker Training","icon":"skin/aws.png","parent":"AWS_SAGE_MAKER"},{"id":"AWS_SAGE_MAKER_TRANSFORM","processingType":"TASK","taskType":"AWS_SAGE_MAKER_TRANSFORM","name":"AWS SageMaker Transform","icon":"skin/aws.png","parent":"AWS_SAGE_MAKER"},{"id":"AWS_SAGE_MAKER_API_COMMAND","processingType":"TASK","taskType":"AWS_SAGE_MAKER_API_COMMAND","name":"AWS SageMaker API Command","icon":"skin/aws.png","parent":"AWS_SAGE_MAKER"},{"id":"AWS_LAMBDA","name":"AWS Lambda","icon":"skin/aws.png","parent":"AWS","folder":true},{"id":"AWS_LAMBDA_INVOKE","name":"AWS Lambda Invoke","icon":"skin/aws.png","parent":"AWS_LAMBDA","processingType":"TASK","taskType":"AWS_LAMBDA_INVOKE"},{"id":"AWS_LAMBDA_CREATE_FUNCTION","name":"AWS Lambda Create Function","icon":"skin/aws.png","parent":"AWS_LAMBDA","processingType":"TASK","taskType":"AWS_LAMBDA_CREATE_FUNCTION"},{"id":"AWS_LAMBDA_DELETE_FUNCTION","name":"AWS Lambda Delete Function","icon":"skin/aws.png","parent":"AWS_LAMBDA","processingType":"TASK","taskType":"AWS_LAMBDA_DELETE_FUNCTION"},{"id":"AWS_EC2","name":"AWS EC2","icon":"skin/aws.png","parent":"AWS","folder":true},{"id":"AWS_EC2_START_INSTANCE","name":"AWS EC2 Start   Instance","icon":"skin/aws.png","parent":"AWS_EC2","processingType":"TASK","taskType":"AWS_EC2_START_INSTANCE"},{"id":"AWS_EC2_STOP_INSTANCE","name":"AWS EC2 Stop Instance","icon":"skin/aws.png","parent":"AWS_EC2","processingType":"TASK","taskType":"AWS_EC2_STOP_INSTANCE"},{"id":"AWS_EC2_TERMINATE_INSTANCE","name":"AWS EC2 Terminate Instance","icon":"skin/aws.png","parent":"AWS_EC2","processingType":"TASK","taskType":"AWS_EC2_TERMINATE_INSTANCE"},{"id":"AWS_EC2_DELETE_VOLUME","name":"AWS EC2 Delete Volume","icon":"skin/aws.png","parent":"AWS_EC2","processingType":"TASK","taskType":"AWS_EC2_DELETE_VOLUME"},{"id":"AWS_S3","name":"AWS S3","icon":"skin/aws.png","parent":"AWS","folder":true},{"id":"AWS_S3_DELETE_OBJECT","name":"AWS S3 Delete Object","icon":"skin/aws.png","parent":"AWS_S3","processingType":"TASK","taskType":"AWS_S3_DELETE_OBJECT"},{"id":"AWS_S3_COPY_OBJECT","name":"AWS S3 Copy Object","icon":"skin/aws.png","parent":"AWS_S3","processingType":"TASK","taskType":"AWS_S3_COPY_OBJECT"},{"id":"AWS_S3_MOVE_OBJECT","name":"AWS S3 Move Object","icon":"skin/aws.png","parent":"AWS_S3","processingType":"TASK","taskType":"AWS_S3_MOVE_OBJECT"},{"id":"AWS_S3_RENAME_OBJECT","name":"AWS S3 Rename Object","icon":"skin/aws.png","parent":"AWS_S3","processingType":"TASK","taskType":"AWS_S3_RENAME_OBJECT"},{"id":"AWS_BATCH","name":"AWS Batch","icon":"skin/aws.png","parent":"AWS","folder":true},{"id":"AWS_BATCH_JOB","name":"AWS Batch Job","icon":"skin/aws.png","parent":"AWS_BATCH","processingType":"TASK","taskType":"AWS_BATCH_JOB"},{"id":"AWS_STEP_FUNCTIONS","name":"AWS Step Functions","icon":"skin/aws.png","parent":"AWS","folder":true},{"id":"AWS_START_STEP_FUNCTION_STATE_MACHINE","name":"AWS Start Step Function State Machine","icon":"skin/aws.png","parent":"AWS_STEP_FUNCTIONS","processingType":"TASK","taskType":"AWS_START_STEP_FUNCTION_STATE_MACHINE"},{"id":"CONTAINER","name":"Container","icon":"skin/container.png","folder":true,"processingType":"TASK","parent":"TASK"},{"id":"DOCKER","name":"Docker","icon":"skin/docker.png","parent":"CONTAINER","folder":true,"processingType":"TASK"},{"id":"DOCKER_START","icon":"skin/docker.png","name":"Start Container","parent":"DOCKER","processingType":"TASK","taskType":"DOCKER_START"},{"id":"DOCKER_STOP","icon":"skin/docker.png","name":"Stop Container","parent":"DOCKER","processingType":"TASK","taskType":"DOCKER_STOP"},{"id":"DOCKER_KILL","icon":"skin/docker.png","name":"Kill Container","parent":"DOCKER","processingType":"TASK","taskType":"DOCKER_KILL"},{"id":"DOCKER_EXEC","icon":"skin/docker.png","name":"Execute Command","parent":"DOCKER","processingType":"TASK","taskType":"DOCKER_EXEC"},{"id":"KUBERNETES","name":"Kubernetes","icon":"skin/kubernetes.png","parent":"CONTAINER","folder":true,"processingType":"TASK"},{"id":"KUBERNETES_CREATE_PERSISTENT_VOLUME_TASK","icon":"skin/kubernetes.png","name":"Create Persistent Volume","parent":"KUBERNETES","processingType":"TASK","taskType":"KUBERNETES_CREATE_PERSISTENT_VOLUME_TASK"},{"id":"KUBERNETES_CREATE_VOLUME_CLAIM_TASK","icon":"skin/kubernetes.png","name":"Create Volume Claim","parent":"KUBERNETES","processingType":"TASK","taskType":"KUBERNETES_CREATE_VOLUME_CLAIM_TASK"},{"id":"KUBERNETES_START_POD_TASK","icon":"skin/kubernetes.png","name":"Start POD","parent":"KUBERNETES","processingType":"TASK","taskType":"KUBERNETES_START_POD_TASK"},{"id":"KUBERNETES_COPY_FILE_TO_POD_TASK","icon":"skin/kubernetes.png","name":"Copy file to POD","parent":"KUBERNETES","processingType":"TASK","taskType":"KUBERNETES_COPY_FILE_TO_POD_TASK"},{"id":"KUBERNETES_RUN_TASK","icon":"skin/kubernetes.png","name":"Execute Command on POD","parent":"KUBERNETES","processingType":"TASK","taskType":"KUBERNETES_RUN_TASK"},{"id":"KUBERNETES_DELETE_POD_TASK","icon":"skin/kubernetes.png","name":"Delete POD","parent":"KUBERNETES","processingType":"TASK","taskType":"KUBERNETES_DELETE_POD_TASK"},{"id":"AZURE","name":"Azure","icon":"skin/azure.png","parent":"CLOUD_SERVICES","folder":true,"processingType":"TASK"},{"id":"AZURE_DATA_FACTORY","name":"Azure Data Factory","icon":"skin/azure.png","parent":"AZURE","folder":true,"processingType":"TASK"},{"id":"AZURE_DATA_FACTORY_TRIGGER","processingType":"TASK","taskType":"AZURE_DATA_FACTORY_TRIGGER","name":"Azure Data Factory Trigger","icon":"skin/azure.png","parent":"AZURE_DATA_FACTORY"},{"id":"AZURE_DATA_FACTORY_PIPELINE","processingType":"TASK","taskType":"AZURE_DATA_FACTORY_PIPELINE","name":"Azure Data Factory Pipeline","icon":"skin/azure.png","parent":"AZURE_DATA_FACTORY"},{"id":"AZURE_DATA_LAKE_JOB","processingType":"TASK","taskType":"AZURE_DATA_LAKE_JOB","name":"Azure Data Lake Job","icon":"skin/azure.png","parent":"AZURE"},{"id":"AZURE_DATABRICKS","name":"Azure DataBricks","icon":"skin/azure.png","parent":"AZURE","folder":true},{"id":"AZURE_DATABRICKS_JOB","parent":"AZURE_DATABRICKS","icon":"skin/azure.png","name":"Azure DataBricks Run Job","processingType":"TASK","taskType":"AZURE_DATABRICKS_JOB"},{"id":"AZURE_DATABRICKS_TERMINATE_CLUSTER","parent":"AZURE_DATABRICKS","icon":"skin/azure.png","name":"Azure DataBricks Terminate Cluster","processingType":"TASK","taskType":"AZURE_DATABRICKS_TERMINATE_CLUSTER"},{"id":"AZURE_DATABRICKS_START_CLUSTER","parent":"AZURE_DATABRICKS","icon":"skin/azure.png","name":"Azure DataBricks Start Cluster","processingType":"TASK","taskType":"AZURE_DATABRICKS_START_CLUSTER"},{"processingType":"SERVICE","serviceType":"MONITOR","monitorType":"AZURE_DATABRICKS_CLUSTER_MONITOR","id":"AZURE_DATABRICKS_CLUSTER_MONITOR","icon":"skin/azure.png","name":"Azure DataBricks Cluster Monitor","parent":"AZURE_DATABRICKS"},{"processingType":"TASK","taskType":"AZURE_DATABRICKS_LIST_CLUSTERS","id":"AZURE_DATABRICKS_LIST_CLUSTERS","icon":"skin/azure.png","name":"Azure DataBricks List Clusters","parent":"AZURE_DATABRICKS"},{"processingType":"TASK","taskType":"AZURE_DATABRICKS_DELETE_CLUSTER","id":"AZURE_DATABRICKS_DELETE_CLUSTER","icon":"skin/azure.png","name":"Azure DataBricks Delete Cluster Permanently","parent":"AZURE_DATABRICKS"},{"id":"INFORMATICA_CLOUD","name":"Informatica Cloud","icon":"skin/informatica.ico","parent":"CLOUD_SERVICES","folder":true},{"processingType":"TASK","taskType":"INFORMATICA_CLOUD_TASKFLOW","id":"INFORMATICA_CLOUD_TASKFLOW","icon":"skin/informatica.ico","name":"Informatica Cloud Taskflow","parent":"INFORMATICA_CLOUD"},{"folder":true,"id":"ETL","icon":"skin/etl.png","name":"ETL","parent":"TASK"},{"processingType":"TASK","taskType":"INFORMATICA_WORKFLOW","id":"INFORMATICA_WORKFLOW","icon":"skin/informatica.ico","name":"Informatica Power Center Workflow","parent":"ETL"},{"processingType":"TASK","taskType":"INFORMATICA_WS_WORKFLOW","id":"INFORMATICA_WS_WORKFLOW","icon":"skin/informatica.ico","name":"Informatica Power Center Web Service Workflow","parent":"ETL"},{"processingType":"TASK","taskType":"IBM_DATASTAGE","id":"IBM_DATASTAGE","icon":"skin/ibminfosphere.png","name":"IBM Infosphere DataStage","parent":"ETL"},{"processingType":"TASK","taskType":"MS_SSIS","id":"MS_SSIS","icon":"skin/ssis.png","name":"MS SQL Server Integration Services","parent":"ETL"},{"folder":true,"id":"ORACLE_DATA_INTEGRATOR","icon":"skin/odi.png","name":"Oracle Data Integrator","parent":"ETL"},{"processingType":"TASK","taskType":"ODI_SESSION","id":"ODI_SESSION","icon":"skin/odi.png","name":"ODI Session","parent":"ORACLE_DATA_INTEGRATOR"},{"processingType":"TASK","taskType":"ODI_LOAD_PLAN","id":"ODI_LOAD_PLAN","icon":"skin/odi.png","name":"ODI Load Plan","parent":"ORACLE_DATA_INTEGRATOR"},{"folder":true,"id":"SAS","icon":"skin/sas.png","name":"SAS","parent":"ETL"},{"processingType":"TASK","taskType":"SAS_4GL","id":"SAS_4GL","icon":"skin/sas.png","name":"SAS Dynamic Code","parent":"SAS"},{"processingType":"TASK","taskType":"SAS_DI","id":"SAS_DI","icon":"skin/sas.png","name":"SAS Stored Code","parent":"SAS"},{"processingType":"TASK","taskType":"SAS_JOB","id":"SAS_JOB","icon":"skin/sas.png","name":"SAS Job","parent":"SAS"},{"folder":true,"id":"SAS_VIYA","icon":"skin/sas_viya.png","name":"SAS Viya","parent":"ETL"},{"processingType":"TASK","taskType":"SAS_VIYA_JOB","id":"SAS_VIYA_JOB","icon":"skin/sas_viya.png","name":"SAS Viya Job","parent":"SAS_VIYA"},{"id":"TALEND","parent":"ETL","icon":"skin/talend.png","name":"Talend"},{"processingType":"TASK","taskType":"TALEND_JOB","id":"TALEND_JOB","icon":"skin/talend.png","name":"Talend Job","parent":"TALEND"},{"id":"DBT_GROUP","icon":"skin/dbt.ico","name":"dbt","parent":"ETL"},{"processingType":"TASK","taskType":"DBT_JOB","id":"DBT_JOB","icon":"skin/dbt.ico","name":"dbt Job","parent":"DBT_GROUP"},{"processingType":"TASK","taskType":"DBT_CORE_JOB","id":"DBT_CORE_JOB","icon":"skin/dbt.ico","name":"dbt Core Job","parent":"DBT_GROUP"},{"folder":true,"id":"ERP","icon":"skin/erp.png","name":"ERP","parent":"TASK"},{"folder":true,"id":"SAP_R3","icon":"skin/sap.png","name":"SAP R/3","parent":"ERP"},{"folder":true,"id":"SAP_R3_JOBS","icon":"skin/sap.png","name":"SAP R/3 Job","parent":"SAP_R3"},{"folder":true,"id":"SAP_R3_OTHER","icon":"skin/sap.png","name":"SAP R/3 Other","parent":"SAP_R3"},{"folder":true,"id":"SAP_4H","icon":"skin/sap.png","name":"SAP S/4HANA","parent":"ERP"},{"folder":true,"id":"SAP_4H_JOBS","icon":"skin/sap.png","name":"SAP 4/HANA Job","parent":"SAP_4H"},{"folder":true,"id":"SAP_4H_OTHER","icon":"skin/sap.png","name":"SAP 4/HANA Other","parent":"SAP_4H"},{"folder":true,"id":"SAP_4HC","icon":"skin/sap.png","name":"SAP S/4HANA Cloud","parent":"ERP"},{"processingType":"TASK","taskType":"SAP_R3_JOB","id":"SAP_R3_JOB","icon":"skin/sap.png","name":"SAP R/3 Job","parent":"SAP_R3_JOBS"},{"processingType":"TASK","taskType":"SAP_R3_VARIANT_CREATE","id":"SAP_R3_VARIANT_CREATE","icon":"skin/sap.png","name":"SAP R/3 Create Variant","parent":"SAP_R3_JOBS"},{"processingType":"TASK","taskType":"SAP_R3_VARIANT_COPY","id":"SAP_R3_VARIANT_COPY","icon":"skin/sap.png","name":"SAP R/3 Copy Variant","parent":"SAP_R3_JOBS"},{"processingType":"TASK","taskType":"SAP_R3_VARIANT_UPDATE","id":"SAP_R3_VARIANT_UPDATE","icon":"skin/sap.png","name":"SAP R/3 Update Variant","parent":"SAP_R3_JOBS"},{"processingType":"TASK","taskType":"SAP_R3_VARIANT_DELETE","id":"SAP_R3_VARIANT_DELETE","icon":"skin/sap.png","name":"SAP R/3 Delete Variant","parent":"SAP_R3_JOBS"},{"processingType":"TASK","taskType":"SAP_R3_RAISE_EVENT","id":"SAP_R3_RAISE_EVENT","icon":"skin/sap.png","name":"SAP R/3 Raise Event","parent":"SAP_R3_OTHER"},{"processingType":"SERVICE","serviceType":"SENSOR","sensorType":"SAP_R3_EVENT_SENSOR","id":"SAP_R3_EVENT_SENSOR","icon":"skin/sap.png","name":"SAP R/3 Event Sensor","parent":"SAP_R3_OTHER"},{"processingType":"TASK","taskType":"SAP_R3_COPY_EXISTING_JOB","id":"SAP_R3_COPY_EXISTING_JOB","icon":"skin/sap.png","name":"SAP R/3 Copy Existing Job","parent":"SAP_R3_JOBS"},{"processingType":"TASK","taskType":"SAP_R3_START_SCHEDULED_JOB","id":"SAP_R3_START_SCHEDULED_JOB","icon":"skin/sap.png","name":"SAP R/3 Start Scheduled Job","parent":"SAP_R3_JOBS"},{"processingType":"TASK","taskType":"SAP_R3_JOB_INTERCEPTOR","id":"SAP_R3_JOB_INTERCEPTOR","icon":"skin/sap.png","name":"SAP R/3 Job Interceptor","parent":"SAP_R3_JOBS"},{"processingType":"TASK","id":"SAP_BW_PROCESS_CHAIN","taskType":"SAP_BW_PROCESS_CHAIN","name":"SAP BW Process Chain","icon":"skin/sap.png","parent":"SAP_R3_OTHER"},{"processingType":"TASK","id":"SAP_ARCHIVE","taskType":"SAP_ARCHIVE","name":"SAP Data Archive","icon":"skin/sap.png","parent":"SAP_R3_OTHER"},{"processingType":"TASK","id":"SAP_FUNCTION_MODULE_CALL","taskType":"SAP_FUNCTION_MODULE_CALL","name":"SAP Function Module Call","icon":"skin/sap.png","parent":"SAP_R3_OTHER"},{"processingType":"TASK","id":"SAP_READ_TABLE","taskType":"SAP_READ_TABLE","name":"SAP Read Table","icon":"skin/sap.png","parent":"SAP_R3_OTHER"},{"processingType":"TASK","id":"SAP_CM_PROFILE_ACTIVATE","taskType":"SAP_CM_PROFILE_ACTIVATE","name":"SAP Activate CM Profile","icon":"skin/sap.png","parent":"SAP_R3_OTHER"},{"processingType":"TASK","id":"SAP_CM_PROFILE_DEACTIVATE","taskType":"SAP_CM_PROFILE_DEACTIVATE","name":"SAP Deactivate CM Profile","icon":"skin/sap.png","parent":"SAP_R3_OTHER"},{"processingType":"TASK","id":"SAP_EXPORT_CALENDAR","taskType":"SAP_EXPORT_CALENDAR","name":"SAP Export Calendar","icon":"skin/sap.png","parent":"SAP_R3_OTHER"},{"processingType":"TASK","id":"SAP_EXPORT_JOB","taskType":"SAP_EXPORT_JOB","name":"SAP Export Job","icon":"skin/sap.png","parent":"SAP_R3_OTHER"},{"processingType":"TASK","id":"SAP_MODIFY_INTERCEPTION_CRITERIA","taskType":"SAP_MODIFY_INTERCEPTION_CRITERIA","name":"SAP R/3 Modify Interception Criteria","icon":"skin/sap.png","parent":"SAP_R3_JOBS"},{"processingType":"SERVICE","serviceType":"SENSOR","sensorType":"SAP_R3_INTERCEPTED_JOB_SENSOR","id":"SAP_R3_INTERCEPTED_JOB_SENSOR","icon":"skin/sap.png","name":"SAP R/3 Intercepted Job Sensor","parent":"SAP_R3_JOBS"},{"processingType":"TASK","taskType":"SAP_4H_JOB","id":"SAP_4H_JOB","icon":"skin/sap.png","name":"SAP 4/H Job","parent":"SAP_4H_JOBS"},{"processingType":"TASK","taskType":"SAP_4H_VARIANT_CREATE","id":"SAP_4H_VARIANT_CREATE","icon":"skin/sap.png","name":"SAP 4/H Create Variant","parent":"SAP_4H_JOBS"},{"processingType":"TASK","taskType":"SAP_4H_VARIANT_COPY","id":"SAP_4H_VARIANT_COPY","icon":"skin/sap.png","name":"SAP 4/H Copy Variant","parent":"SAP_4H_JOBS"},{"processingType":"TASK","taskType":"SAP_4H_VARIANT_UPDATE","id":"SAP_4H_VARIANT_UPDATE","icon":"skin/sap.png","name":"SAP 4/H Update Variant","parent":"SAP_4H_JOBS"},{"processingType":"TASK","taskType":"SAP_4H_VARIANT_DELETE","id":"SAP_4H_VARIANT_DELETE","icon":"skin/sap.png","name":"SAP 4/H Delete Variant","parent":"SAP_4H_JOBS"},{"processingType":"TASK","taskType":"SAP_4H_RAISE_EVENT","id":"SAP_4H_RAISE_EVENT","icon":"skin/sap.png","name":"SAP 4/H Raise Event","parent":"SAP_4H_OTHER"},{"processingType":"SERVICE","serviceType":"SENSOR","sensorType":"SAP_4H_EVENT_SENSOR","id":"SAP_4H_EVENT_SENSOR","icon":"skin/sap.png","name":"SAP 4/H Event Sensor","parent":"SAP_4H_OTHER"},{"processingType":"TASK","taskType":"SAP_4H_COPY_EXISTING_JOB","id":"SAP_4H_COPY_EXISTING_JOB","icon":"skin/sap.png","name":"SAP 4/H Copy Existing Job","parent":"SAP_4H_JOBS"},{"processingType":"TASK","taskType":"SAP_4H_START_SCHEDULED_JOB","id":"SAP_4H_START_SCHEDULED_JOB","icon":"skin/sap.png","name":"SAP 4/H Start Scheduled Job","parent":"SAP_4H_JOBS"},{"processingType":"TASK","taskType":"SAP_4H_JOB_INTERCEPTOR","id":"SAP_4H_JOB_INTERCEPTOR","icon":"skin/sap.png","name":"SAP 4/H Job Interceptor","parent":"SAP_4H_JOBS"},{"processingType":"TASK","id":"SAP_4H_BW_PROCESS_CHAIN","taskType":"SAP_4H_BW_PROCESS_CHAIN","name":"SAP 4/H BW Process Chain","icon":"skin/sap.png","parent":"SAP_4H_OTHER"},{"processingType":"TASK","id":"SAP_4H_ARCHIVE","taskType":"SAP_4H_ARCHIVE","name":"SAP 4/H Data Archive","icon":"skin/sap.png","parent":"SAP_4H_OTHER"},{"processingType":"TASK","id":"SAP_4H_FUNCTION_MODULE_CALL","taskType":"SAP_4H_FUNCTION_MODULE_CALL","name":"SAP 4/H Function Module Call","icon":"skin/sap.png","parent":"SAP_4H_OTHER"},{"processingType":"TASK","id":"SAP_4H_READ_TABLE","taskType":"SAP_4H_READ_TABLE","name":"SAP 4/H Read Table","icon":"skin/sap.png","parent":"SAP_4H_OTHER"},{"processingType":"TASK","id":"SAP_4H_CM_PROFILE_ACTIVATE","taskType":"SAP_4H_CM_PROFILE_ACTIVATE","name":"SAP 4/H Activate CM Profile","icon":"skin/sap.png","parent":"SAP_4H_OTHER"},{"processingType":"TASK","id":"SAP_4H_CM_PROFILE_DEACTIVATE","taskType":"SAP_4H_CM_PROFILE_DEACTIVATE","name":"SAP 4/H Deactivate CM Profile","icon":"skin/sap.png","parent":"SAP_4H_OTHER"},{"processingType":"TASK","id":"SAP_4H_EXPORT_CALENDAR","taskType":"SAP_4H_EXPORT_CALENDAR","name":"SAP 4/H Export Calendar","icon":"skin/sap.png","parent":"SAP_4H_OTHER"},{"processingType":"TASK","id":"SAP_4H_EXPORT_JOB","taskType":"SAP_4H_EXPORT_JOB","name":"SAP 4/H Export Job","icon":"skin/sap.png","parent":"SAP_4H_OTHER"},{"processingType":"TASK","id":"SAP_4H_MODIFY_INTERCEPTION_CRITERIA","taskType":"SAP_4H_MODIFY_INTERCEPTION_CRITERIA","name":"SAP 4/H Modify Interception Criteria","icon":"skin/sap.png","parent":"SAP_4H_JOBS"},{"processingType":"SERVICE","serviceType":"SENSOR","sensorType":"SAP_4H_INTERCEPTED_JOB_SENSOR","id":"SAP_4H_INTERCEPTED_JOB_SENSOR","icon":"skin/sap.png","name":"SAP 4/H Intercepted Job Sensor","parent":"SAP_4H_JOBS"},{"processingType":"SERVICE","serviceType":"MONITOR","monitorType":"SAP_4H_JOB_MONITOR","id":"SAP_4H_JOB_MONITOR","icon":"skin/sap.png","name":"SAP 4/H Job Monitor","parent":"SAP_4H_JOBS"},{"processingType":"TASK","id":"SAP_ODATA_API_CALL","taskType":"SAP_ODATA_API_CALL","name":"SAP ODATA API Call","icon":"skin/sap.png","parent":"SAP_4HC"},{"processingType":"TASK","id":"SAP_IBP_JOB","taskType":"SAP_IBP_JOB","name":"SAP IBP Job","icon":"skin/sap.png","parent":"SAP_4HC"},{"processingType":"TASK","id":"SAP_IBP_CREATE_PROCESS","taskType":"SAP_IBP_CREATE_PROCESS","name":"SAP IBP Create Process","icon":"skin/sap.png","parent":"SAP_4HC","inactive":"hideInactiveFeatures"},{"processingType":"TASK","id":"SAP_IBP_DELETE_PROCESS","taskType":"SAP_IBP_DELETE_PROCESS","name":"SAP IBP Delete Process","icon":"skin/sap.png","parent":"SAP_4HC","inactive":"hideInactiveFeatures"},{"processingType":"TASK","id":"SAP_IBP_SET_PROCESS_STEP_STATUS","taskType":"SAP_IBP_SET_PROCESS_STEP_STATUS","name":"SAP IBP Set Process Job Status","icon":"skin/sap.png","parent":"SAP_4HC","inactive":"hideInactiveFeatures"},{"folder":true,"id":"ORACLE_EBS","icon":"skin/oracle.png","name":"Oracle EBS","parent":"ERP"},{"processingType":"TASK","taskType":"ORACLE_EBS_PROGRAM","id":"ORACLE_EBS_PROGRAM","icon":"skin/oracle.png","name":"Oracle EBS Program","parent":"ORACLE_EBS"},{"processingType":"TASK","taskType":"ORACLE_EBS_REQUEST_SET","id":"ORACLE_EBS_REQUEST_SET","icon":"skin/oracle.png","name":"Oracle EBS Request Set","parent":"ORACLE_EBS"},{"processingType":"TASK","taskType":"ORACLE_EBS_EXECUTE_PROGRAM","id":"ORACLE_EBS_EXECUTE_PROGRAM","icon":"skin/oracle.png","name":"Oracle EBS Execute Program","parent":"ORACLE_EBS"},{"processingType":"TASK","taskType":"ORACLE_EBS_EXECUTE_REQUEST_SET","id":"ORACLE_EBS_EXECUTE_REQUEST_SET","icon":"skin/oracle.png","name":"Oracle EBS Execute Request Set","parent":"ORACLE_EBS"},{"id":"ITSM","folder":true,"icon":"skin/compress_repair.png","name":"ITSM","parent":"TASK"},{"id":"JIRA","parent":"ITSM","icon":"skin/jira.png","name":"Jira","folder":true},{"processingType":"SERVICE","serviceType":"SENSOR","sensorType":"JIRA_ISSUE_SENSOR","id":"JIRA_ISSUE_SENSOR","icon":"skin/jira.png","name":"Jira Issue Sensor","parent":"JIRA"},{"processingType":"TASK","id":"JIRA_ADD_ISSUE","parent":"JIRA","icon":"skin/jira.png","name":"Jira Add Issue","taskType":"JIRA_ADD_ISSUE"},{"processingType":"TASK","id":"JIRA_CLOSE_ISSUE","parent":"JIRA","icon":"skin/jira.png","name":"Jira Close Issue","taskType":"JIRA_CLOSE_ISSUE"},{"id":"SERVICE_NOW","parent":"ITSM","icon":"skin/servicenow.png","name":"ServiceNow","folder":true},{"id":"SERVICE_NOW_CREATE_INCIDENT","parent":"SERVICE_NOW","processingType":"TASK","taskType":"SERVICE_NOW_CREATE_INCIDENT","icon":"skin/servicenow.png","name":"ServiceNow Create Incident"},{"id":"SERVICE_NOW_RESOLVE_INCIDENT","parent":"SERVICE_NOW","processingType":"TASK","taskType":"SERVICE_NOW_RESOLVE_INCIDENT","icon":"skin/servicenow.png","name":"ServiceNow Resolve Incident"},{"id":"SERVICE_NOW_CLOSE_INCIDENT","parent":"SERVICE_NOW","processingType":"TASK","taskType":"SERVICE_NOW_CLOSE_INCIDENT","icon":"skin/servicenow.png","name":"ServiceNow Close Incident"},{"id":"SERVICE_NOW_UPDATE_INCIDENT","parent":"SERVICE_NOW","processingType":"TASK","taskType":"SERVICE_NOW_UPDATE_INCIDENT","icon":"skin/servicenow.png","name":"ServiceNow Update Incident"},{"id":"SERVICE_NOW_ADD_ATTACHMENT","parent":"SERVICE_NOW","processingType":"TASK","taskType":"SERVICE_NOW_ADD_ATTACHMENT","icon":"skin/servicenow.png","name":"ServiceNow Add Attachment"},{"id":"SERVICE_NOW_INCIDENT_STATUS_SENSOR","parent":"SERVICE_NOW","processingType":"SERVICE","serviceType":"SENSOR","sensorType":"SERVICE_NOW_INCIDENT_STATUS_SENSOR","icon":"skin/servicenow.png","name":"ServiceNow Incident Status Sensor"},{"id":"BMC_REMEDY","parent":"ITSM","icon":"skin/bmc.ico","name":"BMC Remedy","folder":true},{"id":"BMC_REMEDY_INCIDENT","parent":"BMC_REMEDY","icon":"skin/bmc.ico","processingType":"TASK","name":"BMC Remedy Incident","taskType":"BMC_REMEDY_INCIDENT"},{"id":"PEOPLESOFT","name":"Peoplesoft","icon":"skin/oracle.png","parent":"ERP","folder":true},{"id":"PEOPLESOFT_APPLICATION_ENGINE_TASK","taskType":"PEOPLESOFT_APPLICATION_ENGINE_TASK","name":"Peoplesoft Application Engine","icon":"skin/oracle.png","parent":"PEOPLESOFT","processingType":"TASK"},{"id":"PEOPLESOFT_COBOL_SQL_TASK","name":"Peoplesoft COBOL SQL","icon":"skin/oracle.png","parent":"PEOPLESOFT","inactive":true},{"id":"PEOPLESOFT_CRW_ONLINE_TASK","taskType":"PEOPLESOFT_CRW_ONLINE_TASK","name":"Peoplesoft CRW Online","icon":"skin/oracle.png","parent":"PEOPLESOFT","processingType":"TASK"},{"id":"PEOPLESOFT_CRYSTAL_REPORTS_TASK","taskType":"PEOPLESOFT_CRYSTAL_REPORTS_TASK","name":"Peoplesoft Crystal Reports","icon":"skin/oracle.png","parent":"PEOPLESOFT","processingType":"TASK"},{"id":"PEOPLESOFT_CUBE_BUILDER_TASK","taskType":"PEOPLESOFT_CUBE_BUILDER_TASK","name":"Peoplesoft Cube Builder","icon":"skin/oracle.png","parent":"PEOPLESOFT","processingType":"TASK"},{"id":"PEOPLESOFT_NVISION_TASK","taskType":"PEOPLESOFT_NVISION_TASK","name":"Peoplesoft nVision","icon":"skin/oracle.png","parent":"PEOPLESOFT","processingType":"TASK"},{"id":"PEOPLESOFT_SQR_PROCESS_TASK","taskType":"PEOPLESOFT_SQR_PROCESS_TASK","name":"Peoplesoft SQR Process","icon":"skin/oracle.png","parent":"PEOPLESOFT","processingType":"TASK"},{"id":"PEOPLESOFT_SQR_REPORT_TASK","taskType":"PEOPLESOFT_SQR_REPORT_TASK","name":"Peoplesoft SQR Report","icon":"skin/oracle.png","parent":"PEOPLESOFT","processingType":"TASK"},{"id":"PEOPLESOFT_WINWORD_TASK","taskType":"PEOPLESOFT_WINWORD_TASK","name":"Peoplesoft Winword","icon":"skin/oracle.png","parent":"PEOPLESOFT","processingType":"TASK"},{"id":"PEOPLESOFT_JOB_TASK","taskType":"PEOPLESOFT_JOB_TASK","name":"Peoplesoft Job","icon":"skin/oracle.png","parent":"PEOPLESOFT","processingType":"TASK"},{"id":"WLA","folder":true,"icon":"skin/gears.png","name":"Workload Automation","parent":"TASK"},{"id":"AUTOMATE_NOW_TRIGGER_EVENT","parent":"WLA","icon":"skin/favicon.png","name":"ANOW! Trigger Event","processingType":"TASK","taskType":"AUTOMATE_NOW_TRIGGER_EVENT"},{"id":"APACHE_AIRFLOW_RUN_DAG","parent":"WLA","icon":"skin/airflow.png","name":"Run Apache Airflow DAG","processingType":"TASK","taskType":"APACHE_AIRFLOW_RUN_DAG"},{"id":"POWER_AUTOMATE_EXECUTE_FLOW","parent":"WLA","icon":"skin/powerAutomate.png","name":"Power Automate Execute Flow","processingType":"TASK","taskType":"POWER_AUTOMATE_EXECUTE_FLOW"},{"id":"ANSIBLE_PLAYBOOK","parent":"WLA","icon":"skin/ansible.png","name":"Ansible playbook","processingType":"TASK","taskType":"ANSIBLE_PLAYBOOK"},{"id":"ANSIBLE_PLAYBOOK_PATH","parent":"WLA","icon":"skin/ansible.png","name":"Ansible script","processingType":"TASK","taskType":"ANSIBLE_PLAYBOOK_PATH"},{"folder":true,"id":"CTRL_M","icon":"skin/bmc.png","name":"Ctrl-M","parent":"WLA"},{"id":"CTRLM_ADD_CONDITION","parent":"CTRL_M","icon":"skin/bmc.png","name":"Add Condition","processingType":"TASK","taskType":"CTRLM_ADD_CONDITION"},{"id":"CTRLM_DELETE_CONDITION","parent":"CTRL_M","icon":"skin/bmc.png","name":"Delete Condition","processingType":"TASK","taskType":"CTRLM_DELETE_CONDITION"},{"id":"CTRLM_ORDER_JOB","parent":"CTRL_M","icon":"skin/bmc.png","name":"Order Job","processingType":"TASK","taskType":"CTRLM_ORDER_JOB"},{"id":"CTRLM_CREATE_JOB","parent":"CTRL_M","icon":"skin/bmc.png","name":"Create Job","processingType":"TASK","taskType":"CTRLM_CREATE_JOB"},{"folder":true,"id":"CTRL_M_RESOURCE","icon":"skin/bmc.png","name":"Ctrl-M Resource","parent":"CTRL_M"},{"id":"CTRLM_RESOURCE_TABLE_ADD","parent":"CTRL_M_RESOURCE","icon":"skin/bmc.png","name":"Add Resource","processingType":"TASK","taskType":"CTRLM_RESOURCE_TABLE_ADD"},{"id":"CTRLM_RESOURCE_TABLE_UPDATE","parent":"CTRL_M_RESOURCE","icon":"skin/bmc.png","name":"Update Resource","processingType":"TASK","taskType":"CTRLM_RESOURCE_TABLE_UPDATE"},{"id":"CTRLM_RESOURCE_TABLE_DELETE","parent":"CTRL_M_RESOURCE","icon":"skin/bmc.png","name":"Delete Resource","processingType":"TASK","taskType":"CTRLM_RESOURCE_TABLE_DELETE"},{"folder":true,"id":"INTERNAL","icon":"skin/milestone.png","name":"Internal Task"},{"folder":true,"id":"PROCESSING","icon":"skin/gear.png","name":"Processing","parent":"INTERNAL"},{"processingType":"TASK","taskType":"RESTART","id":"RESTART","icon":"skin/restart.png","name":"Restart","parent":"PROCESSING"},{"processingType":"TASK","taskType":"FORCE_COMPLETED","id":"FORCE_COMPLETED","icon":"skin/accept.png","name":"Force Completed","parent":"PROCESSING"},{"processingType":"TASK","taskType":"FORCE_FAILED","id":"FORCE_FAILED","icon":"skin/forceFailed.png","name":"Force Failed","parent":"PROCESSING"},{"processingType":"TASK","taskType":"FORCE_READY","id":"FORCE_READY","icon":"skin/exe.png","name":"Force Launch","parent":"PROCESSING"},{"processingType":"TASK","taskType":"HOLD","id":"HOLD","icon":"skin/hold.png","name":"Hold","parent":"PROCESSING"},{"processingType":"TASK","taskType":"RESUME","id":"RESUME","icon":"skin/resume.png","name":"Resume","parent":"PROCESSING"},{"processingType":"TASK","taskType":"ABORT","id":"ABORT","icon":"skin/kill.png","name":"Abort","parent":"PROCESSING"},{"processingType":"TASK","taskType":"KILL","id":"KILL","icon":"skin/kill.png","name":"Kill","parent":"PROCESSING"},{"processingType":"TASK","taskType":"SKIP_ON","id":"SKIP_ON","icon":"skin/passByOn.png","name":"Skip On","parent":"PROCESSING"},{"processingType":"TASK","taskType":"SKIP_OFF","id":"SKIP_OFF","icon":"skin/passByOff.png","name":"Skip Off","parent":"PROCESSING"},{"processingType":"TASK","taskType":"PROCESSING_ACTION_SKIP_ON","id":"PROCESSING_ACTION_SKIP_ON","icon":"skin/passByOn.png","name":"Skip On Action","parent":"PROCESSING"},{"processingType":"TASK","taskType":"PROCESSING_ACTION_SKIP_OFF","id":"PROCESSING_ACTION_SKIP_OFF","icon":"skin/passByOff.png","name":"Skip Off Action","parent":"PROCESSING"},{"processingType":"TASK","taskType":"ARCHIVE","id":"ARCHIVE","icon":"skin/archive.png","name":"Archive","parent":"PROCESSING"},{"processingType":"TASK","taskType":"SET_PRIORITY","id":"SET_PRIORITY","icon":"skin/numeric_stepper.png","name":"Set Priority","parent":"PROCESSING"},{"processingType":"TASK","taskType":"SET_STATUS_CODE","id":"SET_STATUS_CODE","icon":"skin/sort_number.png","name":"Set Status Code","parent":"PROCESSING"},{"processingType":"TASK","taskType":"SET_CONTEXT_VARIABLE_VALUE","id":"SET_CONTEXT_VARIABLE_VALUE","icon":"skin/pi_math--pencil.png","name":"Set context variable","parent":"PROCESSING"},{"processingType":"TASK","taskType":"SET_CONTEXT_VARIABLE_VALUES","id":"SET_CONTEXT_VARIABLE_VALUES","icon":"skin/pi_math--pencil.png","name":"Set multiple context variables","parent":"PROCESSING"},{"processingType":"TASK","taskType":"PROCESSING_RUN_NOW","id":"PROCESSING_RUN_NOW","icon":"skin/gear.png","name":"Add processing from template","parent":"PROCESSING"},{"processingType":"TASK","taskType":"CHECK_PROCESSING_STATE","id":"CHECK_PROCESSING_STATE","icon":"skin/system-monitor.png","name":"Check processing state","parent":"PROCESSING"},{"processingType":"TASK","taskType":"ADD_TAG","id":"ADD_TAG","icon":"skin/price_tag_plus.png","name":"Add Tag","parent":"PROCESSING"},{"processingType":"TASK","taskType":"REMOVE_TAG","id":"REMOVE_TAG","icon":"skin/price_tag_minus.png","name":"Remove Tag","parent":"PROCESSING"},{"processingType":"TASK","taskType":"SET_FOLDER","id":"SET_FOLDER","icon":"skin/folder.png","name":"Set Folder","parent":"PROCESSING"},{"processingType":"TASK","taskType":"PROCESSING_REGISTER_STATE","id":"PROCESSING_REGISTER_STATE","icon":"skin/system-monitor.png","name":"Register Processing State","parent":"PROCESSING"},{"processingType":"TASK","taskType":"PROCESSING_UNREGISTER_STATE","id":"PROCESSING_UNREGISTER_STATE","icon":"skin/system-monitor.png","name":"Unregister Processing State","parent":"PROCESSING"},{"processingType":"TASK","taskType":"PROCESSING_CLEAR_STATE_REGISTRY","id":"PROCESSING_CLEAR_STATE_REGISTRY","icon":"skin/system-monitor.png","name":"Clear Processing Registry","parent":"PROCESSING"},{"processingType":"TASK","taskType":"PROCESSING_ADD_NOTE","id":"PROCESSING_ADD_NOTE","icon":"skin/note_add.png","name":"Add Note","parent":"PROCESSING"},{"folder":true,"id":"RESOURCE","icon":"skin/traffic-light.png","name":"Resource","parent":"INTERNAL"},{"folder":true,"id":"DATA_SOURCE","icon":"skin/database.png","name":"Data Source","parent":"INTERNAL"},{"processingType":"TASK","id":"DATA_SOURCE_GET","name":"Get Data Source Entry","icon":"skin/database_go.png","parent":"DATA_SOURCE","taskType":"DATA_SOURCE_GET"},{"processingType":"TASK","id":"DATA_SOURCE_SET","name":"Set Data Source Entry","icon":"skin/database_add.png","parent":"DATA_SOURCE","taskType":"DATA_SOURCE_SET"},{"processingType":"TASK","id":"DATA_SOURCE_REMOVE","name":"Remove Data Source Entry","icon":"skin/database_delete.png","parent":"DATA_SOURCE","taskType":"DATA_SOURCE_REMOVE"},{"folder":true,"id":"SET_RESOURCE","icon":"skin/traffic-light--pencil.png","name":"Set Resource","parent":"RESOURCE"},{"processingType":"TASK","id":"SET_SEMAPHORE_STATE","name":"Set semaphore state","icon":"skin/traffic-light--pencil.png","parent":"SET_RESOURCE","taskType":"SET_SEMAPHORE_STATE"},{"processingType":"TASK","id":"SET_TIME_WINDOW_STATE","name":"Set time window state","icon":"skin/clock--pencil.png","parent":"SET_RESOURCE","taskType":"SET_TIME_WINDOW_STATE"},{"processingType":"TASK","id":"SET_STOCK_TOTAL_PERMITS","name":"Set stock total permits","icon":"skin/stock--pencil.png","parent":"SET_RESOURCE","taskType":"SET_STOCK_TOTAL_PERMITS"},{"processingType":"TASK","id":"SET_VARIABLE_VALUE","name":"Set variable","icon":"skin/pi_math--pencil.png","parent":"SET_RESOURCE","taskType":"SET_VARIABLE_VALUE"},{"processingType":"TASK","id":"SET_PHYSICAL_RESOURCE","name":"Set physical resource","icon":"skin/memory.png","parent":"SET_RESOURCE","taskType":"SET_PHYSICAL_RESOURCE"},{"processingType":"TASK","id":"SET_METRIC","name":"Set metric","icon":"skin/gauge.png","parent":"SET_RESOURCE","taskType":"SET_METRIC"},{"processingType":"TASK","id":"TRIGGER_EVENT","name":"Trigger Event","icon":"skin/arrow-out.png","parent":"SET_RESOURCE","taskType":"TRIGGER_EVENT"},{"folder":true,"id":"CHECK_RESOURCE","icon":"skin/traffic-light--check.png","name":"Check Resource","parent":"RESOURCE"},{"processingType":"TASK","id":"CHECK_SEMAPHORE_STATE","name":"Check semaphore state","icon":"skin/traffic-light--check.png","parent":"CHECK_RESOURCE","taskType":"CHECK_SEMAPHORE_STATE"},{"processingType":"TASK","id":"CHECK_TIME_WINDOW_STATE","name":"Check time window state","icon":"skin/clock--check.png","parent":"CHECK_RESOURCE","taskType":"CHECK_TIME_WINDOW_STATE"},{"processingType":"TASK","id":"CHECK_STOCK_AVAILABLE_PERMITS","name":"Check stock available permits","icon":"skin/stock--check.png","parent":"CHECK_RESOURCE","taskType":"CHECK_STOCK_AVAILABLE_PERMITS"},{"processingType":"TASK","id":"CHECK_CALENDAR","name":"Check calendar","icon":"skin/date_control.png","parent":"CHECK_RESOURCE","taskType":"CHECK_CALENDAR"},{"processingType":"TASK","id":"CHECK_STOCK_TOTAL_PERMITS","name":"Check stock total permits","icon":"skin/stock-total--check.png","parent":"CHECK_RESOURCE","taskType":"CHECK_STOCK_TOTAL_PERMITS"},{"processingType":"TASK","id":"CHECK_LOCK_STATE","name":"Check lock state","icon":"skin/lock--check.png","parent":"CHECK_RESOURCE","taskType":"CHECK_LOCK_STATE"},{"processingType":"TASK","id":"CHECK_VARIABLE_VALUE","name":"Check variable value","icon":"skin/pi_math--check.png","parent":"CHECK_RESOURCE","taskType":"CHECK_VARIABLE_VALUE"},{"processingType":"TASK","id":"CHECK_PHYSICAL_RESOURCE","name":"Check physical resource","icon":"skin/memory.png","parent":"CHECK_RESOURCE","taskType":"CHECK_PHYSICAL_RESOURCE"},{"processingType":"TASK","id":"CHECK_METRIC","name":"Check metric","icon":"skin/gauge.png","parent":"CHECK_RESOURCE","taskType":"CHECK_METRIC"},{"processingType":"TASK","taskType":"RESOURCE_ADD_TAG","id":"RESOURCE_ADD_TAG","icon":"skin/price_tag_plus.png","name":"Resource Add Tag","parent":"RESOURCE"},{"processingType":"TASK","taskType":"RESOURCE_REMOVE_TAG","id":"RESOURCE_REMOVE_TAG","icon":"skin/price_tag_minus.png","name":"Resource Remove Tag","parent":"RESOURCE"},{"processingType":"TASK","taskType":"RESOURCE_SET_FOLDER","id":"RESOURCE_SET_FOLDER","icon":"skin/folder.png","name":"Set Resource Folder","parent":"RESOURCE"},{"folder":true,"id":"SERVER_NODE","icon":"skin/servers.png","name":"Server Node","parent":"INTERNAL"},{"processingType":"TASK","taskType":"SERVER_NODE_HOLD","id":"SERVER_NODE_HOLD","icon":"skin/hold.png","name":"Server Node Hold","parent":"SERVER_NODE"},{"processingType":"TASK","taskType":"SERVER_NODE_RESUME","id":"SERVER_NODE_RESUME","icon":"skin/resume.png","name":"Server Node Resume","parent":"SERVER_NODE"},{"processingType":"TASK","taskType":"SERVER_NODE_SKIP_ON","id":"SERVER_NODE_SKIP_ON","icon":"skin/passByOn.png","name":"Server Node Skip On","parent":"SERVER_NODE"},{"processingType":"TASK","taskType":"SERVER_NODE_SKIP_OFF","id":"SERVER_NODE_SKIP_OFF","icon":"skin/passByOff.png","name":"Server Node Skip Off","parent":"SERVER_NODE"},{"processingType":"TASK","taskType":"SERVER_NODE_ABORT_ALL","id":"SERVER_NODE_ABORT_ALL","icon":"skin/kill.png","name":"Server Node Abort All","parent":"SERVER_NODE"},{"processingType":"TASK","taskType":"SERVER_NODE_KILL_ALL","id":"SERVER_NODE_KILL_ALL","icon":"skin/kill.png","name":"Server Node Kill All","parent":"SERVER_NODE"},{"processingType":"TASK","taskType":"SERVER_NODE_STOP","id":"SERVER_NODE_STOP","icon":"skin/stop.png","name":"Server Node Stop","parent":"SERVER_NODE"},{"processingType":"TASK","taskType":"SERVER_NODE_ADD_TAG","id":"SERVER_NODE_ADD_TAG","icon":"skin/price_tag_plus.png","name":"Server Node Add Tag","parent":"SERVER_NODE"},{"processingType":"TASK","taskType":"SERVER_NODE_REMOVE_TAG","id":"SERVER_NODE_REMOVE_TAG","icon":"skin/price_tag_minus.png","name":"Server Node Remove Tag","parent":"SERVER_NODE"},{"processingType":"TASK","taskType":"SERVER_NODE_SET_FOLDER","id":"SERVER_NODE_SET_FOLDER","icon":"skin/folder.png","name":"Server Node Set Folder","parent":"SERVER_NODE"},{"processingType":"TASK","taskType":"SERVER_NODE_SET_TOTAL_WEIGHT_CAPACITY","id":"SERVER_NODE_SET_TOTAL_WEIGHT_CAPACITY","icon":"skin/folder.png","name":"Server Node Set Capacity","parent":"SERVER_NODE"},{"folder":true,"id":"PROCESSING_TEMPLATE","icon":"skin/clock.png","name":"Processing Template","parent":"INTERNAL"},{"processingType":"TASK","taskType":"PROCESSING_TEMPLATE_HOLD","id":"PROCESSING_TEMPLATE_HOLD","icon":"skin/hold.png","name":"Processing Template Hold","parent":"PROCESSING_TEMPLATE"},{"processingType":"TASK","taskType":"PROCESSING_TEMPLATE_RESUME","id":"PROCESSING_TEMPLATE_RESUME","icon":"skin/resume.png","name":"Processing Template Resume","parent":"PROCESSING_TEMPLATE"},{"processingType":"TASK","taskType":"PROCESSING_TEMPLATE_SKIP_ON","id":"PROCESSING_TEMPLATE_SKIP_ON","icon":"skin/passByOn.png","name":"Processing Template Skip On","parent":"PROCESSING_TEMPLATE"},{"processingType":"TASK","taskType":"PROCESSING_TEMPLATE_SKIP_OFF","id":"PROCESSING_TEMPLATE_SKIP_OFF","icon":"skin/passByOff.png","name":"Processing Template Skip Off","parent":"PROCESSING_TEMPLATE"},{"folder":true,"id":"MAINTENANCE","icon":"skin/gear.png","name":"Maintenance","parent":"INTERNAL"},{"processingType":"TASK","taskType":"ARCHIVE_INTERVAL","id":"ARCHIVE_INTERVAL","icon":"skin/archive.png","name":"Archive old processing items","parent":"MAINTENANCE"},{"processingType":"TASK","taskType":"ARCHIVE_CLEANUP","id":"ARCHIVE_CLEANUP","icon":"skin/archive.png","name":"Archive cleanup","parent":"MAINTENANCE"},{"processingType":"TASK","taskType":"RECALCULATE_STATISTICS","id":"RECALCULATE_STATISTICS","icon":"skin/calculator.png","name":"Recalculate Statistic","parent":"MAINTENANCE"},{"processingType":"TASK","taskType":"DESIGN_BACKUP","id":"DESIGN_BACKUP","icon":"skin/drive-download.png","name":"Design Backup","parent":"MAINTENANCE"},{"processingType":"TASK","taskType":"DESIGN_IMPORT","id":"DESIGN_IMPORT","icon":"skin/drive-download.png","name":"Design Import","parent":"MAINTENANCE"},{"folder":true,"id":"OTHER","icon":"skin/alarm.png","name":"Other","parent":"INTERNAL"},{"processingType":"TASK","taskType":"WAIT","id":"WAIT","icon":"skin/alarm.png","name":"Wait","parent":"OTHER"},{"processingType":"TASK","taskType":"CHECK_TIME","id":"CHECK_TIME","icon":"skin/clock.png","name":"Check Time","parent":"OTHER"},{"id":"USER_TASKS","name":"User","icon":"skin/user.png","parent":"INTERNAL","folder":true},{"processingType":"TASK","taskType":"USER_CONFIRM","id":"USER_CONFIRM","icon":"skin/thumbUp.png","name":"User confirmation","parent":"USER_TASKS"},{"processingType":"TASK","taskType":"USER_INPUT","id":"USER_INPUT","icon":"skin/pencil.png","name":"User input","parent":"USER_TASKS"},{"processingType":"TASK","taskType":"NOTIFY_GROUP","id":"NOTIFY_GROUP","icon":"skin/users.png","name":"Notify Group","parent":"USER_TASKS"},{"processingType":"TASK","taskType":"NOTIFY_CHANNEL","id":"NOTIFY_CHANNEL","icon":"skin/mail_server_exim.png","name":"Notify Channel","parent":"USER_TASKS"},{"processingType":"TASK","taskType":"NOTIFY_EMAIL","id":"NOTIFY_EMAIL","icon":"skin/mail.png","name":"Notify Email","parent":"USER_TASKS"},{"processingType":"TASK","taskType":"ADHOC_REPORT_SEND","id":"ADHOC_REPORT_SEND","icon":"skin/table.png","name":"Adhoc Report Send","parent":"USER_TASKS"},{"processingType":"TASK","id":"AE","icon":"skin/terminal.gif","name":"AE","parent":"INTERNAL","folder":true},{"processingType":"TASK","taskType":"AE_SCRIPT","id":"AE_SCRIPT","icon":"skin/terminal.gif","name":"AE Script","parent":"AE"},{"processingType":"WORKFLOW","id":"WORKFLOW","name":"Workflow","icon":"skin/diagram.png","folder":true},{"processingType":"WORKFLOW","workflowType":"STANDARD","id":"STANDARD","icon":"skin/diagram.png","name":"Workflow","parent":"WORKFLOW"},{"processingType":"WORKFLOW","workflowType":"BROADCAST","id":"BROADCAST","icon":"skin/rss.png","name":"Broadcast","parent":"WORKFLOW"},{"processingType":"WORKFLOW","workflowType":"FOR_EACH","id":"FOR_EACH","icon":"skin/ordered_list.png","name":"For Each","parent":"WORKFLOW"},{"processingType":"WORKFLOW","workflowType":"SWITCH","id":"SWITCH","icon":"skin/switch.png","name":"Switch","parent":"WORKFLOW"},{"processingType":"WORKFLOW","workflowType":"CYCLE","id":"CYCLE","icon":"skin/cycle.png","name":"Cycle","parent":"WORKFLOW"},{"processingType":"WORKFLOW","workflowType":"TIME_SERIES","id":"TIME_SERIES","icon":"skin/ui-paginator.png","name":"Time Series","parent":"WORKFLOW"},{"processingType":"SERVICE","serviceType":"SENSOR","sensorType":"FILE_SENSOR","id":"FILE_SENSOR","icon":"skin/fileWatcher.png","name":"File Sensor","parent":"FILE_PROCESSING"},{"id":"RPA","icon":"skin/robot.png","name":"Robotic Process Automation","parent":"TASK","folder":true},{"processingType":"TASK","id":"UI_PATH","icon":"skin/uipath.ico","name":"UiPath","parent":"RPA","taskType":"UI_PATH"},{"processingType":"TASK","id":"BLUE_PRISM","icon":"skin/blueprism.ico","name":"Blue Prism","parent":"RPA","taskType":"BLUE_PRISM"},{"processingType":"TASK","id":"ROBOT_FRAMEWORK_START_ROBOT","icon":"skin/robotFramework.png","name":"Robot Framework Start Robot","parent":"RPA","taskType":"ROBOT_FRAMEWORK_START_ROBOT"},{"id":"BI","icon":"skin/table_chart.png","name":"Business Intelligence","parent":"TASK","folder":true},{"id":"TABLEAU","icon":"skin/tableau.ico","name":"Tableau","parent":"BI","folder":true},{"processingType":"TASK","id":"TABLEAU_REFRESH_EXTRACT","icon":"skin/tableau.ico","name":"Tableau Refresh Extract","parent":"TABLEAU","taskType":"TABLEAU_REFRESH_EXTRACT"},{"id":"MICROSOFT_POWER_BI","icon":"skin/powerBi.ico","name":"Microsoft Power BI","parent":"BI","folder":true},{"processingType":"TASK","id":"MICROSOFT_POWER_BI_DATASET_REFRESH","icon":"skin/powerBi.ico","name":"Microsoft Power BI Refresh Data Set","parent":"MICROSOFT_POWER_BI","taskType":"MICROSOFT_POWER_BI_DATASET_REFRESH"},{"processingType":"TASK","id":"MICROSOFT_POWER_BI_DATAFLOW_REFRESH","icon":"skin/powerBi.ico","name":"Microsoft Power BI Refresh Data Flow","parent":"MICROSOFT_POWER_BI","taskType":"MICROSOFT_POWER_BI_DATAFLOW_REFRESH"},{"id":"INSTANT_MESSAGING","name":"Instant Messaging","icon":"skin/comment_edit.png","parent":"TASK","folder":true},{"processingType":"TASK","id":"TELEGRAM_MESSAGE","icon":"skin/telegram.png","name":"Telegram Message","parent":"INSTANT_MESSAGING","taskType":"TELEGRAM_MESSAGE"},{"processingType":"TASK","id":"WHATSAPP_MESSAGE","icon":"skin/whatsapp.png","name":"WhatsApp Message","parent":"INSTANT_MESSAGING","taskType":"WHATSAPP_MESSAGE"},{"processingType":"TASK","id":"TEAMS_CHAT_MESSAGE","icon":"skin/teams.png","name":"Teams Message","parent":"INSTANT_MESSAGING","taskType":"TEAMS_CHAT_MESSAGE"},{"processingType":"SERVICE","serviceType":"SENSOR","sensorType":"SQL_SENSOR","id":"SQL_SENSOR","icon":"skin/database-sql.png","name":"SQL Sensor","parent":"SQL"},{"processingType":"SERVICE","serviceType":"SENSOR","sensorType":"Z_OS_JES_JOB_SENSOR","id":"Z_OS_JES_JOB_SENSOR","icon":"skin/zos.png","name":"z/OS JES Job Sensor","parent":"Z_OS"},{"processingType":"SERVICE","serviceType":"MONITOR","monitorType":"SH_MONITOR","id":"SH_MONITOR","icon":"skin/terminal.gif","name":"Shell Monitor","parent":"CODE"},{"processingType":"SERVICE","serviceType":"MONITOR","monitorType":"PYTHON_MONITOR","id":"PYTHON_MONITOR","icon":"skin/python.png","name":"Python Monitor","parent":"CODE"},{"processingType":"SERVICE","serviceType":"MONITOR","monitorType":"PERL_MONITOR","id":"PERL_MONITOR","icon":"skin/perl.png","name":"Perl Monitor","parent":"CODE"},{"processingType":"SERVICE","serviceType":"MONITOR","monitorType":"RUBY_MONITOR","id":"RUBY_MONITOR","icon":"skin/ruby.png","name":"Ruby Monitor","parent":"CODE"},{"processingType":"SERVICE","serviceType":"MONITOR","monitorType":"GROOVY_MONITOR","id":"GROOVY_MONITOR","icon":"skin/groovy.png","name":"Groovy Monitor","parent":"CODE"},{"processingType":"SERVICE","serviceType":"MONITOR","monitorType":"POWERSHELL_MONITOR","id":"POWERSHELL_MONITOR","icon":"skin/powershell.png","name":"PowerShell Monitor","parent":"CODE"},{"processingType":"SERVICE","serviceType":"MONITOR","monitorType":"HTTP_MONITOR","id":"HTTP_MONITOR","icon":"skin/http.png","name":"HTTP Monitor","parent":"WEB"},{"folder":true,"id":"OPERATING_SYSTEM_MONITOR","icon":"skin/system-monitor.png","name":"OS Monitors","parent":"TASK"},{"processingType":"SERVICE","serviceType":"MONITOR","monitorType":"SYSTEM_MONITOR","id":"SYSTEM_MONITOR","icon":"skin/memory.png","name":"System Monitor","parent":"OPERATING_SYSTEM_MONITOR"},{"processingType":"SERVICE","serviceType":"MONITOR","monitorType":"SYSTEM_PROCESS_MONITOR","id":"SYSTEM_PROCESS_MONITOR","icon":"skin/system-monitor.png","name":"System Process Monitor","parent":"OPERATING_SYSTEM_MONITOR"},{"processingType":"SERVICE","serviceType":"MONITOR","monitorType":"SAP_R3_JOB_MONITOR","id":"SAP_R3_JOB_MONITOR","icon":"skin/sap.png","name":"SAP R/3 Job Monitor","parent":"SAP_R3_JOBS"},{"id":"SLA","title":"Service Manager","name":"Service Manager","icon":"skin/traffic-light.png","folder":true},{"id":"SLA_SERVICE_MANAGER","title":"Service Level Agreement","icon":"skin/traffic-light.png","processingType":"SERVICE","serviceType":"SERVICE_MANAGER","serviceManagerType":"SLA_SERVICE_MANAGER","name":"Service Level Agreement","parent":"SLA"},{"processingType":"SERVICE","serviceType":"MONITOR","monitorType":"PROCESSING_BASELINE_DEVIATION_MONITOR","id":"PROCESSING_BASELINE_DEVIATION_MONITOR","icon":"skin/chart_down_color.png","name":"Baseline Deviation Monitor","parent":"PROCESSING"},{"processingType":"SERVICE","serviceType":"MONITOR","monitorType":"PROCESSING_DEADLINE_MONITOR","id":"PROCESSING_DEADLINE_MONITOR","icon":"skin/chart_stock.png","name":"Processing Deadline Monitor","parent":"SLA"},{"processingType":"TRIGGER","id":"TRIGGER","name":"Trigger","icon":"skin/arrow-out.png","folder":true},{"processingType":"TRIGGER","triggerType":"SCHEDULE","id":"SCHEDULE","icon":"skin/clock.png","name":"Time Schedule","parent":"TRIGGER"},{"processingType":"TRIGGER","triggerType":"USER","id":"USER","icon":"skin/user.png","name":"User","parent":"TRIGGER"},{"processingType":"TRIGGER","triggerType":"EVENT","id":"EVENT","icon":"skin/arrow-out.png","name":"Event Schedule","parent":"TRIGGER"},{"processingType":"TRIGGER","triggerType":"SELF_SERVICE","id":"SELF_SERVICE","icon":"skin/user.png","name":"Self Service","parent":"TRIGGER"},{"parent":"NONEXISTING_ITEM_TO_HIDE_FROM_VIEW","processingType":"TASK","taskType":"TRIGGER_ITEM","id":"TRIGGER_ITEM","name":"Trigger Item","icon":"skin/exe.png","inactive":true},{"processingType":"TASK","taskType":"PROCESSING_OBSERVER","id":"PROCESSING_OBSERVER","icon":"skin/emotion_eye.png","name":"Processing Observer","parent":"NONEXISTING_ITEM_TO_HIDE_FROM_VIEW","inactive":true}]' | ConvertFrom-Json
    If ($JustGiveMeTheJSON -eq $true) {
        Return $TaskTypesJson
    }
    [array]$TaskTypesArray = $TaskTypesJson | ForEach-Object { [PSCustomObject]@{ Parent = $_.parent; Id = $_.id; Name = $_.name; } }
    Return $TaskTypesArray
}

#endregion

#Region - Time Triggers

Function Read-AutomateNOWTimeTrigger {
    <#
    .SYNOPSIS
    Gets the Processing Time Triggers from an instance of AutomateNOW!

    .DESCRIPTION
    Gets the Processing Time Triggers from an instance of AutomateNOW!

    .PARAMETER ScheduleTemplate
    Optional [ANOWScheduleTemplate] object in case you want to retrieve the Processing Time Triggers that are associated to a particular Schedule Template. Use Get-AutomateNOWScheduleTemplate to get this object.

    .PARAMETER timeTriggerType
    Optional string to filter the results on the type of Processing Time Trigger. Valid values are: TIMESTAMP, DAILY, REPEATING, CRON, CALENDAR_INTERVAL

    .PARAMETER startRow
    Integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .INPUTS
    To retrieve all results do not specify a ScheduleTemplate. You can send [ANOWScheduleTemplate] objects either individually or from the pipeline.

    .OUTPUTS
    An array of one or more [ANOWProcessingTimeTrigger] class objects that are linked to the provided [ANOWScheduleTemplate] object

    .EXAMPLE
    Gets the first 100 Processing Time Triggers

    Read-AutomateNOWTimeTrigger

    .EXAMPLE
    Gets the first 100 Processing Time Triggers of type 'DAILY'

    Read-AutomateNOWTimeTrigger -timeTriggerType DAILY

    .EXAMPLE
    Gets the first 100 Processing Time Triggers that are associated with Schedule Template 'ScheduleTemplate1'

    Read-AutomateNOWTimeTrigger -ScheduleTemplate (Get-AutomateNOWScheduleTemplate -Id 'ScheduleTemplate1')

    .EXAMPLE
    Gets the first 100 Processing Time Triggers that are associated with Schedule Template 'ScheduleTemplate1' of type 'DAILY'

    Read-AutomateNOWTimeTrigger -ScheduleTemplate (Get-AutomateNOWScheduleTemplate -Id 'ScheduleTemplate1') -timeTriggerType DAILY

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Use the -ScheduleTemplate parameter if you want to retrieve only the Time Triggers that are associated (connected to) a particular Schedule Template.

    #>
    [OutputType([ANOWProcessingTimeTrigger[]])]
    [Cmdletbinding()]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$' })]
        [Parameter(Mandatory = $true, ParameterSetName = 'Id')]
        [string]$Id,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default', ValueFromPipeline = $True)]
        [ANOWScheduletemplate]$ScheduleTemplate,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [ANOWProcessingTimeTrigger_timeTriggerType]$timeTriggerType,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$sortBy = 'dateCreated',
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$Descending
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }

        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [string]$command = '/processingTimeTrigger/read?'
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Id.Length -gt 0 -or $ScheduleTemplate.id.Length -gt 0) {
            If ($_.Id.Length -gt 0) {
                [ANOWScheduleTemplate]$ScheduleTemplate = $_
            }
            [string]$ScheduleTemplate_id = $ScheduleTemplate.id
        }
        If ($Id.Length -gt 0) {
            $Body.'id' = $Id
        }
        Else {
            If ($ScheduleTemplate_id.Length -gt 0 -or $timeTriggerType.length -gt 0) {
                $Body.Add('operator', 'and')
                $Body.Add('_constructor', 'AdvancedCriteria')
                If ($ScheduleTemplate_id.Length -gt 0) {
                    $Body.Add('criteria1', '{"fieldName":"processingTemplate","operator":"equals","value":"' + $ScheduleTemplate_id + '"}')
                }
                If ($timeTriggerType.length -gt 0) {
                    $Body.Add('criteria2', '{"fieldName":"timeTriggerType","operator":"equals","value":"' + $timeTriggerType + '"}')
                }
            }
            If ($Descending -eq $true) {
                $Body.'_sortBy' = '-' + $sortBy
            }
            Else {
                $Body.'_sortBy' = $sortBy
            }
            $Body.Add('_startRow', $startRow)
            $Body.Add('_endRow', $endRow)
        }
        $Body.Add('_textMatchStyle', 'exact')
        $Body.Add('_operationType', 'fetch')
        $Body.Add('isc_metaDataPrefix', '_')
        $Body.Add('isc_dataFormat', 'json')
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ($command + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        [int32]$ProcessingTimeTriggersCount = $results.response.data.count
        If ($ProcessingTimeTriggersCount -gt 0) {
            $Error.Clear()
            Try {
                [ANOWProcessingTimeTrigger[]]$ProcessingTimeTriggers = ForEach ($result in $results.response.data) {
                    [string]$TimeTrigger_Id = $result.Id
                    If ($result.timeZone.Length -gt 0) {
                        [string]$trigger_timezone = $result.timeZone
                        [ANOWTimeZone]$timezone = Get-AutomateNOWTimeZone -Id $trigger_timezone
                        $result.timeZone = $timezone
                    }
                    If ($result.processingTemplate.Length -gt 0) {
                        $result.processingTemplate = $ScheduleTemplate
                    }
                    If ($result.Calendar.Length -gt 0) {
                        [string]$Calendar_Name = $result.Calendar
                        $Error.Clear()
                        Try {
                            [ANOWCalendar]$Calendar = Get-AutomateNOWCalendar -Id $Calendar_Name
                            $result.Calendar = $Calendar
                        }
                        Catch {
                            [string]$Message = $_.Exception.Message
                            Write-Warning -Message "Get-AutomateNOWCalendar failed to retrieve the calendar [$Calendar_Name] from Time Trigger Id [$TimeTrigger_id] under Read-AutomateNOWTimeTrigger due to [$Message]."
                            Break
                        }
                    }
                    $result
                }
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the response into a series of [ANOWProcessingTimeTrigger] objects due to [$Message]."
                Break
            }
            Return $ProcessingTimeTriggers
        }
        Else {
            If ($ScheduleTemplate_id.Length -gt 0) {
                Write-Verbose -Message "There were no Processing Time Triggers found in ScheduleTemplate ($ScheduleTemplate_id)"
            }
            Else {
                Write-Verbose -Message "There were no Processing Time Triggers found at all. Was this instance of ANOW recently installed?"
            }
        }
    }
    End {

    }
}

Function Set-AutomateNOWTimeTrigger {
    <#
    .SYNOPSIS
    Modifies a Time Trigger on an AutomateNOW! instance

    .DESCRIPTION
    Modifies a Time Trigger on an AutomateNOW! instance

    .PARAMETER TimeTrigger
    A mandatory [ANOWProcessingTimeTrigger] object representing the Time Trigger to be modified

    .PARAMETER timeTriggerType
    A mandatory string representing the type of Processing Time Trigger. Valid choices are: TIMESTAMP, DAILY, REPEATING, CRON, CALENDAR_INTERVAL

    .PARAMETER Hold
    An optional boolean that causes items to be put on hold after loading

    .PARAMETER Skip
    An optional boolean that causes items to not be loaded

    .PARAMETER calculateProcessingTimestampUsingLocalTime
    An optional boolean parameter that sets the checkbox for "Calculate processing timestamp using local time"

    .PARAMETER Calendar
    A [ANOWCalendar] object representing the Calendar object to set on the Time Trigger. Use Get-AutomateNOWCalendar to fetch one of these.

    .PARAMETER CalendarDays
    An optional string to specify only certain days within the calendar. See the Notes section for a detailed table. Valid values are: 'CALENDAR_DAY(1,-1)', 'CALENDAR_DAY(!1)', 'CALENDAR_MONTH(1,3)', 'CALENDAR_DAY_OF_WEEK(1,-1, MON,FRIDAY)', 'RELATIVE_CALENDAR_DAY_OF_WEEK(1,-1)', 'CALENDAR_MONTH_OF_YEAR(1, -2, JAN, JULY)', 'CALENDAR_WEEK_OF_YEAR(3,-10)', 'CALENDAR_DAY_OF_MONTH(1,2,-4)', 'ADD_DAY_OF_WEEK(1,-1, MON,FRIDAY,-1)', 'ADD_MONTH_OF_YEAR(1, -2, JAN, JULY)', 'ADD_WEEK_OF_YEAR(3,-10)', 'ADD_DAY_OF_MONTH(1,2,-4)', 'CALENDAR_DAY(1)', 'CALENDAR_DAY(1)', 'SHIFT(-1D)', 'SHIFT(3W)', 'SHIFT(6M)', 'SHIFT(1Y)'

    .PARAMETER CalendarInterval
    A mandatory int32 to specify how many CalendarIntervalUnits should transpire before activation. For example: Every 5 Days. 5 is the interval and Days is the interval unit.

    .PARAMETER CalendarIntervalUnit
    A mandatory string to specify which type of "unit" is used as the interval. Valid values are: DAY, WEEK, MONTH, YEAR

    .PARAMETER cronExpression
    A mandatory string to specify the cron expression string. See the notes section for a list of examples.

    .PARAMETER endTime
    A mandatory int64 representing the "End Time" or "Until" of the REPEATING time trigger. The allowed range is between 0 and 86399999 (i.e. midnight and 13:59:59.999)

    .PARAMETER preserveHourOfDayAcrossDaylightSavings
    An optional boolean parameter that sets the checkbox for "Preserve hour across daylight savings" [sic]

    .PARAMETER repeatInterval
    A mandatory int64 representing the "Repeat every" value of the REPEATING time trigger. The allowed range is between 0 and 86399999 (i.e. midnight and 13:59:59.999)

    .PARAMETER skipDayIfHourDoesNotExist
    A boolean parameter that sets the checkbox for "Skip day if hour does not exist"

    .PARAMETER startTime
    A mandatory int64 number representing the "Start Time" or "Run Daily At" of the Processing Time Trigger. Note that this number is sometimes not shown in the UI. The allowed range is between 0 and 86399999 (i.e. midnight and 13:59:59.999)

    .PARAMETER timestamp
    A mandatory string representing the "Run Once At" time. Example: 12/31/2029 01:23:45

    .PARAMETER timezone
    An optional [ANOWTimeZone] object representing the timezone object for the Time Trigger. Use Get-AutomateNOWTimeZone to retrieve these objects.

    .PARAMETER ValidFrom
    An optional date string (e.g. 12/31/2029 01:23:45in t) that this Time Trigger is considered "Valid From"te that the timestamp you provide here is agaiapplied nst the Timezone thatobject  is applied to this Time Trigger. Example: 2029-12-31T01:23:45.678'

    .PARAMETER ValidTo
    An optional date string (e.g. 2030-01-01T01:23:45.678) that this Time Trigger is considered "Valid To". Note that the timestamp you provide here is applied against the Timezone object that is applied to this Time Trigger.

    .PARAMETER Quiet
    Switch parameter to silence the output of the updated [ANOWProcessingTimeTrigger] object

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWProcessingTimeTrigger] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWProcessingTimeTrigger] object will be returned

    .EXAMPLE
    Modifies a Time Trigger of type TIMESTAMP
    Read-AutomateNOWTimeTrigger -Id '1a84bcf1-5d2f-41ae-b953-b6085864d08b' | Set-AutomateNOWTimeTrigger -timeTriggerType 'TIMESTAMP' -calculateProcessingTimestampUsingLocalTime $true -timestamp '2029-10-10T18:30:00.000' -timeZone (Get-AutomateNOWTimeZone -Id 'America/New_York') -Skip $true -Hold $true

    .EXAMPLE
    Forcibly modifies a Time Trigger of type DAILY
    Read-AutomateNOWTimeTrigger -Id '4a15969c-803e-432b-bb4d-0ec380153455' | Set-AutomateNOWTimeTrigger -timeTriggerType 'DAILY' -calculateProcessingTimestampUsingLocalTime $true -calendar (Get-AutomateNOWCalendar -Id 'MyCalendar') -calendarDays 'RELATIVE_CALENDAR_DAY_OF_WEEK(1,-1)' -preserveHourOfDayAcrossDaylightSavings $true -startTime 1020000 -skipDayIfHourDoesNotExist $true -timeZone (Get-AutomateNOWTimeZone -Id 'America/New_York') -validFrom '2029-11-01T00:00:00.000' -validTo '2029-12-01T00:00:00.000' -skip $false -hold $false -Force

    .EXAMPLE
    Modifies a Time Trigger of type REPEATING
    Read-AutomateNOWTimeTrigger -Id 'a779f2be-d1f1-4ff7-81b6-3e4159fd7129' | Set-AutomateNOWTimeTrigger -timeTriggerType 'REPEATING' -calendar (Get-AutomateNOWCalendar -Id 'MyCalendar') -calendarDays 'RELATIVE_CALENDAR_DAY_OF_WEEK(1,-1)' -endTime 2020000 -repeatInterval 15000 -startTime 1020000 -validFrom '2029-11-01T00:00:00.000' -validTo '2029-12-01T00:00:00.000' -skip $false -hold $false

    .EXAMPLE
    Modifies a Time Trigger of type CRON
    Read-AutomateNOWTimeTrigger -Id '1078ab80-e068-4ef3-beb8-f63f923d3320' | Set-AutomateNOWTimeTrigger -timeTriggerType 'CRON' -calculateProcessingTimestampUsingLocalTime $true -calendar (Get-AutomateNOWCalendar -Id 'MyCalendar') -calendarDays 'RELATIVE_CALENDAR_DAY_OF_WEEK(1,-1)' -cronExpression '0 0-5 14 * * ?' -timeZone (Get-AutomateNOWTimeZone -Id 'America/New_York') -validFrom '2029-11-01T00:00:00.000' -validTo '2029-12-01T00:00:00.000' -skip $false -hold $false

    .EXAMPLE
    Modifies a Time Trigger of type CALENDAR_INTERVAL
    Read-AutomateNOWTimeTrigger -Id '571d5c9c-bef0-4ef4-9d4e-7cdde4068b68' | Set-AutomateNOWTimeTrigger -timeTriggerType 'CALENDAR_INTERVAL' -calculateProcessingTimestampUsingLocalTime $true -calendarInterval 3 -calendarIntervalUnit 'MONTH' -preserveHourOfDayAcrossDaylightSavings $true -skipDayIfHourDoesNotExist $true -startTime 60000 -timeZone (Get-AutomateNOWTimeZone -Id 'America/New_York') -validFrom '2029-11-01T00:00:00.000' -validTo '2029-12-01T00:00:00.000' -skip $true -hold $true -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Calendar Days values are below:

    CALENDAR_DAY(1,-1)                       First and last day of every month of base calendars
    CALENDAR_DAY(!1)                         All days of base calendars except first day of every month
    CALENDAR_MONTH(1,3)                      Days in first and third months of base calendars
    CALENDAR_DAY_OF_WEEK(1,-1, MON,FRIDAY)   First and last day of week plus mondays and fridays of base calendars
    RELATIVE_CALENDAR_DAY_OF_WEEK(1,-1)      First and last day of all calendar week days in given month
    CALENDAR_MONTH_OF_YEAR(1, -2, JAN, JULY) First (January) and second to last (November) month of year plus June and July of base calendars
    CALENDAR_WEEK_OF_YEAR(3,-10)             Third and 10th from last week of year of base calendars
    CALENDAR_DAY_OF_MONTH(1,2,-4)            First, second and third to last day of each month of base calendars
    ADD_DAY_OF_WEEK(1,-1, MON,FRIDAY,-1)     Add first and last day of week and mondays and fridays
    ADD_MONTH_OF_YEAR(1, -2, JAN, JULY)      Add first (January) and second to last (November) month of year plus June and July
    ADD_WEEK_OF_YEAR(3,-10)                  Add third and 10th from last week of year
    ADD_DAY_OF_MONTH(1,2,-4)                 Add first, second and third to last day of each month
    CALENDAR_DAY(1) and CALENDAR_MONTH(1)    First day of first month in base calendar(s)
    CALENDAR_DAY(1) or CALENDAR_MONTH(1)     First day of every month plus all days in first month of the base calendar
    SHIFT(-1D)                               Move base calendars' days back 1 day
    SHIFT(3W)                                Move base calendars' days forward 3 weeks
    SHIFT(6M)                                Move base calendars' days forward 6 months
    SHIFT(1Y)                                Move base calendars' days forward 1 year

    Cron examples are below:

    '0 0 12 * * ?': 'Fire at 12pm (noon) every day',
    '0 15 10 ? * *': 'Fire at 10:15am every day',
    '0 15 10 * * ?': 'Fire at 10:15am every day',
    '0 15 10 * * ? *': 'Fire at 10:15am every day',
    '0 15 10 * * ? 2005': 'Fire at 10:15am every day during the year 2005',
    '0 * 14 * * ?': 'Fire every minute starting at 2pm and ending at 2:59pm, every day',
    '0 0/5 14 * * ?': 'Fire every 5 minutes starting at 2pm and ending at 2:55pm, every day',
    '0 0/5 14,18 * * ?': 'Fire every 5 minutes starting at 2pm and ending at 2:55pm, AND fire every 5 minutes starting at 6pm and ending at 6:55pm, every day',
    '0 0-5 14 * * ?': 'Fire every minute starting at 2pm and ending at 2:05pm, every day',
    '0 10,44 14 ? 3 WED': 'Fire at 2:10pm and at 2:44pm every Wednesday in the month of March.',
    '0 15 10 ? * MON-FRI': 'Fire at 10:15am every Monday, Tuesday, Wednesday, Thursday and Friday',
    '0 15 10 15 * ?': 'Fire at 10:15am on the 15th day of every month',
    '0 15 10 L * ?': 'Fire at 10:15am on the last day of every month',
    '0 15 10 L-2 * ?': 'Fire at 10:15am on the 2nd-to-last last day of every month',
    '0 15 10 ? * 6L': 'Fire at 10:15am on the last Friday of every month',
    '0 15 10 ? * 6L 2002-2005': 'Fire at 10:15am on every last friday of every month during the years 2002, 2003, 2004 and 2005',
    '0 15 10 ? * 6#3': 'Fire at 10:15am on the third Friday of every month',
    '0 0 12 1/5 * ?': 'Fire at 12pm (noon) every 5 days every month, starting on the first day of the month.',
    '0 11 11 11 11 ?': 'Fire every November 11th at 11:11am.',

    #>
    [OutputType([ANOWProcessingTimeTrigger])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High', DefaultParameterSetName = 'DAILY')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWProcessingTimeTrigger]$TimeTrigger,
        [Parameter(Mandatory = $true)]
        [ANOWProcessingTimeTrigger_timeTriggerType]$timeTriggerType,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$skip,
        [Parameter(Mandatory = $false)]
        [Nullable[boolean]]$hold,
        [Parameter(Mandatory = $false, ParameterSetName = 'TIMESTAMP')]
        [Parameter(Mandatory = $false, ParameterSetName = 'DAILY')]
        [Parameter(Mandatory = $false, ParameterSetName = 'CRON')]
        [Parameter(Mandatory = $false, ParameterSetName = 'CALENDAR_INTERVAL')]
        [Nullable[boolean]]$calculateProcessingTimestampUsingLocalTime,
        [Parameter(Mandatory = $false, ParameterSetName = 'DAILY')]
        [Parameter(Mandatory = $false, ParameterSetName = 'REPEATING')]
        [Parameter(Mandatory = $false, ParameterSetName = 'CRON')]
        [ANOWCalendar]$Calendar,
        [ValidateSet('CALENDAR_DAY(1,-1)', 'CALENDAR_DAY(!1)', 'CALENDAR_MONTH(1,3)', 'CALENDAR_DAY_OF_WEEK(1,-1, MON,FRIDAY)', 'RELATIVE_CALENDAR_DAY_OF_WEEK(1,-1)', 'CALENDAR_MONTH_OF_YEAR(1, -2, JAN, JULY)', 'CALENDAR_WEEK_OF_YEAR(3,-10)', 'CALENDAR_DAY_OF_MONTH(1,2,-4)', 'ADD_DAY_OF_WEEK(1,-1, MON,FRIDAY,-1)', 'ADD_MONTH_OF_YEAR(1, -2, JAN, JULY)', 'ADD_WEEK_OF_YEAR(3,-10)', 'ADD_DAY_OF_MONTH(1,2,-4)', 'CALENDAR_DAY(1)', 'CALENDAR_DAY(1)', 'SHIFT(-1D)', 'SHIFT(3W)', 'SHIFT(6M)', 'SHIFT(1Y)', ignoreCase = $false)]
        [Parameter(Mandatory = $false, ParameterSetName = 'DAILY')]
        [Parameter(Mandatory = $false, ParameterSetName = 'REPEATING')]
        [Parameter(Mandatory = $false, ParameterSetName = 'CRON')]
        [string]$CalendarDays,
        [Parameter(Mandatory = $true, ParameterSetName = 'CALENDAR_INTERVAL')]
        [int32]$calendarInterval,
        [Parameter(Mandatory = $true, ParameterSetName = 'CALENDAR_INTERVAL')]
        [ANOWProcessingTimeTrigger_calendarIntervalUnit]$calendarIntervalUnit,
        [ValidateScript({ (($_ -split ' ' | Measure-Object | Select-Object -ExpandProperty Count) -in (6, 7)) })]
        [Parameter(Mandatory = $true, ParameterSetName = 'CRON', HelpMessage = 'See the help for examples')]
        [string]$cronExpression,
        [ValidateRange(0, 86399999)]
        [Parameter(Mandatory = $true, ParameterSetName = 'REPEATING')]
        [int64]$endTime,
        [Parameter(Mandatory = $false, ParameterSetName = 'DAILY')]
        [Parameter(Mandatory = $false, ParameterSetName = 'CALENDAR_INTERVAL')]
        [Nullable[boolean]]$preserveHourOfDayAcrossDaylightSavings,
        [ValidateRange(0, 86399999)]
        [Parameter(Mandatory = $true, ParameterSetName = 'REPEATING')]
        [int64]$repeatInterval,
        [Parameter(Mandatory = $false, ParameterSetName = 'DAILY')]
        [Parameter(Mandatory = $false, ParameterSetName = 'CALENDAR_INTERVAL')]
        [Nullable[boolean]]$skipDayIfHourDoesNotExist,
        [ValidateRange(0, 86399999)]
        [Parameter(Mandatory = $true, ParameterSetName = 'DAILY')]
        [Parameter(Mandatory = $true, ParameterSetName = 'REPEATING')]
        [Parameter(Mandatory = $true, ParameterSetName = 'CALENDAR_INTERVAL')]
        [int64]$startTime,
        [ValidateScript({ $_ -match '^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}.[0-9]{3}$' })]
        [Parameter(Mandatory = $true, ParameterSetName = 'TIMESTAMP', HelpMessage = 'Enter a valid To date in the format of: 2029-12-31T01:23:45.678')]
        [string]$timestamp,
        [Parameter(Mandatory = $false, ParameterSetName = 'TIMESTAMP')]
        [Parameter(Mandatory = $false, ParameterSetName = 'DAILY')]
        [Parameter(Mandatory = $false, ParameterSetName = 'CRON')]
        [Parameter(Mandatory = $false, ParameterSetName = 'CALENDAR_INTERVAL')]
        [ANOWTimeZone]$TimeZone,
        [ValidateScript({ $_ -match '^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}.[0-9]{3}$' })]
        [Parameter(Mandatory = $false, ParameterSetName = 'DAILY', HelpMessage = 'Enter a valid From date in the format of: 2029-12-31T01:23:45.678')]
        [Parameter(Mandatory = $false, ParameterSetName = 'REPEATING', HelpMessage = 'Enter a valid From date in the format of: 2029-12-31T01:23:45.678')]
        [Parameter(Mandatory = $false, ParameterSetName = 'CRON', HelpMessage = 'Enter a valid From date in the format of: 2029-12-31T01:23:45.678')]
        [Parameter(Mandatory = $false, ParameterSetName = 'CALENDAR_INTERVAL', HelpMessage = 'Enter a valid From date in the format of: 2029-12-31T01:23:45.678')]
        [string]$validFrom,
        [ValidateScript({ $_ -match '^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}.[0-9]{3}$' })]
        [Parameter(Mandatory = $false, ParameterSetName = 'DAILY', HelpMessage = 'Enter a valid To date in the format of: 2029-12-31T01:23:45.678')]
        [Parameter(Mandatory = $false, ParameterSetName = 'REPEATING', HelpMessage = 'Enter a valid To date in the format of: 2029-12-31T01:23:45.678')]
        [Parameter(Mandatory = $false, ParameterSetName = 'CRON', HelpMessage = 'Enter a valid To date in the format of: 2029-12-31T01:23:45.678')]
        [Parameter(Mandatory = $false, ParameterSetName = 'CALENDAR_INTERVAL', HelpMessage = 'Enter a valid To date in the format of: 2029-12-31T01:23:45.678')]
        [string]$validTo,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processingTimeTrigger/update'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWProcessingTimeTrigger]$TimeTrigger = $_
        }
        [string]$TimeTrigger_id = $TimeTrigger.Id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($TimeTrigger_id)")) -eq $true) {
            If ($validFrom.Length -gt 0 -or $validTo.Length -gt 0) {
                If (($validFrom.Length -gt 0 -and $validTo.Length -gt 0) -and ($validTo -eq $validFrom)) {
                    Write-Warning -Message "You can't have the same validFrom and validTo date!"
                    Break
                }
                If (($validFrom.Length -gt 0 -and $validTo.Length -gt 0) -and ($validTo -lt $validFrom)) {
                    Write-Warning -Message "If both a validFrom and validTo are specified then the validTo must be less then the validFrom!"
                    Break
                }
                If (($validFrom.Length -eq 0 -and $validTo.Length -gt 0) -and ($TimeTrigger.validFrom.Length -gt 0)) {
                    If ($TimeTrigger.validFrom -gt $validTo) {
                        Write-Warning -Message "The validTo must be less than the pre-existing validFrom in this Time Trigger!"
                        Break
                    }
                }
                ElseIf (($validFrom.Length -gt 0 -and $validTo.Length -eq 0) -and ($TimeTrigger.validTo.Length -gt 0)) {
                    If ($validFrom -gt $TimeTrigger.validTo) {
                        Write-Warning -Message "The validFrom must be less than the pre-existing validTo in this Time Trigger!"
                        Break
                    }
                }
            }
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            [string]$oldvalues = $TimeTrigger.CreateOldValues()
            $BodyMetaData.Add('id', $TimeTrigger_id )
            If ($skip -eq $true) {
                $BodyMetaData.Add('passBy', 'true' )
            }
            ElseIf ($skip -eq $false) {
                $BodyMetaData.Add('passBy', 'false' )
            }
            If ($hold -eq $true) {
                $BodyMetaData.Add('onHold', 'true' )
            }
            ElseIf ($hold -eq $false) {
                $BodyMetaData.Add('onHold', 'false' )
            }
            $BodyMetaData.Add('tags', $null )
            If ($calculateProcessingTimestampUsingLocalTime -eq $true) {
                $BodyMetaData.Add('calculateProcessingTimestampUsingLocalTime', 'true')
            }
            ElseIf ($calculateProcessingTimestampUsingLocalTime -eq $false) {
                $BodyMetaData.Add('calculateProcessingTimestampUsingLocalTime', 'false')
            }
            If ($Calendar.Id.Length -gt 0) {
                [string]$Calendar_id = $Calendar.simpleId
                $Error.Clear()
                Try {
                    [ANOWCalendar]$Calendar_object = Get-AutomateNOWCalendar -Id $Calendar_id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWCalendar failed to confirm that the Calendar object [$Calendar_id] actually existed under Set-AutomateNOWTimeTrigger due to [$Message]"
                    Break
                }
                If ($Calendar_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWCalendar failed to locate the Calendar object [$Calendar_id] running under Set-AutomateNOWTimeTrigger. Please check again."
                    Break
                }
                [string]$Calendar_id = $Calendar_object.Id
                $BodyMetaData.Add('calendar', $Calendar_id)
            }
            If ($CalendarDays.Length -gt 0) {
                $BodyMetaData.Add('calendarDays', $CalendarDays)
            }
            If ($calendarInterval.Count -gt 0) {
                $BodyMetaData.Add('calendarInterval', $calendarInterval)
            }
            If ($calendarIntervalUnit.Length -gt 0) {
                $BodyMetaData.Add('calendarIntervalUnit', $calendarIntervalUnit)
            }
            If ($cronExpression.Length -gt 0) {
                $BodyMetaData.Add('cronExpression', $cronExpression)
            }
            If ($endTime.Length -gt 0) {
                $BodyMetaData.Add('endTime', $endTime )
            }
            If ($preserveHourOfDayAcrossDaylightSavings -eq $true) {
                $BodyMetaData.Add('preserveHourOfDayAcrossDaylightSavings', 'true')
            }
            ElseIf ($preserveHourOfDayAcrossDaylightSavings -eq $false) {
                $BodyMetaData.Add('preserveHourOfDayAcrossDaylightSavings', 'false')
            }
            If ($repeatInterval.Count -gt 0) {
                $BodyMetaData.Add('repeatInterval', $repeatInterval)
            }
            If ($skipDayIfHourDoesNotExist -eq $true) {
                $BodyMetaData.Add('skipDayIfHourDoesNotExist', 'true')
            }
            ElseIf ($skipDayIfHourDoesNotExist -eq $false) {
                $BodyMetaData.Add('skipDayIfHourDoesNotExist', 'false')
            }
            If ($startTime.Length -gt 0) {
                $BodyMetaData.Add('startTime', $startTime )
            }
            If ($timestamp.Length -gt 0) {
                $BodyMetaData.Add('timestamp', $timestamp)
                $Error.Clear()
                Try {
                    [string]$timestampInLocalTimezone = Get-Date -Date (Get-Date -Date $timestamp).AddMilliseconds($timezone.rawOffset) -Format 'yyyy-MM-ddTHH:mm:ss.fff'
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Somehow Get-Date failed to calculate the timestampInLocalTimezone for timestamp [$timestamp] due to $Message"
                }
                $BodyMetaData.Add('timestampInLocalTimezone', $timestampInLocalTimezone)
            }
            If ($TimeZone.Id.Length -gt 0) {
                [string]$TimeZone_Id = $TimeZone.id
                $BodyMetaData.Add('timeZone', $TimeZone_Id)
            }
            If ($validFrom.Length -gt 0) {
                $BodyMetaData.Add('validFrom', $validFrom)
            }
            If ($validTo.Length -gt 0) {
                $BodyMetaData.Add('validTo', $validTo)
            }
            $BodyMetaData.Add('_oldValues', $oldvalues)
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_componentId', 'ProcessingTimeTriggerEditForm')
            $BodyMetaData.Add('_dataSource', 'ProcessingTimeTriggerDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$TimeTrigger_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            If ($results.response.data[0].timeZone.Length -gt 0) {
                [string]$timezone_id = $results.response.data | Select-Object -First 1.timeZone
                [ANOWTimeZone]$timezone = Get-AutomateNOWTimeZone -Id $timezone_id
                $results.response.data[0].timeZone = $timezone
            }
            If ($results.response.data[0].processingTemplate.Length -gt 0) {
                [string]$processing_template_id = $results.response.data | Select-Object -First 1.processingTemplate
                [ANOWScheduleTemplate]$processingTemplate = Get-AutomateNOWScheduleTemplate -Id $processing_template_id
                $results.response.data[0].processingTemplate = $processingTemplate
            }
            If ($results.response.data[0].Calendar.Length -gt 0) {
                $Error.Clear()
                Try {
                    [ANOWCalendar]$Calendar = Get-AutomateNOWCalendar -Id ($results.response.data[0].Calendar)
                    $results.response.data[0].Calendar = $Calendar
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWCalendar failed to retrieve the calendar object from Time Trigger Id $TimeTrigger_id under Set-AutomateNOWTimeTrigger due to [$Message]."
                    Break
                }
            }
            $Error.Clear()
            Try {
                [ANOWProcessingTimeTrigger]$UpdatedTimeTrigger = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to create the [ANOWProcessingTimeTrigger] object after resuming (unpausing) [$TimeTrigger_id] due to [$Message]."
                Break
            }
            Write-Verbose -Message "Time Trigger $TimeTrigger_id successfully updated"
            If ($Quiet -ne $true) {
                Return $UpdatedTimeTrigger
            }
        }
    }
    End {

    }
}

Function Export-AutomateNOWTimeTrigger {
    <#
    .SYNOPSIS
    Exports the Processing TimeTriggers within a Schedule Template from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Processing TimeTriggers within a Schedule Template from an instance of AutomateNOW! to a local .csv file

    .PARAMETER ProcessingTimeTrigger
    Mandatory [ANOWProcessingTimeTrigger] object (Use Read-AutomateNOWTimeTrigger to retrieve them)

    .INPUTS
    ONLY [ANOWScheduleTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    The [ANOWProcessingTimeTrigger] objects related to the Schedule Template are exported to the local disk in CSV format

    .EXAMPLE
    Exports all of the Processing Time Triggers from a Schedule Template to .csv

    Get-AutomateNOWScheduleTemplate -Id 'ScheduleTemplate1' | Read-AutomateNOWTimeTrigger | Export-AutomateNOWProcessingTimeTrigger

    .NOTES
	
    #>

    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWProcessingTimeTrigger]$ProcessingTimeTrigger
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = "Export-AutomateNOW-ProcessingTimeTriggers-" + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
        [array]$ProcessingTimeTriggers = @()
    }
    Process {
        If ($_.id.Length -gt 0) {
            $ProcessingTimeTrigger = $_ # do not hard type this variable
        }
        $ProcessingTimeTriggers += $ProcessingTimeTrigger
    }
    End {
        $Error.Clear()
        Try {
            $ProcessingTimeTriggers | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWProcessingTimeTrigger] object(s) due to [$Message]"
            Break
        }
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function Remove-AutomateNOWTimeTrigger {
    <#
    .SYNOPSIS
    Removes the Processing TimeTriggers within a Schedule Template from an instance of AutomateNOW!

    .DESCRIPTION
    Removes the Processing TimeTriggers within a Schedule Template from an instance of AutomateNOW!

    .PARAMETER ProcessingTimeTrigger
    An [ANOWProcessingTimeTrigger] object representing the TimeTrigger to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWProcessingTimeTrigger] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Removes the first page of Time Triggers from a Schedule Template named 'ScheduleTemplate1'
    Get-AutomateNOWScheduleTemplate -Id 'ScheduleTemplate1' | Read-AutomateNOWTimeTrigger  | Remove-AutomateNOWTimeTrigger

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWProcessingTimeTrigger]$ProcessingTimeTrigger,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processingTimeTrigger/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWProcessingTimeTrigger]$ProcessingTimeTrigger = $_
        }
        [string]$ProcessingTimeTrigger_id = $ProcessingTimeTrigger.id
        If ($ProcessingTimeTrigger_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ProcessingTimeTrigger_id)")) -eq $true) {
            [string]$oldvalues = $ProcessingTimeTrigger.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $ProcessingTimeTrigger_id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'ProcessingTimeTriggerList'
            $BodyMetaData.'_dataSource' = 'ProcessingTimeTriggerDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ProcessingTimeTrigger_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Processing TimeTrigger $ProcessingTimeTrigger_id was successfully removed"
        }
    }
    End {

    }
}

Function Add-AutomateNOWTimeTrigger {
    <#
    .SYNOPSIS
    Adds a new Processing Time Trigger to a Schedule Template in an instance of AutomateNOW!

    .DESCRIPTION
    Adds a new Processing Time Trigger to a Schedule Template in an instance of AutomateNOW!

    .PARAMETER ScheduleTemplate
    An [ANOWScheduleTemplate] object representing the Schedule Template that will receive the new Processing Time Trigger.

    .PARAMETER timeTriggerType
    A string representing the type of Processing Time Trigger. Valid choices are: TIMESTAMP, DAILY, REPEATING, CRON, CALENDAR_INTERVAL

    .PARAMETER startTime
    An int64 number representing the "start time" of the trigger. Note that this number is sometimes not shown in the UI. It is typically 0 (the first millisecond of the day).

    .PARAMETER endTime
    An int64 number representing the "end time" of the trigger. Note that this number is sometimes not shown in the UI. It is typically 86399999 (the last millisecond before tomorrow).

    .PARAMETER repeatInterval
    An int64 number representing the "repeat interval" of the trigger. Note that this number is sometimes not shown in the UI. It is typically 3600000 (1 hour).

    .PARAMETER timestamp
    Mandatory (for TIMESTAMP type) string representing a UTC timestamp. A valid example is: 12/31/2030 23:59:59

    .PARAMETER timezone
    Mandatory (for TIMESTAMP, DAILY, CRON and CALENDAR_INTERVAL type) [ANOWTimeZone] object representing the timezone object. Use Get-AutomateNOWTimeZone to retrieve these objects. See the help for examples.

    .PARAMETER calendarInterval
    Mandatory (for CALENDAR_INTERVAL type) int64 representing the number of calendarIntervalUnits on which to base the trigger on (e.g. 5)

    .PARAMETER calendarIntervalUnit
    Mandatory (for CALENDAR_INTERVAL type) string representing the type of interval between executions. Valid choices are: DAY, WEEK, MONTH, YEAR.

    .PARAMETER calculateProcessingTimestampUsingLocalTime
    An optional switch parameter that "calculates the timestamp using local time"

    .PARAMETER Quiet
    Switch parameter to silence the emitted [ANOWProcessingTimeTrigger] object

    .PARAMETER Force
    Force the addition without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWScheduleTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    The newly created [ANOWProcessingTimeTrigger] object will be returned. Use -Quiet to suppress this.

    .EXAMPLE
    Forcibly adds a Processing Time Trigger of type 'Timestamp' (with the calculateProcessingTimestampUsingLocalTime flag set to true) configured for America/New_York timezone to a Schedule Template named 'ScheduleTemplate1'. Use the following values for these 3 attributes: -startTime 0 -endTime 86399999 -repeatInterval 3600000

    Get-AutomateNOWScheduleTemplate -Id 'ScheduleTemplate1' | Add-AutomateNOWTimeTrigger -calculateProcessingTimestampUsingLocalTime $true -timezone (Get-AutomateNOWTimeZone -Id 'America/New_York') -timestamp '2030-12-31T12:00:00.000' -timeTriggerType TIMESTAMP -startTime 0 -endTime 86399999 -repeatInterval 3600000 -Force

    .EXAMPLE
    Quietly adds a Processing Time Trigger of type 'Daily' configured for the America/New_York timezone to start at 02:00 to a Schedule Template named 'ScheduleTemplate1'. Use the following values for these 2 attributes: -endTime 86399999 -repeatInterval 3600000

    Get-AutomateNOWScheduleTemplate -Id 'ScheduleTemplate1' | Add-AutomateNOWTimeTrigger -timezone (Get-AutomateNOWTimeZone -Id 'America/New_York') -timeTriggerType DAILY -startTime 7200000 -endTime 86399999 -repeatInterval 3600000 -Quiet

    .EXAMPLE
    Adds a Processing Time Trigger of type 'Repeating' to a Schedule Template named 'ScheduleTemplate1'. Note that you may not specify a timezone with this type of Processing Time Trigger.

    Get-AutomateNOWScheduleTemplate -Id 'ScheduleTemplate1' | Add-AutomateNOWTimeTrigger -timeTriggerType REPEATING -startTime 0 -endTime 86399999 -repeatInterval 3600000

    .EXAMPLE
    Adds a Processing Time Trigger of type 'Cron' to a Schedule Template named 'ScheduleTemplate1'.

    Get-AutomateNOWScheduleTemplate -Id 'ScheduleTemplate1' | Add-AutomateNOWTimeTrigger -timezone (Get-AutomateNOWTimeZone -Id 'America/New_York') -timeTriggerType CRON -cronExpression '0 15 10 * * ? 2005' -startTime 0 -endTime 86399999 -repeatInterval 3600000 -Force

    .EXAMPLE
    Adds a Processing Time Trigger of type 'Calendar Interval' to a Schedule Template named 'ScheduleTemplate1'.

    Get-AutomateNOWScheduleTemplate -Id 'ScheduleTemplate1' | Add-AutomateNOWTimeTrigger -timezone (Get-AutomateNOWTimeZone -Id 'America/New_York') -timeTriggerType CALENDAR_INTERVAL -calendarInterval 1 -calendarIntervalUnit WEEK -startTime 0 -endTime 86399999 -repeatInterval 3600000 -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The ANOW application requires that a Schedule Template is provided when creating a new Processing Time Trigger.

    The "repeating" type of Processing Trigger ONLY uses the server time zone and DOES NOT allow a different time zone to be specified.

    The ANOW application automatically selects the default timezone for you. This module does not do that. Refer to your $anow_session variable for information about the available timezones on the ANOW instance.

    The examples in this function need to be improved.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'TIMESTAMP', ValueFromPipeline = $True)]
        [Parameter(Mandatory = $true, ParameterSetName = 'DAILY', ValueFromPipeline = $True)]
        [Parameter(Mandatory = $true, ParameterSetName = 'REPEATING', ValueFromPipeline = $True)]
        [Parameter(Mandatory = $true, ParameterSetName = 'CRON', ValueFromPipeline = $True)]
        [Parameter(Mandatory = $true, ParameterSetName = 'CALENDAR_INTERVAL', ValueFromPipeline = $True)]
        [ANOWScheduleTemplate]$ScheduleTemplate,
        [Parameter(Mandatory = $true, ParameterSetName = 'TIMESTAMP')]
        [Parameter(Mandatory = $true, ParameterSetName = 'DAILY')]
        [Parameter(Mandatory = $true, ParameterSetName = 'REPEATING')]
        [Parameter(Mandatory = $true, ParameterSetName = 'CRON')]
        [Parameter(Mandatory = $true, ParameterSetName = 'CALENDAR_INTERVAL')]
        [ANOWProcessingTimeTrigger_timeTriggerType]$timeTriggerType,
        [Parameter(Mandatory = $true, ParameterSetName = 'TIMESTAMP', HelpMessage = 'This value is typically 0')]
        [Parameter(Mandatory = $true, ParameterSetName = 'DAILY', HelpMessage = 'This value is typically 0')]
        [Parameter(Mandatory = $true, ParameterSetName = 'REPEATING', HelpMessage = 'This value is typically 0')]
        [Parameter(Mandatory = $true, ParameterSetName = 'CRON', HelpMessage = 'This value is typically 0')]
        [Parameter(Mandatory = $true, ParameterSetName = 'CALENDAR_INTERVAL', HelpMessage = 'This value is typically 0')]
        [int64]$startTime,
        [Parameter(Mandatory = $true, ParameterSetName = 'TIMESTAMP', HelpMessage = 'This value is typically 86399999')]
        [Parameter(Mandatory = $true, ParameterSetName = 'DAILY', HelpMessage = 'This value is typically 86399999')]
        [Parameter(Mandatory = $true, ParameterSetName = 'REPEATING', HelpMessage = 'This value is typically 86399999')]
        [Parameter(Mandatory = $true, ParameterSetName = 'CRON', HelpMessage = 'This value is typically 86399999')]
        [Parameter(Mandatory = $true, ParameterSetName = 'CALENDAR_INTERVAL', HelpMessage = 'This value is typically 86399999')]
        [int64]$endTime,
        [Parameter(Mandatory = $true, ParameterSetName = 'TIMESTAMP', HelpMessage = 'This value is typically 3600000')]
        [Parameter(Mandatory = $true, ParameterSetName = 'DAILY', HelpMessage = 'This value is typically 3600000')]
        [Parameter(Mandatory = $true, ParameterSetName = 'REPEATING', HelpMessage = 'This value is typically 3600000')]
        [Parameter(Mandatory = $true, ParameterSetName = 'CRON', HelpMessage = 'This value is typically 3600000')]
        [Parameter(Mandatory = $true, ParameterSetName = 'CALENDAR_INTERVAL', HelpMessage = 'This value is typically 3600000')]
        [int64]$repeatInterval,
        [ValidateScript({ $_ -match '^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}.[0-9]{3}$' })]
        [Parameter(Mandatory = $true, ParameterSetName = 'TIMESTAMP', HelpMessage = 'Enter a UTC timestamp: 2030-12-31T23:59:59.999')]
        [string]$timestamp,
        [Parameter(Mandatory = $true, ParameterSetName = 'TIMESTAMP')]
        [Parameter(Mandatory = $true, ParameterSetName = 'DAILY')]
        [Parameter(Mandatory = $true, ParameterSetName = 'CRON')]
        [Parameter(Mandatory = $true, ParameterSetName = 'CALENDAR_INTERVAL')]
        [ANOWTimeZone]$timezone,
        [Parameter(Mandatory = $false, ParameterSetName = 'TIMESTAMP')]
        [Parameter(Mandatory = $false, ParameterSetName = 'DAILY')]
        [Parameter(Mandatory = $false, ParameterSetName = 'CRON')]
        [Parameter(Mandatory = $false, ParameterSetName = 'CALENDAR_INTERVAL')]
        [boolean]$calculateProcessingTimestampUsingLocalTime,
        [ValidateScript({ $_ -match '^[0-9 */,?#LW(MON|TUE|WED|THU|FRI|SAT|SUN)-]{1,}$' })]
        [Parameter(Mandatory = $true, ParameterSetName = 'CRON', HelpMessage = 'Enter a cron expresion: 0 15 10 ? * *')]
        [string]$cronExpression,
        [ValidateScript({ $_ -gt 0 })]
        [Parameter(Mandatory = $true, ParameterSetName = 'CALENDAR_INTERVAL', HelpMessage = 'Enter a number for the interval of time units between executions (e.g. 5)')]
        [int64]$calendarInterval,
        [Parameter(Mandatory = $true, ParameterSetName = 'CALENDAR_INTERVAL')]
        [ANOWProcessingTimeTrigger_calendarIntervalUnit]$calendarIntervalUnit,
        [Parameter(Mandatory = $false, ParameterSetName = 'TIMESTAMP')]
        [Parameter(Mandatory = $false, ParameterSetName = 'DAILY')]
        [Parameter(Mandatory = $false, ParameterSetName = 'REPEATING')]
        [Parameter(Mandatory = $false, ParameterSetName = 'CRON')]
        [Parameter(Mandatory = $false, ParameterSetName = 'CALENDAR_INTERVAL')]
        [switch]$Force,
        [Parameter(Mandatory = $false, ParameterSetName = 'TIMESTAMP')]
        [Parameter(Mandatory = $false, ParameterSetName = 'DAILY')]
        [Parameter(Mandatory = $false, ParameterSetName = 'REPEATING')]
        [Parameter(Mandatory = $false, ParameterSetName = 'CRON')]
        [Parameter(Mandatory = $false, ParameterSetName = 'CALENDAR_INTERVAL')]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processingTimeTrigger/create'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
        If ($timeTriggerType -eq 'TIMESTAMP') {
            If ($timestamp.length -eq 0) {
                Write-Warning -Message "Please include the -timestamp parameter. See the help for details."
                Break
            }
        }
        ElseIf ($timeTriggerType -ne 'TIMESTAMP') {
            If ($timestamp.length -gt 0) {
                Write-Warning -Message "Please do not include the -timestamp parameter unless the Processing Trigger Type is TIMESTAMP"
                Break
            }
        }
        If ($timeTriggerType -eq 'REPEATING') {
            If ($timezone.Id.Length -gt 0) {
                Write-Warning -Message "Please do not include the -timezone parameter if the Processing Trigger Type is REPEATING"
                Break
            }
            If ($calculateProcessingTimestampUsingLocalTime -eq $true) {
                Write-Warning -Message "You may not use the -calculateProcessingTimestampUsingLocalTime parameter when Processing Trigger Type is REPEATING"
                Break
            }
        }
        If ($timeTriggerType -eq 'CALENDAR_INTERVAL') {
            If ($calendarIntervalUnit.Length -eq 0) {
                Write-Warning -Message "You must specify the -calendarIntervalUnit when the Processing Trigger Type is CALENDAR_INTERVAL. Please see the help."
                Break
            }
            If ($calendarInterval -eq 0) {
                Write-Warning -Message "You must specify the -calendarInterval when the Processing Trigger Type is CALENDAR_INTERVAL. Please see the help."
                Break
            }
        }
        ElseIf ($timeTriggerType -ne 'CALENDAR_INTERVAL') {
            If ($calendarIntervalUnit.Length -gt 0) {
                Write-Warning -Message "Please do not specify the -calendarIntervalUnit unless the Processing Trigger Type is CALENDAR_INTERVAL. Please see the help."
                Break
            }
            If ($calendarInterval -gt 0) {
                Write-Warning -Message "Please do not specify the -calendarInterval unless the Processing Trigger Type is CALENDAR_INTERVAL. Please see the help."
                Break
            }
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWScheduleTemplate]$ScheduleTemplate = $_
        }
        [string]$ScheduleTemplate_id = $ScheduleTemplate.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ScheduleTemplate_id)")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            [string]$oldvalues = ('{"processingTemplate":"' + $ScheduleTemplate_id + '","timeTriggerType":"' + $timeTriggerType + '","startTime":' + $startTime + ',"repeatInterval":' + $repeatInterval + ',"endTime":' + $endTime + '}')
            $BodyMetaData.'processingTemplate' = $ScheduleTemplate_id
            $BodyMetaData.'timeTriggerType' = $timeTriggerType
            If ($timeTriggerType -ne 'REPEATING') {
                If ($calculateProcessingTimestampUsingLocalTime -eq $true) {
                    $BodyMetaData.'calculateProcessingTimestampUsingLocalTime' = 'true'
                }
                ElseIf ($calculateProcessingTimestampUsingLocalTime -eq $false) {
                    $BodyMetaData.'calculateProcessingTimestampUsingLocalTime' = 'false'
                }
                [string]$timezone_id = $timezone.Id
                If ($timezone_id.length -eq 0) {
                    Write-Warning -Message "Somehow the provided [ANOWTimeZone] object does not have an Id. Please look into this."
                    Break
                }
                $BodyMetaData.'timeZone' = $timezone_id
            }
            If ($timeTriggerType -eq 'TIMESTAMP') {
                $BodyMetaData.'timestamp' = $timestamp
                $Error.Clear()
                Try {
                    [string]$timestampInLocalTimezone = Get-Date -Date (Get-Date -Date $timestamp).AddMilliseconds($timezone.rawOffset) -Format 'yyyy-MM-ddTHH:mm:ss.fff'
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Somehow the timestampInLocalTimezone failed to calculate for timestamp [$timestamp] due to $Message"
                }
                $BodyMetaData.'timestampInLocalTimezone' = $timestampInLocalTimezone
            }
            ElseIf ($timeTriggerType -eq 'DAILY') {
            }
            ElseIf ($timeTriggerType -eq 'REPEATING') {
            }
            ElseIf ($timeTriggerType -eq 'CRON') {
                $BodyMetaData.'cronExpression' = $cronExpression
            }
            ElseIf ($timeTriggerType -eq 'CALENDAR_INTERVAL') {
                $BodyMetaData.'calendarInterval' = $calendarInterval
                $BodyMetaData.'calendarIntervalUnit' = $calendarIntervalUnit
            }
            Else {
                Write-Warning -Message "Could not determine the timeTriggerType"
                Break
            }
            $BodyMetaData.'startTime' = $startTime
            $BodyMetaData.'endTime' = $endTime
            $BodyMetaData.'repeatInterval' = $repeatInterval
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'add'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'ProcessingTimeTriggerCreateWindow_form'
            $BodyMetaData.'_dataSource' = 'ProcessingTimeTriggerDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on $ScheduleTemplate_id due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            If ($results.response.data.Count -gt 0) {
                $Error.Clear()
                Try {
                    $results.response.data[0].processingTemplate = $ScheduleTemplate
                    If ($timeTriggerType -ne 'REPEATING') {
                        $results.response.data[0].timeZone = $timezone
                    }
                    [ANOWProcessingTimeTrigger]$ProcessingTimeTrigger = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to parse the response into an [ANOWProcessingTimeTrigger] object due to [$Message]."
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $ProcessingTimeTrigger
                }
            }
            Write-Verbose -Message "$ScheduleTemplate_id does not contain any Processing Time Trigger objects"
        }
    }
    End {

    }
}

Function Resume-AutomateNOWTimeTrigger {
    <#
    .SYNOPSIS
    Resumes (unpauses) a Time Trigger from "on hold (suspend)" status on an AutomateNOW! instance

    .DESCRIPTION
    Resumes (unpauses) a Time Trigger from "on hold (suspend)" status on an AutomateNOW! instance

    .PARAMETER TimeTrigger
    An [ANOWProcessingTimeTrigger] object representing the Time Trigger to be resumed (unpaused)

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Switch parameter to silence the emitted [ANOWProcessingTimeTrigger] object

    .INPUTS
    ONLY [ANOWProcessingTimeTrigger] objects are accepted (including from the pipeline)

    .OUTPUTS
    The resumed [ANOWProcessingTimeTrigger] object will be returned

    .EXAMPLE
    Resumes the first time trigger within a Schedule Template named 'ScheduleTemplate1'

    $schedule_template = Get-AutomateNOWScheduleTemplate -Id 'ScheduleTemplate1'
    $time_trigger = Read-AutomateNOWTimeTrigger -ScheduleTemplate $schedule_template | Select-Object -First 1
    Resume-AutomateNOWTimeTrigger -TimeTrigger $time_trigger -Force -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWProcessingTimeTrigger]$TimeTrigger,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processingTimeTrigger/update'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWProcessingTimeTrigger]$TimeTrigger = $_
        }
        [string]$TimeTrigger_id = $TimeTrigger.id
        [boolean]$onHold = $TimeTrigger.onHold
        If ($onHold -eq $false) {
            Write-Warning -Message "$TimeTrigger_id is already resumed (unpaused) so there is no action required"
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($TimeTrigger_id)")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $TimeTrigger_id )
            $BodyMetaData.Add('onHold', 'false')
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingTemplateDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$TimeTrigger_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            If ($results.response.data[0].timeZone.Length -gt 0) {
                [string]$timezone_id = $results.response.data | Select-Object -First 1.timeZone
                [ANOWTimeZone]$timezone = Get-AutomateNOWTimeZone -Id $timezone_id
                $results.response.data[0].timeZone = $timezone
            }
            If ($results.response.data[0].processingTemplate.Length -gt 0) {
                [string]$processing_template_id = $results.response.data | Select-Object -First 1.processingTemplate
                [ANOWScheduleTemplate]$processingTemplate = Get-AutomateNOWScheduleTemplate -Id $processing_template_id
                $results.response.data[0].processingTemplate = $processingTemplate
            }
            $Error.Clear()
            Try {
                [ANOWProcessingTimeTrigger]$suspended_TimeTrigger = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to create the [ANOWProcessingTimeTrigger] object after resuming [$TimeTrigger_id] due to [$Message]."
                Break
            }
            Write-Verbose -Message "Time Trigger $TimeTrigger_id successfully suspended (placed on hold)"
            If ($Quiet -ne $true) {
                Return $suspended_TimeTrigger
            }
        }
    }
    End {

    }
}

Function Suspend-AutomateNOWTimeTrigger {
    <#
    .SYNOPSIS
    Places a Time Trigger on hold (suspend) from execution on an AutomateNOW! instance

    .DESCRIPTION
    Places a Time Trigger on hold (suspend) from execution on an AutomateNOW! instance

    .PARAMETER TimeTrigger
    An [ANOWProcessingTimeTrigger] object representing the Time Trigger to be suspended (placed on hold)

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Switch parameter to silence the emitted [ANOWProcessingTimeTrigger] object

    .INPUTS
    ONLY [ANOWProcessingTimeTrigger] objects are accepted (including from the pipeline)

    .OUTPUTS
    The suspended [ANOWProcessingTimeTrigger] object will be returned

    .EXAMPLE
    Suspends the first time trigger within a Schedule Template named 'ScheduleTemplate1'

    $schedule_template = Get-AutomateNOWScheduleTemplate -Id 'ScheduleTemplate1'
    $time_trigger = Read-AutomateNOWTimeTrigger -ScheduleTemplate $schedule_template | Select-Object -First 1
    Suspend-AutomateNOWTimeTrigger -TimeTrigger $time_trigger

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWProcessingTimeTrigger]$TimeTrigger,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processingTimeTrigger/update'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWProcessingTimeTrigger]$TimeTrigger = $_
        }
        [string]$TimeTrigger_id = $TimeTrigger.id
        [boolean]$onHold = $TimeTrigger.onHold
        If ($onHold -eq $true) {
            Write-Warning -Message "$TimeTrigger_id is already on hold so there is no action required"
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($TimeTrigger_id)")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $TimeTrigger_id )
            $BodyMetaData.Add('onHold', 'true')
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingTemplateDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$TimeTrigger_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            If ($results.response.data[0].timeZone.Length -gt 0) {
                [string]$timezone_id = $results.response.data | Select-Object -First 1.timeZone
                [ANOWTimeZone]$timezone = Get-AutomateNOWTimeZone -Id $timezone_id
                $results.response.data[0].timeZone = $timezone
            }
            If ($results.response.data[0].processingTemplate.Length -gt 0) {
                [string]$processing_template_id = $results.response.data | Select-Object -First 1.processingTemplate
                [ANOWScheduleTemplate]$processingTemplate = Get-AutomateNOWScheduleTemplate -Id $processing_template_id
                $results.response.data[0].processingTemplate = $processingTemplate
            }
            $Error.Clear()
            Try {
                [ANOWProcessingTimeTrigger]$resumed_TimeTrigger = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to create the [ANOWProcessingTimeTrigger] object after resuming (unpausing) [$TimeTrigger_id] due to [$Message]."
                Break
            }
            Write-Verbose -Message "Time Trigger $TimeTrigger_id successfully resumed (unpaused)"
            If ($Quiet -ne $true) {
                Return $resumed_TimeTrigger
            }
        }
    }
    End {

    }
}

Function Skip-AutomateNOWTimeTrigger {
    <#
    .SYNOPSIS
    Sets or unsets the Skip flag on a Time Trigger on an AutomateNOW! instance

    .DESCRIPTION
    Sets or unsets the Skip flag on a Time Trigger on an AutomateNOW! instance

    .PARAMETER TimeTrigger
    An [ANOWProcessingTimeTrigger] object representing the Time Trigger to be set to skipped or unskipped

    .PARAMETER UnSkip
    Removes the skip flag from an [ANOWProcessingTimeTrigger] object. This is the opposite of the default behavior.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Switch parameter to silence the emitted [ANOWProcessingTimeTrigger] object

    .INPUTS
    ONLY [ANOWProcessingTimeTrigger] objects are accepted (including from the pipeline)

    .OUTPUTS
    The skipped/unskipped [ANOWProcessingTimeTrigger] object will be returned

    .EXAMPLE

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWProcessingTimeTrigger]$TimeTrigger,
        [Parameter(Mandatory = $false)]
        [switch]$UnSkip,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processingTimeTrigger/update'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWProcessingTimeTrigger]$TimeTrigger = $_
        }
        [string]$TimeTrigger_id = $TimeTrigger.id
        If ($TimeTrigger.passBy -eq $true -and $UnSkip -ne $True) {
            Write-Warning -Message "Time Trigger $TimeTrigger_id already has the skip flag set. No action is required."
            Break
        }
        ElseIf ($TimeTrigger.passBy -eq $false -and $UnSkip -eq $True) {
            Write-Warning -Message "Time Trigger $TimeTrigger_id does not have the skip flag set. No action is required."
            Break
        }
        If ($UnSkip -ne $True) {
            [string]$ProcessDescription = 'Add the Skip flag'
            [string]$passBy = 'true'
        }
        Else {
            [string]$ProcessDescription = 'Remove the Skip flag'
            [string]$passBy = 'false'
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess($TimeTrigger_id, $ProcessDescription)) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $TimeTrigger_id )
            $BodyMetaData.Add('passBy', $passBy)
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_operationId', $operation_id)
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingTemplateDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$TimeTrigger_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            If ($results.response.data[0].timeZone.Length -gt 0) {
                [string]$timezone_id = $results.response.data | Select-Object -First 1.timeZone
                [ANOWTimeZone]$timezone = Get-AutomateNOWTimeZone -Id $timezone_id
                $results.response.data[0].timeZone = $timezone
            }
            If ($results.response.data[0].processingTemplate.Length -gt 0) {
                [string]$processing_template_id = $results.response.data | Select-Object -First 1.processingTemplate
                [ANOWScheduleTemplate]$processingTemplate = Get-AutomateNOWScheduleTemplate -Id $processing_template_id
                $results.response.data[0].processingTemplate = $processingTemplate
            }
            $Error.Clear()
            Try {
                [ANOWProcessingTimeTrigger]$skipped_TimeTrigger = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to create the [ANOWProcessingTimeTrigger] object after setting the skip/unskip flag on [$TimeTrigger_id] due to [$Message]."
                Break
            }
            Write-Verbose -Message "Successfully set the skip/unskip flag on [$TimeTrigger_id]"
            If ($Quiet -ne $true) {
                Return $skipped_TimeTrigger
            }
        }
    }
    End {

    }
}

#endregion

#Region - Time Windows (RESOURCE)

Function Get-AutomateNOWTimeWindow {
    <#
    .SYNOPSIS
    Gets the Time Window objects from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Time Window objects from an AutomateNOW! instance

    .PARAMETER Id
    Optional string containing the simple id of the Time Window to fetch or you can pipeline a series of simple id strings. You may not enter an array here.

    .PARAMETER Detailed
    Switch parameter to provide the detailed properties of the [ANOWTimeWindow] object. This may only be used in conjunction with -Id. Use this option to see the fully populated object.

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100. The console default hard limit is 10,000.

    .PARAMETER sortBy
    Optional string parameter to sort the results by (may not be used with the Id parameter). Valid choices are: {To be continued...}

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .PARAMETER Folder
    Optional string to filter by a particular Folder

    .PARAMETER Tags
    Optional string array of Tags to filter by. Note that the 'containsAny' operator will be used.

    .INPUTS
    Accepts a string representing the simple id of the TimeWindow from the pipeline or individually (but not an array).

    .OUTPUTS
    Either one or more [ANOWTimeWindow] objects

    .EXAMPLE
    Gets the first page of TimeWindow objects

    Get-AutomateNOWTimeWindow

    .EXAMPLE
    Gets the first 500 TimeWindow objects

    Get-AutomateNOWTimeWindow -startRow 0 -endRow 500

    .EXAMPLE
    Gets a single non-detailed TimeWindow named 'TimeWindow1'

    Get-AutomateNOWTimeWindow -Id 'TimeWindow1'

    .EXAMPLE
    Gets a single detailed TimeWindow named 'TimeWindow1'

    Get-AutomateNOWTimeWindow -Id 'TimeWindow1' -Detailed

    .EXAMPLE
    Gets a series of TimeWindow objects through the pipeline

    'TimeWindow1' 'TimeWindow2' | Get-AutomateNOWTimeWindow

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(DefaultParameterSetName = 'Id')]
    Param(
        [Parameter(Mandatory = $False, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [Parameter(Mandatory = $False, ParameterSetName = 'Detailed', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'Detailed')]
        [switch]$Detailed,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [string]$sortBy = 'id',
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [switch]$Descending,
        [Parameter(Mandatory = $False)]
        [string]$Folder,
        [Parameter(Mandatory = $False)]
        [string[]]$Tags
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 ) {
            [string]$TimeWindow_Id = $_
        }
        Else {
            [string]$TimeWindow_Id = $Id
        }
        If ($Detailed -eq $true) {
            $Body.'id' = $TimeWindow_Id
            [string]$textMatchStyle = 'exactCase'
            $Body.'_operationId' = 'readDetailed'
            [string]$Method = 'POST'
        }
        Else {
            $Body.'_constructor' = 'AdvancedCriteria'
            $Body.'operator' = 'and'
            $Body.'criteria1' = '{"fieldName":"resourceType","operator":"equals","value":"TIME_SEMAPHORE"}'
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
            If ($TimeWindow_Id.Length -gt 0) {
                $Body.'criteria2' = ('{"fieldName":"simpleId","operator":"equals","value":"' + $TimeWindow_Id + '"}')
                [string]$textMatchStyle = 'exact'
            }
            Else {
                [string]$textMatchStyle = 'substring'
            }
            $Body.'_componentId' = 'ResourceList'
            If ($Descending -eq $true) {
                $Body.'_sortBy' = '-' + $sortBy
            }
            Else {
                $Body.'_sortBy' = $sortBy
            }
            If ($Folder.Length -gt 0) {
                $Body.'criteria3' = ('{"fieldName":"folder","operator":"equals","value":"' + $Folder + '"}')
            }
            If ($Tags.Count -gt 0) {
                If ($Tags.Count -gt 1) {
                    $Error.Clear()
                    Try {
                        [string]$TagString = $Tags | ConvertTo-Json -Compress
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "ConvertTo-Json failed to convert the provided tag names under Get-AutomateNOWTimeWindow due to [$Message]."
                        Break
                    }
                }
                Else {
                    [string]$TagString = $Tags
                }
                $Body.'criteria4' = ('{"fieldName":"tags","operator":"containsAny","value":' + $TagString + '}')
            }
            [string]$Method = 'GET'
        }
        $Body.'_operationType' = 'fetch'
        $Body.'_textMatchStyle' = $textMatchStyle
        $Body.'_dataSource' = 'ResourceDataSource'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        If ($Detailed -eq $true) {
            [string]$command = ('/resource/readDetailed')
            If ($Null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            If ($null -eq $parameters["Command"]) {
                $parameters.Add('Command', $command)
            }
            Else {
                $parameters.Command = $command
            }
        }
        Else {
            [string]$command = ('/resource/read?' + $Body)
            $parameters.Command = $command
        }
        If ($null -eq $parameters.Method) {
            $parameters.Add('Method', $Method)
        }
        Else {
            $parameters.Method = $Method
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWTimeWindow[]]$TimeWindows = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWTimeWindow failed to parse the results into [ANOWTimeWindow] objects due to [$Message]."
            Break
        }
        If ($TimeWindows.Count -gt 0) {
            Return $TimeWindows
        }
    }
    End {

    }
}

Function Set-AutomateNOWTimeWindow {
    <#
    .SYNOPSIS
    Changes the settings of an Time Window on an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of an Time Window on an AutomateNOW! instance

    .PARAMETER TimeWindow
    An [ANOWTimeWindow] object representing the Time Window to be modified.

    .PARAMETER TurnOn
    Switch parameter to set the Time Window to Open (green) status (cannot be combined with `TurnOff`).

    .PARAMETER TurnOff
    Switch parameter to set the Time Window to Closed (red) status (cannot be combined with `TurnOn`).

    .PARAMETER UnsetDescription
    Optional switch that will remove the Description from the Time Window object.

    .PARAMETER Description
    Optional string to set the description on the new Time Window object.

    .PARAMETER UnsetFolder
    Optional switch that will remove the Folder assignment from the Time Window object.

    .PARAMETER Folder
    Optional string to set a different folder on the Time Window object.

    .PARAMETER UnsetTags
    Optional switch that will remove the Tags from the Time Window object.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the new Time Window object.

    .PARAMETER CodeRepository
    Optional Code Repository to place the Time Window into. Use Get-AutomateNOWCodeRepository to fetch this object.

    .PARAMETER UnsetCodeRepository
    Switch parameter that will remove the the Time Window from its Code Repository.

    .PARAMETER Quiet
    Switch parameter that silences the output of the updated object.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWTimeWindow] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWTimeWindow] object will be returned

    .EXAMPLE
    Changes the description of an Time Window

    $TimeWindow = Get-AutomateNOWTimeWindow -Id 'TimeWindow1'
    Set-AutomateNOWTimeWindow -TimeWindow $TimeWindow -Description 'My Description'

    .EXAMPLE
    Sets a Time Window global status to Open (green)

    $TimeWindow = Get-AutomateNOWTimeWindow -Id 'TimeWindow1'
    Set-AutomateNOWTimeWindow -TimeWindow $TimeWindow -TurnOn

    .EXAMPLE
    Forcibly sets a Time Window global status to Closed (red)

    $TimeWindow = Get-AutomateNOWTimeWindow -Id 'TimeWindow1'
    Set-AutomateNOWTimeWindow -TimeWindow $TimeWindow -TurnOff -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The -TurnOn and -TurnOff parameters are isolated into their own parameter sets. Please try `Get-AutomateNOWTimeWindow -?` for more information.

    #>
    [OutputType([ANOWTimeWindow])]
    [Cmdletbinding(DefaultParameterSetName = 'Default', SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'Default', ValueFromPipeline = $True)]
        [Parameter(Mandatory = $true, ParameterSetName = 'TurnOn', ValueFromPipeline = $True)]
        [Parameter(Mandatory = $true, ParameterSetName = 'TurnOff', ValueFromPipeline = $True)]
        [ANOWTimeWindow]$TimeWindow,
        [Parameter(Mandatory = $true, ParameterSetName = 'TurnOn')]
        [switch]$TurnOn,
        [Parameter(Mandatory = $true, ParameterSetName = 'TurnOff')]
        [switch]$TurnOff,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [string[]]$Tags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [string]$Folder,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'TurnOn')]
        [Parameter(Mandatory = $false, ParameterSetName = 'TurnOff')]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'TurnOn')]
        [Parameter(Mandatory = $false, ParameterSetName = 'TurnOff')]
        [switch]$UnsetCodeRepository,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'TurnOn')]
        [Parameter(Mandatory = $false, ParameterSetName = 'TurnOff')]
        [switch]$Quiet,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'TurnOn')]
        [Parameter(Mandatory = $false, ParameterSetName = 'TurnOff')]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot set the Tags and unset them at the same time. Please choose one or the other. Tags from the source object will be carried over to the new object if you do not specify any tag-related parameters."
            Break
        }
        If ($UnsetCodeRepository -eq $true -and $CodeRepository.Id.Length -gt 0) {
            Write-Warning -Message "You cannot unset the Code Repository and set it at the same time. Please choose one or the other."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWTimeWindow]$TimeWindow = $_
        }
        $Error.Clear()
        Try {
            [ANOWTimeWindow_semaphoreState]$TimeWindow_semaphoreState = $TimeWindow.semaphoreState
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to extract the current state of the Time Window due to [$message]"
            Break
        }
        If ($TimeWindow_semaphoreState -eq 'ON' -and $TurnOn -eq $true) {
            Write-Warning -Message "This TimeWindow is already in an Open (green) state. Disregarding this request."
            Break
        }
        ElseIf ($TimeWindow_semaphoreState -eq 'OFF' -and $TurnOff -eq $true) {
            Write-Warning -Message "This Time Window is already in a Closed (red) state. Disregarding this request."
            Break
        }
        [string]$TimeWindow_id = $TimeWindow.id
        [string]$TimeWindow_simpleId = $TimeWindow.simpleId
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($TimeWindow_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$TimeWindow_exists = ($null -eq (Get-AutomateNOWTimeWindow -Id $TimeWindow_simpleId))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWTimeWindow failed to check if the TimeWindow [$TimeWindow_simpleId] already existed due to [$Message]."
                Break
            }
            If ($TimeWindow_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not an TimeWindow named [$TimeWindow_simpleId] in the [$current_domain] domain. Please check into this."
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $TimeWindow_id
            If ($TurnOn -eq $true -or $TurnOff -eq $true) {
                [string]$operationType = 'custom'
                If ($TurnOn -eq $true) {
                    [string]$operationId = 'turnOn'
                }
                Else {
                    [string]$operationId = 'turnOff'
                }
                $BodyMetaData.'_operationId' = $operationId
                [string]$command = "/resource/$operationId"
            }
            Else {
                [string]$command = '/resource/update'
                [string]$operationType = 'update'
                If ($Description.Length -gt 0) {
                    $BodyMetaData.'description' = $Description
                }
                ElseIf ($UnsetDescription -eq $true) {
                    $BodyMetaData.'description' = $Null
                }
                Else {
                    If ($TimeWindow.description.Length -gt 0) {
                        $BodyMetaData.'description' = $TimeWindow.description
                    }
                }
                If ($UnsetFolder -eq $True) {
                    $BodyMetaData.'folder' = $Null
                }
                ElseIf ($Folder.Length -gt 0) {
                    $BodyMetaData.'folder' = $Folder
                }
                Else {
                    If ($TimeWindow.folder.Length -gt 0) {
                        $BodyMetaData.'folder' = $TimeWindow.folder
                    }
                }
                If ($Tags.Count -gt 0) {
                    [int32]$tag_count = 1
                    ForEach ($tag in $Tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
                ElseIf ($UnsetTags -eq $true) {
                    $BodyMetaData.'tags' = $Null
                }
                Else {
                    If ($TimeWindow.Tags -gt 0) {
                        [int32]$tag_count = 1
                        ForEach ($tag in $TimeWindow.tags) {
                            $BodyMetaData.('tags' + $tag_count ) = $tag
                            $tag_count++
                        }
                    }
                }
            }
            If ($CodeRepository.Id.Length -gt 0) {
                [string]$CodeRepository_Id = $CodeRepository.Id
                $Error.Clear()
                Try {
                    [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository_Id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository_Id] actually existed under Set-AutomateNOWTimeWindow due to [$Message]"
                    Break
                }
                If ($code_repository_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository_Id] under Set-AutomateNOWTimeWindow. Please check again."
                    Break
                }
                $BodyMetaData.'codeRepository' = $CodeRepository_Id
            }
            ElseIf ($UnsetCodeRepository -eq $true) {
                $BodyMetaData.'codeRepository' = $null
            }
            $BodyMetaData.'_operationType' = $operationType
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_dataSource' = 'ResourceDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $parameters.Add('Command', $command)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$TimeWindow_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "TimeWindow object [$TimeWindow_id] was successfully updated"
            $Error.Clear()
            Try {
                [ANOWTimeWindow]$UpdatedTimeWindow = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the returned updated object to an [ANOWTimeWindow] object due to [$Message]. The object was still updated though."
                Break
            }
            If ($Quiet -ne $true) {
                Return $UpdatedTimeWindow
            }
        }
    }
    End {
    }
}

Function Export-AutomateNOWTimeWindow {
    <#
    .SYNOPSIS
    Exports the TimeWindow objects from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the TimeWindow objects from an instance of AutomateNOW! to a local .csv file

    .PARAMETER TimeWindow
    Mandatory [ANOWTimeWindow] object (Use Get-AutomateNOWTimeWindow to retrieve them)

    .INPUTS
    ONLY [ANOWTimeWindow] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWTimeWindow] objects are exported to the local disk in CSV format

    .EXAMPLE
    Exports all of the TimeWindow objects (up to 100 by default)

    Get-AutomateNOWTimeWindow | Export-AutomateNOWTimeWindow

    .EXAMPLE
    Exports 1 TimeWindow by name

    Get-AutomateNOWTimeWindow -Id 'TimeWindow01' | Export-AutomateNOWTimeWindow

    .EXAMPLE
    Exports a series of TimeWindow objects by the pipeline

    @( 'TimeWindow01', 'TimeWindow02' ) | Get-AutomateNOWTimeWindow | Export-AutomateNOWTimeWindow

    .NOTES
	You must present [ANOWTimeWindow] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWTimeWindow]$TimeWindow
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-TimeWindows-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWTimeWindow]$TimeWindow = $_
        }
        $Error.Clear()
        Try {
            $TimeWindow | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWTimeWindow] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function New-AutomateNOWTimeWindow {
    <#
    .SYNOPSIS
    Creates a Time Window within an AutomateNOW! instance

    .DESCRIPTION
    Creates a Time Window within an AutomateNOW! instance and returns back the newly created [ANOWTimeWindow] object

    .PARAMETER Id
    The intended name of the Time Window. For example: 'TimeWindow1'. This value may not contain the domain in brackets.

    .PARAMETER Description
    Optional description of the Time Window (may not exceed 255 characters).

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new Time Window. Do not pass [ANOWTag] objects here.

    .PARAMETER Folder
    Optional name of the folder to place the Time Window into.

    .PARAMETER CodeRepository
    Optional name of the code repository to place the Time Window into.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWTimeWindow.

    .OUTPUTS
    An [ANOWTimeWindow] object representing the newly created Time Window

    .EXAMPLE
    New-AutomateNOWTimeWindow -Id 'TimeWindow01' -Description 'Description01' -Tags 'Tag01' -Folder 'Folder01'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The name (id) of the Time Window must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    #>
    [OutputType([ANOWTimeWindow])]
    [Cmdletbinding()]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $true)]
        [string]$Id,
        [ValidateScript({ $_.Length -le 255 })]
        [Parameter(Mandatory = $false, HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [string]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [boolean]$TimeWindow_exists = ($null -ne (Get-AutomateNOWTimeWindow -Id $Id))
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWTimeWindow failed to check if the TimeWindow [$Id] already existed due to [$Message]."
        Break
    }
    If ($TimeWindow_exists -eq $true) {
        [string]$current_domain = $anow_session.header.domain
        Write-Warning -Message "There is already a TimeWindow named [$Id] in [$current_domain]. Please check into this."
        Break
    }
    ## End warning ##
    [System.Collections.Specialized.OrderedDictionary]$ANOWTimeWindow = [System.Collections.Specialized.OrderedDictionary]@{}
    $ANOWTimeWindow.Add('id', $Id)
    If ($Description.Length -gt 0) {
        $ANOWTimeWindow.Add('description', $Description)
    }
    If ($Tags.Count -gt 0) {
        [int32]$total_tags = $Tags.Count
        [int32]$current_tag = 1
        ForEach ($tag_id in $Tags) {
            $Error.Clear()
            Try {
                [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] running under New-AutomateNOWTimeWindow due to [$message]"
                Break
            }
            If ($tag_object.simpleId.length -eq 0) {
                Throw "New-AutomateNOWTimeWindow has detected that the tag [$tag_id] does not appear to exist. Please check again."
                Break
            }
            ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                [string]$tag_object_simpleId = $tag_object.simpleId
                Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                Break
            }
            [string]$tag_display = $tag_object | ConvertTo-Json -Compress
            Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
            [string]$tag_name_sequence = ('tags' + $current_tag)
            $ANOWTimeWindow.Add($tag_name_sequence, $tag_id)
            $include_properties += $tag_name_sequence
            $current_tag++
        }
    }
    If ($Folder.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] existed under New-AutomateNOWTimeWindow due to [$Message]"
            Break
        }
        If ($folder_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] under New-AutomateNOWTimeWindow. Please check again."
            Break
        }
        [string]$folder_display = $folder_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding folder $folder_display to [ANOWTimeWindow] [$Id]"
        $ANOWTimeWindow.Add('folder', $Folder)
        $include_properties += 'folder'
    }
    If ($CodeRepository.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository] existed under New-AutomateNOWTimeWindow due to [$Message]"
            Break
        }
        If ($code_repository_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository] under New-AutomateNOWTimeWindow. Please check again."
            Break
        }
        [string]$code_repository_display = $code_repository_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding code repository $code_repository_display to [ANOWTimeWindow] [$Id]"
        $ANOWTimeWindow.Add('codeRepository', $CodeRepository)
        $include_properties += 'codeRepository'
    }
    $ANOWTimeWindow.Add('title', 'Time Window')
    $ANOWTimeWindow.Add('icon', '[SKINIMG]/skin/clock.png')
    $oldvalues = ('{"title":"Time Window","resourceType":"TIME_SEMAPHORE","icon":"[SKINIMG]/skin/clock.png"}')
    [string]$BodyObject = ConvertTo-QueryString -InputObject $ANOWTimeWindow -IncludeProperties id, description, title, icon, tags, folder, codeRepository
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    $BodyMetaData.'resourceType' = 'TIME_SEMAPHORE'
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_operationType' = 'add'
    $BodyMetaData.'_oldValues' = $oldvalues
    $BodyMetaData.'_componentId' = 'ResourceCreateWindow_form'
    $BodyMetaData.'_dataSource' = 'ResourceDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$BodyMetaDataString = ConvertTo-QueryString -InputObject $BodyMetaData
    [string]$Body = ($BodyObject + '&' + $BodyMetaDataString)
    [string]$command = '/resource/create'
    [hashtable]$parameters = @{}
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('Body', $Body)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWTimeWindow]$TimeWindow = $results.response.data | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to create the [ANOWTimeWindow] object due to [$Message]."
        Break
    }
    If ($TimeWindow.id.Length -eq 0) {
        Write-Warning -Message "Somehow the newly created [ANOWTimeWindow] Time Window is empty!"
        Break
    }
    If ($Quiet -ne $true) {
        Return $TimeWindow
    }
}

Function Remove-AutomateNOWTimeWindow {
    <#
    .SYNOPSIS
    Removes a TimeWindow from an AutomateNOW! instance

    .DESCRIPTION
    Removes a TimeWindow from an AutomateNOW! instance

    .PARAMETER TimeWindow
    An [ANOWTimeWindow] object representing the TimeWindow to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWTimeWindow] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Remove a single TimeWindow by name

    Get-AutomateNOWTimeWindow -Id 'TimeWindow01' | Remove-AutomateNOWTimeWindow

    .EXAMPLE
    Removes a series of TimeWindow objects via input from the pipeline

    @( 'TimeWindow01', 'TimeWindow02', 'TimeWindow03') | Get-AutomateNOWTimeWindow | Remove-AutomateNOWTimeWindow

    .EXAMPLE
    Forcefully removes all TimeWindow objects that have a timezone configured as UTC

    Get-AutomateNOWTimeWindow | Where-Object { $_.timeZone -eq 'UTC'} | Remove-AutomateNOWTimeWindow -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWTimeWindow]$TimeWindow,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/resource/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWTimeWindow]$TimeWindow = $_
        }
        [string]$TimeWindow_id = $TimeWindow.id
        If ($TimeWindow_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($TimeWindow_id)")) -eq $true) {
            [string]$oldvalues = $TimeWindow.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $TimeWindow.id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'ResourceList'
            $BodyMetaData.'_dataSource' = 'ResourceDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$TimeWindow_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "TimeWindow [$TimeWindow_id] successfully removed"
        }
    }
    End {

    }
}

Function Copy-AutomateNOWTimeWindow {
    <#
    .SYNOPSIS
    Copies an Time Window from an AutomateNOW! instance

    .DESCRIPTION
    Copies an Time Window from an AutomateNOW! instance. AutomateNOW object id can never be changed, but we can copy the object to a new id and it will include all of the items therein.

    .PARAMETER TimeWindow
    Mandatory [ANOWTimeWindow] object to be copied.

    .PARAMETER NewId
    The name (Id) of the new Time Window. The new Id must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    .PARAMETER UnsetDescription
    Optional switch that will ensure that the newly created Time Window will not have a description set.

    .PARAMETER Description
    Optional description to set on the new Time Window object. If you do not set this, the new Time Window object will copy the Description of the source object.

    .PARAMETER UnsetFolder
    Optional switch that will ensure that the newly created Time Window will not have a Folder set.

    .PARAMETER Folder
    Optional description to set a different folder on the new Time Window object. If you do not set this, the new Time Window object will use the same Folder of the source object.

    .PARAMETER UnsetTags
    Optional switch that will ensure that the newly created Time Window will not have any Tags set.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the new Time Window object. If you do not set this, the new Time Window object will apply the same Tags of the source object.

    .PARAMETER Force
    Force the copy without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    ONLY [ANOWTimeWindow] object is accepted. Pipeline support is intentionally unavailable.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Creates a copy of an Time Window and changes the description (multi-line format)
    $TimeWindow01 = Get-AutomateNOWTimeWindow -Id 'TimeWindow_01'
    Copy-AutomateNOWTimeWindow -TimeWindow $TimeWindow01 -NewId 'TimeWindow_01_production' -Description 'TimeWindow 01 Production'

    .EXAMPLE
    Creates a copy of an Time Window that omits the description (one-liner format)
    Copy-AutomateNOWTimeWindow -TimeWindow (Get-AutomateNOWTimeWindow -Id 'TimeWindow_01') -NewId 'TimeWindow_01_production' -UnsetDescription -Tags 'Tag1', 'Tag2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWTimeWindow]$TimeWindow,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot set the Tags and unset them at the same time. Please choose one or the other. Tags from the source object will be carried over to the new object if you do not specify any tag-related parameters."
            Break
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$TimeWindow_exists = ($null -ne (Get-AutomateNOWTimeWindow -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWTimeWindow failed to check if the TimeWindow [$NewId] already existed due to [$Message]."
            Break
        }
        If ($TimeWindow_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a TimeWindow named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End warning ##
        [string]$command = '/resource/copy'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            [string]$TimeWindow_oldId = $TimeWindow.id
            [string]$TimeWindow_simpleId = $TimeWindow.simpleId
            If ($TimeWindow_oldId -eq $NewId) {
                Write-Warning -Message "The new id cannot be the same as the old id."
                Break
            }
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Copy the Time Window $($TimeWindow_simpleId) to $($NewId)?")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                If ($UnsetFolder -eq $True) {
                    $BodyMetaData.'folder' = $Null
                }
                ElseIf ($Folder.Length -gt 0) {
                    $BodyMetaData.'folder' = $Folder
                }
                Else {
                    If ($TimeWindow.folder.Length -gt 0) {
                        $BodyMetaData.'folder' = $TimeWindow.folder
                    }
                }
                If ($Tags.Count -gt 0) {
                    [int32]$tag_count = 1
                    ForEach ($tag in $Tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
                ElseIf ($UnsetTags -eq $true) {
                    $BodyMetaData.'tags' = $Null
                }
                Else {
                    If ($TimeWindow.Tags -gt 0) {
                        [int32]$tag_count = 1
                        ForEach ($tag in $TimeWindow.tags) {
                            $BodyMetaData.('tags' + $tag_count ) = $tag
                            $tag_count++
                        }
                    }
                }
                $BodyMetaData.'oldId' = $TimeWindow_oldId
                $BodyMetaData.'domain' = $TimeWindow.domain
                $BodyMetaData.'id' = $NewId
                If ($UnsetDescription -ne $true) {
                    If ($Description.Length -gt 0) {
                        $BodyMetaData.'description' = $Description
                    }
                    Else {
                        $BodyMetaData.'description' = $TimeWindow.description
                    }
                }
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_operationId' = 'copy'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_dataSource' = 'ResourceDataSource'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties oldId, domain, NewId, description, folder, tags
                $parameters.Body = $Body
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$TimeWindow_oldId] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                $Error.Clear()
                Try {
                    [ANOWTimeWindow]$NewTimeWindow = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to create copied [ANOWTimeWindow] object [$NewId] due to [$Message]."
                    Break
                }
                If ($NewTimeWindow.id.Length -eq 0) {
                    Write-Warning -Message "Somehow the newly created (copied) [ANOWTimeWindow] object [$NewId] is empty!"
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $NewTimeWindow
                }
            }
        }
    }
    End {

    }
}

Function Rename-AutomateNOWTimeWindow {
    <#
    .SYNOPSIS
    Renames a Time Window on an AutomateNOW! instance

    .DESCRIPTION
    Performs a psuedo-rename operations of a Time Window from an AutomateNOW! instance by copying it first and then deleting the source. This function merely combines Copy-AutomateNOWTimeWindow and Remove-AutomateNOWTimeWindow therefore it is to be considered destructive.

    .PARAMETER TimeWindow
    An [ANOWTimeWindow] object representing the Time Window to be renamed.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the Time Window. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER Force
    Force the renaming without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly renamed object.

    .INPUTS
    ONLY [ANOWTimeWindow] objects are accepted. There is intentionally no support for the pipeline.

    .OUTPUTS
    The newly renamed [ANOWTimeWindow] object will be returned.

    .EXAMPLE
    $TimeWindow = Get-AutomateNOWTimeWindow -Id 'TimeWindow01'
    Rename-AutomateNOWTimeWindow -TimeWindow $TimeWindow -NewId 'TimeWindow_01'

    .EXAMPLE
    Rename-AutomateNOWTimeWindow -TimeWindow (Get-AutomateNOWTimeWindow -Id 'TimeWindow01') -NewId 'TimeWindow_01'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    When renaming, you may only specify a different Id (name).

    This action will be blocked if any existing referrals are found on the object.
    #>
    [OutputType([ANOWTimeWindow])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWTimeWindow]$TimeWindow,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin standard warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$new_TimeWindow_exists = ($null -ne (Get-AutomateNOWTimeWindow -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWTimeWindow failed to check if the TimeWindow [$NewId] already existed due to [$Message]."
            Break
        }
        If ($new_TimeWindow_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a TimeWindow named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        #[string]$TimeWindow_id = $TimeWindow.id
        [string]$TimeWindow_id = $TimeWindow.simpleId
        $Error.Clear()
        Try {
            [boolean]$old_TimeWindow_exists = ($null -ne (Get-AutomateNOWTimeWindow -Id $TimeWindow_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWTimeWindow failed to check if the TimeWindow [$TimeWindow_id] already existed due to [$Message]."
            Break
        }
        If ($old_TimeWindow_exists -eq $false) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not a TimeWindow named [$TimeWindow_id] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End standard warning ##
        ## Begin referrals warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [int32]$referrals_count = Find-AutomateNOWObjectReferral -TimeWindow $TimeWindow -Count | Select-Object -Expandproperty referrals
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Find-AutomateNOWObjectReferral failed to extract the referrals on TimeWindow [$TimeWindow_id] due to [$Message]."
            Break
        }
        If ($referrals_count -gt 0) {
            Write-Warning -Message "Unfortunately, you cannot rename a TimeWindow that has referrals. This is because the rename is not actually renaming but copying anew and deleting the old. Please, use the Find-AutomateNOWObjectReferral function to identify referrals and remove them."
            Break
        }
        Else {
            Write-Verbose -Message "The TimeWindow [$TimeWindow_id] does not have any referrals. It is safe to proceed."
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($TimeWindow_id)")) -eq $true) {
                $Error.Clear()
                Try {
                    [ANOWTimeWindow]$new_TimeWindow = Copy-AutomateNOWTimeWindow -TimeWindow $TimeWindow -NewId $NewId -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Copy-AutomateNOWTimeWindow failed to create a new Time Window [$NewId] as Part 1 of the renaming process due to [$Message]."
                    Break
                }
                If ($new_TimeWindow.simpleId -eq $NewId) {
                    Write-Verbose -Message "Part 1: Time Window [$TimeWindow_id] successfully copied to [$NewId]"
                }
                Else {
                    Write-Warning -Message "Somehow the first phase (Copy-AutomateNOWTimeWindow) failed. Please look into this."
                    Break
                }
                $Error.Clear()
                Try {
                    Remove-AutomateNOWTimeWindow -TimeWindow $TimeWindow -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Remove-AutomateNOWTimeWindow failed to remove [$TimeWindow_id] as Part 2 of the renaming process due to [$Message]."
                    Break
                }
                Write-Verbose -Message "Part 2: Time Window [$TimeWindow_id] removed"
                Write-Verbose -Message "Task [$TimeWindow_id] successfully renamed to [$NewId]"
                If ($Quiet -ne $true) {
                    Return $new_TimeWindow
                }
            }
        }
        Else {
            Write-Warning -Message "No action was taken because either the source object didn't exist or the new object already existed"
        }
    }
    End {
    }
}

#endregion

#Region - TimeZones

Function Get-AutomateNOWTimeZone {
    <#
    .SYNOPSIS
    Gets all of the supported time zones from the global session variable

    .DESCRIPTION
    The `Get-AutomateNOWTimeZone` gets all of the supported time zones from the global session variable

    .INPUTS
    `Get-AutomateNOWTimeZone` accepts a timezone ID's from the pipeline

    .OUTPUTS
    An array of [ANOWTimeZone] objects

    .EXAMPLE
    Get-AutomateNOWTimeZone

    .EXAMPLE
    Get-AutomateNOWTimeZone -Id 'Pacific/Honolulu'

    .EXAMPLE
    @( 'Pacific/Honolulu', 'Pacific/Midway' ) | Get-AutomateNOWTimeZone

    .EXAMPLE
    Get-AutomateNOWTimeZone | Where-Object {$_.name -match 'Greenwich' }

    .NOTES
    You must use Import-AutomateNOWTimeZone to fill up the global session variable with the supported timezones.

    #>
    [OutputType([ANOWTimeZone[]])]
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z/+-]{1,}$' })]
        [string]$Id
    )
    Begin {
        [int32]$supported_timezone_count = $anow_session.supported_timezones.count
        If ($supported_timezone_count -eq 0) {
            Write-Warning -Message "Please use Import-AutomateNOWTimeZone to import the supported timezones into your global session variable"
            Break
        }
    }
    Process {
        If ($Id.Length -eq 0) {
            [ANOWTimeZone[]]$Result = $anow_session.supported_timezones
        }
        Else {
            [ANOWTimeZone]$Result = $anow_session.supported_timezones | Where-Object { $_.Id -eq $Id } | Select-Object -First 1
        }
        Return $Result
    }
}

Function Export-AutomateNOWTimeZone {
    <#
    .SYNOPSIS
    Exports the timezones from the global session variable

    .DESCRIPTION
    Exports the timezones from the global session variable to a local .csv file

    .PARAMETER Timezone
    Optional [ANOWTimezone] object (Use Get-AutomateNOWTimezone to retrieve them)

    .PARAMETER Id
    Optional string representing the Id of the timezone (e.g. Americas/New York)

    .INPUTS
    [ANOWTimeZone] objects from the pipeline are accepted or you can specify the name (id) of the timezone (see Examples below).

    .OUTPUTS
    The [ANOWTimeZone] objects are exported to the local disk in CSV format

    .EXAMPLE
    Get-AutomateNOWTimeZone | Export-AutomateNOWTimeZone

    .EXAMPLE
    Get-AutomateNOWTimeZone -Id 'Pacific/Honolulu' | Export-AutomateNOWtimeZone

    .EXAMPLE
    @( 'Pacific/Honolulu', 'Pacific/Midway' ) | Get-AutomateNOWTimeZone | Export-AutomateNOWTimeZone

    .EXAMPLE
    Get-AutomateNOWTimeZone | Where-Object {$_.name -match 'Greenwich' } | Export-AutomateNOWTimeZone

    .NOTES

    #>
    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWTimeZone]$TimeZone,
        [ValidateScript({ $_ -match '^[0-9a-zA-z/+-]{1,}$' })]
        [Parameter(Mandatory = $false, ParameterSetName = 'Individual')]
        [string]$Id
    )
    Begin {
        [int32]$supported_timezone_count = $anow_session.supported_timezones.count
        If ($supported_timezone_count -eq 0) {
            Write-Warning -Message "Please use Import-AutomateNOWTimeZone to import the supported timezones into your global session variable"
            Break
        }
        Else {
            Write-Verbose -Message "Exporting $supported_timezone_count timezone objects."
        }
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = ('Export-AutomateNOW-TimeZones-' + $current_time + '.csv')
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($All -eq $true) {
            $Error.Clear()
            Try {
                [ANOWTimeZone[]]$ANOWTimeZones = $anow_session.supported_timezones
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to extract the [ANOWTimeZone] objects due to [$Message]"
                Break
            }
            $Error.Clear()
            Try {
                $ANOWTimeZones | Export-CSV @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Export-CSV failed to export the [ANOWTimeZone] objects due to [$Message]"
                Break
            }
        }
        ElseIf ($_.id.Length -gt 0) {
            If ($null -eq $parameters.'Append') {
                $parameters.Add('Append', $true)
            }
            [string]$current_timezone_id = $_.id
            [ANOWTimeZone]$ANOWTimeZone = $anow_session.supported_timezones | Where-Object { $_.id -eq $current_timezone_id } | Select-Object -First 1
            $Error.Clear()
            Try {
                $ANOWTimeZone | Export-CSV @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Export-CSV failed to export the [ANOWTimeZone] object on the pipeline due to [$Message]"
                Break
            }
        }
        ElseIf ($Id.length -gt 0) {
            $Error.Clear()
            Try {
                [ANOWTimeZone]$ANOWTimeZone = $anow_session.supported_timezones | Where-Object { $_.Id -eq $Id }
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to extracted the named timezone due to [$Message]. Did you enter a valid Id?"
                Break
            }
            $Error.Clear()
            Try {
                $ANOWTimeZone | Export-CSV @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Export-CSV failed to export the [ANOWTimeZone] objects due to [$Message]"
                Break
            }
        }
        Else {
            Write-Warning -Message "Export-AutomateNOWTimeZone was somehow unable to process the input"
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function Import-AutomateNOWTimeZone {
    <#
    .SYNOPSIS
    Imports all of the supported time zones from an instance of AutomateNOW!

    .DESCRIPTION
    The `Import-AutomateNOWTimeZone` imports all of the supported time zones from an instance of AutomateNOW! into the existing global session variable.

    .INPUTS
    None. You cannot pipe objects to Import-AutomateNOWTimeZone.

    .OUTPUTS
    There is no direct output as the timezone objects are loaded into the existing global session variable.

    .EXAMPLE
    Import-AutomateNOWTimeZone

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    There are no parameters for Import-AutomateNOWTimeZone.

    #>
    [Cmdletbinding()]
    Param(
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    [string]$command = '/home/readTimeZones'
    $BodyObject = New-Object -TypeName System.Collections.Specialized.OrderedDictionary
    $BodyObject.Add('_operationType', 'fetch')
    $BodyObject.Add('_textMatchStyle', 'exact')
    $BodyObject.Add('_componentId', 'cacheAllData')
    $BodyObject.Add('_dataSource', 'TimeZoneDataSource')
    $BodyObject.Add('_operationId', 'TimeZoneDataSource_fetch')
    $BodyObject.Add('isc_metaDataPrefix', '_')
    $BodyObject.Add('isc_dataFormat', 'json')
    [string]$Body = ConvertTo-QueryString -InputObject $BodyObject
    [string]$Instance = $anow_session.Instance
    [hashtable]$parameters = @{}
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'GET')
    $parameters.Add('Body', $Body)
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Instance', $Instance)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
        Break
    }
    [ANOWTimezone[]]$TimeZones = $results.response.data
    [int32]$TimeZones_count = $TimeZones.Count
    If ($TimeZones_count -eq 0) {
        Write-Warning -Message "Somehow there are 0 time zones..."
        Break
    }
    If ($null -eq $anow_session.supported_timezones) {
        $anow_session.Add('supported_timezones', $TimeZones)
    }
    Else {
        $anow_session.supported_timezones = $TimeZones
    }
    Write-Verbose -Message "Imported [$TimeZones_count] time zones into the current session"
}

Function Import-AutomateNOWLocalTimeZone {
    <#
    .SYNOPSIS
    Imports all of the supported time zones from a local file

    .DESCRIPTION
    Imports all of the supported time zones from a local file

    .PARAMETER OverrideConnectionRequirement
    Switch parameter that overrides the requirement to be connected to an ANOW instance before importing the local timezone file into the ANOW session global variable. You should delete that variable that gets created "anow_session" when you are finished with ANOW TimeZones.

    .INPUTS
    None. You cannot pipe objects to Import-AutomateNOWTimeZone.

    .OUTPUTS
    There is no direct output as the timezone objects are loaded into the existing global session variable.

    .EXAMPLE
    Import-AutomateNOWLocalTimeZone

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    There are no parameters for Import-AutomateNOWTimeZone.

    #>
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory = $false)]
        [switch]$OverrideConnectionRequirement
    )
    [string]$LocalTimezoneFile = ($PSScriptRoot + '\timezones.txt')
    If ((Test-Path -Path "$LocalTimezoneFile") -eq $false) {
        Write-Warning -Message "The timezones.txt file is not available!"
    }
    $Error.Clear()
    Try {
        [ANOWTimezone[]]$TimeZones = Get-Content -Path "$LocalTimezoneFile" | ConvertFrom-Json
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Unable to read the local time zones file [$LocalTimezoneFile] due to [$Message]"
        Break
    }
    If ($null -eq $anow_session -and $OverrideConnectionRequirement -ne $true) {
        Write-Warning -Message "You must already have an established session before trying to import the local timezone file. Use the -OverrideConnectionRequirement switch parameter to override this requirement. Pay heed to the warnings that follow."
        Break
    }
    ElseIf ( $null -eq $anow_session -and $OverrideConnectionRequirement -eq $true) {
        Write-Warning -Message "You are overriding the requirement to be connected to an instance when importing the ANOW Time Zones. Please delete the global variable anow_session when you are finished with ANOW Time Zones. Remove-Variable -Name anow_session -Force"
        [hashtable]$anow_session = @{}
        $Error.Clear()
        Try {
            New-Variable -Name 'anow_session' -Scope Global -Value $anow_session -Force
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "New-Variable failed to create the session properties object under Import-AutomateNOWLocalTimeZone due to [$Message]"
            Break
        }
    }
    If ($null -eq $anow_session.supported_timezones) {
        $anow_session.Add('supported_timezones', $TimeZones)
    }
    Else {
        $anow_session.supported_timezones = $TimeZones
    }
    Write-Verbose -Message "Imported [$TimeZones_count] timezones into the current session"
}

#endregion

#Region - User Reports

Function Get-AutomateNOWUserReport {
    <#
    .SYNOPSIS
    Gets the User Reports from an AutomateNOW! instance

    .DESCRIPTION
    Gets the User Reports from an AutomateNOW! instance

    .PARAMETER Id
    The Id of the AdHoc Report. Use this when you only want to retrieve a single report. This parameter cannot be combined with -startRow/-endRow.

    .PARAMETER startRow
    Integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER Folder
    Optional string of the name of the Folder to filter by.

    .PARAMETER Tags
    Optional string array of tags to filter by. Note that for now operator is 'containsAny', not 'containsAll'.

    .INPUTS
    Accepts a string representing the simple id of the User Report from the pipeline or individually (but not an array) or you can specify by start and end rows.

    .OUTPUTS
    An array of one or more [ANOWUserReport] class objects

    .EXAMPLE
    Gets all of the User Report objects
    Get-AutomateNOWUserReport

    .EXAMPLE
    Gets a specific User Report object
    Get-AutomateNOWUserReport -Id 'my_UserReport_01'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Run this function without parameters to retrieve all of the UserReports.

    #>
    [OutputType([ANOWUserReport[]])]
    [Cmdletbinding( DefaultParameterSetName = 'Default' )]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $False, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string[]]$tags,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$folder
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 -or $Id.Length -gt 0) {
            If ($_.Length -gt 0 ) {
                $Body.'id' = $_
            }
            Else {
                $Body.'id' = $Id
            }
            [string]$textMatchStyle = 'exactCase'
            $Body.'_operationId' = 'read'
        }
        Else {
            $Body.Add('operator', 'and')
            $Body.Add('_constructor', 'AdvancedCriteria')
            If ($Tags.count -eq 1) {
                $Body.'criteria1' = '{"fieldName":"tags","operator":"containsAny","value":"' + $tags + '"}'
            }
            ElseIf ($Tags.count -gt 1) {
                [string]$tags_json = $tags | Sort-Object -Unique | ConvertTo-JSON -Compress
                $Body.'criteria1' = '{"fieldName":"tags","operator":"containsAny","value":' + $tags_json + '}'
            }
            If ($Folder.Length -gt 0) {
                $Error.Clear()
                Try {
                    [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] existed under Get-AutomateNOWUserReport due to [$Message]"
                    Break
                }
                If ($folder_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] under Get-AutomateNOWUserReport. Please check again."
                    Break
                }
                [string]$folder_id = $folder_object.simpleId
                $Body.'criteria2' = ('{"fieldName":"folder","operator":"equals","value":' + $folder_id + '}')

            }
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
            [string]$textMatchStyle = 'substring'
            $Body.'_componentId' = 'UserReportList'
        }
        $Body.'_textMatchStyle' = $textMatchStyle
        $Body.'_dataSource' = 'UserReportDataSource'
        $Body.'_operationType' = 'fetch'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/userReport/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] while running Get-AutomateNOWUserReport due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWUserReport[]]$UserReports = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWUserReport] objects due to [$Message]."
            Break
        }
        If ($UserReports.Count -gt 0) {
            Return $UserReports
        }
    }
    End {

    }
}

Function Set-AutomateNOWUserReport {
    <#
    .SYNOPSIS
    Changes the settings of a UserReport on an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of a UserReport on an AutomateNOW! instance

    .PARAMETER UserReport
    An [ANOWUserReport] object representing the UserReport to be changed.

    .PARAMETER Description
    A text description of at least 1 character.

    .PARAMETER RemoveIcon
    Switch parameter that will unset the icon configured for this UserReport.

    .PARAMETER iconSet
    The name of the icon library (if you choose to use one). Possible choices are: FAT_COW, FUGUE (note that FONT_AWESOME is not an actual icon library)

    .PARAMETER iconCode
    The name of the icon which matches the chosen library. Must be lower-case. To see the list of available iconCodes, use Import-AutomateNOWIcon (or Import-AutomateNOWLocalIcon) then try $anow_assets.icon_library."FUGUE"[0..10] to see the names of the first 10 icons from the Fugue library.

    .PARAMETER Folder
    String that specifies the name of the folder to add the UserReport to.

    .PARAMETER UnsetFolder
    Switch parameter that will remove the UserReport from its current folder.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the new Adhoc Report object.

    .PARAMETER UnsetTags
    Switch parameter that will remove all Tags.

    .PARAMETER CodeRepository
    Optional Code Repository to place the User Report into. Use Get-AutomateNOWCodeRepository to fetch this object.

    .PARAMETER UnsetCodeRepository
    Switch parameter that will remove the the User Report from its Code Repository.

    .PARAMETER Quiet
    Switch parameter that silences the output of the updated object.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWUserReport] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWUserReport] object will be returned

    .EXAMPLE
    Sets the tags, folder and description on a UserReport
    Get-AutomateNOWUserReport -Id 'UserReport1' | Set-AutomateNOWUserReport -Tags 'Tag1', 'Tag2' -Folder 'Folder1' -Description 'MyCoolDescription'

    .EXAMPLE
    Forcibly removes the tags, folder, description and icon from a UserReport
    Get-AutomateNOWUserReport -Id 'UserReport1' | Set-AutomateNOWUserReport -RemoveIcon -UnsetDescription -UnsetTags -UnsetFolder -Force

    .EXAMPLE
    Sets the tags on a UserReport
    Get-AutomateNOWUserReport -Id 'UserReport1' | Set-AutomateNOWUserReport -iconSet 'FAT_COW' -iconCode 'abacus'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The -iconSet and -iconCode parameter set requires that you import the local icon names with Import-AutomateNOWIcon or Import-AutomateNOWLocalIcon. This is only to check that the name of the icon being sent to the API is valid.

    If you have three tags on a UserReport and wanted to remove one then use the -SetTags parameter to apply the 2 that you want to keep. If you want to remove all tags then use -UnsetTags.

    If you unset the icon from a UserReport, ANOW will use the default icon (fat_cow\user_report.png)

    The -iconCode and -iconSet parameters may only be used together and exclusive from the rest of the parameters.

    You may not edit the definition of the UserReport with this function. However, you can try editing the source object with Edit-AutomateNOWCodeRepositoryObjectSource

    #>
    [OutputType([ANOWUserReport])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High', DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'Default', ValueFromPipeline = $True)]
        [Parameter(Mandatory = $true, ParameterSetName = 'SetIcon', ValueFromPipeline = $True)]
        [ANOWUserReport]$UserReport,
        [ValidateScript({ $_.Length -le 255 })]
        [Parameter(Mandatory = $false, ParameterSetName = 'Default', HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [string]$Description,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $true, ParameterSetName = 'SetIcon')]
        [ANOWIcon_IconsOnly]$iconSet,
        [ValidateScript({ $_ -match '^[a-z0-9-_]{1,}$' })]
        [Parameter(Mandatory = $true, ParameterSetName = 'SetIcon')]
        [string]$iconCode,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$RemoveIcon,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [string]$Folder,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [string[]]$Tags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'SetIcon')]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'SetIcon')]
        [switch]$UnsetCodeRepository,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'SetIcon')]
        [switch]$Quiet,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'SetIcon')]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($iconSet.length -gt 0 ) {
            If ($anow_assets.icon_library.length -eq 0) {
                Write-Warning -Message "Please import the ANOW icons into your session with Import-AutomateNOWIcon or Import-AutomateNOWLocalIcon"
                Break
            }
            If ($iconCode -notin ($anow_assets.icon_library."$iconSet")) {
                Write-Warning -Message "The icon [$iconCode] does not appear to exist within the [$iconSet] icon set. Please check again."
                Break
            }
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot set the Tags and unset them at the same time. Please choose one or the other. Tags from the source object will be carried over to the new object if you do not specify any tag-related parameters."
            Break
        }
        If ($UnsetCodeRepository -eq $true -and $CodeRepository.Id.Length -gt 0) {
            Write-Warning -Message "You cannot unset the Code Repository and set it at the same time. Please choose one or the other."
            Break
        }
        [string]$command = '/userReport/update'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWUserReport]$UserReport = $_
        }
        [string]$UserReport_id = $UserReport.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($UserReport_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$UserReport_exists = ($null -eq (Get-AutomateNOWUserReport -Id $UserReport_id))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWUserReport failed to check if the UserReport [$UserReport_id] already existed due to [$Message]."
                Break
            }
            If ($UserReport_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not a UserReport named [$UserReport_id] in the current domain [$current_domain]. Please check into this."
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $UserReport_id
            $BodyMetaData.'_oldValues' = $UserReport.CreateOldValues()
            If ($Description.Length -gt 0) {
                $BodyMetaData.'description' = $Description
            }
            ElseIf ($UnsetDescription -eq $true) {
                $BodyMetaData.'description' = $null
            }
            If ($RemoveIcon -eq $true) {
                $BodyMetaData.'iconSet' = $null
                $BodyMetaData.'iconCode' = $null
                $BodyMetaData.'_componentId' = 'UserReportVM'
            }
            ElseIf ($iconCode.Length -gt 0) {
                $BodyMetaData.'iconCode' = $iconCode
                $BodyMetaData.'iconSet' = $iconSet
                $BodyMetaData.'_componentId' = 'UserReportEditForm'
            }
            If ($Folder.Length -gt 0) {
                $Error.Clear()
                Try {
                    [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] actually existed under Set-AutomateNOWUserReport due to [$Message]"
                    Break
                }
                If ($folder_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] under Set-AutomateNOWUserReport. Please check again."
                    Break
                }
                [string]$folder_display = $folder_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Adding folder $folder_display to [ANOWUserReport] [$UserReport_id]"
                $BodyMetaData.'folder' = $Folder
            }
            ElseIf ($UnsetFolder -eq $true) {
                $BodyMetaData.'folder' = $null
            }
            If ($Tags.Count -gt 0) {
                [int32]$total_tags = $Tags.Count
                [int32]$current_tag = 1
                ForEach ($tag_id in $Tags) {
                    $Error.Clear()
                    Try {
                        [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] running under Set-AutomateNOWUserReport due to [$message]"
                        Break
                    }
                    If ($tag_object.simpleId.length -eq 0) {
                        Throw "Get-AutomateNOWTag has detected that the tag [$tag_id] does not appear to exist running under Set-AutomateNOWUserReport. Please check again."
                        Break
                    }
                    ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                        [string]$tag_object_simpleId = $tag_object.simpleId
                        Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                        Break
                    }
                    [string]$tag_display = $tag_object | ConvertTo-Json -Compress
                    Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
                    [string]$tag_name_sequence = ('tags' + $current_tag)
                    $BodyMetaData."$tag_name_sequence" = $tag_id
                    $include_properties += $tag_name_sequence
                    $current_tag++
                }
            }
            ElseIf ($UnsetTags -eq $true) {
                $BodyMetaData.'tags' = $null
            }
            If ($CodeRepository.Id.Length -gt 0) {
                [string]$CodeRepository_Id = $CodeRepository.Id
                $Error.Clear()
                Try {
                    [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository_Id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository_Id] actually existed under Set-AutomateNOWUserReport due to [$Message]"
                    Break
                }
                If ($code_repository_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository_Id] under Set-AutomateNOWUserReport. Please check again."
                    Break
                }
                $BodyMetaData.'codeRepository' = $CodeRepository_Id
            }
            ElseIf ($UnsetCodeRepository -eq $true) {
                $BodyMetaData.'codeRepository' = $null
            }
            $BodyMetaData.'_operationType' = 'update'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_dataSource' = 'UserReportDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties $include_properties
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$UserReport_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "UserReport $UserReport_id was successfully updated"
            $Error.Clear()
            Try {
                [ANOWUserReport]$UpdatedUserReport = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the returned updated object to an [ANOWUserReport] object due to [$Message]. The object was still updated though."
                Break
            }
            If ($Quiet -ne $true) {
                Return $UpdatedUserReport
            }
        }
    }
    End {

    }
}

Function Export-AutomateNOWUserReport {
    <#
    .SYNOPSIS
    Exports the UserReports from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the UserReports from an instance of AutomateNOW! to a local .csv file

    .PARAMETER UserReport
    Mandatory [ANOWUserReport] object (Use Get-AutomateNOWUserReport to retrieve them)

    .INPUTS
    ONLY [ANOWUserReport] objects from the pipeline are accepted. Strings are not accepted.

    .OUTPUTS
    The [ANOWUserReport] objects are exported to the local disk in CSV format

    .EXAMPLE
    Get-AutomateNOWUserReport | Export-AutomateNOWUserReport

    .NOTES
	You must present [ANOWUserReport] objects to the pipeline to use this function.
    #>

    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ANOWUserReport]$UserReport
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-UserReport-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWUserReport]$UserReport = $_
        }
        $Error.Clear()
        Try {
            $UserReport | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWUserReport] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function Remove-AutomateNOWUserReport {
    <#
    .SYNOPSIS
    Removes a UserReport from an AutomateNOW! instance

    .DESCRIPTION
    Removes a UserReport from an AutomateNOW! instance

    .PARAMETER UserReport
    An [ANOWUserReport] object representing the UserReport to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWUserReport] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Get-AutomateNOWUserReport -Id 'UserReport01' | Remove-AutomateNOWUserReport

    .EXAMPLE
    @( 'UserReport1', 'UserReport2', 'UserReport3') | Remove-AutomateNOWUserReport

    .EXAMPLE
    Get-AutomateNOWUserReport | ? { $_.simpleId -like 'test*' } | Remove-AutomateNOWUserReport

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWUserReport]$UserReport,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/userReport/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWUserReport]$UserReport = $_
        }
        [string]$UserReport_id = $UserReport.id
        If ($UserReport_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($UserReport_id)")) -eq $true) {
            [string]$oldvalues = $UserReport.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $UserReport_id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'UserReportList'
            $BodyMetaData.'_dataSource' = 'UserReportDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$UserReport_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "UserReport $UserReport_id successfully removed"
        }
    }
    End {

    }
}

Function Copy-AutomateNOWUserReport {
    <#
    .SYNOPSIS
    Copies an UserReport from an AutomateNOW! instance

    .DESCRIPTION
    Copies a UserReport from an AutomateNOW! instance.

    .PARAMETER UserReport
    Mandatory [ANOWUserReport] object to be copied.

    .PARAMETER NewId
    The name (Id) of the new UserReport. The new Id must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    .PARAMETER UnsetDescription
    Optional switch that will ensure that the newly created UserReport will not have a description set.

    .PARAMETER Description
    Optional description to set on the new UserReport object. If you do not set this, the new UserReport object will copy the Description of the source object.

    .PARAMETER UnsetFolder
    Optional switch that will ensure that the newly created UserReport will not have a Folder set.

    .PARAMETER Folder
    Optional description to set a different folder on the new UserReport object. If you do not set this, the new UserReport object will use the same Folder of the source object.

    .PARAMETER UnsetTags
    Optional switch that will ensure that the newly created UserReport will not have any Tags set.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the new UserReport object. If you do not set this, the new UserReport object will apply the same Tags of the source object.

    .PARAMETER Force
    Force the copy without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    ONLY [ANOWUserReport] object is accepted. Pipeline support is intentionally unavailable.

    .OUTPUTS
    The newly created [ANOWUserReport] object will be emitted. Use the -Quiet parameter to suppress this.

    .EXAMPLE
    Creates a copy of a UserReport named 'UserReport1' to 'UserReport1_production' and changes the description
    $UserReport1 = Get-AutomateNOWUserReport -Id 'UserReport1'
    Copy-AutomateNOWUserReport -UserReport $UserReport01 -NewId 'UserReport1_production' -Description 'UserReport1 - Production'

    .EXAMPLE
    Creates a copy of a UserReport named 'UserReport1' to 'UserReport1_production' that omits the description but also sets different tags on the new copy.
    Copy-AutomateNOWUserReport -UserReport (Get-AutomateNOWUserReport -Id 'UserReport1') -NewId 'UserReport1_production' -UnsetDescription -Tags 'Tag1', 'Tag2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global UserReport.

    AutomateNOW object id's can never change, but we can copy the object to a new id and it will (typically) include all of the items therein.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWUserReport]$UserReport,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot set the Tags and unset them at the same time. Please choose one or the other. Tags from the source object will be carried over to the new object if you do not specify any tag-related parameters."
            Break
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$UserReport_exists = ($null -ne (Get-AutomateNOWUserReport -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWUserReport failed to check if the UserReport [$NewId] already existed due to [$Message]."
            Break
        }
        If ($UserReport_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a UserReport named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End warning ##
        [string]$command = '/userReport/copy'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            [string]$UserReport_oldId = $UserReport.id
            [string]$UserReport_simpleId = $UserReport.simpleId
            If ($UserReport_oldId -eq $NewId) {
                Write-Warning -Message "The new id cannot be the same as the old id."
                Break
            }
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Copy the UserReport $($UserReport_simpleId) to $($NewId)?")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                If ($UnsetFolder -eq $True) {
                    $BodyMetaData.'folder' = $Null
                }
                ElseIf ($Folder.Length -gt 0) {
                    $BodyMetaData.'folder' = $Folder
                }
                Else {
                    If ($UserReport.folder.Length -gt 0) {
                        $BodyMetaData.'folder' = $UserReport.folder
                    }
                }
                If ($Tags.Count -gt 0) {
                    [int32]$tag_count = 1
                    ForEach ($tag in $Tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
                ElseIf ($UnsetTags -eq $true) {
                    $BodyMetaData.'tags' = $Null
                }
                Else {
                    If ($UserReport.Tags -gt 0) {
                        [int32]$tag_count = 1
                        ForEach ($tag in $UserReport.tags) {
                            $BodyMetaData.('tags' + $tag_count ) = $tag
                            $tag_count++
                        }
                    }
                }
                $BodyMetaData.'oldId' = $UserReport_oldId
                $BodyMetaData.'domain' = $UserReport.domain
                $BodyMetaData.'id' = $NewId
                If ($UnsetDescription -ne $true) {
                    If ($Description.Length -gt 0) {
                        $BodyMetaData.'description' = $Description
                    }
                    Else {
                        $BodyMetaData.'description' = $UserReport.description
                    }
                }
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_operationId' = 'copy'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_dataSource' = 'UserReportDataSource'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties oldId, domain, NewId, description, folder, tags
                $parameters.Body = $Body
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$UserReport_oldId] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                $Error.Clear()
                Try {
                    [ANOWUserReport]$NewUserReport = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to create copied [ANOWUserReport] object [$NewId] due to [$Message]."
                    Break
                }
                If ($NewUserReport.id.Length -eq 0) {
                    Write-Warning -Message "Somehow the newly created (copied) [ANOWUserReport] object [$NewId] is empty!"
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $NewUserReport
                }
            }
        }
    }
    End {

    }
}

Function Rename-AutomateNOWUserReport {
    <#
    .SYNOPSIS
    Renames a UserReport on an AutomateNOW! instance

    .DESCRIPTION
    Performs a psuedo-rename operations of a UserReport from an AutomateNOW! instance by copying it first and then deleting the source. This function merely combines Copy-AutomateNOWUserReport and Remove-AutomateNOWUserReport therefore it is to be considered destructive.

    .PARAMETER UserReport
    An [ANOWUserReport] object representing the UserReport to be renamed.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the UserReport. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER Force
    Force the renaming without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly renamed object.

    .INPUTS
    ONLY [ANOWUserReport] objects are accepted. There is intentionally no support for the pipeline.

    .OUTPUTS
    The newly renamed [ANOWUserReport] object will be returned.

    .EXAMPLE
    Renames a UserReport from 'UserReport1' to 'UserReport2' in a multi-line format

    $UserReport = Get-AutomateNOWUserReport -Id 'UserReport1'
    Rename-AutomateNOWUserReport -UserReport $UserReport -NewId 'UserReport2'

    .EXAMPLE
    Renames a UserReport from 'UserReport1' to 'UserReport2' in a single-line format

    Rename-AutomateNOWUserReport -UserReport (Get-AutomateNOWUserReport -Id 'UserReport1') -NewId 'UserReport2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global UserReport.

    When renaming, you may only specify a different Id (name).

    This action will be blocked if any existing referrals are found on the object.
    #>
    [OutputType([ANOWUserReport])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWUserReport]$UserReport,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin standard warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$new_UserReport_exists = ($null -ne (Get-AutomateNOWUserReport -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWUserReport failed to check if the UserReport [$NewId] already existed due to [$Message]."
            Break
        }
        If ($new_UserReport_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a UserReport named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        #[string]$UserReport_id = $UserReport.id
        [string]$UserReport_id = $UserReport.simpleId
        $Error.Clear()
        Try {
            [boolean]$old_UserReport_exists = ($null -ne (Get-AutomateNOWUserReport -Id $UserReport_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWUserReport failed to check if the UserReport [$UserReport_id] already existed due to [$Message]."
            Break
        }
        If ($old_UserReport_exists -eq $false) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not a UserReport named [$UserReport_id] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End standard warning ##
        ## Begin referrals warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.

        <# Temporarily commented out because Object Referrals are not supported for User Reports (yet)

        $Error.Clear()
        Try {
            [int32]$referrals_count = Find-AutomateNOWObjectReferral -UserReport $UserReport -Count | Select-Object -Expandproperty referrals
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Find-AutomateNOWObjectReferral failed to extract the referrals on UserReport [$UserReport_id] due to [$Message]."
            Break
        }
        If ($referrals_count -gt 0) {
            Write-Warning -Message "Unfortunately, you cannot rename a UserReport that has referrals. This is because the rename is not actually renaming but copying anew and deleting the old. Please, use the Find-AutomateNOWObjectReferral function to identify referrals and remove them."
            Break
        }
        Else {
            Write-Verbose -Message "The UserReport [$UserReport_id] does not have any referrals. It is safe to proceed."
        }
        #>
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($UserReport_id)")) -eq $true) {
                $Error.Clear()
                Try {
                    [ANOWUserReport]$new_UserReport = Copy-AutomateNOWUserReport -UserReport $UserReport -NewId $NewId -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Copy-AutomateNOWUserReport failed to create a new UserReport [$NewId] as Part 1 of the renaming process due to [$Message]."
                    Break
                }
                If ($new_UserReport.simpleId -eq $NewId) {
                    Write-Verbose -Message "Part 1: UserReport [$UserReport_id] successfully copied to [$NewId]"
                }
                Else {
                    Write-Warning -Message "Somehow the first phase (Copy-AutomateNOWUserReport) failed. Please look into this."
                    Break
                }
                $Error.Clear()
                Try {
                    Remove-AutomateNOWUserReport -UserReport $UserReport -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Remove-AutomateNOWUserReport failed to remove [$UserReport_id] as Part 2 of the renaming process due to [$Message]."
                    Break
                }
                Write-Verbose -Message "Part 2: UserReport [$UserReport_id] removed"
                Write-Verbose -Message "Task [$UserReport_id] successfully renamed to [$NewId]"
                If ($Quiet -ne $true) {
                    Return $UserReport
                }
            }
        }
        Else {
            Write-Warning -Message "No action was taken because either the source object didn't exist or the new object already existed"
        }
    }
    End {
    }
}

#endregion

#Region - Variables (RESOURCE)

Function Get-AutomateNOWVariable {
    <#
    .SYNOPSIS
    Gets the Variable objects from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Variable objects from an AutomateNOW! instance

    .PARAMETER Id
    Optional string containing the simple id of the Variable to fetch or you can pipeline a series of simple id strings. You may not enter an array here.

    .PARAMETER Detailed
    Switch parameter to provide the detailed properties of the [ANOWVariable] object. This may only be used in conjunction with -Id. Use this option to see the fully populated object.

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100. The console default hard limit is 10,000.

    .PARAMETER sortBy
    Optional string parameter to sort the results by (may not be used with the Id parameter). Valid choices are: {To be continued...}

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .PARAMETER Folder
    Optional string to filter by a particular Folder

    .PARAMETER Tags
    Optional string array of Tags to filter by. Note that the 'containsAny' operator will be used.

    .INPUTS
    Accepts a string representing the simple id of the Variable from the pipeline or individually (but not an array).

    .OUTPUTS
    Either one or more [ANOWVariable] objects

    .EXAMPLE
    Gets the first page of Variables

    Get-AutomateNOWVariable

    .EXAMPLE
    Gets the first 500 Variable objects

    Get-AutomateNOWVariable -startRow 0 -endRow 500

    .EXAMPLE
    Gets the non-detailed version of a Variable named 'Variable1'

    Get-AutomateNOWVariable -Id 'Variable1'

    .EXAMPLE
    Gets the non-detailed version of a Variable named 'Variable1'

    Get-AutomateNOWVariable -Id 'Variable1' -Detailed

    .EXAMPLE
    Gets a series of Variable objects through the pipeline

    'Variable1' 'Variable2' | Get-AutomateNOWVariable

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(DefaultParameterSetName = 'Id')]
    Param(
        [Parameter(Mandatory = $False, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [Parameter(Mandatory = $False, ParameterSetName = 'Detailed', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'Detailed')]
        [switch]$Detailed,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [string]$sortBy = 'id',
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [switch]$Descending,
        [Parameter(Mandatory = $False)]
        [string]$Folder,
        [Parameter(Mandatory = $False)]
        [string[]]$Tags
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 ) {
            [string]$Variable_Id = $_
        }
        Else {
            [string]$Variable_Id = $Id
        }
        If ($Detailed -eq $true) {
            $Body.'id' = $Variable_Id
            [string]$textMatchStyle = 'exactCase'
            $Body.'_operationId' = 'readDetailed'
            [string]$Method = 'POST'
        }
        Else {
            $Body.'_constructor' = 'AdvancedCriteria'
            $Body.'operator' = 'and'
            $Body.'criteria1' = '{"fieldName":"resourceType","operator":"equals","value":"VARIABLE"}'
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
            If ($Variable_Id.Length -gt 0) {
                $Body.'criteria2' = ('{"fieldName":"simpleId","operator":"equals","value":"' + $Variable_Id + '"}')
                [string]$textMatchStyle = 'exact'
            }
            Else {
                [string]$textMatchStyle = 'substring'
            }
            $Body.'_componentId' = 'ResourceList'
            If ($Descending -eq $true) {
                $Body.'_sortBy' = '-' + $sortBy
            }
            Else {
                $Body.'_sortBy' = $sortBy
            }
            If ($Folder.Length -gt 0) {
                $Body.'criteria3' = ('{"fieldName":"folder","operator":"equals","value":"' + $Folder + '"}')
            }
            If ($Tags.Count -gt 0) {
                If ($Tags.Count -gt 1) {
                    $Error.Clear()
                    Try {
                        [string]$TagString = $Tags | ConvertTo-Json -Compress
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "
                         due to [$Message]."
                        Break
                    }
                }
                Else {
                    [string]$TagString = $Tags
                }
                $Body.'criteria4' = ('{"fieldName":"tags","operator":"containsAny","value":' + $TagString + '}')
            }
            [string]$Method = 'GET'
        }
        $Body.'_operationType' = 'fetch'
        $Body.'_textMatchStyle' = $textMatchStyle
        $Body.'_dataSource' = 'ResourceDataSource'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        If ($Detailed -eq $true) {
            [string]$command = ('/resource/readDetailed')
            If ($Null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            If ($null -eq $parameters["Command"]) {
                $parameters.Add('Command', $command)
            }
            Else {
                $parameters.Command = $command
            }
        }
        Else {
            [string]$command = ('/resource/read?' + $Body)
            $parameters.Command = $command
        }
        If ($null -eq $parameters.Method) {
            $parameters.Add('Method', $Method)
        }
        Else {
            $parameters.Method = $Method
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWVariable[]]$Variables = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWVariable failed to parse the results into [ANOWVariable] objects due to [$Message]."
            Break
        }
        If ($Variables.Count -gt 0) {
            Return $Variables
        }
    }
    End {

    }
}

Function Set-AutomateNOWVariable {
    <#
    .SYNOPSIS
    Changes the settings of an Variable on an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of an Variable on an AutomateNOW! instance

    .PARAMETER Variable
    An [ANOWVariable] object representing the Variable to be modified.

    .PARAMETER Value
    Optional string to set the value of the variable to.

    .PARAMETER UnsetDescription
    Optional switch that will remove the Description from the Variable object.

    .PARAMETER Description
    Optional string to set the description on the new Variable object.

    .PARAMETER UnsetFolder
    Optional switch that will remove the Folder assignment from the Variable object.

    .PARAMETER Folder
    Optional string to set a different folder on the Variable object.

    .PARAMETER UnsetTags
    Optional switch that will remove the Tags from the Variable object.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the new Variable object.

    .PARAMETER CodeRepository
    Optional Code Repository to place the Variable into. Use Get-AutomateNOWCodeRepository to fetch this object.

    .PARAMETER UnsetCodeRepository
    Switch parameter that will remove the the Variable from its Code Repository.

    .PARAMETER Quiet
    Switch parameter that silences the output of the updated object.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWVariable] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWVariable] object will be returned

    .EXAMPLE
    Changes the description and folder, along with setting 2 tags on a Variable

    $Variable = Get-AutomateNOWVariable -Id 'Variable1'
    Set-AutomateNOWVariable -Description 'Awesome description!' -Tags 'Tag1', 'Tag2' -Folder 'Folder1'

    .EXAMPLE
    Forcibly changes the total permits of a Variable to 1000

    $Variable = Get-AutomateNOWVariable -Id 'Variable1'
    Set-AutomateNOWVariable -Variable $Variable -TotalPermits 1000 -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    If you remove the validation it is possible to set the Variables beyond 1,000,000

    #>
    [OutputType([ANOWVariable])]
    [Cmdletbinding(SupportsShouldProcess, DefaultParameterSetName = 'Default', ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'Default', ValueFromPipeline = $True)]
        [Parameter(Mandatory = $true, ParameterSetName = 'SetValue', ValueFromPipeline = $True)]
        [ANOWVariable]$Variable,
        [Parameter(Mandatory = $true, ParameterSetName = 'SetValue')]
        [string]$Value,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [string[]]$Tags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [string]$Folder,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetCodeRepository,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'SetValue')]
        [switch]$Quiet,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'SetValue')]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot set the Tags and unset them at the same time. Please choose one or the other. Tags from the source object will be carried over to the new object if you do not specify any tag-related parameters."
            Break
        }
        If ($UnsetCodeRepository -eq $true -and $CodeRepository.Id.Length -gt 0) {
            Write-Warning -Message "You cannot unset the Code Repository and set it at the same time. Please choose one or the other."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWVariable]$Variable = $_
        }
        [string]$Variable_id = $Variable.id
        [string]$Variable_simpleId = $Variable.simpleId
        [string]$current_Variable_value = $Variable.value
        If ($current_Variable_value.Length -eq 0) {
            Write-Verbose -Message "Detected the value of Variable object [$Variable_simpleId] is empty"
        }
        Else {
            Write-Verbose -Message "Detected the value of Variable object [$Variable_simpleId] to be [$current_Variable_value]"
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Variable_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$Variable_exists = ($null -eq (Get-AutomateNOWVariable -Id $Variable_simpleId))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWVariable failed to check if the Variable [$Variable_simpleId] already existed due to [$Message]."
                Break
            }
            If ($Variable_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not a Variable named [$Variable_simpleId] in the [$current_domain] domain. Please check into this."
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $Variable_id
            If ($Value.Length -gt 0) {
                If ($Value -eq $current_Variable_value) {
                    Write-Warning -Message "No action is required. The Variable [$Variable_simpleId] is already set to [$Value]"
                    Break
                }
                Else {
                    Write-Verbose -Message "Changing the value of [$Variable_simpleId] from [$current_Variable_value] to [$Value]"
                }
                $BodyMetaData.'newValue' = $Value
                [string]$operationId = 'setValue'
                [string]$operationType = 'custom'
                $BodyMetaData.'_operationId' = $operationId
                [string]$command = "/resource/$operationId"
            }
            Else {
                [string]$command = '/resource/update'
                [string]$operationType = 'update'
                If ($Description.Length -gt 0) {
                    $BodyMetaData.'description' = $Description
                }
                ElseIf ($UnsetDescription -eq $true) {
                    $BodyMetaData.'description' = $Null
                }
                Else {
                    If ($Variable.description.Length -gt 0) {
                        $BodyMetaData.'description' = $Variable.description
                    }
                }
                If ($UnsetFolder -eq $True) {
                    $BodyMetaData.'folder' = $Null
                }
                ElseIf ($Folder.Length -gt 0) {
                    $BodyMetaData.'folder' = $Folder
                }
                Else {
                    If ($Variable.folder.Length -gt 0) {
                        $BodyMetaData.'folder' = $Variable.folder
                    }
                }
                If ($Tags.Count -gt 0) {
                    [int32]$tag_count = 1
                    ForEach ($tag in $Tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
                ElseIf ($UnsetTags -eq $true) {
                    $BodyMetaData.'tags' = $Null
                }
                Else {
                    If ($Variable.Tags -gt 0) {
                        [int32]$tag_count = 1
                        ForEach ($tag in $Variable.tags) {
                            $BodyMetaData.('tags' + $tag_count ) = $tag
                            $tag_count++
                        }
                    }
                }
            }
            If ($CodeRepository.Id.Length -gt 0) {
                [string]$CodeRepository_Id = $CodeRepository.Id
                $Error.Clear()
                Try {
                    [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository_Id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository_Id] actually existed under Set-AutomateNOWVariable due to [$Message]"
                    Break
                }
                If ($code_repository_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository_Id] under Set-AutomateNOWVariable. Please check again."
                    Break
                }
                $BodyMetaData.'codeRepository' = $CodeRepository_Id
            }
            ElseIf ($UnsetCodeRepository -eq $true) {
                $BodyMetaData.'codeRepository' = $null
            }
            $BodyMetaData.'_operationType' = $operationType
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_dataSource' = 'ResourceDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            If ($null -eq $parameters["Command"]) {
                $parameters.Add('Command', $command)
            }
            Else {
                $parameters.Command = $command
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Variable_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Variable object [$Variable_id] was successfully updated"
            $Error.Clear()
            Try {
                [ANOWVariable]$UpdatedVariable = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the returned updated object to an [ANOWVariable] object due to [$Message]. The object was still updated though."
                Break
            }
            If ($Quiet -ne $true) {
                Return $UpdatedVariable
            }
        }
    }
    End {
    }
}

Function Export-AutomateNOWVariable {
    <#
    .SYNOPSIS
    Exports the Variable objects from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Variable objects from an instance of AutomateNOW! to a local .csv file

    .PARAMETER Variable
    Mandatory [ANOWVariable] object (Use Get-AutomateNOWVariable to retrieve them)

    .INPUTS
    ONLY [ANOWVariable] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWVariable] objects are exported to the local disk in CSV format

    .EXAMPLE
    Exports all of the Variable objects (up to 100 by default)

    Get-AutomateNOWVariable | Export-AutomateNOWVariable

    .EXAMPLE
    Exports 1 Variable by name

    Get-AutomateNOWVariable -Id 'Variable01' | Export-AutomateNOWVariable

    .EXAMPLE
    Exports a series of Variable objects by the pipeline

    @( 'Variable01', 'Variable02' ) | Get-AutomateNOWVariable | Export-AutomateNOWVariable

    .NOTES
	You must present [ANOWVariable] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWVariable]$Variable
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-Variables-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWVariable]$Variable = $_
        }
        $Error.Clear()
        Try {
            $Variable | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWVariable] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function New-AutomateNOWVariable {
    <#
    .SYNOPSIS
    Creates a Variable within an AutomateNOW! instance

    .DESCRIPTION
    Creates a Variable within an AutomateNOW! instance and returns back the newly created [ANOWVariable] object

    .PARAMETER Id
    The intended name of the Variable. For example: 'Variable1'. This value may not contain the domain in brackets.

    .PARAMETER Description
    Optional description of the Variable (may not exceed 255 characters).

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new Variable. Do not pass [ANOWTag] objects here.

    .PARAMETER Folder
    Optional name of the folder to place the Variable into.

    .PARAMETER CodeRepository
    Optional name of the code repository to place the Variable into.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWVariable.

    .OUTPUTS
    An [ANOWVariable] object representing the newly created Variable

    .EXAMPLE
    New-AutomateNOWVariable -Id 'Variable01' -Description 'Description01' -Tags 'Tag01' -Folder 'Folder01' -CodeRepository 'Repository01'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The name (id) of the Variable must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    #>
    [OutputType([ANOWVariable])]
    [Cmdletbinding()]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $true)]
        [string]$Id,
        [ValidateScript({ $_.Length -le 255 })]
        [Parameter(Mandatory = $false, HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [string]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [boolean]$Variable_exists = ($null -ne (Get-AutomateNOWVariable -Id $Id))
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWVariable failed to check if the Variable [$Id] already existed due to [$Message]."
        Break
    }
    If ($Variable_exists -eq $true) {
        [string]$current_domain = $anow_session.header.domain
        Write-Warning -Message "There is already a Variable named [$Id] in [$current_domain]. Please check into this."
        Break
    }
    ## End warning ##
    [System.Collections.Specialized.OrderedDictionary]$ANOWVariable = [System.Collections.Specialized.OrderedDictionary]@{}
    $ANOWVariable.Add('id', $Id)
    If ($Description.Length -gt 0) {
        $ANOWVariable.Add('description', $Description)
    }
    If ($Tags.Count -gt 0) {
        [int32]$total_tags = $Tags.Count
        [int32]$current_tag = 1
        ForEach ($tag_id in $Tags) {
            $Error.Clear()
            Try {
                [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] running under New-AutomateNOWVariable due to [$message]"
                Break
            }
            If ($tag_object.simpleId.length -eq 0) {
                Throw "New-AutomateNOWVariable has detected that the tag [$tag_id] does not appear to exist. Please check again."
                Break
            }
            ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                [string]$tag_object_simpleId = $tag_object.simpleId
                Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                Break
            }
            [string]$tag_display = $tag_object | ConvertTo-Json -Compress
            Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
            [string]$tag_name_sequence = ('tags' + $current_tag)
            $ANOWVariable.Add($tag_name_sequence, $tag_id)
            $include_properties += $tag_name_sequence
            $current_tag++
        }
    }
    If ($Folder.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] existed under New-AutomateNOWVariable due to [$Message]"
            Break
        }
        If ($folder_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] under New-AutomateNOWVariable. Please check again."
            Break
        }
        [string]$folder_display = $folder_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding folder $folder_display to [ANOWVariable] [$Id]"
        $ANOWVariable.Add('folder', $Folder)
        $include_properties += 'folder'
    }
    If ($CodeRepository.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository] existed under New-AutomateNOWVariable due to [$Message]"
            Break
        }
        If ($code_repository_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository] under New-AutomateNOWVariable. Please check again."
            Break
        }
        [string]$code_repository_display = $code_repository_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding code repository $code_repository_display to [ANOWVariable] [$Id]"
        $ANOWVariable.Add('codeRepository', $CodeRepository)
        $include_properties += 'codeRepository'
    }
    $ANOWVariable.Add('title', 'Variable')
    $ANOWVariable.Add('icon', '[SKINIMG]/skin/pi_math.png')
    $oldvalues = ('{"title":"Variable","resourceType":"VARIABLE","icon":"[SKINIMG]/skin/pi_math.png"}')
    [string]$BodyObject = ConvertTo-QueryString -InputObject $ANOWVariable -IncludeProperties id, description, title, icon, tags, folder, codeRepository
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    $BodyMetaData.'resourceType' = 'VARIABLE'
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_operationType' = 'add'
    $BodyMetaData.'_oldValues' = $oldvalues
    $BodyMetaData.'_componentId' = 'ResourceCreateWindow_form'
    $BodyMetaData.'_dataSource' = 'ResourceDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$BodyMetaDataString = ConvertTo-QueryString -InputObject $BodyMetaData
    [string]$Body = ($BodyObject + '&' + $BodyMetaDataString)
    [string]$command = '/resource/create'
    [hashtable]$parameters = @{}
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('Body', $Body)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWVariable]$Variable = $results.response.data | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to parse the result of New-AutomateNOWVariable into an [ANOWVariable] object due to [$Message]."
        Break
    }
    If ($Variable.id.Length -eq 0) {
        Write-Warning -Message "Somehow the newly created [ANOWVariable] object is empty!"
        Break
    }
    If ($Quiet -ne $true) {
        Return $Variable
    }
}

Function Remove-AutomateNOWVariable {
    <#
    .SYNOPSIS
    Removes a Variable from an AutomateNOW! instance

    .DESCRIPTION
    Removes a Variable from an AutomateNOW! instance

    .PARAMETER Variable
    An [ANOWVariable] object representing the Variable to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWVariable] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Remove a single Variable by name

    Get-AutomateNOWVariable -Id 'Variable01' | Remove-AutomateNOWVariable

    .EXAMPLE
    Removes a series of Variable objects via input from the pipeline

    @( 'Variable01', 'Variable02', 'Variable03') | Get-AutomateNOWVariable | Remove-AutomateNOWVariable

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWVariable]$Variable,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/resource/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWVariable]$Variable = $_
        }
        [string]$Variable_id = $Variable.id
        If ($Variable_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Variable_id)")) -eq $true) {
            [string]$oldvalues = $Variable.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $Variable.id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'ResourceList'
            $BodyMetaData.'_dataSource' = 'ResourceDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Variable_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Variable [$Variable_id] successfully removed"
        }
    }
    End {

    }
}

Function Copy-AutomateNOWVariable {
    <#
    .SYNOPSIS
    Copies an Variable from an AutomateNOW! instance

    .DESCRIPTION
    Copies an Variable from an AutomateNOW! instance. AutomateNOW object id can never be changed, but we can copy the object to a new id and it will include all of the items therein.

    .PARAMETER Variable
    Mandatory [ANOWVariable] object to be copied.

    .PARAMETER NewId
    The name (Id) of the new Variable. The new Id must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    .PARAMETER UnsetDescription
    Optional switch that will ensure that the newly created Variable will not have a description set.

    .PARAMETER Description
    Optional description to set on the new Variable object. If you do not set this, the new Variable object will copy the Description of the source object.

    .PARAMETER UnsetFolder
    Optional switch that will ensure that the newly created Variable will not have a Folder set.

    .PARAMETER Folder
    Optional description to set a different folder on the new Variable object. If you do not set this, the new Variable object will use the same Folder of the source object.

    .PARAMETER UnsetTags
    Optional switch that will ensure that the newly created Variable will not have any Tags set.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the new Variable object. If you do not set this, the new Variable object will apply the same Tags of the source object.

    .PARAMETER Force
    Force the copy without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    ONLY [ANOWVariable] object is accepted. Pipeline support is intentionally unavailable.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Creates a copy of an Variable and changes the description (multi-line format)
    $Variable01 = Get-AutomateNOWVariable -Id 'Variable_01'
    Copy-AutomateNOWVariable -Variable $Variable01 -NewId 'Variable_01_production' -Description 'Variable 01 Production'

    .EXAMPLE
    Creates a copy of an Variable that omits the description (one-liner format)
    Copy-AutomateNOWVariable -Variable (Get-AutomateNOWVariable -Id 'Variable_01') -NewId 'Variable_01_production' -UnsetDescription -Tags 'Tag1', 'Tag2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWVariable]$Variable,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot set the Tags and unset them at the same time. Please choose one or the other. Tags from the source object will be carried over to the new object if you do not specify any tag-related parameters."
            Break
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$Variable_exists = ($null -ne (Get-AutomateNOWVariable -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWVariable failed to check if the Variable [$NewId] already existed due to [$Message]."
            Break
        }
        If ($Variable_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Variable named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End warning ##
        [string]$command = '/resource/copy'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            [string]$Variable_oldId = $Variable.id
            [string]$Variable_simpleId = $Variable.simpleId
            If ($Variable_oldId -eq $NewId) {
                Write-Warning -Message "The new id cannot be the same as the old id."
                Break
            }
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Copy the Variable $($Variable_simpleId) to $($NewId)?")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                If ($UnsetFolder -eq $True) {
                    $BodyMetaData.'folder' = $Null
                }
                ElseIf ($Folder.Length -gt 0) {
                    $BodyMetaData.'folder' = $Folder
                }
                Else {
                    If ($Variable.folder.Length -gt 0) {
                        $BodyMetaData.'folder' = $Variable.folder
                    }
                }
                If ($Tags.Count -gt 0) {
                    [int32]$tag_count = 1
                    ForEach ($tag in $Tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
                ElseIf ($UnsetTags -eq $true) {
                    $BodyMetaData.'tags' = $Null
                }
                Else {
                    If ($Variable.Tags -gt 0) {
                        [int32]$tag_count = 1
                        ForEach ($tag in $Variable.tags) {
                            $BodyMetaData.('tags' + $tag_count ) = $tag
                            $tag_count++
                        }
                    }
                }
                $BodyMetaData.'oldId' = $Variable_oldId
                $BodyMetaData.'domain' = $Variable.domain
                $BodyMetaData.'id' = $NewId
                If ($UnsetDescription -ne $true) {
                    If ($Description.Length -gt 0) {
                        $BodyMetaData.'description' = $Description
                    }
                    Else {
                        $BodyMetaData.'description' = $Variable.description
                    }
                }
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_operationId' = 'copy'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_dataSource' = 'ResourceDataSource'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties oldId, domain, NewId, description, folder, tags
                $parameters.Body = $Body
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Variable_oldId] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                $Error.Clear()
                Try {
                    [ANOWVariable]$NewVariable = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to create copied [ANOWVariable] object [$NewId] due to [$Message]."
                    Break
                }
                If ($NewVariable.id.Length -eq 0) {
                    Write-Warning -Message "Somehow the newly created (copied) [ANOWVariable] object [$NewId] is empty!"
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $NewVariable
                }
            }
        }
    }
    End {

    }
}

Function Rename-AutomateNOWVariable {
    <#
    .SYNOPSIS
    Renames a Variable on an AutomateNOW! instance

    .DESCRIPTION
    Performs a psuedo-rename operations of a Variable from an AutomateNOW! instance by copying it first and then deleting the source. This function merely combines Copy-AutomateNOWVariable and Remove-AutomateNOWVariable therefore it is to be considered destructive.

    .PARAMETER Variable
    An [ANOWVariable] object representing the Variable to be renamed.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the Variable. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER Force
    Force the renaming without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly renamed object.

    .INPUTS
    ONLY [ANOWVariable] objects are accepted. There is intentionally no support for the pipeline.

    .OUTPUTS
    The newly renamed [ANOWVariable] object will be returned.

    .EXAMPLE
    $Variable = Get-AutomateNOWVariable -Id 'Variable01'
    Rename-AutomateNOWVariable -Variable $Variable -NewId 'Variable_01'

    .EXAMPLE
    Rename-AutomateNOWVariable -Variable (Get-AutomateNOWVariable -Id 'Variable01') -NewId 'Variable_01'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    When renaming, you may only specify a different Id (name).

    This action will be blocked if any existing referrals are found on the object.
    #>
    [OutputType([ANOWVariable])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWVariable]$Variable,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin standard warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$new_Variable_exists = ($null -ne (Get-AutomateNOWVariable -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWVariable failed to check if the Variable [$NewId] already existed due to [$Message]."
            Break
        }
        If ($new_Variable_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Variable named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        #[string]$Variable_id = $Variable.id
        [string]$Variable_id = $Variable.simpleId
        $Error.Clear()
        Try {
            [boolean]$old_Variable_exists = ($null -ne (Get-AutomateNOWVariable -Id $Variable_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWVariable failed to check if the Variable [$Variable_id] already existed due to [$Message]."
            Break
        }
        If ($old_Variable_exists -eq $false) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not a Variable named [$Variable_id] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End standard warning ##
        ## Begin referrals warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [int32]$referrals_count = Find-AutomateNOWObjectReferral -Variable $Variable -Count | Select-Object -Expandproperty referrals
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Find-AutomateNOWObjectReferral failed to extract the referrals on Variable [$Variable_id] due to [$Message]."
            Break
        }
        If ($referrals_count -gt 0) {
            Write-Warning -Message "Unfortunately, you cannot rename a Variable that has referrals. This is because the rename is not actually renaming but copying anew and deleting the old. Please, use the Find-AutomateNOWObjectReferral function to identify referrals and remove them."
            Break
        }
        Else {
            Write-Verbose -Message "The Variable [$Variable_id] does not have any referrals. It is safe to proceed."
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Variable_id)")) -eq $true) {
                $Error.Clear()
                Try {
                    [ANOWVariable]$new_Variable = Copy-AutomateNOWVariable -Variable $Variable -NewId $NewId -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Copy-AutomateNOWVariable failed to create a new Variable [$NewId] as Part 1 of the renaming process due to [$Message]."
                    Break
                }
                If ($new_Variable.simpleId -eq $NewId) {
                    Write-Verbose -Message "Part 1: Variable [$Variable_id] successfully copied to [$NewId]"
                }
                Else {
                    Write-Warning -Message "Somehow the first phase (Copy-AutomateNOWVariable) failed. Please look into this."
                    Break
                }
                $Error.Clear()
                Try {
                    Remove-AutomateNOWVariable -Variable $Variable -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Remove-AutomateNOWVariable failed to remove [$Variable_id] as Part 2 of the renaming process due to [$Message]."
                    Break
                }
                Write-Verbose -Message "Part 2: Variable [$Variable_id] removed"
                Write-Verbose -Message "Task [$Variable_id] successfully renamed to [$NewId]"
                If ($Quiet -ne $true) {
                    Return $Variable
                }
            }
        }
        Else {
            Write-Warning -Message "No action was taken because either the source object didn't exist or the new object already existed"
        }
    }
    End {
    }
}

#endregion

#Region - Variable Timestamps

Function Get-AutomateNOWVariableTimestamp {
    <#
    .SYNOPSIS
    Gets the Variable Timestamp objects from a Variable object in an AutomateNOW! instance

    .DESCRIPTION
    Gets the Variable Timestamp objects from a Variable object in an AutomateNOW! instance

    .PARAMETER Variable
    An [ANOWVariable] object representing the Variable to be queried for its Timestamps.

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100. The console default hard limit is 10,000.

    .PARAMETER sortBy
    Optional string parameter to sort the results by. The only known choice is timestamp so this parameter will most likely not have additional sorting options in the future.

    .PARAMETER Ascending
    Optional switch parameter to sort the results in ascending order (oldest to newest)

    .PARAMETER CurrentMonth
    Optional switch parameter to retrieve only the Variable Timestamp objects from the current month (according to the server Java timezone). Cannot be combined with -LastMonth or -NextMonth

    .PARAMETER LastMonth
    Optional switch parameter to retrieve only the Variable Timestamp objects from the previous month (according to the server Java timezone). Cannot be combined with -CurrentMonth or -NextMonth

    .PARAMETER NextMonth
    Optional switch parameter to retrieve only the Variable Timestamp objects from the next month (according to the server Java timezone). Cannot be combined with -LastMonth or -CurrentMonth

    .INPUTS
    Only [ANOWVariable] objects are accept. Lack of pipeline capability is intentional.

    .OUTPUTS
    Either one or more [ANOWVariableTimestamp] objects

    .EXAMPLE
    Gets all of the available Variable Timestamp objects from a specified Variable object

    $Variable = Get-AutomateNOWVariable -id 'Variable1'
    Get-AutomateNOWVariableTimeStamp -Variable $Variable

    .EXAMPLE
    Gets the Variable Timestamp objects from a specified Variable object for the current month

    $Variable = Get-AutomateNOWVariable -id 'Variable1'
    Get-AutomateNOWVariableTimeStamp -Variable $Variable -CurrentMonth

    .EXAMPLE
    Gets the Variable Timestamp objects from a specified Variable object for the following next month sorted in ascending order

    $Variable = Get-AutomateNOWVariable -id 'Variable1'
    Get-AutomateNOWVariableTimeStamp -Variable $Variable -NextMonth -Ascending

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    This is a case where objects are returned in descending order from the console by default. Thus this function has an -Ascending switch parameter instead of -Descending.

    #>
    [Cmdletbinding(DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $True, ParameterSetName = 'Default', ValueFromPipeline = $true)]
        [Parameter(Mandatory = $True, ParameterSetName = 'CurrentMonth', ValueFromPipeline = $true)]
        [Parameter(Mandatory = $True, ParameterSetName = 'NextMonth', ValueFromPipeline = $true)]
        [Parameter(Mandatory = $True, ParameterSetName = 'LastMonth', ValueFromPipeline = $true)]
        [ANOWVariable]$Variable,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'CurrentMonth')]
        [Parameter(Mandatory = $False, ParameterSetName = 'NextMonth')]
        [Parameter(Mandatory = $False, ParameterSetName = 'LastMonth')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'CurrentMonth')]
        [Parameter(Mandatory = $False, ParameterSetName = 'NextMonth')]
        [Parameter(Mandatory = $False, ParameterSetName = 'LastMonth')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'CurrentMonth')]
        [Parameter(Mandatory = $False, ParameterSetName = 'NextMonth')]
        [Parameter(Mandatory = $False, ParameterSetName = 'LastMonth')]
        [string]$sortBy = 'timestamp',
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'CurrentMonth')]
        [Parameter(Mandatory = $False, ParameterSetName = 'NextMonth')]
        [Parameter(Mandatory = $False, ParameterSetName = 'LastMonth')]
        [switch]$Ascending,
        [Parameter(Mandatory = $True, ParameterSetName = 'CurrentMonth')]
        [switch]$CurrentMonth,
        [Parameter(Mandatory = $True, ParameterSetName = 'NextMonth')]
        [switch]$NextMonth,
        [Parameter(Mandatory = $True, ParameterSetName = 'LastMonth')]
        [switch]$LastMonth
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        [string]$Method = 'GET'
        $parameters.Add('Method', $Method)
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0 ) {
            [ANOWVariable]$Variable = $_
        }
        [string]$Variable_Id = $Variable.Id
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($CurrentMonth -eq $true -or $NextMonth -eq $true -or $LastMonth -eq $true) {
            [string]$server_java_timezone = $anow_session.instance_info.licenseInfo.javaTimezone
            If ($server_java_timezone.Length -eq 0) {
                Write-Warning -Message "The server java timezone is not available in the global session variable. Please use Connect-AutomateNOW to establish your session."
                Break
            }
            $Error.Clear()
            Try {
                [ANOWTimeZone]$server_java_timezone_object = Get-AutomateNOWTimeZone -Id $server_java_timezone
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWTimeZone failed to create a timezone object under Get-AutomateNOWVariableTimestamp due to [$Message]."
                Break
            }
            [int64]$rawOffset = $server_java_timezone_object.rawOffset
            If ($LastMonth -eq $true) {
                [string]$endOfSelectedMonth = Get-Date -Date ((Get-Date -Year (Get-Date -Date (Get-Date).ToUniversalTime()).Year -Month (Get-Date -Date (Get-Date).ToUniversalTime()).AddMonths(0).Month -Day 1 -Hour 0 -Minute 0 -Second 0 -Millisecond 0).AddMilliseconds(-1)).AddMilliseconds($rawOffset * -1) -Format 'yyyy-MM-ddTHH:mm:ss.fff'
                [string]$startOfSelectedMonth = Get-Date -Date ((Get-Date -Year (Get-Date -Date (Get-Date).ToUniversalTime()).Year -Month ((Get-Date -Date (Get-Date).ToUniversalTime()).Month - 1 ) -Day 1 -Hour 0 -Minute 0 -Second 0 -Millisecond 0)).AddMilliseconds($rawOffset * -1) -Format 'yyyy-MM-ddTHH:mm:ss.fff'
            }
            ElseIf ($CurrentMonth -eq $true) {
                [string]$endOfSelectedMonth = Get-Date -Date ((Get-Date -Year (Get-Date -Date (Get-Date).ToUniversalTime()).Year -Month (Get-Date -Date (Get-Date).ToUniversalTime()).AddMonths(1).Month -Day 1 -Hour 0 -Minute 0 -Second 0 -Millisecond 0).AddMilliseconds(-1)).AddMilliseconds($rawOffset * -1) -Format 'yyyy-MM-ddTHH:mm:ss.fff'
                [string]$startOfSelectedMonth = Get-Date -Date ((Get-Date -Year (Get-Date -Date (Get-Date).ToUniversalTime()).Year -Month ((Get-Date -Date (Get-Date).ToUniversalTime()).Month + 0 ) -Day 1 -Hour 0 -Minute 0 -Second 0 -Millisecond 0)).AddMilliseconds($rawOffset * -1) -Format 'yyyy-MM-ddTHH:mm:ss.fff'
            }
            Else {
                [string]$endOfSelectedMonth = Get-Date -Date ((Get-Date -Year (Get-Date -Date (Get-Date).ToUniversalTime()).Year -Month (Get-Date -Date (Get-Date).ToUniversalTime()).AddMonths(2).Month -Day 1 -Hour 0 -Minute 0 -Second 0 -Millisecond 0).AddMilliseconds(-1)).AddMilliseconds($rawOffset * -1) -Format 'yyyy-MM-ddTHH:mm:ss.fff'
                [string]$startOfSelectedMonth = Get-Date -Date ((Get-Date -Year (Get-Date -Date (Get-Date).ToUniversalTime()).Year -Month ((Get-Date -Date (Get-Date).ToUniversalTime()).Month + 1 ) -Day 1 -Hour 0 -Minute 0 -Second 0 -Millisecond 0)).AddMilliseconds($rawOffset * -1) -Format 'yyyy-MM-ddTHH:mm:ss.fff'
            }
            [string]$lessOrEqual = $endOfSelectedMonth
            [string]$greaterOrEqual = $startOfSelectedMonth
            Write-Verbose -Message "Calculating monthly timestamps: End of current month = $endOfCurrentMonth, Start of current month = $startOfCurrentMonth"
            $Body.'_constructor' = 'AdvancedCriteria'
            $Body.'operator' = 'and'
            $Body.'criteria1' = ('{"fieldName":"resource","operator":"equals","value":"' + $Variable_Id + '"}')
            $Body.'criteria2' = ('{"fieldName":"timestamp","operator":"lessOrEqual","value":"' + $lessOrEqual + '"}')
            $Body.'criteria3' = ('{"fieldName":"timestamp","operator":"greaterOrEqual","value":"' + $greaterOrEqual + '"}')
            [string]$componentId = 'ResourceMonthlyCalendar'
        }
        Else {
            $Body.'resource' = $Variable_Id
            [string]$componentId = 'ResourceTimestampStateList'
        }
        $Body.'_componentId' = $componentId
        $Body.'_startRow' = $startRow
        $Body.'_endRow' = $endRow
        If ($Ascending -eq $true) {
            $Body.'_sortBy' = $sortBy
        }
        Else {
            $Body.'_sortBy' = '-' + $sortBy
        }
        $Body.'_operationType' = 'fetch'
        $Body.'_textMatchStyle' = 'exact'
        $Body.'_dataSource' = 'ResourceTimestampStateDataSource'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/resourceTimestampState/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWVariableTimestamp[]]$VariableTimestamps = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWVariable failed to parse the results into [ANOWVariable] objects due to [$Message]."
            Break
        }
        If ($VariableTimestamps.Count -eq 0) {
            Write-Warning -Message "$Variable_Id is a Variable without any timestamp objects."
        }
        Else {
            Return $VariableTimestamps
        }
    }
    End {

    }
}

Function Set-AutomateNOWVariableTimestamp {
    <#
    .SYNOPSIS
    Sets a Variable value and timestape for a *specific day*.

    .DESCRIPTION
    Sets a Variable value and timestape for a *specific day*.

    .PARAMETER Variable
    An [ANOWVariable] object representing the Variable to be modified.

    .PARAMETER Date
    A string in ISO-8601 specifying the year, month and day to set the state of the Variable for (example: 2029-12-31). This is a simple 10 character date string without hours, minutes seconds. This function will make the neccessary adjustment to the timestamp based on the server Java timezone.

    .PARAMETER Value
    String that sets the value of the Variable for the specified day timestamp. You must specify either -Value or -UnsetValue.

    .PARAMETER UnsetValue
    Switch parameter that unsets (removes) the value of the Variable for the specified day timestamp. You must specify either -Value or -UnsetValue.

    .PARAMETER Quiet
    Switch parameter that silences the output of the updated object.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWVariable] objects are accepted along with one (or more across the pipeline) -date strings.

    .OUTPUTS
    The updated [ANOWResourceTimestamp] object will be returned

    .EXAMPLE
    Sets the value for a single day within a Variable

    $Variable = Get-AutomateNOWVariable -Id 'Variable1'
    Set-AutomateNOWVariableTimetamp -Variable $Variable -Value 'abc' -Date '2029-06-02'

    .EXAMPLE
    Forcibly removes the value on a series of dates in a Variable object. The dates are sent through the pipeline.

    $Variable = Get-AutomateNOWVariable -Id 'Variable1'
    @('2029-06-01', '2029-06-02', '2029-06-03') | Set-AutomateNOWVariableTimetamp -Variable $Variable -UnsetValue -Force

    .EXAMPLE
    Calculates and forcibly sets the value for all days of the following month (i.e. "next month") into the Variable object.
    $Variable = Get-AutomateNOWVariable -Id 'Variable1'
    $Value = 'abc'
    $(For($i=1; $i -le ([datetime]::DaysInMonth(((Get-Date).ToUniversalTime()).AddMonths(1).Year, ((Get-Date).ToUniversalTime()).AddMonths(1).Month)); $i++) { [string](Get-Date).ToUniversalTime().AddMonths(1).Year  + "-" + [string]((Get-Date).ToUniversalTime().AddMonths(1).Month).ToString("00") + "-" + ($i.ToString("00")) }) | Set-AutomateNOWVariableTimestamp -Variable $Variable -Value $Value -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Use Set-AutomateNOWVariable if you wish to change the 'global' value of the Variable. This function is for setting the -individual- dates (day timestamps) within a Variable object.

    #>
    [OutputType([ANOWResourceTimestampState])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'Default', ValueFromPipeline = $True)]
        [Parameter(Mandatory = $true, ParameterSetName = 'unSet', ValueFromPipeline = $True)]
        [string]$date,
        [Parameter(Mandatory = $true, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $true, ParameterSetName = 'unSet')]
        [ANOWVariable]$Variable,
        [Parameter(Mandatory = $true, ParameterSetName = 'Default')]
        [string]$Value,
        [Parameter(Mandatory = $true, ParameterSetName = 'unSet')]
        [switch]$unsetValue,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'unSet')]
        [switch]$Quiet,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'unSet')]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        [string]$command = "/resourceTimestampState/setState"
        [string]$method = 'POST'
        $parameters.Add('Method', $method)
        $parameters.Add('Command', $command)
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.Length -gt 0) {
            [string]$date = $_
        }
        [string]$Variable_id = $Variable.id
        [string]$Variable_simpleId = $Variable.simpleId
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Variable_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$Variable_exists = ($null -eq (Get-AutomateNOWVariable -Id $Variable_simpleId))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWVariable failed to check if the Variable [$Variable_simpleId] already existed due to [$Message]."
                Break
            }
            If ($Variable_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not an Variable named [$Variable_simpleId] in the [$current_domain] domain. Please check into this."
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'resource' = $Variable_id
            $BodyMetaData.'resourceType' = 'VARIABLE'
            If ($unsetValue -eq $true ) {
                [string]$Value = ''
            }
            $BodyMetaData.'value' = $Value
            $Error.Clear()
            Try {
                [string]$timestamp = New-AutomateNOWServerDayTimestamp -date $date
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "New-AutomateNOWServerDayTimestamp failed to convert [$date] due to [$Message]."
                Break
            }
            [string]$regex_daytimestamp_z = '^[2][0-9]{3}-(01|02|03|04|05|06|07|08|09|10|11|12)-(01|02|03|04|05|06|07|08|09|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31)T(00|01|02|03|04|05|06|07|08|09|10|11|12|13|14|15|16|17|18|19|20|21|22|23):[0-2]{1}[0-9]{1}.[0-6]{1}[0-9]{1}.[0-9]{3}$'
            # example timestamp for a server located in a +4 timezone: 2029-05-07T20:00:00.000 with a date string of 2030-05-08
            If ($timestamp -notmatch $regex_daytimestamp_z ) {
                Write-Warning -Message "Somehow the returned day timestamp [$timestamp] is invalid"
            }
            $BodyMetaData.'timestamp' = $timestamp
            $BodyMetaData.'_operationId' = 'setValue'
            $BodyMetaData.'_operationType' = 'custom'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_dataSource' = 'ResourceTimestampStateDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Variable_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Variable object [$Variable_id] was successfully updated with a new timestamp"
            $Error.Clear()
            Try {
                [ANOWResourceTimestamp]$VariableTimestamp = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to convert the response to a valid [ANOWResourceTimestamp] object due to [$Message]."
                Break
            }
            If ($Quiet -ne $true) {
                Return $VariableTimestamp
            }
        }
    }
    End {
    }
}

Function Export-AutomateNOWVariableTimestamp {
    <#
    .SYNOPSIS
    Exports the Variable Timestamp objects from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Variable Timestamp objects from an instance of AutomateNOW! to a local .csv file

    .PARAMETER Variable
    Mandatory [ANOWVariableTimestamp] object (Use Get-AutomateNOWVariableTimestamp to retrieve them)

    .INPUTS
    ONLY [ANOWVariableTimestamp] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWVariableTimestamp] objects are exported to the local disk in CSV format

    .EXAMPLE
    Exports all of the Variable Timestamp objects (up to 100 by default)

    Get-AutomateNOWVariableTimestamp | Export-AutomateNOWVariableTimestamp

    .EXAMPLE
    Exports 1 Variable Timestamp by Variable name name

    Get-AutomateNOWVariable -Id 'Variable01' | Get-AutomateNOWVariableTimestamp | Export-AutomateNOWVariableTimestamp

    .EXAMPLE
    Exports a series of Variable Timestamp objects by the pipeline

    @( 'Variable01', 'Variable02' ) | Get-AutomateNOWVariable | Get-AutomateNOWVariableTimestamp | Export-AutomateNOWVariableTimestamp

    .NOTES
	You must present [ANOWVariableTimestamp] to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'Pipeline', ValueFromPipeline = $true)]
        [ANOWVariableTimestamp]$VariableTimestamp
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-VariableTimestamps-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWVariableTimestamp]$VariableTimestamp = $_
        }
        $Error.Clear()
        Try {
            $VariableTimestamp | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWVariableTimestamp] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

#endregion

#Region - View Setups

Function Get-AutomateNOWViewSetup {
    <#
    .SYNOPSIS
    Gets the View Setup Objects from an AutomateNOW! instance

    .DESCRIPTION
    Gets the View Setup Objects from an AutomateNOW! instance

    .PARAMETER Id
    Optional CASE-SENSITIVE string containing the Id of the View Setup object

    .PARAMETER startRow
    Integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER sortBy
    Optional string parameter to sort the results by (may not be used with the Id parameter). Valid choices are: id*, name, iconCode, dateCreated, lastUpdated, createdBy, lastUpdatedBy

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .PARAMETER PublicOnly
    Optional switch parameter to limit the results to Views that are public.

    .PARAMETER PrivateOnly
    Optional switch parameter to limit the results to Views that are private.

    .INPUTS
    A single Id or a string of Id's across the pipeline will be accepted.

    .OUTPUTS
    Either one or more [ANOWViewSetup] objects

    .EXAMPLE
    Gets the first page of View Setup objects

    Get-AutomateNOWViewSetup

    .EXAMPLE
    Gets a single View Setup named 'ViewSetup1'

    Get-AutomateNOWViewSetup -Id 'ViewSetup1'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [OutputType([ANOWViewSetup[]])]
    [Cmdletbinding(DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $True, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'Public')]
        [Parameter(Mandatory = $False, ParameterSetName = 'Private')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $False, ParameterSetName = 'Public')]
        [Parameter(Mandatory = $False, ParameterSetName = 'Private')]
        [int32]$endRow = 100,
        [ValidateSet('id', 'name', 'iconCode', 'dateCreated', 'lastUpdated', 'createdBy', 'lastUpdatedBy', IgnoreCase = $false)]
        [Parameter(Mandatory = $False, ParameterSetName = 'Public')]
        [Parameter(Mandatory = $False, ParameterSetName = 'Private')]
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$sortBy = 'id',
        [Parameter(Mandatory = $False, ParameterSetName = 'Public')]
        [Parameter(Mandatory = $False, ParameterSetName = 'Private')]
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$Descending,
        [Parameter(Mandatory = $False, ParameterSetName = 'Public')]
        [switch]$PublicOnly,
        [Parameter(Mandatory = $False, ParameterSetName = 'Private')]
        [switch]$PrivateOnly
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
        If ($AllLoadBalancers -eq $true -and $AllChildNodes -eq $true) {
            Write-Warning -Message "You can't request only load balancer and then only load balancer nodes in the same request. Please choose one or the other."
            Break
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If (($_.Length -gt 0 -or $Id.Length -gt 0) ) {
            If ($_.Length -gt 0) {
                $Body.'id' = $_
            }
            Else {
                $Body.'id' = $Id
            }
            [string]$textMatchStyle = 'exactCase'
        }
        ElseIf ($itemId.Length -gt 0) {
            $Body.'itemId' = $itemId
            [string]$textMatchStyle = 'exactCase'
        }
        Else {
            $Body.'_constructor' = 'AdvancedCriteria'
            $Body.'operator' = 'and'
            If ($PublicOnly -eq $true) {
                $Body.'criteria1' = '{"fieldName":"publicSetup","operator":"equals","value":"true"}'
            }
            ElseIf ($PrivateOnly -eq $true) {
                $Body.'criteria1' = '{"fieldName":"publicSetup","operator":"equals","value":"false"}'
            }
            $Body.'_componentId' = 'ViewSetupList'
            $Body.'_startRow' = $startRow
            $Body.'_endRow' = $endRow
            [string]$textMatchStyle = 'substring'
            If ($Descending -eq $true) {
                $Body.'_sortBy' = '-' + $sortBy
            }
            Else {
                $Body.'_sortBy' = $sortBy
            }
        }
        $Body.'_operationId' = 'read'
        $Body.'_operationType' = 'fetch'
        $Body.'_textMatchStyle' = $textMatchStyle
        $Body.'_dataSource' = 'ViewSetupDataSource'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/viewSetup/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWViewSetup[]]$ViewSetups = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWViewSetup] objects due to [$Message]."
            Break
        }
        If ($ViewSetups.Count -gt 0) {
            Return $ViewSetups
        }
    }
    End {

    }
}

Function Export-AutomateNOWViewSetup {
    <#
    .SYNOPSIS
    Exports the View Setup objects from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the View Setup objects from an instance of AutomateNOW! to a local .csv file

    .PARAMETER ViewSetup
    Mandatory [ANOWViewSetup] object (Use Get-AutomateNOWViewSetup to retrieve them)

    .INPUTS
    ONLY [ANOWViewSetup] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWViewSetup] objects are exported to the local disk in CSV format

    .EXAMPLE
    Exports the first page of View Setup objects

    Get-AutomateNOWViewSetup | Export-AutomateNOWViewSetup

    .EXAMPLE
    Exports a single View Setup object named 'ViewSetup1'

    Get-AutomateNOWViewSetup -Id 'ViewSetup1' | Export-AutomateNOWViewSetup

    .EXAMPLE
    Exports a series of View Setup objects by Id across the pipeline

    ''ViewSetup1', 'ViewSetup2' | Get-AutomateNOWViewSetup | Export-AutomateNOWViewSetup

    .NOTES
	You must present [ANOWViewSetup] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWViewSetup]$ViewSetup
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-ViewSetups-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWViewSetup]$ViewSetup = $_
        }
        $Error.Clear()
        Try {
            $ViewSetup | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWViewSetup] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function Remove-AutomateNOWViewSetup {
    <#
    .SYNOPSIS
    Removes a View Setup from an AutomateNOW! instance

    .DESCRIPTION
    Removes a View Setup from an AutomateNOW! instance

    .PARAMETER ViewSetup
    An [ANOWViewSetup] object representing the View Setup to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWViewSetup] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Remove a single ViewSetup by Id

    Get-AutomateNOWViewSetup -Id '375787b5-37e4-4117-80ef-05967bcc5abb' | Remove-AutomateNOWViewSetup

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWViewSetup]$ViewSetup,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/viewSetup/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWViewSetup]$ViewSetup = $_
        }
        [string]$ViewSetup_id = $ViewSetup.id
        If ($ViewSetup_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ViewSetup_id)")) -eq $true) {
            [string]$oldvalues = $ViewSetup.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $ViewSetup.id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'DomainProcessingTypeList'
            $BodyMetaData.'_dataSource' = 'DomainProcessingTypeDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ViewSetup_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "View Setup [$ViewSetup_id] successfully removed"
        }
    }
    End {

    }
}

Function Copy-AutomateNOWViewSetup {
    <#
    .SYNOPSIS
    Copies a View Setup object from an AutomateNOW! instance

    .DESCRIPTION
    Copies a View Setup object from an AutomateNOW! instance.

    .PARAMETER ViewSetup
    Mandatory [ANOWViewSetup] object to be copied.

    .PARAMETER NewId
    The name (Id) of the new View Setup object. The new Id must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    .PARAMETER Force
    Force the copy without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    ONLY [ANOWViewSetup] object is accepted. Pipeline support is intentionally unavailable.

    .OUTPUTS
    The newly created [ANOWViewSetup] object will be emitted. Use the -Quiet parameter to suppress this.

    .EXAMPLE
    Creates a copy of a ViewSetup named 'ViewSetup1' to 'ViewSetup2'
    $ViewSetup1 = Get-AutomateNOWViewSetup -Id 'ViewSetup1'
    Copy-AutomateNOWViewSetup -ViewSetup $ViewSetup1 -NewId 'ViewSetup2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global ViewSetup.

    AutomateNOW object id's can never change, but we can copy the object to a new id and it will (typically) include all of the items therein.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWViewSetup]$ViewSetup,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$ViewSetup_exists = ($null -ne (Get-AutomateNOWViewSetup -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWViewSetup failed to check if the ViewSetup [$NewId] already existed due to [$Message]."
            Break
        }
        If ($ViewSetup_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a ViewSetup named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End warning ##
        [string]$command = '/viewSetup/copy'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            [string]$ViewSetup_oldId = $ViewSetup.id
            [string]$ViewSetup_simpleId = $ViewSetup.simpleId
            If ($ViewSetup_oldId -eq $NewId) {
                Write-Warning -Message "The new id cannot be the same as the old id."
                Break
            }
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Copy the ViewSetup $($ViewSetup_simpleId) to $($NewId)?")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                $BodyMetaData.'oldId' = $ViewSetup_oldId
                $BodyMetaData.'domain' = $ViewSetup.domain
                $BodyMetaData.'id' = $NewId
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_operationId' = 'copy'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_dataSource' = 'ViewSetupDataSource'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
                $parameters.Body = $Body
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$ViewSetup_oldId] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                $Error.Clear()
                Try {
                    [ANOWViewSetup]$NewViewSetup = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to create copied [ANOWViewSetup] object [$NewId] due to [$Message]."
                    Break
                }
                If ($NewViewSetup.id.Length -eq 0) {
                    Write-Warning -Message "Somehow the newly created (copied) [ANOWViewSetup] object [$NewId] is empty!"
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $NewViewSetup
                }
            }
        }
    }
    End {

    }
}

Function Rename-AutomateNOWViewSetup {
    <#
    .SYNOPSIS
    Renames a View Setup object on an AutomateNOW! instance

    .DESCRIPTION
    Performs a psuedo-rename operations of a View Setup object from an AutomateNOW! instance by copying it first and then deleting the source. This function merely combines Copy-AutomateNOWViewSetup and Remove-AutomateNOWViewSetup therefore it is to be considered destructive.

    .PARAMETER ViewSetup
    An [ANOWViewSetup] object representing the View Setup object to be renamed.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the View Setup object. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER Force
    Force the renaming without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly renamed object.

    .INPUTS
    ONLY [ANOWViewSetup] objects are accepted. There is intentionally no support for the pipeline.

    .OUTPUTS
    The newly renamed [ANOWViewSetup] object will be returned.

    .EXAMPLE
    Renames a View Setup object from 'ViewSetup1' to 'ViewSetup2' in a multi-line format

    $ViewSetup = Get-AutomateNOWViewSetup -Id 'ViewSetup1'
    Rename-AutomateNOWViewSetup -ViewSetup $ViewSetup -NewId 'ViewSetup2'

    .EXAMPLE
    Renames a View Setup object from 'ViewSetup1' to 'ViewSetup2' in a single-line format

    Rename-AutomateNOWViewSetup -ViewSetup (Get-AutomateNOWViewSetup -Id 'ViewSetup1') -NewId 'ViewSetup2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global ViewSetup.

    When renaming, you may only specify a different Id (name).
    #>
    [OutputType([ANOWViewSetup])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWViewSetup]$ViewSetup,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin standard warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$new_ViewSetup_exists = ($null -ne (Get-AutomateNOWViewSetup -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWViewSetup failed to check if the ViewSetup [$NewId] already existed due to [$Message]."
            Break
        }
        If ($new_ViewSetup_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a ViewSetup named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        #[string]$ViewSetup_id = $ViewSetup.id
        [string]$ViewSetup_id = $ViewSetup.simpleId
        $Error.Clear()
        Try {
            [boolean]$old_ViewSetup_exists = ($null -ne (Get-AutomateNOWViewSetup -Id $ViewSetup_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWViewSetup failed to check if the ViewSetup [$ViewSetup_id] already existed due to [$Message]."
            Break
        }
        If ($old_ViewSetup_exists -eq $false) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not a ViewSetup named [$ViewSetup_id] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End standard warning ##
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ViewSetup_id)")) -eq $true) {
                $Error.Clear()
                Try {
                    [ANOWViewSetup]$new_ViewSetup = Copy-AutomateNOWViewSetup -ViewSetup $ViewSetup -NewId $NewId -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Copy-AutomateNOWViewSetup failed to create a new View Setup object [$NewId] as Part 1 of the renaming process due to [$Message]."
                    Break
                }
                If ($new_ViewSetup.simpleId -eq $NewId) {
                    Write-Verbose -Message "Part 1: View Setup object [$ViewSetup_id] successfully copied to [$NewId]"
                }
                Else {
                    Write-Warning -Message "Somehow the first phase (Copy-AutomateNOWViewSetup) failed. Please look into this."
                    Break
                }
                $Error.Clear()
                Try {
                    Remove-AutomateNOWViewSetup -ViewSetup $ViewSetup -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Remove-AutomateNOWViewSetup failed to remove [$ViewSetup_id] as Part 2 of the renaming process due to [$Message]."
                    Break
                }
                Write-Verbose -Message "Part 2: View Setup object [$ViewSetup_id] removed"
                Write-Verbose -Message "Task [$ViewSetup_id] successfully renamed to [$NewId]"
                If ($Quiet -ne $true) {
                    Return $ViewSetup
                }
            }
        }
        Else {
            Write-Warning -Message "No action was taken because either the source object didn't exist or the new object already existed"
        }
    }
    End {
    }
}

#endregion

#Region - Workflows (PROCESSING)

Function Get-AutomateNOWWorkflow {
    <#
    .SYNOPSIS
    Gets the Workflows from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Workflows from an AutomateNOW! instance

    .PARAMETER Id
    A single int64 containing the NUMERICAL id of the Workflow to fetch (a.k.a. RunId)

    .PARAMETER WorkflowTemplate
    Optional [ANOWWorkflowTemplate] object by which to filter results by.

    .PARAMETER launchedById
    Optional [int64] RunId of the Workflow that you wish to search for based on the launchedById property.

    .PARAMETER Type
    Optional string containing the type of Workflow. Valid choices are STANDARD, BROADCAST, FOR_EACH, TIME_SERIES, SWITCH, CYCLE

    .PARAMETER processingStatus
    Optional 'processing status' to filterby. You can only choose one. Valid choices are: WAITING, READY, EXECUTING, COMPLETED, FAILED

    .PARAMETER startRow
    Integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER sortBy
    Optional string parameter to sort the results by (may not be used with the Id parameter). Valid choices are: {To be continued...}

    .PARAMETER Descending
    Optional switch parameter to sort in ascending order

    .PARAMETER ItemsOnly
    Optional switch parameter that modifies the -Id parameter set to provide the executed child Items within the Workflow. This switch completely changes the output of this function and may only be used in conjuntion with the -Id parameter.

    .PARAMETER IncludeArchived
    Optional switch parameter removes the filter for archived items thus both archived and non-archived items will be returned.

    .PARAMETER OnlyArchived
    Optional switch parameter filters out non-archived items thus only archived items will be returned.

    .PARAMETER Folder
    Optional string to filter by a particular Folder

    .PARAMETER Tags
    Optional string array of Tags to filter by. Note that the 'containsAny' operator will be used.

    .INPUTS
    Accepts a string representing the simple id of the Workflow from the pipeline or individually (but not an array).

    .OUTPUTS
    An array of one or more [ANOWWorkflow] class objects

    .EXAMPLE
    Gets the first page of Workflows based on a Workflow Template named 'WorkflowTemplate1'

    $workflow_template = Get-AutomateNOWWorkflowTempate -Id 'WorkflowTemplate1'
    $workflow_template | Get-AutomateNOWWorkflow

    .EXAMPLE
    Gets the first page of Workflows that are of type TRIGGER

    Get-AutomateNOWWorkflow -WorkflowType TRIGGER

    .EXAMPLE
    Gets the first 1000 Workflows that are in EXECUTING status

    Get-AutomateNOWWorkFlow -startRow 0 -endRow 1000 -processingStatus EXECUTING

    .EXAMPLE
    Gets the first 1000 Workflows that were launched from a Workflow Template named 'WorkflowTemplate1'

    Get-AutomateNOWWorkflow -WorkflowTemplate (Get-AutomateNOWWorkflowTemplate -Id 'WorkflowTemplate1') -startRow 0 -endRow 1000

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Use Get-AutomateNOWWorkflowTemplate if you are looking for Workflow Templates (a.k.a. Design Templates)

    #>
    [Cmdletbinding(DefaultParameterSetName = 'All')]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $True, ValueFromPipeline = $true, ParameterSetName = 'Id')]
        [int64]$Id,
        [Parameter(Mandatory = $False, ValueFromPipeline = $true, ParameterSetName = 'All')]
        [ANOWWorkflowTemplate]$WorkflowTemplate,
        [Parameter(Mandatory = $True, ParameterSetName = 'launchedById')]
        [int64]$launchedById,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [ANOWProcessing_workflowType]$Type,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [ANOWProcessing_processingStatus]$ProcessingStatus,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Id')]
        [Parameter(Mandatory = $false, ParameterSetName = 'launchedById')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Id')]
        [Parameter(Mandatory = $false, ParameterSetName = 'launchedById')]
        [int32]$endRow = 100,
        [ValidateSet('dateCreated', 'id', 'firstStartTime', 'startTime', 'endTime', ignoreCase = $false)]
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [Parameter(Mandatory = $false, ParameterSetName = 'launchedById')]
        [string]$sortBy = 'dateCreated',
        [Parameter(Mandatory = $False, ParameterSetName = 'All')]
        [Parameter(Mandatory = $false, ParameterSetName = 'launchedById')]
        [switch]$Descending,
        [Parameter(Mandatory = $false, ParameterSetName = 'Id')]
        [switch]$ItemsOnly,
        [Parameter(Mandatory = $false, ParameterSetName = 'All')]
        [Parameter(Mandatory = $false, ParameterSetName = 'launchedById')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Id')]
        [switch]$IncludeArchived,
        [Parameter(Mandatory = $false, ParameterSetName = 'All')]
        [Parameter(Mandatory = $false, ParameterSetName = 'launchedById')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Id')]
        [switch]$OnlyArchived,
        [Parameter(Mandatory = $false, ParameterSetName = 'All')]
        [string]$Folder,
        [Parameter(Mandatory = $false, ParameterSetName = 'All')]
        [string[]]$Tags
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [string]$command = ('/processing/read')
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWWorkflowTemplate]$WorkflowTemplate = $_
        }
        ElseIf ($_ -is [int64]) {
            [string]$Id = $_
        }
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($Id -gt 0 -and $ItemsOnly -ne $true) {
            $BodyMetaData.'id' = $Id
            $BodyMetaData.'_operationId' = 'read'
            [string]$textMatchStyle = 'exactCase'
        }
        Else {
            [string]$ComponentId = 'ProcessingList'
            $BodyMetaData.'_constructor' = 'AdvancedCriteria'
            $BodyMetaData.'operator' = 'and'
            If ($OnlyArchived -eq $true) {
                $BodyMetaData.'criteria1' = '{"fieldName":"archived","operator":"equals","value":true}'
            }
            ElseIf ($IncludeArchived -ne $true) {
                $BodyMetaData.'criteria1' = '{"fieldName":"archived","operator":"equals","value":false}'
            }
            If (($Type.Length -gt 0)) {
                $BodyMetaData.'criteria2' = '{"fieldName":"itemType","operator":"equals","value":"' + $Type + '"}'
            }
            ElseIf ($ItemsOnly -eq $true -and $Id -gt 0) {
                $BodyMetaData.'criteria2' = '{"fieldName":"parent","value":"' + $Id + '","operator":"equals"}'
            }
            ElseIf ($WorkflowTemplate.Id.Length -gt 0) {
                $BodyMetaData.'criteria2' = ('{"fieldName":"template","operator":"equals","value":"' + $WorkflowTemplate.Id + '"}')
                [string]$Type = $WorkflowTemplate.workflowType
                $BodyMetaData.'criteria3' = '{"fieldName":"itemType","operator":"equals","value":"' + $Type + '"}'
            }
            ElseIf ($launchedById -gt 0) {
                $BodyMetaData.'criteria2' = '{"fieldName":"parent","value":null,"operator":"equals"}'
                $BodyMetaData.'criteria3' = ('{"fieldName":"launchedById","operator":"equals","value":"' + $launchedById + '"}')
                $BodyMetaData.'criteria4' = '{"fieldName":"isRoot","operator":"equals","value":true}'
            }
            Else {
                $Error.Clear()
                Try {
                    [string]$all_workflow_types = ([ANOWProcessing_workflowType].GetEnumNames() | ForEach-Object { '"' + $_ + '"' }) -join ','
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWWorkflow was unable to enumerate the object class [ANOWProcessing_workflowType] due to [$Message]."
                    Break
                }
                $BodyMetaData.'criteria2' = '{"fieldName":"itemType","operator":"inSet","value":[' + $all_workflow_types + ']}'
            }
            If ($Folder.Length -gt 0) {
                $BodyMetaData.'criteria5' = ('{"fieldName":"folder","operator":"equals","value":"' + $Folder + '"}')
            }
            If ($Tags.Count -gt 0) {
                If ($Tags.Count -gt 1) {
                    $Error.Clear()
                    Try {
                        [string]$TagString = $Tags | ConvertTo-Json -Compress
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "ConvertTo-Json failed to convert the provided tag names under Get-AutomateNOWWorkflow due to [$Message]."
                        Break
                    }
                }
                Else {
                    [string]$TagString = $Tags
                }
                $BodyMetaData.'criteria6' = ('{"fieldName":"tags","operator":"containsAny","value":' + $TagString + '}')
            }
            If ($ProcessingStatus.Length -gt 0) {
                [string]$ProcessingStatus = $ProcessingStatus.ToString()
                $BodyMetaData.'criteria7' = ('{"fieldName":"processingStatus","operator":"inSet","value":["' + $ProcessingStatus + '"]}')
            }
            If ($ItemsOnly -ne $true) {
                $BodyMetaData.'criteria8' = '{"fieldName":"isProcessing","operator":"equals","value":true}'
            }
            Else {
                [string]$componentId = 'ProcessingItemList'
            }
            $BodyMetaData.'_componentId' = $componentId
            $BodyMetaData.'_startRow' = $startRow
            $BodyMetaData.'_endRow' = $endRow
            If ($Descending -eq $true) {
                $BodyMetaData.'_sortBy' = '-' + $sortBy
            }
            Else {
                $BodyMetaData.'_sortBy' = $sortBy
            }
            [string]$textMatchStyle = 'substring'
        }
        $BodyMetaData.'_operationType' = 'fetch'
        $BodyMetaData.'_textMatchStyle' = $textMatchStyle
        $BodyMetaData.'_dataSource' = 'ProcessingDataSource'
        $BodyMetaData.'isc_metaDataPrefix' = '_'
        $BodyMetaData.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        If ($null -eq $parameters.Body) {
            $parameters.Add('Body', $Body)
        }
        Else {
            $parameters.Body = $Body
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        If ($results.response.data.Count -eq 1) {
            If ($results.response.data.processingType -eq 'TASK') {
                $Error.Clear()
                Try {
                    [ANOWTask]$workflows = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to parse the response into an [ANOWTask] object due to [$Message]."
                    Break
                }
            }
            ElseIf ($results.response.data.processingType -eq 'TRIGGER') {
                $Error.Clear()
                Try {
                    [ANOWSchedule]$workflows = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to parse the response into an [ANOWSchedule] object due to [$Message]."
                    Break
                }
            }
            ElseIf ($results.response.data.processingType -eq 'SERVICE') {
                $Error.Clear()
                Try {
                    [ANOWServiceManager]$workflows = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to parse the response into an [ANOWServiceManager] object due to [$Message]."
                    Break
                }
            }
            Else {
                $Error.Clear()
                Try {
                    [ANOWWorkflow]$workflows = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to parse the response into a series of [ANOWWorkflow] objects due to [$Message]."
                    Break
                }
            }
        }
        Else {
            $Error.Clear()
            Try {
                [ANOWWorkflow[]]$workflows = $results.response.data
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the response into a series of [ANOWWorkflow] objects due to [$Message]."
                Break
            }
        }
        If ($workflows.Count -gt 0) {
            Return $workflows
        }
    }
    End {

    }
}

Function Export-AutomateNOWWorkflow {
    <#
    .SYNOPSIS
    Exports the Workflows from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Workflows from an instance of AutomateNOW! to a local .csv file

    .PARAMETER Workflow
    Mandatory [ANOWWorkflow] object (Use Get-AutomateNOWWorkflow to retrieve them)

    .PARAMETER Type
    Mandatory string containing the type of Workflow. Valid choices are STANDARD, BROADCAST, FOR_EACH, TIME_SERIES, SWITCH, CYCLE

    .INPUTS
    ONLY [ANOWWorkflow] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWWorkflow] objects are exported to the local disk in CSV format

    .EXAMPLE
    Get-AutomateNOWWorkflow | Export-AutomateNOWWorkflow -Type STANDARD

    .EXAMPLE
    Get-AutomateNOWWorkflow -Type STANDARD | Export-AutomateNOWWorkflow -Type STANDARD

    .EXAMPLE
    Get-AutomateNOWWorkflow -Id 'Workflow01' | Export-AutomateNOWWorkflow -Type FOR_EACH

    .EXAMPLE
    @( 'Workflow01', 'Workflow02', 'Workflow03' ) | Get-AutomateNOWWorkflow | Export-AutomateNOWWorkflow -Type STANDARD

    .EXAMPLE
    Get-AutomateNOWWorkflow | Where-Object { $_.id -like '*MyWorkflow*' } | Export-AutomateNOWWorkflow -Type STANDARD

    .NOTES
	You must present [ANOWWorkflow] objects to the pipeline to use this function.

    The -Type parameter is mandatory here!
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWWorkflow]$Workflow,
        [Parameter(Mandatory = $False)]
        [ANOWProcessing_workflowType]$Type
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-Workflows-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWWorkflow]$workflow_ = $_
        }
        $Error.Clear()
        Try {
            $workflow_ | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWWorkflow] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function Remove-AutomateNOWWorkflow {
    <#
    .SYNOPSIS
    Archives a Workflow from an AutomateNOW! instance

    .DESCRIPTION
    Archives a Workflow from an AutomateNOW! instance

    .PARAMETER Workflow
    An [ANOWWorkflow] object representing the Workflow Template to be archived.

    .PARAMETER Force
    Force the archiving without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWWorkflow] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Archives a single Workflow

    Get-AutomateNOWWorkflow -Id 'Workflow01' | Remove-AutomateNOWWorkflow

    .EXAMPLE
    Archives a series of Workflows without prompting

    @( 'Workflow1', 'Workflow2', 'Workflow3') | Remove-AutomateNOWWorkflow -Force

    .EXAMPLE
    Archives all For_Each Workflows

    Get-AutomateNOWWorkflow | ? { $_.serverWorkflowType -eq 'FOR_EACH' } | Remove-AutomateNOWWorkflow

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The term Remove and Archive are synonymous from the API perspective. In ANOW parlance, Templates are 'Deleted' and Workflows are 'Archived'.
    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWWorkflow]$Workflow,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processing/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWWorkflow]$Workflow = $_
        }
        [int64]$Workflow_id = $Workflow.id
        If ($Workflow_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess($Workflow_id, 'Archive')) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
            $Body.Add('id', $Workflow_id)
            $Body.Add('_operationType', 'remove')
            $Body.Add('_operationId', 'delete')
            $Body.Add('_textMatchStyle', 'exact')
            $Body.Add('_dataSource', 'ProcessingDataSource')
            $Body.Add('isc_metaDataPrefix', '_')
            $Body.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $Body
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Workflow_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Workflow $Workflow_id successfully archived"
        }
    }
    End {

    }
}

Function Restart-AutomateNOWWorkflow {
    <#
    .SYNOPSIS
    Restarts a Workflow from an AutomateNOW! instance

    .DESCRIPTION
    Restarts a Workflow from an AutomateNOW! instance

    .PARAMETER Workflow
    An [ANOWWorkflow] object representing the Workflow to be restarted

    .PARAMETER Quiet
    Switch parameter to omit the informational message if the Restart was successful

    .PARAMETER Force
    Force the restart without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWWorkflow] objects are accepted (including from the pipeline)

    .OUTPUTS
    An informational message is written to the screen unless -Quiet is used

    .EXAMPLE
    Restarts a single Workflow

    Get-AutomateNOWWorkflow -Id 'Workflow_01' | Restart-AutomateNOWWorkflow

    .EXAMPLE
    Quietly restarts multiple Workflows

    @('Workflow1', 'Workflow2') | Get-AutomateNOWWorkflow | Restart-AutomateNOWWorkflow -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWWorkflow]$Workflow,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processing/restart'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id -gt 0) {
            [int64]$Workflow_id = $_.id
        }
        Else {
            [int64]$Workflow_id = $Workflow.id
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Workflow_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [ANOWWorkflow]$current_workflow = Get-AutomateNOWWorkflow -Id $Workflow_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWWorkflow failed to check if the Workflow [$Workflow_id] existed under Restart-AutomateNOWWorkflow due to [$Message]."
                Break
            }
            If ($current_workflow.id.length -eq 0) {
                Write-Warning -Message "The Workflow you specified does not seem to exist (Restart-AutomateNOWWorkflow)"
                Break
            }
            [string]$current_workflow_status = $current_workflow.processingStatus
            If ($current_workflow_status -notin [ANOWProcessing_processingStatus].GetEnumNames()) {
                Write-Warning -Message "Somehow the processing status of the Workflow [$Workflow_id] cannot be read (Restart-AutomateNOWWorkflow)"
                Break
            }
            If ($current_workflow_status -notin @('COMPLETED', 'FAILED')) {
                Write-Warning -Message "[$Workflow_id] cannot be restarted as it currently in [$current_workflow_status] processing status"
                Break
            }
            Else {
                Write-Verbose -Message "[$Workflow_id] had a status of $current_workflow_status"
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('restartType', 'RESTART_FROM_BEGINNING')
            $BodyMetaData.Add('restartFailedOnly', 'false' ) # Note this value is currently not available in the console
            $BodyMetaData.Add('id', $Workflow_id )
            $BodyMetaData.Add('_operationType', 'custom')
            $BodyMetaData.Add('_operationId', 'restart')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Workflow_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            If ($Quiet -ne $true) {
                Write-Information -MessageData "Workflow $Workflow_id was successfully restarted"
            }
        }
    }
    End {

    }
}

Function Stop-AutomateNOWWorkflow {
    <#
    .SYNOPSIS
    Stops a Workflow on an AutomateNOW! instance

    .DESCRIPTION
    Stops a Workflow on an AutomateNOW! instance with either a soft or hard stop

    .PARAMETER Workflow
    An [ANOWWorkflow] object representing the Workflow to be stopped

    .PARAMETER Kill
    Switch parameter to indicate 'Hard kill' of the Workflow. You must include either this parameter or -Abort

    .PARAMETER Abort
    Switch parameter to indicate 'Soft abort' of the Workflow. You must include either this parameter or -Kill

    .PARAMETER Force
    Force the stoppage without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWWorkflow] objects are accepted (including from the pipeline)

    .OUTPUTS
    An informational message is written to the screen unless -Quiet is used

    .EXAMPLE
    Stops a single Workflow

    Get-AutomateNOWWorkflow -Id 'Workflow_01' | Stop-AutomateNOWWorkflow -Abort

    .EXAMPLE
    Quietly stops multiple Workflows

    @('Workflow1', 'Workflow2') | Get-AutomateNOWWorkflow | Stop-AutomateNOWWorkflow -Kill -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWWorkflow]$Workflow,
        [Parameter(Mandatory = $true, ParameterSetName = 'Kill')]
        [switch]$Kill,
        [Parameter(Mandatory = $true, ParameterSetName = 'Abort')]
        [switch]$Abort,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($Kill -eq $true) {
            [string]$operation_id = 'kill'
        }
        Else {
            [string]$operation_id = 'abort'
        }
        [string]$command = ('/processing/' + $operation_id)
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id -gt 0) {
            [int64]$Workflow_id = $_.id
        }
        Else {
            [int64]$Workflow_id = $Workflow.id
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Workflow_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [ANOWWorkflow]$current_workflow = Get-AutomateNOWWorkflow -Id $Workflow_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWWorkflow failed to check if the Workflow [$Workflow_id] existed under Restart-AutomateNOWWorkflow due to [$Message]."
                Break
            }
            If ($current_workflow.id.length -eq 0) {
                Write-Warning -Message "The Workflow you specified does not seem to exist (Stop-AutomateNOWWorkflow)"
                Break
            }
            [string]$current_workflow_status = $current_workflow.processingStatus
            If ($current_workflow_status -notin [ANOWProcessing_processingStatus].GetEnumNames()) {
                Write-Warning -Message "Somehow the processing status of the Workflow [$Workflow_id] cannot be read (Stop-AutomateNOWWorkflow)"
                Break
            }
            If ($current_workflow_status -in @('COMPLETED', 'FAILED')) {
                Write-Warning -Message "[$Workflow_id] cannot be stopped as it currently in [$current_workflow_status] processing status"
                Break
            }
            Else {
                Write-Verbose -Message "[$Workflow_id] had a status of $current_workflow_status"
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $Workflow_id )
            $BodyMetaData.Add('_operationType', 'custom')
            $BodyMetaData.Add('_operationId', $operation_id)
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Workflow_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            If ($Quiet -ne $true) {
                Write-Information -MessageData "Workflow $Workflow_id was successfully stopped"
            }
        }
    }
    End {

    }
}

Function Resume-AutomateNOWWorkflow {
    <#
    .SYNOPSIS
    Resumes a Workflow that is on hold (suspended) on an AutomateNOW! instance

    .DESCRIPTION
    Resumes a Workflow that is on hold (suspended) on an AutomateNOW! instance

    .PARAMETER Workflow
    An [ANOWWorkflow] object representing the Workflow to be resumed

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWWorkflow] objects are accepted (including from the pipeline)

    .OUTPUTS
    A verbose information message will be sent indicating success

    .EXAMPLE
    Get-AutomateNOWWorkflow -Id 'Workflow01' | Resume-AutomateNOWWorkflow -Force

    .EXAMPLE
    Get-AutomateNOWWorkflow -Id 'Workflow01', 'Workflow02' | Resume-AutomateNOWWorkflow

    .EXAMPLE
    @( 'Workflow1', 'Workflow2', 'Workflow3') | Resume-AutomateNOWWorkflow

    .EXAMPLE
    Get-AutomateNOWWorkflow | ? { $_.serverWorkflowType -eq 'LINUX' } | Resume-AutomateNOWWorkflow

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $True, ValueFromPipeline = $True)]
        [ANOWWorkflow]$Workflow,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processing/resume'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWWorkflow]$Workflow = $_
        }
        [int64]$Workflow_id = $Workflow.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Workflow_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [ANOWWorkflow]$current_workflow = Get-AutomateNOWWorkflow -Id $Workflow_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWWorkflow failed to check if the Workflow [$Workflow_id] existed under Resume-AutomateNOWWorkflow due to [$Message]."
                Break
            }
            If ($current_workflow.id.length -eq 0) {
                Write-Warning -Message "The Workflow you specified does not seem to exist (Resume-AutomateNOWWorkflow)"
                Break
            }
            [boolean]$current_workflow_hold_status = $current_workflow.onHold
            If ($current_workflow_hold_status -eq $false) {
                Write-Warning -Message "[$Workflow_id] cannot be resumed as it is not currently suspended (on hold)"
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $Workflow_id )
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_operationId', 'resume')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Workflow_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Workflow $Workflow_id successfully resumed"
        }
    }
    End {

    }
}

Function Suspend-AutomateNOWWorkflow {
    <#
    .SYNOPSIS
    Places a Workflow on hold (suspend) from execution on an AutomateNOW! instance

    .DESCRIPTION
    Places a Workflow on hold (suspend) from execution on an AutomateNOW! instance

    .PARAMETER Workflow
    An [ANOWWorkflow] object representing the Workflow to be suspended (placed on hold)

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWWorkflow] objects are accepted (including from the pipeline)

    .OUTPUTS
    A verbose information message will be sent indicating success

    .EXAMPLE
    Get-AutomateNOWWorkflow -Id 'Workflow01' | Suspend-AutomateNOWWorkflow -Force

    .EXAMPLE
    Get-AutomateNOWWorkflow -Id 'Workflow01', 'Workflow02' | Suspend-AutomateNOWWorkflow

    .EXAMPLE
    @( 'Workflow1', 'Workflow2', 'Workflow3') | Suspend-AutomateNOWWorkflow

    .EXAMPLE
    Get-AutomateNOWWorkflow | ? { $_.serverWorkflowType -eq 'LINUX' } | Suspend-AutomateNOWWorkflow

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWWorkflow]$Workflow,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processing/hold'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWWorkflow]$Workflow = $_
        }
        [string]$Workflow_id = $Workflow.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Workflow_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [ANOWWorkflow]$current_workflow = Get-AutomateNOWWorkflow -Id $Workflow_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWWorkflow failed to check if the Workflow [$Workflow_id] existed under Resume-AutomateNOWWorkflow due to [$Message]."
                Break
            }
            If ($current_workflow.id.length -eq 0) {
                Write-Warning -Message "The Workflow you specified does not seem to exist (Resume-AutomateNOWWorkflow)"
                Break
            }
            [boolean]$current_workflow_hold_status = $current_workflow.onHold
            If ($current_workflow_hold_status -eq $true) {
                Write-Warning -Message "[$Workflow_id] cannot be suspended (placed on hold) as it is already suspended (on hold)"
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $Workflow_id )
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_operationId', 'hold')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Workflow_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Workflow $Workflow_id successfully suspended (placed on hold)"
        }
    }
    End {

    }
}

Function Skip-AutomateNOWWorkflow {
    <#
    .SYNOPSIS
    Sets or unsets the Skip flag on a Workflow on an AutomateNOW! instance

    .DESCRIPTION
    Sets or unsets the Skip flag on a Workflow on an AutomateNOW! instance

    .PARAMETER Workflow
    An [ANOWWorkflow] object representing the Workflow to be set to skipped or unskipped

    .PARAMETER UnSkip
    Removes the skip flag from an [ANOWWorkflow] object. This is the opposite of the default behavior.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Switch parameter to silence the emitted [ANOWWorkflow] object

    .INPUTS
    ONLY [ANOWWorkflow] objects are accepted (including from the pipeline)

    .OUTPUTS
    The skipped/unskipped [ANOWWorkflow] object will be returned

    .EXAMPLE
    Sets a Workflow to Skip (bypass)

    Get-AutomateNOWWorkflow -Id 'Workflow01' | Skip-AutomateNOWWorkflow -Force

    .EXAMPLE
    Unsets the Skip (bypass) flag on a Workflow

    Get-AutomateNOWWorkflow | Skip-AutomateNOWWorkflow -UnSkip

    .EXAMPLE
    Sets an array of Workflows to Skip (bypass)

    @( 1234567, 2345678, 34567890) | Skip-AutomateNOWWorkflow

    .EXAMPLE
    Get-AutomateNOWWorkflow | ? { $_.workflowType -eq 'FOR_EACH' } | Skip-AutomateNOWWorkflow -UnSkip -Force -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWWorkflow]$Workflow,
        [Parameter(Mandatory = $false)]
        [switch]$UnSkip,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnSkip -ne $True) {
            [string]$skip_flag_status = 'On'
            [string]$operation_id = 'passByOn'
            [string]$ProcessDescription = 'Add the Skip flag'
        }
        Else {
            [string]$skip_flag_status = 'Off'
            [string]$operation_id = 'passByOff'
            [string]$ProcessDescription = 'Remove the Skip flag'
        }
        [string]$command = ('/processing/' + $operation_id)
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWWorkflow]$Workflow = $_
        }
        [string]$Workflow_id = $Workflow.id
        If ($Workflow.passBy -eq $true -and $UnSkip -ne $True) {
            Write-Warning -Message "Workflow $Workflow_id already has the skip flag set. No action is required."
            Break
        }
        ElseIf ($Workflow.passBy -eq $false -and $UnSkip -eq $True) {
            Write-Warning -Message "Workflow $Workflow_id does not have the skip flag set. No action is required."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess($Workflow_id, $ProcessDescription)) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $Workflow_id )
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_operationId', $operation_id)
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Workflow_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Successfully set the skip flag to [$skip_flag_status] on [$Workflow_id]"
        }
    }
    End {

    }
}

#endregion

#Region - Workflow Templates (PROCESSING_TEMPLATE)

Function Get-AutomateNOWWorkflowTemplate {
    <#
    .SYNOPSIS
    Gets the Workflow Templates from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Workflow Templates from an AutomateNOW! instance

    .PARAMETER Id
    Mandatory string containing the simple id of the Workflow Template to fetch or you can pipeline a series of simple id strings. You may not enter an array here.

    .PARAMETER Type
    Mandatory string containing the type of Workflow Template. Valid choices are STANDARD, BROADCAST, FOR_EACH, TIME_SERIES, SWITCH, CYCLE

    .PARAMETER sortBy
    Optional string parameter to sort the results by. Valid choices are: id {To be continued...}

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER Tags
    Optional string array of tags to filter by. Note that for now operator is 'containsAny', not 'containsAll'.

    .PARAMETER Folder
    Optional name of folder to filter the results by.

    .PARAMETER OverrideProcessingType
    Switch parameter that allows this function to retrieve Processing Templates that are not Workflows.

    .INPUTS
    Accepts a string representing the simple id of the Workflow Template from the pipeline or individually (but not an array).

    .OUTPUTS
    An array of one or more [ANOWWorkflowTemplate] class objects

    .EXAMPLE
    Get-AutomateNOWWorkflowTempate

    .EXAMPLE
    Get-AutomateNOWWorkflowTemplate -Id 'workflow_01'

    .EXAMPLE
    Get-AutomateNOWWorkflowTemplate -Type FOR_EACH

    .EXAMPLE
    @( 'workflow_01', 'workflow_02' ) | Get-AutomateNOWWorkflowTemplate

    .EXAMPLE
    Gets all Workflow Templates that are tagged with 'Tag1' or 'Tag2'

    Get-AutomateNOWWorkflowTemplate -Tags 'Tag1', 'Tag2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Run this function without parameters to retrieve all of the Workflows.

    #>
    [OutputType([ANOWWorkflowTemplate[]])]
    [Cmdletbinding()]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $False, ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $False)]
        [ANOWProcessingTemplate_workflowType]$Type,
        [Parameter(Mandatory = $False)]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False)]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False)]
        [string]$sortBy = 'id',
        [Parameter(Mandatory = $False)]
        [string[]]$Tags,
        [Parameter(Mandatory = $False)]
        [string]$Folder,
        [Parameter(Mandatory = $False)]
        [switch]$OverrideProcessingType
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        $Body.'_constructor' = 'AdvancedCriteria'
        $Body.'operator' = 'and'
        $Body.'_operationType' = 'fetch'
        $Body.'_startRow' = $startRow
        $Body.'_endRow' = $endRow
        $Body.'_componentId' = 'ProcessingTemplateList'
        $Body.'_dataSource' = 'ProcessingTemplateDataSource'
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        If ($Descending -eq $true) {
            $Body.'_sortBy' = '-' + $sortBy
        }
        Else {
            $Body.'_sortBy' = $sortBy
        }
        If ($_.Length -gt 0 -or $Id.Length -gt 0) {
            If ($_.Length -gt 0 ) {
                $Body.'id' = $_
            }
            Else {
                $Body.'id' = $Id
            }
            $Body.'_operationId' = 'read'
            [string]$textMatchStyle = 'exactCase'
        }
        Else {
            [string]$textMatchStyle = 'substring'
            If ( $Type.length -eq 0) {
                [string]$fieldName = 'processingType'
                [string]$value = 'WORKFLOW'
            }
            Else {
                [string]$fieldName = 'workflowType'
                [string]$value = $Type
            }
            $Body.'criteria1' = ('{"fieldName":"' + $fieldName + '","operator":"equals","value":"' + $value + '"}')
            If ($Tags.Count -gt 0) {
                ForEach ($tag_id in $Tags) {
                    $Error.Clear()
                    Try {
                        [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] running under Get-AutomateNOWWorkflowTemplate due to [$message]"
                        Break
                    }
                    If ($tag_object.simpleId.length -eq 0) {
                        Throw "Get-AutomateNOWTag has detected that the tag [$tag_id] does not appear to exist under Get-AutomateNOWWorkflowTemplate. Please check again."
                        Break
                    }
                    ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                        [string]$tag_object_simpleId = $tag_object.simpleId
                        Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                        Break
                    }
                    [string]$tags_json = $Tags | Sort-Object -Unique | ConvertTo-JSON -Compress
                    $Body.'criteria2' = ('{"fieldName":"tags","operator":"containsAny","value":' + $tags_json + '}')
                }
            }
            If ($Folder.Length -gt 0) {
                If ($null -eq (Get-AutomateNOWFolder -Id $Folder)) {
                    Write-Warning -Message "The folder [$Folder] does not appear to exist. Please only use existing Folders when filtering."
                    Break
                }
                $Body.'criteria3' = ('{"fieldName":"folder","operator":"equals","value":"' + $folder + '"}')
            }
        }
        $Body.'_textMatchStyle' = $textMatchStyle
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/processingTemplate/read?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.Command = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWWorkflowTemplate[]]$WorkflowTemplates = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWWorkflowTemplate] objects due to [$Message]."
            Break
        }
        If ($WorkflowTemplates.Count -gt 0) {
            If ($WorkflowTemplates.Count -eq 1 -and $WorkflowTemplates.processingType -ne 'WORKFLOW' -and $OverrideProcessingType -ne $true) {
                [string]$processingType = $WorkflowTemplates.processingType
                If ($processingType -in @('TASK', 'SERVICE')) {
                    Write-Warning -Message "$Id is actually a Task Template. Please use Get-AutomateNOWTaskTemplate to retrieve this item."
                }
                ElseIf ($processingType -eq 'TRIGGER') {
                    Write-Warning -Message "$Id is actually a Schedule Template. Please use Get-AutomateNOWScheduleTemplate to retrieve this item."
                }
                Else {
                    Write-Warning -Message "Could not identify what type of template object [$processingType] is. Please look into this..."
                }
                Break
            }
            Return $WorkflowTemplates
        }
    }
    End {

    }
}

Function Set-AutomateNOWWorkflowTemplate {
    <#
    .SYNOPSIS
    Changes the settings of a Workflow Template on an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of a Workflow Template on an AutomateNOW! instance

    .PARAMETER WorkflowTemplate
    An [ANOWWorkflowTemplate] object representing the Workflow Template to be changed.

    .PARAMETER Description
    Optional description of the Workflow Template (may not exceed 255 characters).

    .PARAMETER UnsetDescription
    Optional switch that will remove the Description from the Workflow Template object.

    .PARAMETER Folder
    A string representing the name of the Folder to move the Workflow Template into.

    .PARAMETER UnsetFolder
    A switch parameter that will move the Workflow Template out of its current folder.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to include with this object.

    .PARAMETER UnsetTags
    A switch parameter that will remove the Tags from the Workflow Template

    .PARAMETER CodeRepository
    Optional Code Repository to place the Workflow Template into. Use Get-AutomateNOWCodeRepository to fetch this object.

    .PARAMETER UnsetCodeRepository
    Switch parameter that will remove the the Workflow Template from its Code Repository.

    .PARAMETER Title
    A string representing the "alias" of the Workflow Template (this property needs a better explanation)

    .PARAMETER UnsetTitle
    A switch parameter that will remove the Title from the Workflow Template

    .PARAMETER ResultMapping
    An [ResultMapping] object representing the Result Mapping object to set on the Workflow Template.

    .PARAMETER UnsetResultMapping
    A switch parameter that will remove the Result Mapping assignment from the Workflow Template.

    .PARAMETER Calendar
    A [ANOWCalendar] object representing the Calendar object to set on the Workflow Template. Use Get-AutomateNOWCalendar to fetch one of these.

    .PARAMETER UnsetCalendar
    A switch parameter that will remove the Calendar assignment from the Workflow Template.

    .PARAMETER DelayedStartTime
    Optional string that allows processing items to start on a specific date or time or delay the execution for a period ranging from days to seconds. Example 1: 2029-12-31, Example 2: 2029-12-31 23:59:59, Example 3: 23:59:59

    .PARAMETER UnsetDelayedStartTime
    A switch parameter that will remove the Delayed Start Time from the Workflow Template.

    .PARAMETER TimeZone
    Optional [ANOWTimeZone] object that modifies (it is unknown exactly what this property modifies since it is not defined in the documentation yet)

    .PARAMETER UnsetTimeZone
    A switch parameter that will remove the Time Zone from the Workflow Template.

    .PARAMETER Approval
    A [ANOWApproval] object representing the Approval object to set on the Workflow Template.

    .PARAMETER UnsetApproval
    A switch parameter that will remove the Approval assignment from the Workflow Template.

    .PARAMETER Priority
    An integer representing the items priority which determines the order when queuing for resources (Stock and Locks) and [for] being executed by Server Nodes. Default Priority is 0. Minimal Priority is 0.

    .PARAMETER Weight
    An integer representing a logical measure of resources required to process the item by the Server Node. Each Server Node has [a] maximum weight capacity[.] Weight determines [the] number of parallel processes that can run simultaneously. Default processing Weight is 1. Minimal Weight is 0.

    .PARAMETER LazyLoad
    A boolean to enable the Workflow Template on Lazy Load status. You must specify $true or $false here.

    .PARAMETER OnHold
    A boolean to put the Workflow Template on Hold status. You must specify $true or $false here. When $true, it's the same as the Suspend-AutomateNOWWorkflowTemplate function. When $false, Resume-AutomateNOWWorkflowTemplate function.

    .PARAMETER Skip
    A boolean to put the Workflow Template on Skip status. You must specify $true or $false here. When $true, it's the same as the Skip-AutomateNOWWorkflowTemplate function. When $false, Skip-AutomateNOWWorkflowTemplate with -UnSkip parameter.

    .PARAMETER VerboseMode
    A boolean setting that enables Verbose Mode on the Task. You must specify $true or $false here.

    .PARAMETER AutoArchive
    A boolean that causes the Workflows from this Workflow Template to be archived immediately after execution. You must specify $true or $false here.

    .PARAMETER PassResources
    A boolean that indicates if the Workflow Template should pass its Resources to its children.

    .PARAMETER PassActions
    A boolean that indicates if the Workflow Template should pass its Actions to its children.

    .PARAMETER KeepResources
    A boolean that indicates if the Workflow Template should keep its Resources (Stocks and Locks) even if it fails to execute.

    .PARAMETER UseScripts
    A boolean that indicates if the Workflows from this Workflow Template should ?

    .PARAMETER EagerScriptExecution
    A boolean that indicates if the scripts from the Workflows from this Workflow Template should use "Eager" load strategy. In order to use this parameter, you must include -UseScripts $true.

    .PARAMETER Owner
    A string which appears to represent the user who owns the object. In practice, it is just a string. This particular property does not appear to be explained anywhere in the documentation.

    .PARAMETER statisticalDuration
    A int64 number in milliseconds of the expected duration of the Task Template. The minimum/maximum is 1000/31536000000 (1 second/1 year). The default is 60000 (1 minute).

    .PARAMETER Quiet
    Switch parameter that silences the output of the updated object.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWWorkflowTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWWorkflowTemplate] object will be returned

    .EXAMPLE
    $workflow_template = Get-AutomateNOWWorkflowTemplate -Id 'workflow_01'
    Set-AutomateNOWWorkflowTemplate -WorkflowTemplate $workflow_template -Description 'Description!' -Force
    Set-AutomateNOWWorkflowTemplate -WorkflowTemplate $workflow_template -UnsetDescription -Force
    Set-AutomateNOWWorkflowTemplate -WorkflowTemplate $workflow_template -Title 'title!' -Force
    Set-AutomateNOWWorkflowTemplate -WorkflowTemplate $workflow_template -UnsetTags -Force
    Set-AutomateNOWWorkflowTemplate -WorkflowTemplate $workflow_template -Tags 'Tag1' -Force
    Set-AutomateNOWWorkflowTemplate -WorkflowTemplate $workflow_template -UnsetFolder -Force
    Set-AutomateNOWWorkflowTemplate -WorkflowTemplate $workflow_template -Folder 'Folder1' -Force
    Set-AutomateNOWWorkflowTemplate -WorkflowTemplate $workflow_template -title 'Title1' -Force
    Set-AutomateNOWWorkflowTemplate -WorkflowTemplate $workflow_template -ResultMapping (Get-AutomateNOWResultMapping -Id 'result_mapping1') -Force
    Set-AutomateNOWWorkflowTemplate -WorkflowTemplate $workflow_template -UnsetResultMapping -Force
    Set-AutomateNOWWorkflowTemplate -WorkflowTemplate $workflow_template -Calendar (Get-AutomateNOWCalendar -Id 'calendar1') -Force
    Set-AutomateNOWWorkflowTemplate -WorkflowTemplate $workflow_template -UnsetCalendar -Force
    Set-AutomateNOWWorkflowTemplate -WorkflowTemplate $workflow_template -Approval (Get-AutomateNOWApproval -Id 'approval1') -Force
    Set-AutomateNOWWorkflowTemplate -WorkflowTemplate $workflow_template -UnsetApproval -Force
    Set-AutomateNOWWorkflowTemplate -WorkflowTemplate $workflow_template -Priority 1 -Weight 1 -LazyLoad $true -OnHold $true -Skip $true -AutoArchive $true -PassResources $true -PassActions $true -KeepREsources $true -UseScripts $true -EagerScriptExecution $true -Owner 'owner' -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.
    #>
    [OutputType([ANOWWorkflowTemplate])]
    [Cmdletbinding(SupportsShouldProcess, DefaultParameterSetName = 'Default', ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWWorkflowTemplate]$WorkflowTemplate,
        [ValidateScript({ $_.Length -le 255 })]
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [string]$Description,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false, ParameterSetName = 'SetFolder')]
        [string]$Folder,
        [Parameter(Mandatory = $false, ParameterSetName = 'SetFolder')]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [string[]]$Tags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetCodeRepository,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [string]$Title,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetTitle,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [ANOWResultMapping]$ResultMapping,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetResultMapping,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [ANOWCalendar]$Calendar,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetCalendar,
        [ValidateScript({ $_ -match '([0-9]{4}-[0-9]{2}-[0-9]{2}){0,}( {0,}[0-9]{2}:[0-9]{2}:[0-9]{2}){0,}' })]
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [string]$DelayedStartTime,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetDelayedStartTime,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [ANOWTimeZone]$TimeZone,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetTimeZone,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [ANOWApproval]$Approval,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$UnsetApproval,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [int32]$Priority,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [int32]$Weight,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Nullable[boolean]]$LazyLoad,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Nullable[boolean]]$OnHold = $null,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Nullable[boolean]]$Skip = $null,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Nullable[boolean]]$VerboseMode,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Nullable[boolean]]$AutoArchive = $null,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Nullable[boolean]]$KeepResources = $null,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Nullable[boolean]]$PassActions = $null,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Nullable[boolean]]$UseScripts = $null,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Nullable[boolean]]$EagerScriptExecution = $null,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [string]$Owner,
        [ValidateRange(1000, 31536000000)]
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [int64]$statisticalDuration,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetFolder -eq $true -or $Folder.Length -gt 0) {
            [string]$command = '/processingTemplate/setFolder'
            [string]$operationId = 'setFolder'
        }
        Else {
            [string]$command = '/processingTemplate/update'
            [string]$componentId = 'ProcessingTemplateValuesManager'
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
        If ($Description.Length -gt 0 -and $UnsetDescription -eq $true) {
            Write-Warning -Message 'You cannot set the Description and unset it at the same time. Please choose one or the other.'
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Exit
        }
        If ($Tags.count -gt 0 -and $UnsetTags -eq $true) {
            Write-Warning -Message "You cannot set the tags and unset them at the same time. Please choose one or the other."
        }
        If ($Title.Length -gt 0 -and $UnsetTitle -eq $true) {
            Write-Warning -Message 'You cannot set the Title and unset it at the same time. Please choose one or the other.'
            Break
        }
        If ($ResultMapping.Id.Length -gt 0 -and $UnsetResultMapping -eq $true) {
            Write-Warning -Message 'You cannot set the Result Mapping and unset it at the same time. Please choose one or the other.'
            Break
        }
        If ($Calendar.Id.Length -gt 0 -and $UnsetCalendar -eq $true) {
            Write-Warning -Message 'You cannot set the Calendar and unset it at the same time. Please choose one or the other.'
            Break
        }
        If ($UnsetApproval -eq $true -and $Approval.id.Length -gt 0) {
            Write-Warning -Message "You cannot set the Approval and unset it at the same time. Please choose one or the other."
            Exit
        }
        If ($EagerScriptExecution -eq $true -and $UseScripts -ne $true) {
            Write-Warning -Message 'To use -EagerScriptExecution, you must include -UseScripts $true'
            Break
        }
        If ($UnsetTimeZone -eq $true -and $TimeZone.Id.Length -gt 0) {
            Write-Warning -Message "You cannot set the Time Zone and unset it at the same time. Please choose one or the other."
            Exit
        }
        If ($UnsetDelayedStartTime -eq $true -and $DelayedStartTime.Length -gt 0) {
            Write-Warning -Message "You cannot set the Delayed Start Time and unset it at the same time. Please choose one or the other."
            Exit
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWWorkflowTemplate]$WorkflowTemplate = $_
        }
        [string]$WorkflowTemplate_id = $WorkflowTemplate.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($WorkflowTemplate_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$WorkflowTemplate_exists = ($null -eq (Get-AutomateNOWWorkflowTemplate -Id $WorkflowTemplate_id))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWWorkflowTemplate failed to check if the Workflow Template [$WorkflowTemplate_id] already existed due to [$Message]."
                Break
            }
            If ($WorkflowTemplate_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not a Workflow Template named [$WorkflowTemplate_id] in the current domain [$current_domain]. Please check into this."
                Break
            }
            ## End warning ##
            [System.Collections.ArrayList]$include_properties = [System.Collections.ArrayList]@()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $WorkflowTemplate_id
            If ($Description.Length -gt 0) {
                $BodyMetaData.'description' = $Description
            }
            ElseIf ($UnsetDescription -eq $true) {
                $BodyMetaData.'description' = $null
                $include_properties += 'description'
            }
            If ($Folder.Length -gt 0) {
                $Error.Clear()
                Try {
                    [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the Folder [$Folder] actually existed while running under Set-AutomateNOWWorkflowTemplate due to [$Message]"
                    Break
                }
                If ($folder_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] running under Set-AutomateNOWWorkflowTemplate. Please check again."
                    Break
                }
                [string]$folder_display = $folder_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Adding Folder $folder_display to [ANOWWorkflowTemplate] [$WorkflowTemplate_id]"
                $BodyMetaData.'folder' = $Folder
                $include_properties += 'folder'
            }
            ElseIf ($UnsetFolder -eq $true) {
                [string]$folder_display = $folder_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Removing [ANOWWorkflowTemplate] [$WorkflowTemplate_id] from Folder $folder_display"
                $BodyMetaData.'folder' = $null
                $include_properties += 'folder'
            }
            If ($Tags.Count -gt 0) {
                [int32]$total_tags = $Tags.Count
                [int32]$current_tag = 1
                ForEach ($tag_id in $Tags) {
                    $Error.Clear()
                    Try {
                        [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] running under New-AutomateNOWWorkflowTemplate due to [$message]"
                        Break
                    }
                    If ($tag_object.simpleId.length -eq 0) {
                        Throw "New-AutomateNOWWorkflowTemplate has detected that the tag [$tag_id] does not appear to exist. Please check again."
                        Break
                    }
                    ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                        [string]$tag_object_simpleId = $tag_object.simpleId
                        Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                        Break
                    }
                    [string]$tag_display = $tag_object | ConvertTo-Json -Compress
                    Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
                    [string]$tag_name_sequence = ('tags' + $current_tag)
                    $BodyMetaData.Add($tag_name_sequence, $tag_id)
                    $include_properties += $tag_name_sequence
                    $current_tag++
                }
            }
            ElseIf ($UnsetTags -eq $true) {
                [string]$tags_display = ($Calendar.tags) | ConvertTo-Json -Compress
                Write-Verbose -Message "Removing tags [$tags_display] from [$WorkflowTemplate_id]"
                $BodyMetaData.'tags' = $null
                $include_properties += 'tags'
            }
            If ($CodeRepository.Id.Length -gt 0) {
                [string]$CodeRepository_Id = $CodeRepository.Id
                $Error.Clear()
                Try {
                    [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository_Id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository_Id] actually existed under Set-AutomateNOWWorkflowTemplate due to [$Message]"
                    Break
                }
                If ($code_repository_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository_Id] under Set-AutomateNOWWorkflowTemplate. Please check again."
                    Break
                }
                $BodyMetaData.'codeRepository' = $CodeRepository_Id
            }
            ElseIf ($UnsetCodeRepository -eq $true) {
                $BodyMetaData.'codeRepository' = $null
            }
            If ($Title.Length -gt 0) {
                $BodyMetaData.'title' = $Title
            }
            ElseIf ( $UnsetTitle -eq $true) {
                $BodyMetaData.'title' = $null
            }
            If ($ResultMapping.simpleId.Length -gt 0) {
                [string]$ResultMapping_id = $ResultMapping.simpleId
                $Error.Clear()
                Try {
                    [ANOWResultMapping]$rm_object = Get-AutomateNOWResultMapping -Id $ResultMapping_id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWResultMapping failed to confirm that the Result Mapping [$ResultMapping_id] actually existed while running under Set-AutomateNOWWorkflowTemplate due to [$Message]"
                    Break
                }
                If ($rm_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWResultMapping failed to locate the Result Mapping [$ResultMapping_id] running under Set-AutomateNOWWorkflowTemplate. Please check again."
                    Break
                }
                [string]$rm_display = $rm_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Adding Result Mapping $rm_display to [ANOWWorkflowTemplate] [$WorkflowTemplate_id]"
                $BodyMetaData.'resultMapping' = $ResultMapping_id
                $include_properties += 'resultMapping'
            }
            ElseIf ($UnsetResultMapping -eq $true) {
                [string]$rm_display = $rm_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Removing [ANOWWorkflowTemplate] [$ResultMapping_id] from Result Mapping $rm_display"
                $BodyMetaData.'resultMapping' = $null
                $include_properties += 'resultMapping'
            }
            If ($Calendar.Id.Length -gt 0) {
                [string]$Calendar_id = $Calendar.simpleId
                $Error.Clear()
                Try {
                    [ANOWCalendar]$Calendar_object = Get-AutomateNOWCalendar -Id $Calendar_id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWCalendar failed to confirm that the Calendar object [$Calendar_id] actually existed while running under Set-AutomateNOWWorkflowTemplate due to [$Message]"
                    Break
                }
                If ($Calendar_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWCalendar failed to locate the Calendar object [$Calendar_id] running under Set-AutomateNOWWorkflowTemplate. Please check again."
                    Break
                }
                Write-Verbose -Message "Adding Calendar object [$Calendar_id] to [ANOWWorkflowTemplate] [$WorkflowTemplate_id]"
                $BodyMetaData.'calendar' = $Calendar_id
                $include_properties += 'calendar'
            }
            ElseIf ($UnsetCalendar -eq $true) {
                [string]$Calendar_id = $Calendar.simpleId
                Write-Verbose -Message "Removing [ANOWCalendar] [$Calendar_id] from [ANOWWorkflowTemplate] [$WorkflowTemplate_id]"
                $BodyMetaData.'calendar' = $null
                $include_properties += 'calendar'
            }
            If ($DelayedStartTime.Length -gt 0) {
                $BodyMetaData.Add('delayedStartTime', $DelayedStartTime)
            }
            ElseIf ( $UnsetDelayedStartTime -eq $true) {
                $BodyMetaData.Add('delayedStartTime', $null)
            }
            If ($TimeZone.id.Length -gt 0) {
                [string]$timezone_id = ($TimeZone.id)
                $BodyMetaData.Add('timeZone', $timezone_id )
            }
            ElseIf ($UnsetTimeZone -eq $true) {
                $BodyMetaData.Add('timeZone', $null )
            }
            If ($Approval.Id.Length -gt 0) {
                [string]$Approval_id = $Approval.simpleId
                $Error.Clear()
                Try {
                    [ANOWApproval]$Approval_object = Get-AutomateNOWApproval -Id $Approval_id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWApproval failed to confirm that the Approval object [$Approval_id] actually existed while running under Set-AutomateNOWWorkflowTemplate due to [$Message]"
                    Break
                }
                If ($Approval_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWApproval failed to locate the Approval object [$Approval_id] running under Set-AutomateNOWWorkflowTemplate. Please check again."
                    Break
                }
                Write-Verbose -Message "Adding Approval object [$Approval_id] to [ANOWWorkflowTemplate] [$WorkflowTemplate_id]"
                $BodyMetaData.'approvalConfiguration' = $Approval_id
                $include_properties += 'approvalConfiguration'
            }
            ElseIf ($UnsetApproval -eq $true) {
                [string]$Approval_id = $Approval.simpleId
                Write-Verbose -Message "Removing [ANOWApproval] [$Approval_id] from [ANOWWorkflowTemplate] [$WorkflowTemplate_id]"
                $BodyMetaData.'approvalConfiguration' = $null
                $include_properties += 'approvalConfiguration'
            }
            If ($Priority -ge 0) {
                $BodyMetaData.'priority' = $Priority
            }
            If ($Weight -ge 0) {
                $BodyMetaData.'weight' = $Weight
            }
            If ($LazyLoad -eq $false) {
                $BodyMetaData.'lazyLoad' = 'false'
            }
            ElseIf ($LazyLoad -eq $true) {
                $BodyMetaData.'lazyLoad' = 'true'
            }
            If ($OnHold -eq $false) {
                $BodyMetaData.'onHold' = 'false'
            }
            ElseIf ($OnHold -eq $true) {
                $BodyMetaData.'onHold' = 'true'
            }
            If ($Skip -eq $false) {
                $BodyMetaData.'passBy' = 'false'
            }
            ElseIf ($Skip -eq $true) {
                $BodyMetaData.'passBy' = 'true'
            }
            If ($VerboseMode -eq $true) {
                $BodyMetaData.'verboseMode' = 'true'
            }
            ElseIf ($VerboseMode -eq $false) {
                $BodyMetaData.'verboseMode' = 'false'
            }
            If ($AutoArchive -eq $false) {
                $BodyMetaData.'autoArchive' = 'false'
            }
            ElseIf ($AutoArchive -eq $true) {
                $BodyMetaData.'autoArchive' = 'true'
            }
            If ($PassResources -eq $false) {
                $BodyMetaData.'passResourceDependenciesToChildren' = 'false'
            }
            ElseIf ($PassResources -eq $true) {
                $BodyMetaData.'passResourceDependenciesToChildren' = 'true'
            }
            If ($PassActions -eq $false) {
                $BodyMetaData.'passActionsToChildren' = 'false'
            }
            ElseIf ($PassActions -eq $true) {
                $BodyMetaData.'passActionsToChildren' = 'true'
            }
            If ($KeepResources -eq $false) {
                $BodyMetaData.'keepResourcesOnFailure' = 'false'
            }
            ElseIf ($KeepResources -eq $true) {
                $BodyMetaData.'keepResourcesOnFailure' = 'true'
            }
            If ($UseScripts -eq $false) {
                $BodyMetaData.'useScripts' = 'false'
            }
            ElseIf ($UseScripts -eq $true) {
                $BodyMetaData.'useScripts' = 'true'
            }
            If ($EagerScriptExecution -eq $false) {
                $BodyMetaData.'eagerScriptExecution' = 'false'
            }
            ElseIf ($EagerScriptExecution -eq $true) {
                $BodyMetaData.'eagerScriptExecution' = 'true'
            }
            If ($Owner.Length -gt 0) {
                $BodyMetaData.'owner' = $Owner
            }
            If ($statisticalDuration -ge 1000) {
                $BodyMetaData.'statisticalDuration' = $statisticalDuration
            }
            $BodyMetaData.'_operationType' = 'update'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_oldValues' = $WorkflowTemplate.CreateOldValues()
            If ($componentId.Length -gt 0) {
                $BodyMetaData.'_componentId' = $componentId
            }
            If ($operationId.Length -gt 0) {
                $BodyMetaData.'_operationId' = $operationId
            }
            $BodyMetaData.'_dataSource' = 'ProcessingTemplateDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties $include_properties
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$WorkflowTemplate_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Workflow Template $WorkflowTemplate_id was successfully updated"
            $Error.Clear()
            Try {
                [ANOWWorkflowTemplate]$UpdatedWorkflowTemplate = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the response into an [ANOWWorkflowTemplate] object (under Set-AutomateNOWWorkflowTemplate) due to [$Message]."
                Break
            }
            If ($Quiet -ne $true) {
                Return $UpdatedWorkflowTemplate
            }
        }
    }
    End {
    }
}

Function Export-AutomateNOWWorkflowTemplate {
    <#
    .SYNOPSIS
    Exports the Workflow Templates from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Workflow Templates from an instance of AutomateNOW! to a local .csv file

    .PARAMETER WorkflowTemplate
    Mandatory [ANOWWorkflowTemplate] object (Use Get-AutomateNOWWorkflowTemplate to retrieve them)

    .PARAMETER Type
    Mandatory string containing the type of Workflow Template. Valid choices are STANDARD, BROADCAST, FOR_EACH, TIME_SERIES, SWITCH, CYCLE

    .INPUTS
    ONLY [ANOWWorkflowTemplate] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWWorkflowTemplate] objects are exported to the local disk in CSV format

    .EXAMPLE
    Get-AutomateNOWWorkflowTemplate | Export-AutomateNOWWorkflowTemplate -Type STANDARD

    .EXAMPLE
    Get-AutomateNOWWorkflowTemplate -Type STANDARD | Export-AutomateNOWWorkflowTemplate -Type STANDARD

    .EXAMPLE
    Get-AutomateNOWWorkflowTemplate -Id 'Workflow01' | Export-AutomateNOWWorkflowTemplate -Type FOR_EACH

    .EXAMPLE
    @( 'Workflow01', 'Workflow02', 'Workflow03' ) | Get-AutomateNOWWorkflowTemplate | Export-AutomateNOWWorkflowTemplate -Type STANDARD

    .EXAMPLE
    Get-AutomateNOWWorkflowTemplate | Where-Object { $_.id -like '*MyWorkflow*' } | Export-AutomateNOWWorkflowTemplate -Type STANDARD

    .NOTES
	You must present [ANOWWorkflowTemplate] objects to the pipeline to use this function.

    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWWorkflowTemplate]$WorkflowTemplate,
        [Parameter(Mandatory = $False)]
        [ANOWProcessingTemplate_workflowType]$Type
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-WorkflowTemplates-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWWorkflowTemplate]$WorkflowTemplate = $_
        }
        $Error.Clear()
        Try {
            $WorkflowTemplate | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWWorkflowTemplate] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function New-AutomateNOWWorkflowTemplate {
    <#
    .SYNOPSIS
    Creates a Workflow Template within an AutomateNOW! instance

    .DESCRIPTION
    Creates a Workflow Template within an AutomateNOW! instance and returns back the newly created [ANOWWorkflowTemplate] object

    .PARAMETER WorkflowType
    Required type of the Workflow Template.

    .PARAMETER Id
    Mandatory "name" of the Workflow Template. For example: 'WorkflowTemplate1'. This value may not contain the domain in brackets. This is the unique key of this object.

    .PARAMETER Description
    Optional description of the Workflow Template (may not exceed 255 characters).

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to include with this object.

    .PARAMETER Folder
    Optional string representing the Folder to place this object into.

    .PARAMETER DesignTemplate
    Optional string representing the Design Template to place this object into.

    .PARAMETER Workspace
    Optional string representing the Workspace to place this object into.

    .PARAMETER CodeRepository
    Optional name of the code repository to place the Workflow into.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWWorkflowTemplate.

    .OUTPUTS
    An [ANOWWorkflowTemplate] object representing the newly created Workflow Template. Use the -Quiet parameter to suppress this.

    .EXAMPLE
    Creates a new "For Each" Workflow Template
    New-AutomateNOWWorkflowTemplate -WorkflowType FOR_EACH -Id 'WorkflowTemplate01' -Description 'Description text' -Tags 'Tag01', 'Tag02' -Folder 'Folder01' -Workspace 'Workspace01' -CodeRepository 'CodeRepository01'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The name (id) of the Workflow Template must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    #>
    [OutputType([ANOWWorkflowTemplate])]
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWProcessingTemplate_workflowType]$WorkflowType,
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $true)]
        [string]$Id,
        [ValidateScript({ $_.Length -le 255 })]
        [Parameter(Mandatory = $false, HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [string]$DesignTemplate,
        [Parameter(Mandatory = $false)]
        [string]$Workspace,
        [Parameter(Mandatory = $false)]
        [string]$CodeRepository,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [boolean]$WorkflowTemplate_exists = ($null -ne (Get-AutomateNOWWorkflowTemplate -Id $Id))
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWWorkflowTemplate failed to check if the Workflow Template [$Id] already existed due to [$Message]."
        Break
    }
    If ($WorkflowTemplate_exists -eq $true) {
        [string]$current_domain = $anow_session.header.domain
        Write-Warning -Message "There is already a Workflow Template named [$Id] in [$current_domain]. Please check into this."
        Break
    }
    ## End warning ##
    [System.Collections.Specialized.OrderedDictionary]$ANOWWorkflowTemplate = [System.Collections.Specialized.OrderedDictionary]@{}
    $ANOWWorkFlowTemplate.Add('id', $Id)
    $ANOWWorkflowTemplate.Add('processingType', 'WORKFLOW')
    $ANOWWorkFlowTemplate.Add('workflowType', $WorkflowType)
    [string[]]$include_properties = 'id', 'processingType', 'workflowType'
    If ($Description.Length -gt 0) {
        $ANOWWorkflowTemplate.Add('description', $Description)
        $include_properties += 'description'
    }
    If ($Tags.Count -gt 0) {
        [int32]$total_tags = $Tags.Count
        [int32]$current_tag = 1
        ForEach ($tag_id in $Tags) {
            $Error.Clear()
            Try {
                [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] under New-AutomateNOWWorkflowTemplate due to [$message]"
                Break
            }
            If ($tag_object.simpleId.length -eq 0) {
                Throw "New-AutomateNOWWorkflowTemplate has detected that the tag [$tag_id] does not appear to exist. Please check again."
                Break
            }
            ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                [string]$tag_object_simpleId = $tag_object.simpleId
                Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                Break
            }
            [string]$tag_display = $tag_object | ConvertTo-Json -Compress
            Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
            [string]$tag_name_sequence = ('tags' + $current_tag)
            $ANOWWorkflowTemplate.Add($tag_name_sequence, $tag_id)
            $include_properties += $tag_name_sequence
            $current_tag++
        }
    }
    If ($Folder.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] actually existed while running under New-AutomateNOWWorkflowTemplate due to [$Message]"
            Break
        }
        If ($folder_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] running under New-AutomateNOWWorkflowTemplate. Please check again."
            Break
        }
        [string]$folder_display = $folder_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding folder $folder_display to [ANOWWorkflowTemplate] [$Id]"
        $ANOWWorkflowTemplate.Add('folder', $Folder)
        $include_properties += 'folder'
    }
    If ($DesignTemplate.Length -gt 0) {
        $ANOWWorkflowTemplate.Add('designTemplate', $DesignTemplate)
        $include_properties += 'designTemplate'
    }
    If ($Workspace.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWWorkspace]$workspace_object = Get-AutomateNOWWorkspace -Id $Workspace
        }
        Catch {
            [string]$Message = $_.Exception.Message
            [string]$Workspace_id = $Workspace.Id
            Write-Warning -Message "Get-AutomateNOWWorkspace failed to confirm that the workspace [$Workspace_id] actually existed while running under New-AutomateNOWWorkflowTemplate due to [$Message]"
            Break
        }
        If ($workspace_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWWorkspace failed to locate the Workspace [$Workspace] running under New-AutomateNOWWorkflowTemplate. Please check again."
            Break
        }
        [string]$workspace_display = $workspace_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding workspace $workspace_display to [ANOWWorkflowTemplate] [$Id]"
        $ANOWWorkflowTemplate.Add('workspace', $Workspace)
        $include_properties += 'workspace'
    }
    If ($CodeRepository.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository] actually existed while running under New-AutomateNOWWorkflowTemplate due to [$Message]"
            Break
        }
        If ($code_repository_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository] running under New-AutomateNOWWorkflowTemplate. Please check again."
            Break
        }
        [string]$code_repository_display = $code_repository_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding code repository $code_repository_display to [ANOWWorkflowTemplate] [$Id]"
        $ANOWWorkflowTemplate.Add('codeRepository', $CodeRepository)
        $include_properties += 'codeRepository'
    }
    [string]$BodyObject = ConvertTo-QueryString -InputObject $ANOWWorkflowTemplate -IncludeProperties $include_properties
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_operationType' = 'add'
    $BodyMetaData.'_oldValues' = '{"processingType":"WORKFLOW","workflowType":"' + $WorkflowType + '","workspace":null}'
    $BodyMetaData.'_componentId' = 'ProcessingTemplateCreateWindow_form'
    $BodyMetaData.'_dataSource' = 'ProcessingTemplateDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$BodyMetaDataString = ConvertTo-QueryString -InputObject $BodyMetaData
    [string]$Body = ($BodyObject + '&' + $BodyMetaDataString)
    [string]$command = '/processingTemplate/create'
    [hashtable]$parameters = @{}
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('Body', $Body)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWWorkflowTemplate]$WorkflowTemplate = $results.response.data | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to create [ANOWWorkflowTemplate] object due to [$Message]."
        Break
    }
    If ($WorkflowTemplate.id.Length -eq 0) {
        Write-Warning -Message "Somehow the newly created [ANOWWorkflowTemplate] is empty!"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWWorkflowTemplate]$WorkflowTemplate = Get-AutomateNOWWorkflowTemplate -Id $Id
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWWorkflowTemplate failed to confirm that the [ANOWWorkflowTemplate] object [$Id] was created due to [$Message]."
        Break
    }
    If ($Quiet -ne $true) {
        Return $WorkflowTemplate
    }
}

Function Remove-AutomateNOWWorkflowTemplate {
    <#
    .SYNOPSIS
    Removes a Workflow Template from an AutomateNOW! instance

    .DESCRIPTION
    Removes a Workflow Template from an AutomateNOW! instance

    .PARAMETER WorkflowTemplate
    An [ANOWWorkflowTemplate] object representing the Workflow Template to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWWorkflowTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Get-AutomateNOWWorkflowTemplate -Id 'Workflow01' | Remove-AutomateNOWWorkflowTemplate

    .EXAMPLE
    Get-AutomateNOWWorkTemplate -Id 'Workflow01', 'Workflow02' | Remove-AutomateNOWWorkflowTemplate

    .EXAMPLE
    @( 'Workflow1', 'Workflow2', 'Workflow3') | Remove-AutomateNOWWorkflowTemplate

    .EXAMPLE
    Get-AutomateNOWWorkflowTemplate | ? { $_.workflowType -eq 'BROADCAST' } | Remove-AutomateNOWWorkflowTemplate

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWWorkflowTemplate]$WorkflowTemplate,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processingTemplate/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWWorkflowTemplate]$WorkflowTemplate = $_
        }
        [string]$WorkflowTemplate_id = $WorkflowTemplate.id
        If ($WorkflowTemplate_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($WorkflowTemplate_id)")) -eq $true) {
            [string]$oldvalues = $WorkflowTemplate.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $WorkflowTemplate_id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'ProcessingTemplateList'
            $BodyMetaData.'_dataSource' = 'ProcessingTemplateDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$WorkflowTemplate_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$error_message = $results.response.data
                If ($error_message -match 'Object may still be in use') {
                    [string]$WorkflowTemplate_id_formatted = $WorkflowTemplate_id -split '\]' | Select-Object -Last 1
                    Write-Warning -Message "This object $WorkflowTemplate_id_formatted is still in use somewhere therefore it cannot be removed! Please use 'Find-AutomateNOWObjectReferral -Object $WorkflowTemplate_id_formatted' to list the references for this object and then remove them."
                }
                Else {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
            }
            Write-Verbose -Message "Workflow $WorkflowTemplate_id successfully removed"
        }
    }
    End {

    }
}

Function Copy-AutomateNOWWorkflowTemplate {
    <#
    .SYNOPSIS
    Copies a Workflow Template from an AutomateNOW! instance

    .DESCRIPTION
    Copies a Workflow Template from an AutomateNOW! instance. AutomateNOW object id can never be changed, but we can copy the object to a new id and it will include all of the items therein.

    .PARAMETER WorkflowTemplate
    Mandatory [ANOWWorkflowTemplate] object to be copied.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the Workflow Template. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER Description
    Optional description of the Workflow Template (may not exceed 255 characters). You may send an empty string here to ensure that the description is blanked out. Do not use this parameter if your intention is to keep the description from the previous Workflow Template.

    .PARAMETER UnsetDescription
    Optional switch that will ensure that the newly created Workflow Template will not carry over its previous description.

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new Workflow Template. The UnsetTags DOES NOT influence this parameter.

    .PARAMETER UnsetTags
    Optional switch that will purposely omit the previously existing tags on the new copy of the Workflow Template. You can still specify new tags with -Tags but the old previous ones will not be carried over. In the UI, this is accomplished by clicking the existing tags off.

    .PARAMETER Folder
    Optional name of the folder to place the Workflow Template into. The UnsetFolder parameter overrides this setting.

    .PARAMETER UnsetFolder
    Optional switch that will ensure that the newly created Workflow Template will not be placed in a folder.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .PARAMETER Force
    Force the copy without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWWorkflowTemplate] objects are accepted. Pipeline support is intentionally unavailable.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    This is a safe standard example that is recommended

    $workflow01 = Get-AutomateNOWWorkflowTemplate -Id 'old_name_Workflow01'
    Copy-AutomateNOWWorkflowTemplate -WorkflowTemplate $workflow01 -NewId 'new_name_Workflow02'

    .EXAMPLE
    This is a one-liner approach

    Copy-AutomateNOWWorkflowTemplate -WorkflowTemplate (Get-AutomateNOWWorkflowTemplate -Id 'old_name_Workflow01') -NewId 'new_name_Workflow02'

    .EXAMPLE
    This approach users a For Each loop to iterate through a standard renaming pattern. This approach is not recommended.

    @( 'Workflow1', 'Workflow2', 'Workflow3') | Get-AutomateNOWWorkflowTemplate | ForEachObject { Copy-AutomateNOWWorkflowTemplate -WorkflowTemplate $_ -NewId ($_.simpleId -replace 'Workflow[0-9]', ()'Workflow-' + $_.simpleId[-1]))}

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The new id (name) of the Workflow Template must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.
    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWWorkflowTemplate]$WorkflowTemplate,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$Workflow_template_exists = ($null -ne (Get-AutomateNOWWorkflowTemplate -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWWorkflowTemplate failed to check if the Workflow Template [$NewId] already existed due to [$Message]."
            Break
        }
        If ($Workflow_template_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Workflow Template named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End warning ##
        [string]$command = '/processingTemplate/copy'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            [string]$WorkflowTemplate_oldId = $WorkflowTemplate.id
            [string]$WorkflowTemplate_simpleId = $WorkflowTemplate.simpleId
            If ($WorkflowTemplate_oldId -eq $NewId) {
                Write-Warning -Message "The new id cannot be the same as the old id."
                Break
            }
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Copy the Workflow Template $($WorkflowTemplate_simpleId) to $($NewId)?")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                $BodyMetaData.'oldId' = $WorkflowTemplate_oldId
                $BodyMetaData.'domain' = $WorkflowTemplate.domain
                $BodyMetaData.'id' = $NewId
                If ($UnsetDescription -ne $true) {
                    If ($Description.Length -gt 0) {
                        $BodyMetaData.'description' = $Description
                    }
                    Else {
                        $BodyMetaData.'description' = $WorkflowTemplate.description
                    }
                }
                If ($UnsetFolder -ne $True) {
                    If ($Folder.Length -gt 0) {
                        $BodyMetaData.'folder' = $Folder
                    }
                    Else {
                        $BodyMetaData.'folder' = $WorkflowTemplate.folder
                    }
                }
                [int32]$tag_count = 1
                If ($Tags.Count -gt 0) {
                    ForEach ($tag in $Tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
                If ($UnsetTags -ne $true) {
                    If ($WorkflowTemplate.tags -gt 0) {
                        ForEach ($tag in $WorkflowTemplate.tags) {
                            $BodyMetaData.('tags' + $tag_count ) = $tag
                            $tag_count++
                        }
                    }
                }
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_operationId' = 'copy'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_dataSource' = 'ProcessingTemplateDataSource'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData #-IncludeProperties oldId, domain, NewId, description, folder
                $Body = $Body -replace '&tags[0-9]{1,}', '&tags'
                $parameters.Body = $Body
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$WorkflowTemplate_id] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                $Error.Clear()
                Try {
                    [ANOWWorkflowTemplate]$WorkflowTemplate = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to create copied [ANOWWorkflowTemplate] object due to [$Message]."
                    Break
                }
                If ($WorkflowTemplate.id.Length -eq 0) {
                    Write-Warning -Message "Somehow the newly created (copied) [ANOWWorkflowTemplate] object is empty!"
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $WorkflowTemplate
                }
            }
        }
    }
    End {

    }
}

Function Rename-AutomateNOWWorkflowTemplate {
    <#
    .SYNOPSIS
    Renames a Workflow Template from an AutomateNOW! instance

    .DESCRIPTION
    Performs a psuedo-rename operations of a Workflow Template from an AutomateNOW! instance by copying it first and then deleting the source. This function merely combines Copy-AutomateNOWWorkflowTemplate and Remove-AutomateNOWWorkflowTemplate therefore it is to be considered destructive.

    .PARAMETER WorkflowTemplate
    An [ANOWWorkflowTemplate] object representing the Workflow Template to be renamed.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the Workflow Template. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER Force
    Force the renaming without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly renamed object.

    .INPUTS
    ONLY [ANOWWorkflowTemplate] objects are accepted. There is intentionally no support for the pipeline.

    .OUTPUTS
    The newly renamed [ANOWWorkflowTemplate] object will be returned.

    .EXAMPLE
    $workflow_template = Get-AutomateNOWWorkflowTemplate -Id 'Workflow01'
    Rename-AutomateNOWWorkflowTemplate -WorkflowTemplate $workflow_template -NewId 'WORKFLOW_TEMPLATE_01'

    .EXAMPLE
    Rename-AutomateNOWWorkflowTemplate -WorkflowTemplate (Get-AutomateNOWWorkflowTemplate -Id 'Workflow01') -NewId 'WORKFLOW_TEMPLATE_01'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    When renaming, you may only specify a different Id (name).

    This action will be blocked if any existing referrals are found on the object.
    #>
    [OutputType([ANOWWorkflowTemplate])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWWorkflowTemplate]$WorkflowTemplate,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin standard warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$new_Workflow_template_exists = ($null -ne (Get-AutomateNOWWorkflowTemplate -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWWorkflowTemplate failed to check if the Workflow Template [$NewId] already existed due to [$Message]."
            Break
        }
        If ($new_Workflow_template_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Workflow Template named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        [string]$WorkflowTemplate_id = $WorkflowTemplate.id
        $Error.Clear()
        Try {
            [boolean]$old_Workflow_template_exists = ($null -ne (Get-AutomateNOWWorkflowTemplate -Id $WorkflowTemplate_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWWorkflowTemplate failed to check if the Workflow Template [$WorkflowTemplate_id] already existed due to [$Message]."
            Break
        }
        If ($old_Workflow_template_exists -eq $false) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not a Workflow Template named [$WorkflowTemplate_id] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End standard warning ##
        ## Begin referrals warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [int32]$referrals_count = Find-AutomateNOWObjectReferral -WorkflowTemplate $WorkflowTemplate -Count | Select-Object -Expandproperty referrals
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Find-AutomateNOWObjectReferral failed to extract the referrals on Workflow Template [$WorkflowTemplate_id] due to [$Message]."
            Break
        }
        If ($referrals_count -gt 0) {
            Write-Warning -Message "Unfortunately, you cannot rename a Workflow Template that has referrals. This is because the rename is not actually renaming but copying anew and deleting the old. Please, use the Find-AutomateNOWObjectReferral function to identify referrals and remove them."
            Break
        }
        Else {
            Write-Verbose -Message "The Workflow Template [$WorkflowTemplate_id] does not have any referrals. It is safe to proceed."
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($WorkflowTemplate_id)")) -eq $true) {
                $Error.Clear()
                Try {
                    [ANOWWorkflowTemplate]$new_workflow_template = Copy-AutomateNOWWorkflowTemplate -WorkflowTemplate $WorkflowTemplate -NewId $NewId -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Copy-AutomateNOWWorkflowTemplate failed to create a new Workflow Template [$NewId] as Part 1 of the renaming process due to [$Message]."
                    Break
                }
                If ($new_workflow_template.simpleId -eq $NewId) {
                    Write-Verbose -Message "Part 1: Workflow template [$WorkflowTemplate_id] successfully copied to [$NewId]"
                }
                Else {
                    Write-Warning -Message "Somehow the first phase (Copy-AutomateNOWWorkflowTemplate) failed. Please look into this."
                    Break
                }
                $Error.Clear()
                Try {
                    Remove-AutomateNOWWorkflowTemplate -WorkflowTemplate $WorkflowTemplate -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Remove-AutomateNOWWorkflowTemplate failed to remove [$WorkflowTemplate_id] as Part 2 of the renaming process due to [$Message]."
                    Break
                }
                Write-Verbose -Message "Part 2: Workflow template [$WorkflowTemplate_id] removed"
                Write-Verbose -Message "Workflow [$WorkflowTemplate_id] successfully renamed to [$NewId]"
                If ($Quiet -ne $true) {
                    Return $new_workflow_template
                }
            }
        }
        Else {
            Write-Warning -Message "No action was taken because either the source object didn't exist or the new object already existed"
        }
    }
    End {
    }
}

Function Start-AutomateNOWWorkflowTemplate {
    <#
    .SYNOPSIS
    Starts a Workflow Template from an AutomateNOW! instance

    .DESCRIPTION
    Starts a Workflow Template from an AutomateNOW! instance

    .PARAMETER WorkflowTemplate
    An [ANOWWorkflowTemplate] object representing the Workflow Template to be started.

    .PARAMETER WorkflowTemplateId
    A string representing the Id of the Workflow Template. Do not include the domain prefix.

    .Parameter WorkflowParameters
    An optional [hashtable] containing the parameters to start the Workflow Template with. Example: @{"parameter1"="ABC";"parameter2"="123";}

    .PARAMETER UseAutomaticName
    A switch parameter that is ENABLED BY DEFAULT. You do not need to enable this as it is defaulted to on. This parameter simulates the default format of the executed Workflow name (see 'Name' below)

    .PARAMETER Name
    A string representing the name of the running executed Workflow. Only use this if you want to OVERRIDE the default naming standard that the console suggests when executing a Workflow. The console defaults to a format of "Manual Execution - [Workflow name] - [date utc]".

    .PARAMETER Description
    Optional description of the executed Workflow (may not exceed 255 characters).

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new Workflow.

    .PARAMETER Folder
    Optional name of the folder to place the executed Workflow into.

    .PARAMETER ProcessingTimestamp
    This parameter is -disabled- for now. Instead, the default timestamp will be used to ensure uniqueness. The documentation is unclear or mistaken around this parameter.

    .PARAMETER DelayedStartTime
    Optional string that allows processing items to start on a specific date or time or delay the execution for a period ranging from days to seconds. Example 1: 2029-12-31, Example 2: 2029-12-31 23:59:59, Example 3: 23:59:59

    .PARAMETER TimeZone
    Optional [ANOWTimeZone] object that modifies (it is unknown exactly what this property modifies since it is not defined in the documentation yet)

    .PARAMETER Priority
    Optional integer between 0 and 1000 to specify the priority of the executed Workflow. Defaults to 0.

    .PARAMETER Hold
    Optional switch to set the 'On Hold' property of the executed Workflow to enabled. This is $false by default but in the console the checkbox is enabled.

    .PARAMETER VerboseMode
    Optional switch that will cause the Workflow to "produce more events with minor performance impact"

    .PARAMETER ForceLoad
    Optional switch that overrides any 'Ignore Condition' that might exist on the Workflow Template

    .PARAMETER Quiet
    Switch parameter to silence the newly created [ANOWWorkflow] object

    .INPUTS
    ONLY [ANOWWorkflowTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    An [ANOWWorkflow] object representing the started Workflow will be returned.

    .EXAMPLE
    Starts a Workflow Template with an automatically generated name and otherwise default values.

    Get-AutomateNOWWorkflowTemplate -Id 'WorkflowTemplate_01' | Start-AutomateNOWWorkflowTemplate -UseAutomaticName

    .EXAMPLE
    Starts a Workflow Template with a manually entered name, on hold, at priority 42, placed into a Folder and with two tags.

    Get-AutomateNOWWorkflowTemplate -Id 'WorkflowTemplate_01' | Start-AutomateNOWWorkflowTemplate -Name 'WorkflowTemplate_01 2024/01/30' -Description 'My executed Workflow' -Folder 'Folder1' -Tags 'Tag1', 'Tag2' -Hold -Priority 42

    .EXAMPLE
    Starts a Workflow Template without using the pipeline

    $workflow_template = Get-AutomateNOWWorkflowTemplate -Id 'WorkflowTemplate_01'
    Start-AutomateNOWWorkflowTemplate -WorkflowTemplate $workflow_template -UseAutomaticName

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Avoid using the -Name parameter unless you really need to use it. If -Name is not supplied, the parameter set will use -UseAutomaticName instead, which simulates the behavior of the console.

    Although the API will accept a simple datestamp for the delayedStartTime (e.g. 2029-12-31), this function will not. You must specify a timestamp with the date. See the examples.

    #>
    [Cmdletbinding(DefaultParameterSetName = 'UseAutomaticName')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'Object', ValueFromPipeline = $True)]
        [ANOWWorkflowTemplate]$WorkflowTemplate,
        [Parameter(Mandatory = $true, ParameterSetName = 'Id')]
        [string]$WorkflowTemplateId,
        [Parameter(Mandatory = $false)]
        [hashtable]$WorkflowParameters,
        [Parameter(Mandatory = $false, ParameterSetName = 'UseAutomaticName')]
        [boolean]$UseAutomaticName = $true,
        [Parameter(Mandatory = $true, ParameterSetName = 'SpecifyNameManually')]
        [string]$Name,
        [Parameter(Mandatory = $false, HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [string]$Folder = '',
        [ValidateScript({ $_ -match '([0-9]{4}-[0-9]{2}-[0-9]{2}){0,}( {0,}[0-9]{2}:[0-9]{2}:[0-9]{2}){0,}' })]
        [Parameter(Mandatory = $false)]
        [string]$DelayedStartTime,
        [Parameter(Mandatory = $false)]
        [ANOWTimeZone]$TimeZone,
        [ValidateRange(0, 1000)]
        [Parameter(Mandatory = $false)]
        [int32]$Priority = 0,
        [Parameter(Mandatory = $false)]
        [switch]$Hold,
        [Parameter(Mandatory = $false)]
        [switch]$VerboseMode,
        [Parameter(Mandatory = $false)]
        [switch]$ForceLoad,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processing/executeNow'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [string]$domain = $anow_session.current_domain
        If ($_.id.Length -gt 0) {
            [string]$WorkflowTemplate_id = $_.id
        }
        ElseIf ($WorkflowTemplateId.Length -gt 0) {
            [string]$WorkflowTemplate_Id = ('[' + $domain + ']' + $WorkflowTemplateId )
        }
        ElseIf ($Id.Length -gt 0) {
            [string]$WorkflowTemplate_Id = ('[' + $domain + ']' + $Id )
        }
        Else {
            [string]$WorkflowTemplate_id = $WorkflowTemplate.id
        }
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        $BodyMetaData.Add('id', $WorkflowTemplate_id )
        $BodyMetaData.Add('runId', $WorkflowTemplate_id )
        If ($priority -gt 0) {
            $BodyMetaData.Add('priority', $priority )
        }
        If ($null -ne $TimeZone) {
            [string]$timezone_id = ($TimeZone.id)
            $BodyMetaData.Add('timeZone', $timezone_id )
        }
        $BodyMetaData.Add('processingTimestamp', [string](Get-Date -Date ((Get-Date).ToUniversalTime()) -Format 'yyyy-MM-ddTHH:mm:ss.fff'))
        [string[]]$include_properties = 'id', 'runId', 'priority', 'processingTimestamp', 'hold', 'forceLoad', 'name'
        If ($Tags.Count -gt 0) {
            [int32]$total_tags = $Tags.Count
            [int32]$current_tag = 1
            ForEach ($tag_id in $Tags) {
                $Error.Clear()
                Try {
                    [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] under Start-AutomateNOWWorkflowTemplate due to [$message]"
                    Break
                }
                If ($tag_object.simpleId.length -eq 0) {
                    Throw "Start-AutomateNOWWorkflowTemplate has detected that the tag [$tag_id] does not appear to exist. Please check again."
                    Break
                }
                ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                    [string]$tag_object_simpleId = $tag_object.simpleId
                    Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                    Break
                }
                [string]$tag_display = $tag_object | ConvertTo-Json -Compress
                Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
                [string]$tag_name_sequence = ('tags' + $current_tag)
                $ANOWWorkflowTemplate.Add($tag_name_sequence, $tag_id)
                $include_properties += $tag_name_sequence
                $current_tag++
            }
        }
        If ($folder.Length -gt 0) {
            $Error.Clear()
            Try {
                [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWFolder had an error while retrieving the folder [$folder] running under Start-AutomateNOWWorkflowTemplate due to [$message]"
                Break
            }
            If ($folder_object.simpleId.Length -eq 0) {
                Throw "Start-AutomateNOWWorkflowTemplate has detected that the folder [$folder] does not appear to exist. Please check again."
                Break
            }
            $BodyMetaData.Add('folder', $folder)
            $include_properties += $folder
        }
        If ($hold -ne $true) {
            $BodyMetaData.Add('hold', 'false')
        }
        Else {
            $BodyMetaData.Add('hold', 'true')
        }
        If ($forceLoad -ne $true) {
            $BodyMetaData.Add('forceLoad', 'false')
        }
        Else {
            $BodyMetaData.Add('forceLoad', 'true')
        }
        If ($VerboseMode -ne $true) {
            $BodyMetaData.Add('verboseMode', 'true')
        }
        Else {
            $BodyMetaData.Add('verboseMode', 'true')
        }
        If ($DelayedStartTime.Length -gt 0) {
            $BodyMetaData.Add('delayedStartTime', $DelayedStartTime)
        }
        If ($WorkflowParameters.Count -gt 0) {
            $Error.Clear()
            Try {
                [string]$task_parameters_json = $WorkflowParameters | ConvertTo-Json -Compress
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "ConvertTo-Json failed to execute the provided parameters to Start-AutomateNOWWorkflowTemplate due to [$Message]."
                Break
            }
            $BodyMetaData.Add('parameters', $task_parameters_json)
        }
        Else {
            $BodyMetaData.Add('parameters', '{}')
        }
        If ($Name.Length -gt 0) {
            $BodyMetaData.Add('name', $Name)
        }
        ElseIf ($UseAutomaticName -eq $true) {
            [string]$Name = New-AutomateNOWDefaultProcessingTitle -simpleId $WorkflowTemplate_simpleId
            $BodyMetaData.Add('name', $Name)
            Write-Verbose -Message "Generated automatic name [$Name] for this Workflow"
        }
        Else {
            Write-Warning -Message "Unable to determine how to name this Workflow that needs to be started"
            Break
        }
        $BodyMetaData.Add('_operationType', 'add')
        $BodyMetaData.Add('_operationId', 'executeNow')
        $BodyMetaData.Add('_textMatchStyle', 'exact')
        $BodyMetaData.Add('_dataSource', 'ProcessingDataSource')
        $BodyMetaData.Add('isc_metaDataPrefix', '_')
        $BodyMetaData.Add('isc_dataFormat', 'json')
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        If ($null -eq $parameters.Body) {
            $parameters.Add('Body', $Body)
        }
        Else {
            $parameters.Body = $Body
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$WorkflowTemplate_id] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        Write-Verbose -Message "Workflow $WorkflowTemplate_id successfully started as [$Name]"
        $Error.Clear()
        Try {
            [ANOWWorkflow]$Workflow = $results.response.data | Select-Object -First 1
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Unable to create the [ANOWWorkflow] object under Start-AutomateNOWWorkflowTemplate from the response due to [$Message]."
            Break
        }
        If ($Quiet -ne $true) {
            Return $Workflow
        }
    }
    End {

    }
}

Function Resume-AutomateNOWWorkflowTemplate {
    <#
    .SYNOPSIS
    Resumes a Workflow Template that is on hold (suspended) on an AutomateNOW! instance

    .DESCRIPTION
    Resumes a Workflow Template that is on hold (suspended) on an AutomateNOW! instance

    .PARAMETER WorkflowTemplate
    An [ANOWWorkflowTemplate] object representing the Workflow Template to be resumed

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Switch parameter to silence the emitted [ANOWWorkflowTemplate] object

    .INPUTS
    ONLY [ANOWWorkflowTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    The resumed [ANOWWorkflowTemplate] object will be returned

    .EXAMPLE
    Get-AutomateNOWWorkflowTemplate -Id 'WorkflowTemplate01' | Resume-AutomateNOWWorkflowTemplate -Force

    .EXAMPLE
    Get-AutomateNOWWorkflowTemplate -Id 'WorkflowTemplate01', 'WorkflowTemplate02' | Resume-AutomateNOWWorkflowTemplate

    .EXAMPLE
    @( 'WorkflowTemplate1', 'WorkflowTemplate2', 'WorkflowTemplate3') | Resume-AutomateNOWWorkflowTemplate

    .EXAMPLE
    Get-AutomateNOWWorkflowTemplate | ? { $_.workflowType -eq 'FOR_EACH' } | Resume-AutomateNOWWorkflowTemplate

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.
    #>

    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWWorkflowTemplate]$WorkflowTemplate,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processingTemplate/resume'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWWorkflowTemplate]$WorkflowTemplate = $_
        }
        [string]$WorkflowTemplate_id = $WorkflowTemplate.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($WorkflowTemplate_id)")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $WorkflowTemplate_id )
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_operationId', 'resume')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingTemplateDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$WorkflowTemplate_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            $Error.Clear()
            Try {
                [ANOWWorkflowTemplate]$resumed_Workflow_template = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to create the [ANOWWorkflowTemplate] object after resuming [$WorkflowTemplate_id] due to [$Message]."
                Break
            }
            Write-Verbose -Message "Workflow $WorkflowTemplate_id successfully resumed"
            If ($Quiet -ne $true) {
                Return $resumed_Workflow_template
            }
        }
    }
    End {

    }
}

Function Suspend-AutomateNOWWorkflowTemplate {
    <#
    .SYNOPSIS
    Places a Workflow Template on hold (suspend) from execution on an AutomateNOW! instance

    .DESCRIPTION
    Places a Workflow Template on hold (suspend) from execution on an AutomateNOW! instance

    .PARAMETER WorkflowTemplate
    An [ANOWWorkflowTemplate] object representing the Workflow Template to be suspended (placed on hold)

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Switch parameter to silence the emitted [ANOWWorkflowTemplate] object

    .INPUTS
    ONLY [ANOWWorkflowTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    The suspended [ANOWWorkflowTemplate] object will be returned

    .EXAMPLE
    Get-AutomateNOWWorkflowTemplate -Id 'Workflow01' | Suspend-AutomateNOWWorkflowTemplate -Force

    .EXAMPLE
    Get-AutomateNOWWorkflowTemplate -Id 'Workflow01', 'Workflow02' | Suspend-AutomateNOWWorkflowTemplate

    .EXAMPLE
    @( 'Workflow1', 'Workflow2', 'Workflow3') | Suspend-AutomateNOWWorkflowTemplate

    .EXAMPLE
    Get-AutomateNOWWorkflowTemplate | ? { $_.serverWorkflowType -eq 'LINUX' } | Suspend-AutomateNOWWorkflowTemplate

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWWorkflowTemplate]$WorkflowTemplate,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processingTemplate/hold'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWWorkflowTemplate]$WorkflowTemplate = $_
        }
        [string]$WorkflowTemplate_id = $WorkflowTemplate.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($WorkflowTemplate_id)")) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $WorkflowTemplate_id )
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_operationId', 'hold')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingTemplateDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$WorkflowTemplate_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            $Error.Clear()
            Try {
                [ANOWWorkflowTemplate]$suspended_Workflow_template = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to create the [ANOWWorkflowTemplate] object after suspending [$WorkflowTemplate_id] due to [$Message]."
                Break
            }
            Write-Verbose -Message "Workflow $WorkflowTemplate_id successfully suspended (placed on hold)"
            If ($Quiet -ne $true) {
                Return $suspended_Workflow_template
            }
        }
    }
    End {

    }
}

Function Skip-AutomateNOWWorkflowTemplate {
    <#
    .SYNOPSIS
    Sets or unsets the Skip flag on a Workflow Template on an AutomateNOW! instance

    .DESCRIPTION
    Sets or unsets the Skip flag on a Workflow Template on an AutomateNOW! instance

    .PARAMETER WorkflowTemplate
    An [ANOWWorkflowTemplate] object representing the Workflow Template to be set to skipped or unskipped

    .PARAMETER UnSkip
    Removes the skip flag from an [ANOWWorkflowTemplate] object. This is the opposite of the default behavior.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Switch parameter to silence the emitted [ANOWWorkflowTemplate] object

    .INPUTS
    ONLY [ANOWWorkflowTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    The skipped/unskipped [ANOWWorkflowTemplate] object will be returned

    .EXAMPLE
    Sets a Workflow Template to Skip (bypass)

    Get-AutomateNOWWorkflowTemplate -Id 'WorkflowTemplate01' | Skip-AutomateNOWWorkflowTemplate -Force

    .EXAMPLE
    Unsets the Skip (bypass) flag on a Workflow Template

    Get-AutomateNOWWorkflowTemplate | Skip-AutomateNOWWorkflowTemplate -UnSkip

    .EXAMPLE
    Sets an array of Workflow Template to Skip (bypass)

    @( 'WorkflowTemplate1', 'WorkflowTemplate2', 'WorkflowTemplate3') | Skip-AutomateNOWWorkflowTemplate

    .EXAMPLE
    Get-AutomateNOWWorkflowTemplate | ? { $_.workflowType -eq 'FOR_EACH' } | Skip-AutomateNOWWorkflowTemplate -UnSkip -Force -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWWorkflowTemplate]$WorkflowTemplate,
        [Parameter(Mandatory = $false)]
        [switch]$UnSkip,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnSkip -ne $True) {
            [string]$skip_flag_status = 'On'
            [string]$operation_id = 'passByOn'
            [string]$ProcessDescription = 'Add the Skip flag'
        }
        Else {
            [string]$skip_flag_status = 'Off'
            [string]$operation_id = 'passByOff'
            [string]$ProcessDescription = 'Remove the Skip flag'
        }
        [string]$command = ('/processingTemplate/' + $operation_id)
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWWorkflowTemplate]$WorkflowTemplate = $_
        }
        [string]$WorkflowTemplate_id = $WorkflowTemplate.id
        If ($WorkflowTemplate.passBy -eq $true -and $UnSkip -ne $True) {
            Write-Warning -Message "Workflow Template $WorkflowTemplate_id already has the skip flag set. No action is required."
            Break
        }
        ElseIf ($WorkflowTemplate.passBy -eq $false -and $UnSkip -eq $True) {
            Write-Warning -Message "Workflow Template $WorkflowTemplate_id does not have the skip flag set. No action is required."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess($WorkflowTemplate_id, $ProcessDescription)) -eq $true) {
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $WorkflowTemplate_id )
            $BodyMetaData.Add('_operationType', 'update')
            $BodyMetaData.Add('_operationId', $operation_id)
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingTemplateDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            $parameters.Add('Body', $Body)
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$WorkflowTemplate_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            $Error.Clear()
            Try {
                [ANOWWorkflowTemplate]$skipped_workflow_template = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to create the [ANOWWorkflowTemplate] object after setting the skip flag to [$skip_flag_status] on [$WorkflowTemplate_id] due to [$Message]."
                Break
            }
            Write-Verbose -Message "Successfully set the skip flag to [$skip_flag_status] on [$WorkflowTemplate_id]"
            If ($Quiet -ne $true) {
                Return $skipped_workflow_template
            }
        }
    }
    End {

    }
}

Function Confirm-AutomateNOWWorkflowTemplate {
    <#
    .SYNOPSIS
    Validates (confirms) a Workflow Template on an AutomateNOW! instance

    .DESCRIPTION
    Validates (confirms) a Workflow Template on an AutomateNOW! instance

    .PARAMETER WorkflowTemplate
    An [ANOWWorkflowTemplate] object representing the Workflow Template to be set to confirmed (verified)

    .PARAMETER Quiet
    Returns a boolean $true or $false based on the result of the validation check

    .INPUTS
    ONLY [ANOWWorkflowTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    A string with the results from the API will returned.

    .EXAMPLE
    Validates a single Workflow Template

    Get-AutomateNOWWorkflowTemplate -Id 'WorkflowTemplate01' | Confirm-AutomateNOWWorkflowTemplate

    .EXAMPLE
    Validates a series of Workflow Templates

    @( 'WorkflowTemplate1', 'WorkflowTemplate2', 'WorkflowTemplate3') | Confirm-AutomateNOWWorkflowTemplate

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding()]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWWorkflowTemplate]$WorkflowTemplate,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [string]$WorkflowTemplate_id = $_.id
        }
        ElseIf ($WorkflowTemplate.id.Length -gt 0) {
            [string]$WorkflowTemplate_id = $WorkflowTemplate.id
        }
        Else {
            [string]$WorkflowTemplate_id = $Id
        }
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        $BodyMetaData.Add('id', $WorkflowTemplate_id )
        $BodyMetaData.Add('_operationType', 'custom')
        $BodyMetaData.Add('_operationId', 'validate')
        $BodyMetaData.Add('_textMatchStyle', 'exact')
        $BodyMetaData.Add('_dataSource', 'ProcessingTemplateDataSource')
        $BodyMetaData.Add('isc_metaDataPrefix', '_')
        $BodyMetaData.Add('isc_dataFormat', 'json')
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        [string]$command = ('/processingTemplate/validate?' + $Body)
        $parameters.Add('Command', $command)
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$WorkflowTemplate_id] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            If ($Quiet -eq $true) {
                Return $false
            }
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "The response code was [$response_code] instead of 0. The Workflow Template $WorkflowTemplate_id is not validated. Please see the full response $full_response_display"
        }
        Else {
            If ($Quiet -eq $true) {
                Return $true
            }
            Else {
                Write-Information -MessageData "The Workflow Template $WorkflowTemplate_id is confirmed as valid."
            }
        }
    }
    End {

    }
}

#endregion

#Region - Workflow Template Items (PROCESSING_TEMPLATE_ITEM)

Function Read-AutomateNOWWorkflowTemplateItem {
    <#
    .SYNOPSIS
    Reads the processing items and their -sort order- within a Workflow Template from an AutomateNOW! instance

    .DESCRIPTION
    Reads the processing items and their -sort order- within a Workflow Template from an AutomateNOW! instance

    .PARAMETER WorkflowTemplate
    An [ANOWWorkflowTemplate] object representing the Workflow Template to be read.

    .PARAMETER Id
    A string containing the 36-character guid Id of the Workflow Item to fetch.

    .PARAMETER Name
    Optional "name" of the Workflow Item. Be careful with this parameter as the "name" of the Workflow Item is not required to be unique outside of the Processing Template that it is a part of.

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .INPUTS
    ONLY [ANOWWorkflowTemplate] objects are accepted (including from the pipeline)

    .OUTPUTS
    [ANOWProcessingTemplateItem] objects that represent the processing template items will be returned.

    .EXAMPLE
    Get all of the items in a specified Workflow.

    $workflow_template = Get-AutomateNOWWorkflowTemplate -Id 'WorkflowTemplate1'
    $workflow_template_items = $workflow_template | Read-AutomateNOWWorkflowTemplateItem

    .EXAMPLE
    Gets a specific item in a Workflow Template by its 36-character GUID id

    Read-AutomateNOWWorkflowTemplateItem -Id '12342fde-7e1e-4a69-ae7c-bc15e19a0fe1'

    .EXAMPLE
    Gets a specific item in a Workflow Template named 'TaskTemplate1' from within a Workflow Template named 'WorkflowTemplate1'

    Get-AutomateNOWWorkflowTemplate -Id 'WorkflowTemplate1' | Read-AutomateNOWWorkflowTemplateItem -Name 'TaskTemplate1'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The first item listed will be the Workflow itself which has a sort order of -1. The remaining child items will start at sort order 1 or above. There is no sort order of 0.

    #>
    [OutputType([ANOWProcessingTemplateItem[]])]
    [Cmdletbinding(DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'Default', ValueFromPipeline = $true)]
        [ANOWWorkflowTemplate]$WorkflowTemplate,
        [ValidateScript({ $_ -match '^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$' })]
        [Parameter(Mandatory = $true, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$Name,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWWorkflowTemplate]$WorkflowTemplate = $_
        }
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($Id.Length -gt 0) {
            $BodyMetaData.Add('id', $Id )
        }
        ElseIf ($WorkflowTemplate.Id.Length -gt 0) {
            [string]$WorkflowTemplate_id = $WorkflowTemplate.Id
            $BodyMetaData.Add('workflow', $WorkflowTemplate_id )
            If ($Name.Length -gt 0) {
                <# This code does not work :(
                $BodyMetaData.Add('_constructor', 'AdvancedCriteria')
                $BodyMetaData.Add('operator', 'and')
                $BodyMetaData.Add('criteria1', '{"fieldName":"name","operator":"equals","value":"' + $Name + '"}')
                #>
            }
            Else {
                $BodyMetaData.Add('_operationId', 'readWorkflow')
                $BodyMetaData.Add('_startRow', $startRow)
                $BodyMetaData.Add('_endRow', $endRow)
                $BodyMetaData.Add('_sortBy1', '-isMasterRecord')
                $BodyMetaData.Add('_sortBy2', 'sortOrder')
                $BodyMetaData.Add('_sortBy3', 'title')
            }
        }
        Else {
            Write-Warning -Message "Could not determine the arrangement under Read-AutomateNOWWorkflowTemplateItem"
            Break
        }
        $BodyMetaData.Add('_componentId', 'ProcessingTemplateItemList')
        $BodyMetaData.Add('_textMatchStyle', 'exact')
        $BodyMetaData.Add('_operationType', 'fetch')
        $BodyMetaData.Add('_dataSource', 'ProcessingTemplateItemDataSource')
        $BodyMetaData.Add('isc_metaDataPrefix', '_')
        $BodyMetaData.Add('isc_dataFormat', 'json')
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        [string]$command = ('/processingTemplateItem/readWorkflow' + '?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.'Command' = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$WorkflowTemplate_id] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        If ($results.response.data.count -gt 0) {
            $Error.Clear()
            Try {
                If ($null -eq $WorkflowTemplate) {
                    If ($results.response.data.count -ne 1) {
                        Write-Warning -Message "The expected number of Workflow Template Items in this scenario was 1. Please look into this."
                        Break
                    }
                    [string]$WorkflowTemplateItem_Id = $results.response.data.id
                    If ($results.response.data.workflow.Length -eq 0) {
                        Write-Warning -Message "The workflow property within Workflow Template Item $WorkflowTemplateItem_Id was empty. Please look into this."
                        Break
                    }
                    [string]$WorkflowTemplate_simpleId = $results.response.data.workflow -split ']' | Select-Object -Last 1
                    [ANOWWorkflowTemplate]$WorkflowTemplate = Get-AutomateNOWWorkflowTemplate -Id $WorkflowTemplate_simpleId
                }
                [ANOWProcessingTemplateItem[]]$ProcessingTemplateItems = $results.response.data | Where-Object { $_.sortOrder -ge 0 } | ForEach-Object {
                    $_.workflow = $WorkflowTemplate
                    If ($_.processingType -eq 'TRIGGER' -or $_.parentProcessingType -eq 'TRIGGER') {
                        [ANOWScheduleTemplateItem]$_
                    }
                    ElseIf ($_.processingType -eq 'WORKFLOW' -or $_.parentProcessingType -eq 'WORKFLOW') {
                        [ANOWWorkflowTemplateItem]$_
                    }
                    ElseIf ($_.processingType -eq 'TASK' -or $_.parentProcessingType -eq 'TASK') {
                        [ANOWTaskTemplateItem]$_
                    }
                    ElseIf ($_.processingType -eq 'SERVICE' -or $_.parentProcessingType -eq 'SERVICE') {
                        [ANOWServiceManagerTemplateItem]$_
                    }
                    Else {
                        [string]$processingType = $_.processingType
                        [string]$parentProcessingType = $_.parentProcessingType
                        Write-Warning -Message "Unable to determine the type of Processing Template ($processingType / $parentProcessingType) under Read-AutomateNOWWorkflowTemplateItem reading $WorkflowTemplate_id. Please look into this."
                        Break
                    }
                }
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the Workflow Template Items from $WorkflowTemplate_id due to [$Message]"
                Break
            }
            Write-Verbose -Message "Workflow Template Items successfully read from $WorkflowTemplate_id"
            If ($Name.Length -gt 0) {
                [ANOWProcessingTemplateItem[]]$ProcessingTemplateItems = $ProcessingTemplateItems | Where-Object { $_.name -eq $Name } | Select-Object -First 1
            }
            Return $ProcessingTemplateItems
        }
        Else {
            Write-Verbose -Message "There were no Workflow Template Items within $WorkflowTemplate_id"
        }
    }
    End {

    }
}

Function Add-AutomateNOWWorkflowTemplateItem {
    <#
    .SYNOPSIS
    Adds a Processing Template to a Workflow Template

    .DESCRIPTION
    Adds a Processing Template (i.e. Task, Workflow, Service Manager or Integration) to a Workflow Template

    .PARAMETER WorkflowTemplate
    Mandatory [ANOWWorkflowTemplate] object representing the Workflow Template that is receiving a new item.

    .Parameter ProcessingTemplate
    Mandatory [ANOWProcessingTemplate] (only Task Template, Workflow Template or Service Manager Template) object representing the Processing Template that is being added to the Workflow Template as a new item.

    .PARAMETER sortOrder
    Optional int32 specifying the sort order. When not specified, the sort order will be LAST. If needed, use Read-AutomateNOWWorkflow to obtain the current sort order of the items in the Workflow.

    .PARAMETER Quiet
    Switch parameter to silence the emitted [ANOWWorkflowTemplateItem] object

    .PARAMETER Force
    Force the addition of the object without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    Any of [ANOWTaskTemplate], [ANOWWorkflowTemplate] or [ANOWServiceManagerTemplate] objects are accepted (including from the pipeline). You can also use Get-AutomateNOWProcessingTemplate. Do not send Schedule Templates to Workflow Templates.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Forcibly and quietly adds 2 Task Templates to a Workflow Template named 'WorkflowTemplate1' (multi-line format)

    $task_template1 = Get-AutomateNOWTaskTemplate -Id 'TaskTemplate1'
    $task_template2 = Get-AutomateNOWTaskTemplate -Id 'TaskTemplate2'
    $workflow_template1 = Get-AutomateNOWWorkflowTemplate -Id 'WorkflowTemplate1'

    $task_template1, $task_template2 | Add-AutomateNOWWorkflowTemplateItem -WorkflowTemplate $workflow_template1 -Quiet -Force

    .EXAMPLE
    Uses the pipeline to add a Service Manager Template named 'ServiceManagerTemplate1' to a Workflow Template named 'WorkflowTemplate1' (one-liner format)

    Get-AutomateNOWServiceManagerTemplate -Id 'ServiceManagerTemplate1' | Add-AutomateNOWWorkflowTemplateItem -WorkflowTemplate (Get-AutomateNOWWorkflowTemplate -Id 'WorkflowTemplate1')

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The sort order cannot be changed yet through this module. All items are added as the last item.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWWorkflowTemplate]$WorkflowTemplate,
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [PSObject]$ProcessingTemplate,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$WorkflowTemplate_id = $WorkflowTemplate.Id
        [string]$command = '/processingTemplateItem/create'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [PSObject]$ProcessingTemplate = $_
        }
        [string]$ProcessingTemplate_id = $ProcessingTemplate.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Add $($ProcessingTemplate_id) to $($WorkflowTemplate_id)")) -eq $true) {
            $Error.Clear()
            Try {
                [ANOWProcessingTemplateItem[]]$WorkflowTemplateItems = Read-AutomateNOWWorkflowTemplateItem -WorkflowTemplate $WorkflowTemplate -startRow 0 -endRow 10000
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Read-AutomateNOWWorkflowTemplateItem failed to Read $WorkflowTemplate_id under Add-AutomateNOWWorkflowTemplateItem due to [$Message]."
                Break
            }
            [int32]$WorkflowTemplateItems_Count = $WorkflowTemplateItems.Count
            If ($WorkflowTemplateItems_Count -gt 0) {
                Write-Verbose -Message "$WorkflowTemplate_id currently has $WorkflowTemplateItems_Count items before any changes were made"
                [int32]$last_item_order = ($WorkflowTemplateItems | Sort-Object -Property sortOrder | Select-Object -Last 1 | Select-Object -ExpandProperty sortOrder) + 1
            }
            Else {
                Write-Verbose -Message "$WorkflowTemplate_id does not have any items yet. This will be the first item added to it."
                [int32]$last_item_order = 0
            }
            [ANOWProcessingTemplate_processingType]$processingType = $ProcessingTemplate.processingType
            # Note that the taskType property is still sent as an empty property when the Processing Template is a Workflow
            If ($null -ne $ProcessingTemplate.taskType) {
                [ANOWProcessingTemplate_taskType]$taskType = $ProcessingTemplate.taskType
            }
            Else {
                [string]$taskType = ''
            }
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('workflow', $WorkflowTemplate_id )
            $BodyMetaData.Add('processingType', $processingType )
            $BodyMetaData.Add('processingTemplate', $processingTemplate_id )
            $BodyMetaData.Add('taskType', $taskType )
            $BodyMetaData.Add('sortOrder', $last_item_order )
            $BodyMetaData.Add('_operationType', 'add')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingTemplateItemDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties 'taskType'
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$WorkflowTemplate_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            If ($results.response.data.count -gt 0) {
                $Error.Clear()
                Try {
                    [array]$ProcessingTemplateItem = $results.response.data | Where-Object { $_.sortOrder -ge 0 } | ForEach-Object {
                        $_.workflow = $WorkflowTemplate
                        If ($_.processingType -eq 'TASK' -or $_.parentProcessingType -eq 'TASK') {
                            [ANOWTaskTemplateItem]$_
                        }
                        ElseIf ($_.processingType -eq 'WORKFLOW' -or $_.parentProcessingType -eq 'WORKFLOW') {
                            [ANOWWorkflowTemplateItem]$_
                        }
                        ElseIf ($_.processingType -eq 'SERVICE' -or $_.parentProcessingType -eq 'SERVICE') {
                            [ANOWServiceManagerTemplateItem]$_
                        }
                        Else {
                            [string]$processingType = $_.processingType
                            [string]$parentProcessingType = $_.parentProcessingType
                            Write-Warning -Message "Unable to determine the type of Processing Template ($processingType / $parentProcessingType) under Read-AutomateNOWWorkflowTemplateItem reading $WorkflowTemplate_id. Please look into this."
                            Break
                        }
                    }
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to parse the Processing Template Item from $WorkflowTemplate_id due to [$Message]"
                    Break
                }
                Write-Verbose -Message "Workflow Template Item successfully added to $WorkflowTemplate_id"
                If ($Quiet -ne $true) {
                    Return $ProcessingTemplateItem
                }
            }
            Else {
                Write-Verbose -Message "There were no Workflow Template Items within $WorkflowTemplate_id"
            }
        }
    }
    End {

    }
}

Function Remove-AutomateNOWWorkflowTemplateItem {
    <#
    .SYNOPSIS
    Removes a Processing Template from a Workflow Template

    .DESCRIPTION
    Removes a Processing Template Item (i.e. Task, Workflow, Service Manager or Integration) from a Workflow Template

    .PARAMETER WorkflowTemplate
    Mandatory [ANOWWorkflowTemplate] object representing the Workflow Template that will lose a Processing Template.

    .Parameter ProcessingTemplateItem
    Mandatory [ANOWProcessingTemplateItem] (i.e. Task, Workflow, Service Manager or Integration) object representing the Processing Template Item that is being removed from the Workflow Template. Use Read-AutomateNOWWorkflowTemplate to retrieve the Processing Template Items from a Workflow Template.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    You must present a [ANOWWorkflowTemplate] object to the -WorkflowTemplate parameter along with [ANOWProcessingTemplateItem] objects to the -ProcessingTemplateItem parameter. The latter can be pipelined.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Removes a single Processing Template Item from a Workflow Template

    $Workflow_template = Get-AutomateNOWWorkflowTemplate -Id 'WorkflowTemplate1'
    $processing_template_item = Read-AutomateNOWWorkflowTemplateItem -WorkflowTemplate $Workflow_template | Where-Object { $_.Id -eq '3fc63622-5e87-468e-a71f-bd78450219e3'}
    Remove-AutomateNOWWorkflowTemplateItem -WorkflowTemplate $Workflow_template -ProcessingTemplateItem $processing_template_item

    .EXAMPLE
    Forcibly removes all instances of a Workflow named 'Workflow1' that was added to a Workflow Template named 'WorkflowTemplate1'.

    $Workflow_template = Get-AutomateNOWWorkflowTemplate -Id 'WorkflowTemplate1'
    $workflow_items = Read-AutomateNOWWorkflowTemplateItem -WorkflowTemplate $Workflow_template | Where-Object { $_.processingTemplate -eq 'Workflow1'}
    $workflow_items | Remove-AutomateNOWWorkflowTemplateItem -WorkflowTemplate $Workflow_template -Force

    .EXAMPLE
    Removes all Processing Template Items from a Workflow Template

    Read-AutomateNOWWorkflowTemplateItem -WorkflowTemplate (Get-AutomateNOWWorkflowTemplate -Id 'WorkflowTemplate1') | Remove-AutomateNOWWorkflowTemplateItem -WorkflowTemplate (Get-AutomateNOWWorkflowTemplate -Id 'WorkflowTemplate1')

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Only Task Templates and Workflow Templates are supported. Service Managers and Integrations are not supported yet.

    Remember that once a Processing Template is added to a Workflow Template or Workflow Template it becomes a Processing Template Item which have a 36-character GUID for the Id.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWWorkflowTemplate]$WorkflowTemplate,
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWProcessingTemplateItem]$ProcessingTemplateItem,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$WorkflowTemplate_id = $WorkflowTemplate.Id
        [string]$command = '/processingTemplateItem/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWProcessingTemplateItem]$ProcessingTemplateItem = $_
        }
        [string]$ProcessingTemplateItem_id = $ProcessingTemplateItem.id
        If ($ProcessingTemplateItem_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If ($ProcessingTemplateItem_id -notmatch '^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$') {
            Write-Warning -Message "Was expecting the Id of the Processing Template Id to match a 36-character GUID, instead received [$ProcessingTemplateItem_id]. Please check into this."
            Break
        }
        Else {
            Write-Verbose -Message "Received [$ProcessingTemplateItem_id] for the Id of the Processing Template Item to be removed"
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($ProcessingTemplateItem_id)")) -eq $true) {
            $Error.Clear()
            Try {
                [PSCustomObject]$WorkflowTemplateItems = Read-AutomateNOWWorkflowTemplateItem -WorkflowTemplate $WorkflowTemplate -startRow 0 -endRow 10000
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Read-AutomateNOWWorkflowTemplateItem failed to Read [$WorkflowTemplate_id] under Remove-AutomateNOWWorkflowTemplateItem due to [$Message]."
                Break
            }
            [int32]$WorkflowTemplateItems_Count = $WorkflowTemplateItems.Count
            If ($WorkflowTemplateItems_Count -eq 0) {
                Write-Verbose -Message "$WorkflowTemplate_id does not have any Processing Template items added to it yet... Please check again."
                Break
            }
            If ($ProcessingTemplateItem_id -notin ($WorkflowTemplateItems.Id) ) {
                Write-Warning -Message "The Processing Template Item $ProcessingTemplateItem_id is not actually added to [$WorkflowTemplate_id]. Please check this."
                Break
            }
            [string]$old_values = $ProcessingTemplateItem.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $ProcessingTemplateItem_id )
            $BodyMetaData.Add('_oldValues', $old_values )
            $BodyMetaData.Add('_operationType', 'remove')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingTemplateItemDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$WorkflowTemplate_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Processing Template $ProcessingTemplateItem_id ($processingType) was removed from $WorkflowTemplate_id"
        }
    }
    End {

    }
}

#endregion

#Region - Workflow Template Dependencies

Function Read-AutomateNOWWorkflowTemplateDependency {
    <#
    .SYNOPSIS
    Reads the Processing Template Dependency objects that are associated with a Workflow Template on an AutomateNOW! instance

    .DESCRIPTION
    Reads the Processing Template Dependency objects that are associated with a Workflow Template on an AutomateNOW! instance

    .PARAMETER WorkflowTemplate
    An [ANOWWorkflowTemplate] object representing the Workflow Template to read the dependencies from.

    .PARAMETER Successors
    Switch parameter that forces only predecessor Processing Template Item dependencies of the Workflow Template to be returned. If you do not provide this switch then the results may include other depency types (e.g. resources).

    .PARAMETER Id
    A string containing the 36-character guid Id of the Workflow Template Dependency object to fetch.

    .PARAMETER dependencyType
    An optional string that will filter the results based on the type of dependency. Valid choices are: PREDECESSOR; PROCESSING_TEMPLATE; WORKFLOW_ITEM; RESOURCE; EVENT; CHRONOLOGY; AND; OR; XOR; NAND; NOR; XNOR;

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .INPUTS
    Either a [ANOWProcessingTemplateItem] object or its id are required

    .OUTPUTS
    [ANOWProcessingTemplateDependency] objects will be returned

    .EXAMPLE
    Imagine a WorkflowTemplate named 'WorkflowTemplate1' that contains two Task Templates named 'TaskTemplate1' and 'TaskTemplate2' where 'TaskTemplate2' has been configured as a successor of 'TaskTemplate1'.

    Gets the -name- of the successor Workflow Template Item for a Task named 'TaskTemplate1' within a Workflow Template named 'WorkflowTemplate1'. Note the use of the -Successors switch parameter (one-liner format)

    Get-AutomateNOWWorkflowTemplate -Id 'WorkflowTemplate1' | Read-AutomateNOWWorkflowTemplateItem -Name 'TaskTemplate1' | Read-AutomateNOWWorkflowTemplateDependency -Successors | Select-Object -ExpandProperty sourceTitle

    .EXAMPLE
    Imagine a WorkflowTemplate named 'WorkflowTemplate1' that contains two Task Templates named 'TaskTemplate1' and 'TaskTemplate2' where 'TaskTemplate2' has been configured as a successor of 'TaskTemplate1'.

    Gets the -name- of the predecessor Workflow Template Item for a Task named 'TaskTemplate2' within a Workflow Template named 'WorkflowTemplate1'. Note the lack of -Successors switch parameter (one-liner format).

    Get-AutomateNOWWorkflowTemplate -Id 'WorkflowTemplate1' | Read-AutomateNOWWorkflowTemplateItem -Name 'TaskTemplate2' | Read-AutomateNOWWorkflowTemplateDependency | Select-Object -ExpandProperty predecessor

    .EXAMPLE
    Gets the first page of successor Workflow Template Dependency objects from a Workflow Template Item with an id of 'a7c1290d-89f4-4d37-9bfb-7ffaf9ce6c89' (one-liner format)

    Read-AutomateNOWWorkflowTemplateItem -Id 'a7c1290d-89f4-4d37-9bfb-7ffaf9ce6c89' | Read-AutomateNOWWorkflowTemplateDependency -Successors

    .EXAMPLE
    Gets a specific Workflow Template Dependency object with an id of 'c680bdfc-ba66-4645-971d-1c3ada3d545b'

    Read-AutomateNOWWorkflowTemplateDependency -Id 'c680bdfc-ba66-4645-971d-1c3ada3d545b'

    .EXAMPLE
    Gets the first page of RESOURCE related dependencies from a Task Template named 'TaskTemplate1' that is part of a Workflow Template named 'WorkflowTemplate1'.

    Get-AutomateNOWWorkflowTemplate -Id 'WorkflowTemplate1' | Read-AutomateNOWWorkflowTemplateItem -Name 'TaskTemplate1' | Read-AutomateNOWWorkflowTemplateDependency -dependencyType RESOURCE

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Do not overlook the -Successors switch parameter.

    #>
    [OutputType([ANOWProcessingTemplateDependency[]])]
    [Cmdletbinding(DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'Default', ValueFromPipeline = $true)]
        [ANOWProcessingTemplateItem]$ProcessingTemplateItem,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$Successors,
        [ValidateScript({ $_ -match '^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$' })]
        [Parameter(Mandatory = $true, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$Name,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [ANOWProcessingTemplateDependency_dependencyType]$dependencyType,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($endRow -le $startRow) {
            Write-Warning -Message "The endRow must be greater than the startRow. Please try again."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            Try {
                [ANOWProcessingTemplateItem]$ProcessingTemplateItem = $_
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to convert the pipeline item to an [ANOWProcessingTemplateItem] object due to [$Message]."
                Break
            }
            [string]$ProcessingTemplateItem_Name = $ProcessingTemplateItem.name
        }
        ElseIf ($_.length -eq 36) {
            [string]$Id = $_
        }
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($Id.Length -eq 36) {
            $BodyMetaData.Add('id', $Id )
        }
        Else {
            If ($ProcessingTemplateItem.id.Length -eq 0) {
                Write-Warning -Message "Somehow the Processing Template Item that was supplied has an empty id. Please look into this."
                Break
            }
            [string]$WorkflowTemplate_id = $ProcessingTemplateItem.workflow.id
            [string]$WorkflowTemplate_simpleId = $ProcessingTemplateItem.workflow.simpleId
            $BodyMetaData.Add('_constructor', 'AdvancedCriteria')
            $BodyMetaData.Add('_startRow', $startRow)
            $BodyMetaData.Add('_endRow', $endRow)
        }
        If ($Successors -eq $true) {
            $BodyMetaData.Add('operator', 'or')
            $BodyMetaData.Add('criteria1', '{"_constructor":"AdvancedCriteria","operator":"and","criteria":[{"fieldName":"dependencyType","operator":"equals","value":"PREDECESSOR"},{"fieldName":"workflow","operator":"equals","value":"' + $WorkflowTemplate_id + '"},{"fieldName":"predecessor","operator":"equals","value":"' + $ProcessingTemplateItem_Name + '"}]}')
            $BodyMetaData.Add('criteria2', '{"_constructor":"AdvancedCriteria","operator":"and","criteria":[{"fieldName":"dependencyType","operator":"equals","value":"PROCESSING_TEMPLATE"},{"fieldName":"processingTemplate","operator":"equals","value":"' + $ProcessingTemplateItem_Name + '"}]}')
            $BodyMetaData.Add('criteria3', '{"_constructor":"AdvancedCriteria","operator":"and","criteria":[{"fieldName":"dependencyType","operator":"equals","value":"WORKFLOW_ITEM"},{"fieldName":"workflowTemplateItem","operator":"equals","value":"Download-Report.ZendeskCaseBackup.ps1"},{"fieldName":"workflowTemplate","operator":"equals","value":"' + $WorkflowTemplate_simpleId + '"}]}')
            [string]$componentId = 'ProcessingTemplateSuccessorList'
        }
        Else {
            $BodyMetaData.Add('operator', 'and')
            $BodyMetaData.Add('criteria1', ('{"fieldName":"workflow","operator":"equals","value":"' + $WorkflowTemplate_id + '"}'))
            $BodyMetaData.Add('criteria2', ('{"fieldName":"workflowItem","operator":"equals","value":"' + $ProcessingTemplateItem_Name + '"}'))
            $BodyMetaData.Add('criteria3', ('{"operator":"or","criteria":[{"fieldName":"resourceType","operator":"isNull"},{"fieldName":"resourceType","operator":"notInSet","value":["STOCK","LOCK"]}]}'))
            If ($dependencyType.Length -gt 0) {
                $BodyMetaData.Add('criteria4', ('{"fieldName":"dependencyType","operator":"equals","value":"' + $dependencyType + '"}'))
            }
            [string]$componentId = 'ProcessingTemplateDependencyList'
            [string]$operationId = 'ProcessingTemplateDependencyDataSource_fetch'
            $BodyMetaData.Add('_operationId', $operationId)
        }
        $BodyMetaData.Add('_componentId', $componentId)
        $BodyMetaData.Add('_textMatchStyle', 'exact')
        $BodyMetaData.Add('_operationType', 'fetch')
        $BodyMetaData.Add('_dataSource', 'ProcessingTemplateDependencyDataSource')
        $BodyMetaData.Add('isc_metaDataPrefix', '_')
        $BodyMetaData.Add('isc_dataFormat', 'json')
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        [string]$command = ('/processingTemplateDependency/read' + '?' + $Body)
        If ($null -eq $parameters["Command"]) {
            $parameters.Add('Command', $command)
        }
        Else {
            $parameters.'Command' = $command
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$WorkflowTemplate_id] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        If ($results.response.data.count -gt 0) {
            If ($Id.Length -eq 36) {
                If ($results.response.data.workflow.length -eq 0) {
                    Write-Warning -Message "Somehow the workflow property of the retrieved Workflow Template Dependency object was empty. Please look into this."
                    Break
                }
                [string]$WorkflowTemplate_id = $results.response.data | Select-Object -First 1 -ExpandProperty workflow
                [string]$WorkflowTemplate_simpleId = $WorkflowTemplate_id -split ']' | Select-Object -Last 1
                $Error.Clear()
                Try {
                    [ANOWWorkflowTemplate]$WorkflowTemplate = Get-AutomateNOWWorkflowTemplate -Id $WorkflowTemplate_simpleId
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to extract the Workflow Template object from Workflow Template Item on [$ProcessingTemplateItem_Name] due to [$Message]."
                    Break
                }
            }
            [ANOWProcessingTemplateDependency[]]$ProcessingTemplateDependencies = ForEach ($result in $results.response.data) {
                $Error.Clear()
                Try {
                    $result.workflow = $WorkflowTemplate
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to parse the Workflow Template Items from $WorkflowTemplate_id due to [$Message]"
                    Break
                }
                $result
            }
            Write-Verbose -Message "Workflow Template Items successfully read from $WorkflowTemplate_id"
            Return $ProcessingTemplateDependencies
        }
        Else {
            Write-Verbose -Message "There were no Workflow Template Items within $WorkflowTemplate_id"
        }
    }
    End {

    }
}

Function Add-AutomateNOWWorkflowTemplateDependency {
    <#
    .SYNOPSIS
    Adds a dependency between two Processing Template Items within a Workflow Template

    .DESCRIPTION
    Adds a dependency between two Processing Template Items within a Workflow Template

    .PARAMETER WorkflowTemplate
    Mandatory [ANOWWorkflowTemplate] object that the dependency will be configured for.

    .Parameter WorkflowTemplateItem
    Mandatory [ANOWWorkflowTemplateItem] object representing the Processing Template Item that is receiving the dependency to another Processing Template Item within the same Workflow Template.

    .PARAMETER DependencyType
    Mandatory type of dependency that will exist between the two Processing Template Items. Valid choices are: PREDECESSOR; PROCESSING_TEMPLATE; WORKFLOW_ITEM; RESOURCE; EVENT; CHRONOLOGY; AND; OR; XOR; NAND; NOR; XNOR;

    .PARAMETER Predecessor
    Mandatory (when -DependencyType is PREDECESSOR) [ANOWWorkflowTemplateItem] object representing the Processing Template Item that is being set as the predessor to the Processing Template Item that was specified with the -WorkflowTemplateItem parameter.

    .PARAMETER Quiet
    Switch parameter to silence the emitted [ANOWWorkflowTemplateItem] object

    .PARAMETER Force
    Force the addition of the object without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    An [ANOWWorkflowTemplate] object must be presented along with at least one [ANOWWorkflowTemplateItem] object from within that Workflow Template. Pipeline support is intentionally not included.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Forcefully adds a Workflow Template Item named 'TaskTemplate1' as a predecessor to a Workflow Template Item named 'TaskTemplate2' within a Workflow Template named 'WorkflowTemplate1'

    $workflow_template = Get-AutomateNOWWorkflowTemplate -Id 'WorkflowTemplate1'
    $predecessor_item = $workflow_template | Read-AutomateNOWWorkflowTemplateItem -Name 'TaskTemplate1'
    $successor_item = $workflow_template | Read-AutomateNOWWorkflowTemplateItem -Name 'TaskTemplate2'
    Add-AutomateNOWWorkflowTemplateDependency -WorkflowTemplate $workflow_template -WorkflowTemplateItem $successor_item -Predecessor $predecessor_item -DependencyType PREDECESSOR -Force

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    ONLY adding Workflow Template Items as predecessor to other WorkflowTemplate Items is supported. All other options such as adding a Semaphore (etc) are not added yet.

    #>
    [Cmdletbinding(SupportsShouldProcess = $true, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWWorkflowTemplate]$WorkflowTemplate,
        [Parameter(Mandatory = $true)]
        [ANOWWorkflowTemplateItem]$WorkflowTemplateItem,
        [Parameter(Mandatory = $true)]
        [ANOWProcessingTemplateDependency_dependencyType]$DependencyType,

        [Parameter(Mandatory = $true, ParameterSetName = 'WorkflowTemplateItem')]
        [ANOWWorkflowTemplateItem]$Predecessor,
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    If ($DependencyType -eq 'PREDECESSOR' -and $Predecessor.Id.Length -eq 0) {
        Write-Warning -Message "You must include a Workflow Template Item with the -Predecessor parameter when the -DepencyType is PREDECESSOR"
        Break
    }
    [string]$WorkflowTemplate_id = $WorkflowTemplate.id
    [string]$WorkflowTemplate_simpleId = $WorkflowTemplate.simpleId
    [string]$command = '/processingTemplateDependency/create'
    [hashtable]$parameters = @{}
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$WorkflowTemplateItem_processingTemplate = $WorkflowTemplateItem.processingTemplate
    If ($WorkflowTemplateItem_processingTemplate.Length -eq 0) {
        Write-Warning -Message "Somehow the name (processingTemplate) property of the supplied (via the -WorkflowTemplateItem parameter) Workflow Template Item was empty. Please look into this."
        Break
    }
    If ($Predecessor.id.Length -gt 0) {
        [string]$Predecessor_processingTemplate = $Predecessor.processingTemplate
        [string]$target = "Workflow Template Item $Predecessor_processingTemplate will be added as a predecessor of $WorkflowTemplateItem_processingTemplate"
    }
    Else {
        Write-Warning -Message "Dependency type $DependencyType is not supported yet"
        Break
    }
    If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($target) within $($WorkflowTemplate_simpleId)")) -eq $true) {
        $Error.Clear()
        Try {
            [ANOWProcessingTemplateItem[]]$WorkflowTemplateItems = Read-AutomateNOWWorkflowTemplateItem -WorkflowTemplate $WorkflowTemplate -startRow 0 -endRow 10000
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Read-AutomateNOWWorkflowTemplateItem failed to Read $WorkflowTemplate_id under Add-AutomateNOWWorkflowTemplateItem due to [$Message]."
            Break
        }
        [int32]$WorkflowTemplateItems_Count = $WorkflowTemplateItems.Count
        If ($WorkflowTemplateItems_Count -eq 0) {
            Write-Verbose -Message "$WorkflowTemplate_id has zero items within"
            Break
        }
        [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
        $BodyMetaData.Add('workflow', $WorkflowTemplate_id )
        $BodyMetaData.Add('workflowItem', $WorkflowTemplateItem_processingTemplate)
        $BodyMetaData.Add('dependencyType', $DependencyType)
        If ($Predecessor.id.Length -gt 0) {
            [string]$componentId = 'ProcessingTemplateDependencyList'
            $BodyMetaData.Add('predecessor', $Predecessor_processingTemplate)
        }
        ElseIf ($Semaphore.id.Length -gt 0) {
            [string]$componentId = 'ProcessingTemplateDependencyEditForm'
            [string]$Semaphore_Id = $Semaphore.id
            $BodyMetaData.Add('resource', $Semaphore_Id)
            $BodyMetaData.Add('resourceType', 'BINARY_SEMAPHORE')
            $BodyMetaData.Add('semaphoreState', $semaphoreState)
            If ($timestampRelation.Length -gt 0) {
                $BodyMetaData.Add('timestampRelation', $timestampRelation)
            }
            If ($timestampSelection.Length -gt 0) {
                $BodyMetaData.Add('timestampSelector', $timestampSelection)
            }
            If ($Calendar.Id.Length -gt 0) {
                [string]$Calendar_Id = $Calendar.Id
                $BodyMetaData.Add('timestampCalendar', $Calendar_Id)
            }
            If ($timestampOffset.Length -gt 0) {
                $BodyMetaData.Add('timestampOffset', $timestampOffset)
            }
            If ($specificTimestamp.Length -gt 0) {
                $BodyMetaData.Add('specificTimestamp', $specificTimestamp)
            }
            If ($selectedDates.Count -gt 0) {
                [string]$selectedDates_string = $selectedDates -join ','
                $BodyMetaData.Add('selectedDates', $selectedDates_string)
            }
        }
        ElseIf ($TimeWindow.Id.Length -gt 0) {
            [string]$componentId = 'ProcessingTemplateDependencyEditForm'
            [string]$TimeWindow_Id = $TimeWindow.id
            $BodyMetaData.Add('resource', $TimeWindow_Id)
            $BodyMetaData.Add('resourceType', 'TIME_SEMAPHORE')
            $BodyMetaData.Add('semaphoreState', $TimeWindowState)
        }
        ElseIf ($Variable.Id.Length -gt 0) {
            [string]$componentId = 'ProcessingTemplateDependencyEditForm'
            [string]$Variable_Id = $Variable.id
            $BodyMetaData.Add('resource', $Variable_Id)
            $BodyMetaData.Add('resourceType', 'VARIABLE')
            $BodyMetaData.Add('valueOperator', $valueOperator)
            If ($Value.Length -gt 0) {
                $BodyMetaData.Add('value', $value)
            }
        }
        Else {
            Write-Warning -Message "Dependency type $DependencyType is not supported yet"
            Break
        }
        $BodyMetaData.Add('_oldValues', '{}' )
        $BodyMetaData.Add('_operationType', 'add')
        $BodyMetaData.Add('_textMatchStyle', 'exact')
        $BodyMetaData.Add('_componentId', $componentId)
        $BodyMetaData.Add('_dataSource', 'ProcessingTemplateDependencyDataSource')
        $BodyMetaData.Add('isc_metaDataPrefix', '_')
        $BodyMetaData.Add('isc_dataFormat', 'json')
        [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
        If ($null -eq $parameters.Body) {
            $parameters.Add('Body', $Body)
        }
        Else {
            $parameters.Body = $Body
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$WorkflowTemplate_id] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        If ($results.response.data.count -eq 1) {
            [PSCustomObject]$ProcessingTemplateDependency = $results.response.data | Select-Object -ExcludeProperty workflow
            $ProcessingTemplateDependency | Add-Member -MemberType NoteProperty -Name workflow -Value $WorkflowTemplate
            If ($ProcessingTemplateDependency.workspace.length -gt 0) {
                [string]$Workspace_id = $ProcessingTemplateDependency.workspace
                $Error.Clear()
                Try {
                    [ANOWWorkspace]$Workspace = Get-AutomateNOWWorkspace -Id $Workspace_id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWWorkspace failed to retrieve $Workspace_id (under Add-AutomateNOWWorkflowTemplateDependency) due to [$Message]"
                    Break
                }
                [PSCustomObject]$ProcessingTemplateDependency = $ProcessingTemplateDependency | Select-Object -ExcludeProperty workspace
                $ProcessingTemplateDependency | Add-Member -MemberType NoteProperty -Name workspace -Value $Workspace
            }
            $Error.Clear()
            Try {
                [ANOWProcessingTemplateDependency]$ProcessingTemplateDependency = $ProcessingTemplateDependency
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the result of adding the dependency within $WorkflowTemplate_id between $WorkflowTemplateItem_processingTemplate and its target due to [$Message]"
                Break
            }
            Write-Verbose -Message "A Processing Template Dependency was successfully added to $WorkflowTemplate_id between $WorkflowTemplateItem_processingTemplate and its target"
            If ($Quiet -ne $true) {
                Return $ProcessingTemplateDependency
            }
        }
        Else {
            Write-Verbose -Message "There were no Processing Template Dependencies within $WorkflowTemplate_id"
        }
    }
}

Function Remove-AutomateNOWWorkflowTemplateDependency {
    <#
    .SYNOPSIS
    Removes a Processing Template Dependency from a Workflow Template Item within a Workflow Template

    .DESCRIPTION
    Removes a Processing Template Dependency from a Workflow Template Item within a Workflow Template

    .PARAMETER WorkflowTemplateDependency
    Mandatory [ANOWWorkflowTemplateDependency] object representing the Workflow Template Dependency that will be removed

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    You must present one or more [ANOWWorkflowTemplateDependency] object to the WorkflowTemplateDependency parameter or the pipeline

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Imagine a Workflow Template named 'WorkflowTemplate1' that contains two Task Templates named 'TaskTemplate1' and 'TaskTemplate2' where 'TaskTemplate2' has been configured as a successor of 'TaskTemplate1'.

    Removes a successor Workflow Template Dependency object between 'TaskTemplate1' and 'TaskTemplate2' within a Workflow Template named 'WorkflowTemplate1'

    Get-AutomateNOWWorkflowTemplate -Id 'WorkflowTemplate1' | Read-AutomateNOWWorkflowTemplateItem -Name 'TaskTemplate1' | Read-AutomateNOWWorkflowTemplateDependency -Successors | Remove-AutomateNOWWorkflowTemplateDependency

    .EXAMPLE
    Removes a specific Workflow Template Dependency object by its id (one-liner)

    Read-AutomateNOWWorkflowTemplateDependency -Id '1e6da255-b2d5-458f-aff6-711b06c14921' | Remove-AutomateNOWWorkflowTemplateDependency

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWProcessingTemplateDependency]$WorkflowTemplateDependency,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/processingTemplateDependency/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWProcessingTemplateDependency]$WorkflowTemplateDependency = $_
        }
        [string]$WorkflowTemplateDependency_id = $WorkflowTemplateDependency.id
        If ($WorkflowTemplateDependency_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If ($WorkflowTemplateDependency_id -notmatch '^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$') {
            Write-Warning -Message "Was expecting the Id of the Workflow Template Dependency object to match a 36-character GUID, instead received [$WorkflowTemplateDependency_id]. Please check into this."
            Break
        }
        Else {
            Write-Verbose -Message "Received [$WorkflowTemplateDependency_id] for the Id of the Workflow Template Dependency to be removed"
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($WorkflowTemplateDependency_id)")) -eq $true) {
            $Error.Clear()
            Try {
                [PSCustomObject]$WorkflowTemplateDependency_Check = Read-AutomateNOWWorkflowTemplateDependency -Id $WorkflowTemplateDependency_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Read-AutomateNOWWorkflowTemplateDependency failed to Read [$WorkflowTemplateDependency_id] under Remove-AutomateNOWWorkflowTemplateDependency due to [$Message]."
                Break
            }
            If ($WorkflowTemplateDependency_id -ne $WorkflowTemplateDependency_Check.id ) {
                [string]$unexpected_id = $WorkflowTemplateDependency_Check.id
                Write-Warning -Message "Somehow the Workflow Template Dependency with id $WorkflowTemplateDependency_id was not the same as the checked object $unexpected_id. Please check this."
                Break
            }
            [string]$old_values = $WorkflowTemplateDependency.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.Add('id', $WorkflowTemplateDependency_id )
            $BodyMetaData.Add('_oldValues', $old_values )
            $BodyMetaData.Add('_operationType', 'remove')
            $BodyMetaData.Add('_textMatchStyle', 'exact')
            $BodyMetaData.Add('_dataSource', 'ProcessingTemplateDependencyDataSource')
            $BodyMetaData.Add('isc_metaDataPrefix', '_')
            $BodyMetaData.Add('isc_dataFormat', 'json')
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$WorkflowTemplate_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            [string]$WorkflowTemplate_id = $WorkflowTemplateDependency.workflow.id
            Write-Verbose -Message "Workflow Template Dependency $WorkflowTemplateDependency_id has been removed from $WorkflowTemplate_id"
        }
    }
    End {

    }
}

#endregion

#Region - Workspaces

Function Get-AutomateNOWWorkspace {
    <#
    .SYNOPSIS
    Gets the Workspaces from an AutomateNOW! instance

    .DESCRIPTION
    Gets the Workspaces from an AutomateNOW! instance

    .PARAMETER Id
    Optional string containing the simple id of the Workspace to fetch or you can pipeline a series of simple id strings. You may not enter an array here.

    .PARAMETER startRow
    Optional integer to indicate the row to start from. This is intended for when you need to paginate the results. Default is 0.

    .PARAMETER endRow
    Optional integer to indicate the row to stop on. This is intended for when you need to paginate the results. Default is 100.

    .PARAMETER sortBy
    Optional string parameter to sort the results by. Valid choices are: id {To be continued...}

    .PARAMETER Descending
    Optional switch parameter to sort in descending order

    .PARAMETER Folder
    Optional string to filter by a particular Folder

    .PARAMETER Tags
    Optional string array of Tags to filter by. Note that the 'containsAny' operator will be used.

    .INPUTS
    Accepts a string representing the simple id of the Workspace from the pipeline or individually (but not an array).

    .OUTPUTS
    An array of one or more [ANOWWorkspace] class objects

    .EXAMPLE
    Gets all Workspaces

    Get-AutomateNOWWorkspace

    .EXAMPLE
    Gets a single Workspace

    Get-AutomateNOWWorkspace -Id 'Workspace1'

    .EXAMPLE
    Gets a series of Workspaces from an array of strings sent across the pipeline

    'Workspace1', 'Workspace2' | Get-AutomateNOWWorkspace

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    Run this function without parameters to retrieve all of the Workspaces.

    #>
    [OutputType([ANOWWorkspace[]])]
    [Cmdletbinding(DefaultParameterSetName = 'Default')]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $False, ParameterSetName = 'Id', ValueFromPipeline = $true)]
        [string]$Id,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$startRow = 0,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int32]$endRow = 100,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$sortBy = 'id',
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$Descending,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$Folder,
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string[]]$Tags
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [hashtable]$parameters = @{}
        $parameters.Add('Method', 'GET')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        [System.Collections.Specialized.OrderedDictionary]$Body = [System.Collections.Specialized.OrderedDictionary]@{}
        If ($_.Length -gt 0 -or $Id.Length -gt 0) {
            If ($_.Length -gt 0 ) {
                [string]$Workspacename = $_
            }
            Else {
                [string]$Workspacename = $Id
            }
            [string]$textMatchStyle = 'exact'
            $Body.'id' = $Workspacename
        }
        Else {
            [string]$textMatchStyle = 'substring'
            $Body.'_constructor' = 'AdvancedCriteria'
            $Body.'operator' = 'and'
            If ($Folder.Length -gt 0) {
                $Body.'criteria1' = ('{"fieldName":"folder","operator":"equals","value":"' + $Folder + '"}')
            }
            If ($Tags.Count -gt 0) {
                If ($Tags.Count -gt 1) {
                    $Error.Clear()
                    Try {
                        [string]$TagString = $Tags | ConvertTo-Json -Compress
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "ConvertTo-Json failed to convert the provided tag names under Get-AutomateNOWWorkspace due to [$Message]."
                        Break
                    }
                }
                Else {
                    [string]$TagString = $Tags
                }
                $Body.'criteria2' = ('{"fieldName":"tags","operator":"containsAny","value":' + $TagString + '}')
            }
        }
        $Body.'_operationType' = 'fetch'
        $Body.'_startRow' = $startRow
        $Body.'_endRow' = $endRow
        $Body.'_textMatchStyle' = $textMatchStyle
        $Body.'_componentId' = 'WorkspaceList'
        $Body.'_dataSource' = 'WorkspaceDataSource'
        If ($Descending -eq $true) {
            $Body.'_sortBy' = '-' + $sortBy
        }
        Else {
            $Body.'_sortBy' = $sortBy
        }
        $Body.'isc_metaDataPrefix' = '_'
        $Body.'isc_dataFormat' = 'json'
        [string]$Body = ConvertTo-QueryString -InputObject $Body
        [string]$command = ('/workspace/read?' + $Body)
        If ($null -ne $parameters['command']) {
            $parameters.command = $command
        }
        Else {
            $parameters.Add('command', $command)
        }
        $Error.Clear()
        Try {
            [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] due to [$Message]."
            Break
        }
        [int32]$response_code = $results.response.status
        If ($response_code -ne 0) {
            [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
            Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
            Break
        }
        $Error.Clear()
        Try {
            [ANOWWorkspace[]]$Workspaces = $results.response.data
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Failed to parse the response into a series of [ANOWWorkspace] objects due to [$Message]."
            Break
        }
        If ($Workspaces.Count -gt 0) {
            Return $Workspaces
        }
    }
    End {

    }
}

Function Set-AutomateNOWWorkspace {
    <#
    .SYNOPSIS
    Changes the settings of a Workspace on an AutomateNOW! instance

    .DESCRIPTION
    Changes the settings of a Workspace on an AutomateNOW! instance

    .PARAMETER Workspace
    Mandatory [ANOWWorkspace] object representing the Workspace to be changed.

    .PARAMETER Description
    The description of the Workspace (maximum length is 255 characters)

    .PARAMETER UnsetDescription
    Removes the description from the Workspace

    .PARAMETER Folder
    String that specifies the name of the folder to place the Workspace into.

    .PARAMETER UnsetFolder
    Switch parameter that will remove the Workspace from its current folder.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the new Workspace object.

    .PARAMETER UnsetTags
    Switch parameter that will remove all Tags.

    .PARAMETER CodeRepository
    Optional Code Repository to place the Workspace into. Use Get-AutomateNOWCodeRepository to fetch this object.

    .PARAMETER UnsetCodeRepository
    Switch parameter that will remove the the Workspace from its Code Repository.

    .PARAMETER iconSet
    Optional The name of the icon library. Possible choices are: FAT_COW, FUGUE (note that FONT_AWESOME is not an actual icon library)

    .PARAMETER iconCode
    The name of the icon which matches the chosen library. Must be lower-case.

    .PARAMETER RemoveIcon
    Switch parameter that will remove the icon configured for this workspace.

    .PARAMETER WorkspacePrefix
    Sets the Prefix of the Workspace. This is a forced prefix that gets prepended to any processing template that is created within this Workspace. Unlike the UI, a default suggested prefix will not be generated for you.

    .PARAMETER UnsetWorkspacePrefix
    Switch parameter that will unset the Prefix of the Workspace.

    .PARAMETER WorkspaceTagType
    Sets the Workspage Tag Type. The two choices are: SET_WORKSPACE_TAGS, SET_SPECIFIC_TAGS. Note, if you specify SET_SPECIFIC_TAGS then you must also include the -WorkspaceTags parameter as well with the names (string array) of the Tag objects to set.

    .PARAMETER UnsetWorkspaceTagType
    Switch parameter that will remove the Workspace Tag Type. If this was set to SET_SPECIFIC_TAGS then the tags set will also be removed.

    .PARAMETER WorkspaceTags
    Required when -WorkspaceTagType is set to SET_SPECIFIC_TAGS. A string array of CASE-SENSITIVE Tag Id's to set as the Workspace Tags that will be automatically added to any new processing templates created within this Workspace.

    .PARAMETER WorkspaceFolderType
    Enables the 'Automatically set tags to workspace template'. Valid choices are: SET_WORKSPACE_FOLDER, SET_SPECIFIC_FOLDER, CREATE_SUB_FOLDER_PER_WORKFLOW. Note, if you specify SET_SPECIFIC_FOLDER then you must include the -Folder parameter as well with the name (string) of the Folder object.

    .PARAMETER UnsetWorkspaceFolderType
    Switch parameter that will remove the Workspace Tag Type. If this was set to SET_SPECIFIC_FOLDER then the folder set will also be removed.

    .PARAMETER WorkspaceFolder
    String that specifies the folder object when -WorkspaceFolderType is SET_SPECIFIC_FOLDER.

    .PARAMETER Quiet
    Switch parameter that silences the output of the updated object.

    .PARAMETER Force
    Force the change without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWWorkspace] objects are accepted (including from the pipeline)

    .OUTPUTS
    The updated [ANOWWorkspace] object will be returned

    .EXAMPLE
    Sets the description, icon, tags, folder, code repository, prefix, tag type with two Tags and a folder type with a specific Folder on a Workspace named 'Workspace1' (one-liner format)

    Import-AutomateNOWLocalIcon
    Get-AutomateNOWWorkspace -Id 'Workspace1' | Set-AutomateNOWWorkspace -Description 'my desc' -iconSet FAT_COW -iconCode abacus -Tags 'Tag1', 'Tag2' -Folder 'Folder1' -CodeRepository (Get-AutomateNOWCodeRepository -Id 'Repository1') -WorkspacePrefix 'template_prefix_1' -WorkspaceTagType SET_SPECIFIC_TAGS -WorkspaceTags 'Tag3', 'Tag4' -WorkspaceFolderType SET_SPECIFIC_FOLDER -WorkspaceFolder 'Folder2'

    .EXAMPLE
    Forcibly and quietly removes the description, icon, tags, folder, code repository, prefix, tag type and folder type from a Workspace named 'Workspace1'

    Get-AutomateNOWWorkspace -Id 'Workspace1' | Set-AutomateNOWWorkspace -UnsetDescription -RemoveIcon -UnsetTags -UnsetFolder -UnsetCoderepository -UnsetWorkspacePrefix -UnsetWorkspaceTagType -UnsetWorkspaceFolderType -Force -Quiet

    .EXAMPLE
    Quietly sets the icon on a Workspace named 'Workspace1'

    Get-AutomateNOWWorkspace -Id 'Workspace1' | Set-AutomateNOWWorkspace -iconSet FAT_COW -iconCode 'acorn' -Quiet

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    If you have three tags on a Workspace and wanted to remove one then use the -SetTags parameter to apply the 2 that you want to keep. If you want to remove all tags then use -UnsetTags.

    If you specify either of the icon parameters then you must specify both of them.

    #>
    [OutputType([ANOWWorkspace])]
    [Cmdletbinding(SupportsShouldProcess, DefaultParameterSetName = 'Default', ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $True)]
        [ANOWWorkspace]$Workspace,
        [ValidateScript({ $_.Length -le 255 })]
        [Parameter(Mandatory = $false, ParameterSetName = 'Default', HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon', HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [string]$Description,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [string]$Folder,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [string[]]$Tags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [ANOWCodeRepository]$CodeRepository,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [switch]$UnsetCodeRepository,
        [Parameter(Mandatory = $true, ParameterSetName = 'WithIcon')]
        [ANOWIcon_IconsOnly]$iconSet,
        [ValidateScript({ $_ -match '^[a-z0-9-_]{1,}$' })]
        [Parameter(Mandatory = $true, ParameterSetName = 'WithIcon')]
        [string]$iconCode,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$RemoveIcon,
        [ValidateScript({ $_.Length -le 255 })]
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [string]$WorkspacePrefix,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [switch]$UnsetWorkspacePrefix,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [ANOWWorkspace_workspaceSetTagType]$WorkspaceTagType,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [switch]$UnsetWorkspaceTagType,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [string[]]$WorkspaceTags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [ANOWWorkspace_workspaceSetFolderType]$WorkspaceFolderType,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [switch]$UnsetWorkspaceFolderType,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'WithIcon')]
        [string]$WorkspaceFolder,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set and unset the Description. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set and unset the Folder. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.count -gt 0) {
            Write-Warning -Message "You cannot set and unset the Tags. Please choose one or the other."
            Break
        }
        If ($UnsetCodeRepository -eq $true -and $CodeRepository.id.Length -gt 0) {
            Write-Warning -Message "You cannot set and unset the Code Repository. Please choose one or the other."
            Break
        }
        If ($iconSet.length -gt 0 ) {
            If ($RemoveIcon -eq $true) {
                Write-Warning -Message "You cannot set and unset the Icon. Please choose one or the other."
                Break
            }
            If ($anow_assets.icon_library.length -eq 0) {
                Write-Warning -Message "Please import the ANOW icons into your session with Import-AutomateNOWIcon or Import-AutomateNOWLocalIcon"
                Break
            }
            If ($iconCode -notin ($anow_assets.icon_library."$iconSet")) {
                Write-Warning -Message "The icon [$iconCode] does not appear to exist within the [$iconSet] icon set. Please check again."
                Break
            }
        }
        If ($UnsetWorkspacePrefix -eq $true -and $WorkspacePrefix.Length -gt 0) {
            Write-Warning -Message "You cannot set and unset the Workspace Prefix. Please choose one or the other."
            Break
        }
        If ($UnsetWorkspaceTagType -eq $true -and $WorkspaceTagType.Length -gt 0) {
            Write-Warning -Message "You cannot set and unset the Workspace Tag type. Please choose one or the other."
            Break
        }
        ElseIf ($WorkspaceTagType -eq 'SET_SPECIFIC_TAGS' -and $WorkspaceTags.Count -eq 0) {
            Write-Warning -Message "You must include -WorkspaceTags when -WorkspaceTagType is specified as SET_SPECIFIC_TAGS."
            Break
        }
        ElseIf ($WorkspaceTags.Count -gt 0 -and $WorkspaceTagType.Length -eq 0) {
            Write-Warning -Message "You must include -WorkspaceTagType when specifying -WorkspaceTags."
            Break
        }
        ElseIf ($WorkspaceTags.Count -gt 0 -and $WorkspaceTagType -eq 'SET_WORKSPACE_TAG') {
            Write-Warning -Message "You may not include -WorkspaceTags when WorkspaceTagType is specified as SET_WORKSPACE_TAG."
            Break
        }
        If ($UnsetWorkspaceFolderType -eq $true -and $WorkspaceFolderType.Length -gt 0) {
            Write-Warning -Message "You cannot set and unset the Workspace Folder type. Please choose one or the other."
            Break
        }
        ElseIf ($WorkspaceFolderType -eq 'SET_SPECIFIC_FOLDER' -and $WorkspaceFolder.Length -eq 0) {
            Write-Warning -Message 'You must include -WorkspaceFolder when specifying a Workspace Folder Type of SET_SPECIFIC_FOLDER.'
            Break
        }
        ElseIf ($WorkspaceFolder.Length -gt 0 -and $WorkspaceFolderType.Length -eq 0) {
            Write-Warning -Message 'You must include -WorkspaceFolderType when specifying a Workspace Folder.'
            Break
        }
        ElseIf ($WorkspaceFolder.Length -gt 0 -and $WorkspaceFolderType -ne 'SET_SPECIFIC_FOLDER') {
            Write-Warning -Message 'Please do not include the -WorkspaceFolder parameter unless -WorkspaceFolderType is specified as SET_SPECIFIC_FOLDER.'
            Break
        }
        [string]$command = '/workspace/update'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWWorkspace]$Workspace = $_
        }
        [string]$Workspace_id = $Workspace.id
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Workspace_id)")) -eq $true) {
            ## Begin warning ##
            ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
            $Error.Clear()
            Try {
                [boolean]$Workspace_exists = ($null -eq (Get-AutomateNOWWorkspace -Id $Workspace_id))
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWWorkspace failed to check if the Workspace [$Workspace_id] already existed due to [$Message]."
                Break
            }
            If ($Workspace_exists -eq $true) {
                [string]$current_domain = $anow_session.header.domain
                Write-Warning -Message "There is not a Workspace named [$Workspace_id] in the current domain [$current_domain]. Please check into this."
                Break
            }
            ## End warning ##
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $Workspace_id
            [string]$old_values = $Workspace.CreateOldValues()
            If ($Description.Length -gt 0) {
                $BodyMetaData.'description' = $Description
            }
            ElseIf ($UnsetDescription -eq $true) {
                $BodyMetaData.'description' = $null
            }

            If ($Folder.Length -gt 0) {
                $Error.Clear()
                Try {
                    [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] actually existed under Set-AutomateNOWWorkspace due to [$Message]"
                    Break
                }
                If ($folder_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] under Set-AutomateNOWWorkspace. Please check again."
                    Break
                }
                $BodyMetaData.'folder' = $Folder
            }
            ElseIf ($UnsetFolder -eq $true) {
                $BodyMetaData.'folder' = $null
            }

            If ($Tags.Count -gt 0) {
                [int32]$total_tags = $Tags.Count
                [int32]$current_tag = 1
                ForEach ($tag_id in $Tags) {
                    $Error.Clear()
                    Try {
                        [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] running under Set-AutomateNOWWorkspace due to $Message"
                        Break
                    }
                    If ($tag_object.simpleId.length -eq 0) {
                        Throw "Get-AutomateNOWTag has detected that the tag [$tag_id] does not appear to exist running under Set-AutomateNOWWorkspace. Please check again."
                        Break
                    }
                    ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                        [string]$tag_object_simpleId = $tag_object.simpleId
                        Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                        Break
                    }
                    [string]$tag_display = $tag_object | ConvertTo-Json -Compress
                    Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
                    [string]$tag_name_sequence = ('tags' + $current_tag)
                    $BodyMetaData."$tag_name_sequence" = $tag_id
                    $include_properties += $tag_name_sequence
                    $current_tag++
                }
            }
            ElseIf ($UnsetTags -eq $true) {
                $BodyMetaData.'tags' = $null
            }
            If ($CodeRepository.Id.Length -gt 0) {
                [string]$CodeRepository_Id = $CodeRepository.Id
                $Error.Clear()
                Try {
                    [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository_Id
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository_Id] actually existed under Set-AutomateNOWWorkspace due to [$Message]"
                    Break
                }
                If ($code_repository_object.simpleId.Length -eq 0) {
                    Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository_Id] under Set-AutomateNOWWorkspace. Please check again."
                    Break
                }
                $BodyMetaData.'codeRepository' = $CodeRepository_Id
            }
            ElseIf ($UnsetCodeRepository -eq $true) {
                $BodyMetaData.'codeRepository' = $null
            }
            If ($iconCode.Length -gt 0) {
                $BodyMetaData.'iconCode' = $iconCode
                $BodyMetaData.'iconSet' = $iconSet
            }
            ElseIf ($RemoveIcon -eq $true) {
                $BodyMetaData.'iconCode' = $null
                $BodyMetaData.'iconSet' = $null
            }
            If ($WorkspacePrefix.Length -gt 0) {
                $BodyMetaData.'addPrefix' = 'true'
                $BodyMetaData.'prefix' = $WorkspacePrefix
            }
            ElseIf ($UnsetWorkspacePrefix -eq $true) {
                $BodyMetaData.'addPrefix' = 'false'
                $BodyMetaData.'prefix' = $null
            }
            If ($WorkspaceTagType.Length -gt 0) {
                $BodyMetaData.'setTags' = 'true'
                $BodyMetaData.'workspaceSetTagType' = $WorkspaceTagType
                If ($WorkspaceTags.Count -gt 0 -and $WorkspaceTagType -eq 'SET_SPECIFIC_TAGS') {
                    [int32]$total_tags = $Tags.Count
                    [int32]$current_tag = 1
                    ForEach ($tag_id in $Tags) {
                        $Error.Clear()
                        Try {
                            [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
                        }
                        Catch {
                            [string]$Message = $_.Exception.Message
                            Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] running under Set-AutomateNOWWorkspace (Workspace Tags) due to [$message]"
                            Break
                        }
                        If ($tag_object.simpleId.length -eq 0) {
                            Throw "Get-AutomateNOWTag has detected that the tag [$tag_id] does not appear to exist running under Set-AutomateNOWWorkspace (Workspace Tags). Please check again."
                            Break
                        }
                        ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                            [string]$tag_object_simpleId = $tag_object.simpleId
                            Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check your Workspace Tags more carefully..."
                            Break
                        }
                        [string]$tag_name_sequence = ('setWorkspaceTags' + $current_tag)
                        $BodyMetaData."$tag_name_sequence" = $tag_id
                        $current_tag++
                    }
                }
            }
            ElseIf ($UnsetWorkspaceTagType -eq $true) {
                $BodyMetaData.'setTags' = 'false'
                $BodyMetaData.'workspaceSetTagType' = $null
            }

            If ($WorkspaceFolderType.Length -gt 0) {
                $BodyMetaData.'setFolder' = 'true'
                $BodyMetaData.'workspaceSetFolderType' = $WorkspaceFolderType
                If ($WorkspaceFolder.Length -gt 0 -and $WorkspaceFolderType -eq 'SET_SPECIFIC_FOLDER') {
                    $Error.Clear()
                    Try {
                        [ANOWFolder]$workspace_folder_object = Get-AutomateNOWFolder -Id $WorkspaceFolder
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$WorkspaceFolder] actually existed under Set-AutomateNOWWorkspace (Workspace Folder) due to [$Message]"
                        Break
                    }
                    If ($workspace_folder_object.simpleId.Length -eq 0) {
                        Throw "Get-AutomateNOWFolder failed to locate the Folder [$WorkspaceFolder] under Set-AutomateNOWWorkspace (Workspace Folder). Please check again."
                        Break
                    }
                    $BodyMetaData.'setWorkspaceFolder' = $WorkspaceFolder
                }
            }
            ElseIf ($UnsetWorkspaceFolderType -eq $true) {
                $BodyMetaData.'setFolder' = 'false'
                $BodyMetaData.'workspaceSetFolderType' = $null
            }
            $BodyMetaData.'_componentId' = 'WorkspaceVM'
            $BodyMetaData.'_oldValues' = $old_values
            $BodyMetaData.'_operationType' = 'update'
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_dataSource' = 'WorkspaceDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters.Body) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Workspace_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Workspace $Workspace_id was successfully updated"
            $Error.Clear()
            Try {
                [ANOWWorkspace]$UpdatedWorkspace = $results.response.data | Select-Object -First 1
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Failed to parse the returned updated object to an [ANOWWorkspace] object due to [$Message]. The object was still updated though."
                Break
            }
            If ($Quiet -ne $true) {
                Return $UpdatedWorkspace
            }
        }
    }
    End {
    }
}

Function Export-AutomateNOWWorkspace {
    <#
    .SYNOPSIS
    Exports the Workspaces from an instance of AutomateNOW!

    .DESCRIPTION
    Exports the Workspaces from an instance of AutomateNOW! to a local .csv file

    .PARAMETER Workspace
    Mandatory [ANOWWorkspace] object (Use Get-AutomateNOWWorkspace to retrieve them)

    .INPUTS
    ONLY [ANOWWorkspace] objects from the pipeline are accepted

    .OUTPUTS
    The [ANOWWorkspace] objects are exported to the local disk in CSV format

    .EXAMPLE
    Get-AutomateNOWWorkspace | Export-AutomateNOWWorkspace

    .EXAMPLE
    Get-AutomateNOWWorkspace -Id 'Workspace01' | Export-AutomateNOWWorkspace

    .EXAMPLE
    @( 'Workspace01', 'Workspace02' ) | Get-AutomateNOWWorkspace | Export-AutomateNOWWorkspace

    .EXAMPLE
    Get-AutomateNOWWorkspace | Where-Object { $_.simpleId -eq 'Workspace01' } | Export-AutomateNOWWorkspace

    .NOTES
	You must present [ANOWWorkspace] objects to the pipeline to use this function.
    #>

    [Cmdletbinding(DefaultParameterSetName = 'Pipeline')]
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = 'Pipeline')]
        [ANOWWorkspace]$Workspace
    )
    Begin {
        [string]$current_time = Get-Date -Format 'yyyyMMddHHmmssfff'
        [string]$ExportFileName = 'Export-AutomateNOW-Workspaces-' + $current_time + '.csv'
        [string]$ExportFilePath = ((Get-Location | Select-Object -ExpandProperty Path) + '\' + $ExportFileName)
        [hashtable]$parameters = @{}
        $parameters.Add('Path', $ExportFilePath)
        $parameters.Add('Append', $true)
        If ($PSVersionTable.PSVersion.Major -eq 5) {
            $parameters.Add('NoTypeInformation', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWWorkspace]$Workspace = $_
        }
        $Error.Clear()
        Try {
            $Workspace | Export-CSV @parameters
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Export-CSV failed to export the [ANOWWorkspace] object on the pipeline due to [$Message]"
            Break
        }
    }
    End {
        $Error.Clear()
        If ((Test-Path -Path $ExportFilePath) -eq $true) {
            [System.IO.FileInfo]$fileinfo = Get-Item -Path "$ExportFilePath"
            [int32]$filelength = $fileinfo.Length
            [string]$filelength_display = "{0:N0}" -f $filelength
            Write-Information -MessageData "Created file $ExportFileName ($filelength_display bytes)"
        }
    }
}

Function New-AutomateNOWWorkspace {
    <#
    .SYNOPSIS
    Creates a Workspace within an AutomateNOW! instance

    .DESCRIPTION
    Creates a Workspace within an AutomateNOW! instance and returns back the newly created [ANOWWorkspace] object

    .PARAMETER Id
    The intended name of the Workspace. For example: 'LinuxWorkspace1'. This value may not contain the domain in brackets.

    .PARAMETER Description
    Optional description of the Workspace (may not exceed 255 characters).

    .PARAMETER Tags
    Optional string array containing the CASE-SENSITIVE id's of the tags to assign to the new Workspace.

    .PARAMETER Folder
    Optional name of the folder to place the DataSource into.

    .PARAMETER iconSet
    Mandatory string representing a choice between three icon sets. Valid choices are: FAT_COW, FUGUE, FONT_AWESOME

    .PARAMETER iconCode
    The name of the icon which matches the chosen library. Must be lower-case.

    .PARAMETER CodeRepository
    Optional name of the code repository to place the Workspace into.

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object

    .INPUTS
    None. You cannot pipe objects to New-AutomateNOWWorkspace.

    .OUTPUTS
    An [ANOWWorkspace] object representing the newly created Workspace

    .EXAMPLE
    New-AutomateNOWWorkspace -Id 'Workspace1' -Description 'Workspace1 description' -Tags 'Tag1', 'Tag2' -Folder 'Folder1' -iconSet 'FAT_COW' -iconCode 'paper_airplane' -codeRepository 'Repository1'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    The name (id) of the Workspace must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    The names of the icon is not enforced here! If you want to know the names of the available icons try: Import-AutomateNOWLocalIcon; $anow_assets.icon_library.FUGUE;

    #>
    [OutputType([ANOWWorkspace])]
    [Cmdletbinding(DefaultParameterSetName = 'Default')]
    Param(
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,}$' })]
        [Parameter(Mandatory = $true, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $true, ParameterSetName = 'iconSet')]
        [string]$Id,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'iconSet', HelpMessage = "Enter a descriptive string up to 255 characters (UTF8 compatible)")]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'iconSet')]
        [string[]]$Tags,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'iconSet')]
        [string]$Folder,
        [Parameter(Mandatory = $true, ParameterSetName = 'iconSet')]
        [ANOWIcon_IconsOnly]$iconSet,
        [ValidateScript({ $_ -match '^[a-z0-9-_]{1,}$' })]
        [Parameter(Mandatory = $true, ParameterSetName = 'iconSet')]
        [string]$iconCode,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'iconSet')]
        [string]$CodeRepository,
        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'iconSet')]
        [switch]$Quiet
    )
    If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
        Write-Warning -Message "Somehow there is not a valid token confirmed."
        Break
    }
    ## Begin warning ##
    ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
    $Error.Clear()
    Try {
        [boolean]$Workspace_exists = ($null -ne (Get-AutomateNOWWorkspace -Id $Id))
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Get-AutomateNOWWorkspace failed to check if the Workspace [$Id] already existed due to [$Message]."
        Break
    }
    If ($Workspace_exists -eq $true) {
        [string]$current_domain = $anow_session.header.domain
        Write-Warning -Message "There is already a Workspace named [$Id] in [$current_domain]. Please check into this."
        Break
    }
    ## End warning ##
    [System.Collections.Specialized.OrderedDictionary]$ANOWWorkspace = [System.Collections.Specialized.OrderedDictionary]@{}
    $ANOWWorkspace.Add('id', $Id)
    If ($Description.Length -gt 0) {
        $ANOWWorkspace.Add('description', $Description)
    }
    If ($Tags.Count -gt 0) {
        [int32]$total_tags = $Tags.Count
        [int32]$current_tag = 1
        ForEach ($tag_id in $Tags) {
            $Error.Clear()
            Try {
                [ANOWTag]$tag_object = Get-AutomateNOWTag -Id $tag_id
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Get-AutomateNOWTag had an error while retrieving the tag [$tag_id] under New-AutomateNOWWorkspace due to [$message]"
                Break
            }
            If ($tag_object.simpleId.length -eq 0) {
                Throw "New-AutomateNOWWorkspace has detected that the tag [$tag_id] does not appear to exist. Please check again."
                Break
            }
            ElseIf ($tag_object.simpleId -eq $tag_id -and $tag_object.simpleId -cne $tag_id) {
                [string]$tag_object_simpleId = $tag_object.simpleId
                Throw "Wait! Tags are case-sensitive. [$tag_object_simpleId] is not the same case as [$tag_id]. Please check more carefully..."
                Break
            }
            [string]$tag_display = $tag_object | ConvertTo-Json -Compress
            Write-Verbose -Message "Adding tag $tag_display [$current_tag of $total_tags]"
            [string]$tag_name_sequence = ('tags' + $current_tag)
            $ANOWWorkspace.Add($tag_name_sequence, $tag_id)
            $include_properties += $tag_name_sequence
            $current_tag++
        }
    }
    If ($Folder.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWFolder]$folder_object = Get-AutomateNOWFolder -Id $Folder
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWFolder failed to confirm that the folder [$Folder] actually existed under New-AutomateNOWWorkspace due to [$Message]"
            Break
        }
        If ($folder_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWFolder failed to locate the Folder [$Folder] under New-AutomateNOWWorkspace. Please check again."
            Break
        }
        [string]$folder_display = $folder_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding folder $folder_display to [ANOWWorkspace] [$Id]"
        $ANOWWorkspace.Add('folder', $Folder)
        $include_properties += 'folder'
    }
    If ($CodeRepository.Length -gt 0) {
        $Error.Clear()
        Try {
            [ANOWCodeRepository]$code_repository_object = Get-AutomateNOWCodeRepository -Id $CodeRepository
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWCodeRepository failed to confirm that the code repository [$CodeRepository] actually existed under New-AutomateNOWWorkspace due to [$Message]"
            Break
        }
        If ($code_repository_object.simpleId.Length -eq 0) {
            Throw "Get-AutomateNOWCodeRepository failed to locate the Code Repository [$CodeRepository] under New-AutomateNOWWorkspace. Please check again."
            Break
        }
        [string]$code_repository_display = $code_repository_object | ConvertTo-Json -Compress
        Write-Verbose -Message "Adding code repository $code_repository_display to [ANOWWorkspace] [$Id]"
        $ANOWWorkspace.Add('codeRepository', $CodeRepository)
        $include_properties += 'codeRepository'
    }
    If ($iconSet.Length -gt 0) {
        $ANOWWorkspace.'iconSet' = $iconSet
    }
    If ($iconCode.Length -gt 0) {
        $ANOWWorkspace.'iconCode' = $iconCode
    }
    [string]$BodyObject = ConvertTo-QueryString -InputObject $ANOWWorkspace -IncludeProperties id, description, tags, folder, codeRepository, iconSet, iconCode
    [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
    $BodyMetaData.'_operationType' = 'add'
    $BodyMetaData.'_textMatchStyle' = 'exact'
    $BodyMetaData.'_oldValues' = '{}'
    $BodyMetaData.'_componentId' = 'WorkspaceCreateWindow_form'
    $BodyMetaData.'_dataSource' = 'WorkspaceDataSource'
    $BodyMetaData.'isc_metaDataPrefix' = '_'
    $BodyMetaData.'isc_dataFormat' = 'json'
    [string]$BodyMetaDataString = ConvertTo-QueryString -InputObject $BodyMetaData
    [string]$Body = ($BodyObject + '&' + $BodyMetaDataString)
    [string]$command = '/workspace/create'
    [hashtable]$parameters = @{}
    $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
    $parameters.Add('Command', $command)
    $parameters.Add('Method', 'POST')
    $parameters.Add('Body', $Body)
    If ($anow_session.NotSecure -eq $true) {
        $parameters.Add('NotSecure', $true)
    }
    [string]$parameters_display = $parameters | ConvertTo-Json -Compress
    $Error.Clear()
    Try {
        [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] with parameters $parameters_display due to [$Message]."
        Break
    }
    [int32]$response_code = $results.response.status
    If ($response_code -ne 0) {
        [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
        Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
        Break
    }
    $Error.Clear()
    Try {
        [ANOWWorkspace]$Workspace = $results.response.data | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Failed to create [ANOWWorkspace] object due to [$Message]."
        Break
    }
    If ($Workspace.id.Length -eq 0) {
        Write-Warning -Message "Somehow the newly created [ANOWWorkspace] object is empty!"
        Break
    }
    Return $Workspace

}

Function Remove-AutomateNOWWorkspace {
    <#
    .SYNOPSIS
    Removes a Workspace from an AutomateNOW! instance

    .DESCRIPTION
    Removes a Workspace from an AutomateNOW! instance

    .PARAMETER Workspace
    An [ANOWWorkspace] object representing the Workspace to be deleted.

    .PARAMETER Force
    Force the removal without confirmation. This is equivalent to -Confirm:$false

    .INPUTS
    ONLY [ANOWWorkspace] objects are accepted (including from the pipeline)

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Get-AutomateNOWWorkspace -Id 'Workspace01' | Remove-AutomateNOWWorkspace

    .EXAMPLE
    @( 'Workspace1', 'Workspace2', 'Workspace3') | Remove-AutomateNOWWorkspace

    .EXAMPLE
    Get-AutomateNOWWorkspace | ? { $_.simpleId -like 'test*' } | Remove-AutomateNOWWorkspace

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $false, ValueFromPipeline = $True)]
        [ANOWWorkspace]$Workspace,
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        [string]$command = '/workspace/delete'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($_.id.Length -gt 0) {
            [ANOWWorkspace]$Workspace = $_
        }
        [string]$Workspace_id = $Workspace.id
        If ($Workspace_id.Length -eq 0) {
            Write-Warning -Message "Somehow an object with an empty Id was passed to this function. Please look into this."
            Break
        }
        If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Workspace_id)")) -eq $true) {
            [string]$oldvalues = $Workspace.CreateOldValues()
            [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
            $BodyMetaData.'id' = $Workspace_id
            $BodyMetaData.'_textMatchStyle' = 'exact'
            $BodyMetaData.'_operationType' = 'remove'
            $BodyMetaData.'_oldValues' = $oldvalues
            $BodyMetaData.'_componentId' = 'WorkspaceList'
            $BodyMetaData.'_dataSource' = 'WorkspaceDataSource'
            $BodyMetaData.'isc_metaDataPrefix' = '_'
            $BodyMetaData.'isc_dataFormat' = 'json'
            [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData
            If ($null -eq $parameters["Body"]) {
                $parameters.Add('Body', $Body)
            }
            Else {
                $parameters.Body = $Body
            }
            $Error.Clear()
            Try {
                [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
            }
            Catch {
                [string]$Message = $_.Exception.Message
                Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Workspace_id] due to [$Message]."
                Break
            }
            [int32]$response_code = $results.response.status
            If ($response_code -ne 0) {
                [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                Break
            }
            Write-Verbose -Message "Workspace $Workspace_id successfully removed"
        }
    }
    End {

    }
}

Function Copy-AutomateNOWWorkspace {
    <#
    .SYNOPSIS
    Copies a Workspace from an AutomateNOW! instance

    .DESCRIPTION
    Copies a Workspace from an AutomateNOW! instance. AutomateNOW object id can never be changed, but we can copy the Workspace to a new object with a new Id and it will include all of the settings but not the items.

    .PARAMETER Workspace
    Mandatory [ANOWWorkspace] object to be copied.

    .PARAMETER NewId
    The name (Id) of the new Workspace. The new Id must be unique (per domain). It may consist only of letters, numbers, underscore, dot or hyphen.

    .PARAMETER UnsetDescription
    Optional switch that will ensure that the newly created Workspace will not have a description set.

    .PARAMETER Description
    Optional description to set on the new Workspace object. If you do not set this, the new Workspace object will copy the Description of the source object.

    .PARAMETER UnsetFolder
    Optional switch that will ensure that the newly created Workspace will not have a Folder set.

    .PARAMETER Folder
    Optional description to set a different folder on the new Workspace object. If you do not set this, the new Workspace object will use the same Folder of the source object.

    .PARAMETER UnsetTags
    Optional switch that will ensure that the newly created Workspace will not have any Tags set.

    .PARAMETER Tags
    Optional string array of CASE-SENSITIVE Tag Id's to set on the new Workspace object. If you do not set this, the new Workspace object will apply the same Tags of the source object.

    .PARAMETER Force
    Force the copy without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly created object.

    .INPUTS
    ONLY [ANOWWorkspace] object is accepted. Pipeline support is intentionally unavailable.

    .OUTPUTS
    None. The status will be written to the console with Write-Verbose.

    .EXAMPLE
    Creates a copy of an Workspace and changes the description (multi-line format)
    $Workspace01 = Get-AutomateNOWWorkspace -Id 'Workspace_01'
    Copy-AutomateNOWWorkspace -Workspace $Workspace01 -NewId 'Workspace_01_production' -Description 'Workspace 01 Production'

    .EXAMPLE
    Creates a copy of an Workspace that omits the description (one-liner format)
    Copy-AutomateNOWWorkspace -Workspace (Get-AutomateNOWWorkspace -Id 'Workspace_01') -NewId 'Workspace_01_production' -UnsetDescription -Tags 'Tag1', 'Tag2'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    #>
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWWorkspace]$Workspace,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_.Length -le 255 })]
        [string]$Description,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetDescription,
        [Parameter(Mandatory = $false)]
        [string[]]$Tags,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetTags,
        [Parameter(Mandatory = $false)]
        [string]$Folder,
        [Parameter(Mandatory = $false)]
        [switch]$UnsetFolder,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        If ($UnsetDescription -eq $true -and $Description.Length -gt 0) {
            Write-Warning -Message "You cannot set the description and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetFolder -eq $true -and $Folder.Length -gt 0) {
            Write-Warning -Message "You cannot set the Folder and unset it at the same time. Please choose one or the other."
            Break
        }
        If ($UnsetTags -eq $true -and $Tags.Count -gt 0) {
            Write-Warning -Message "You cannot set the Tags and unset them at the same time. Please choose one or the other. Tags from the source object will be carried over to the new object if you do not specify any tag-related parameters."
            Break
        }
        ## Begin warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$Workspace_exists = ($null -ne (Get-AutomateNOWWorkspace -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWWorkspace failed to check if the Workspace [$NewId] already existed due to [$Message]."
            Break
        }
        If ($Workspace_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Workspace named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End warning ##
        [string]$command = '/workspace/copy'
        [hashtable]$parameters = @{}
        $parameters.Add('Command', $command)
        $parameters.Add('Method', 'POST')
        $parameters.Add('ContentType', 'application/x-www-form-urlencoded; charset=UTF-8')
        If ($anow_session.NotSecure -eq $true) {
            $parameters.Add('NotSecure', $true)
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            [string]$Workspace_oldId = $Workspace.id
            [string]$Workspace_simpleId = $Workspace.simpleId
            If ($Workspace_oldId -eq $NewId) {
                Write-Warning -Message "The new id cannot be the same as the old id."
                Break
            }
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("Copy the Workspace $($Workspace_simpleId) to $($NewId)?")) -eq $true) {
                [System.Collections.Specialized.OrderedDictionary]$BodyMetaData = [System.Collections.Specialized.OrderedDictionary]@{}
                If ($UnsetFolder -eq $True) {
                    $BodyMetaData.'folder' = $Null
                }
                ElseIf ($Folder.Length -gt 0) {
                    $BodyMetaData.'folder' = $Folder
                }
                Else {
                    If ($Workspace.folder.Length -gt 0) {
                        $BodyMetaData.'folder' = $Workspace.folder
                    }
                }
                If ($Tags.Count -gt 0) {
                    [int32]$tag_count = 1
                    ForEach ($tag in $Tags) {
                        $BodyMetaData.('tags' + $tag_count ) = $tag
                        $tag_count++
                    }
                }
                ElseIf ($UnsetTags -eq $true) {
                    $BodyMetaData.'tags' = $Null
                }
                Else {
                    If ($Workspace.Tags -gt 0) {
                        [int32]$tag_count = 1
                        ForEach ($tag in $Workspace.tags) {
                            $BodyMetaData.('tags' + $tag_count ) = $tag
                            $tag_count++
                        }
                    }
                }
                $BodyMetaData.'oldId' = $Workspace_oldId
                $BodyMetaData.'domain' = $Workspace.domain
                $BodyMetaData.'id' = $NewId
                If ($UnsetDescription -ne $true) {
                    If ($Description.Length -gt 0) {
                        $BodyMetaData.'description' = $Description
                    }
                    Else {
                        $BodyMetaData.'description' = $Workspace.description
                    }
                }
                $BodyMetaData.'_operationType' = 'add'
                $BodyMetaData.'_operationId' = 'copy'
                $BodyMetaData.'_textMatchStyle' = 'exact'
                $BodyMetaData.'_dataSource' = 'WorkspaceDataSource'
                $BodyMetaData.'isc_metaDataPrefix' = '_'
                $BodyMetaData.'isc_dataFormat' = 'json'
                [string]$Body = ConvertTo-QueryString -InputObject $BodyMetaData -IncludeProperties oldId, domain, NewId, description, folder, tags
                $parameters.Body = $Body
                $Error.Clear()
                Try {
                    [PSCustomObject]$results = Invoke-AutomateNOWAPI @parameters
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Invoke-AutomateNOWAPI failed to execute [$command] on [$Workspace_oldId] due to [$Message]."
                    Break
                }
                [int32]$response_code = $results.response.status
                If ($response_code -ne 0) {
                    [string]$full_response_display = $results.response | ConvertTo-Json -Compress -Depth 10
                    Write-Warning -Message "Somehow the response code was not 0 but was [$response_code]. Please look into this. Body: $full_response_display"
                    Break
                }
                $Error.Clear()
                Try {
                    [ANOWWorkspace]$NewWorkspace = $results.response.data | Select-Object -First 1
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to create copied [ANOWWorkspace] object [$NewId] due to [$Message]."
                    Break
                }
                If ($NewWorkspace.id.Length -eq 0) {
                    Write-Warning -Message "Somehow the newly created (copied) [ANOWWorkspace] object [$NewId] is empty!"
                    Break
                }
                If ($Quiet -ne $true) {
                    Return $NewWorkspace
                }
            }
        }
    }
    End {

    }
}

Function Rename-AutomateNOWWorkspace {
    <#
    .SYNOPSIS
    Renames a Workspace on an AutomateNOW! instance

    .DESCRIPTION
    Performs a psuedo-rename operations of a Workspace from an AutomateNOW! instance by copying it first and then deleting the source. This function merely combines Copy-AutomateNOWWorkspace and Remove-AutomateNOWWorkspace therefore it is to be considered destructive.

    .PARAMETER Workspace
    An [ANOWWorkspace] object representing the Workspace to be renamed.

    .PARAMETER NewId
    Mandatory string indicating the new id or name of the Workspace. The Id is the same as a primary key, it must be unique. The console will provide the old Id + '_COPY' in the UI when making a copy. The Id is limited to 1024 characters.

    .PARAMETER Force
    Force the renaming without confirmation. This is equivalent to -Confirm:$false

    .PARAMETER Quiet
    Optional switch to suppress the return of the newly renamed object.

    .INPUTS
    ONLY [ANOWWorkspace] objects are accepted. There is intentionally no support for the pipeline.

    .OUTPUTS
    The newly renamed [ANOWWorkspace] object will be returned.

    .EXAMPLE
    $Workspace = Get-AutomateNOWWorkspace -Id 'Workspace01'
    Rename-AutomateNOWWorkspace -Workspace $Workspace -NewId 'Workspace_01'

    .EXAMPLE
    Rename-AutomateNOWWorkspace -Workspace (Get-AutomateNOWWorkspace -Id 'Workspace01') -NewId 'Workspace_01'

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.

    When renaming, you may only specify a different Id (name).

    This action will be blocked if any existing referrals are found on the object.
    #>
    [OutputType([ANOWWorkspace])]
    [Cmdletbinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    Param(
        [Parameter(Mandatory = $true)]
        [ANOWWorkspace]$Workspace,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ $_ -match '^[0-9a-zA-z_.-]{1,1024}$' })]
        [string]$NewId,
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )
    Begin {
        If ((Confirm-AutomateNOWSession -Quiet) -ne $true) {
            Write-Warning -Message "Somehow there is not a valid token confirmed."
            Break
        }
        ## Begin standard warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [boolean]$new_Workspace_exists = ($null -ne (Get-AutomateNOWWorkspace -Id $NewId))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWWorkspace failed to check if the Workspace [$NewId] already existed due to [$Message]."
            Break
        }
        If ($new_Workspace_exists -eq $true) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is already a Workspace named [$NewId] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        #[string]$Workspace_id = $Workspace.id
        [string]$Workspace_id = $Workspace.simpleId
        $Error.Clear()
        Try {
            [boolean]$old_Workspace_exists = ($null -ne (Get-AutomateNOWWorkspace -Id $Workspace_id))
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Get-AutomateNOWWorkspace failed to check if the Workspace [$Workspace_id] already existed due to [$Message]."
            Break
        }
        If ($old_Workspace_exists -eq $false) {
            [string]$current_domain = $anow_session.header.domain
            Write-Warning -Message "There is not a Workspace named [$Workspace_id] in [$current_domain]. You may not proceed."
            [boolean]$PermissionToProceed = $false
        }
        ## End standard warning ##
        ## Begin referrals warning ##
        ## Do not tamper with this below code which makes sure that the object exists before attempting to change it.
        $Error.Clear()
        Try {
            [int32]$referrals_count = Find-AutomateNOWObjectReferral -Workspace $Workspace -Count | Select-Object -Expandproperty referrals
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Find-AutomateNOWObjectReferral failed to extract the referrals on Workspace [$Workspace_id] due to [$Message]."
            Break
        }
        If ($referrals_count -gt 0) {
            Write-Warning -Message "Unfortunately, you cannot rename a Workspace that has referrals. This is because the rename is not actually renaming but copying anew and deleting the old. Please, use the Find-AutomateNOWObjectReferral function to identify referrals and remove them."
            Break
        }
        Else {
            Write-Verbose -Message "The Workspace [$Workspace_id] does not have any referrals. It is safe to proceed."
        }
    }
    Process {
        If ($PermissionToProceed -ne $false) {
            If (($Force -eq $true) -or ($PSCmdlet.ShouldProcess("$($Workspace_id)")) -eq $true) {
                $Error.Clear()
                Try {
                    [ANOWWorkspace]$new_Workspace = Copy-AutomateNOWWorkspace -Workspace $Workspace -NewId $NewId -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Copy-AutomateNOWWorkspace failed to create a new Workspace [$NewId] as Part 1 of the renaming process due to [$Message]."
                    Break
                }
                If ($new_Workspace.simpleId -eq $NewId) {
                    Write-Verbose -Message "Part 1: Workspace [$Workspace_id] successfully copied to [$NewId]"
                }
                Else {
                    Write-Warning -Message "Somehow the first phase (Copy-AutomateNOWWorkspace) failed. Please look into this."
                    Break
                }
                $Error.Clear()
                Try {
                    Remove-AutomateNOWWorkspace -Workspace $Workspace -Force
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Remove-AutomateNOWWorkspace failed to remove [$Workspace_id] as Part 2 of the renaming process due to [$Message]."
                    Break
                }
                Write-Verbose -Message "Part 2: Workspace [$Workspace_id] removed"
                Write-Verbose -Message "Task [$Workspace_id] successfully renamed to [$NewId]"
                If ($Quiet -ne $true) {
                    Return $new_Workspace
                }
            }
        }
        Else {
            Write-Warning -Message "No action was taken because either the source object didn't exist or the new object already existed"
        }
    }
    End {
    }
}

#endregion

#EndRegion

#Region = API Functions =

Function Invoke-AutomateNOWAPI {
    <#
    .SYNOPSIS
    Invokes the API of an AutomateNOW instance

    .DESCRIPTION
    The `Invoke-AutomateNOWAPI` cmdlet sends API commands (in the form of HTTPS requests) to an instance of AutomateNOW. It returns the results in either JSON or PSCustomObject.

    .PARAMETER Command
    Specifies the command to invoke with the API call. The value must begin with a forward slash. For example: /secUser/getUserInfo

    .PARAMETER Method
    Specifies the method to use with the API call. Valid values are GET and POST.

    .PARAMETER Headers
    Optional hashtable to add headers.

    .PARAMETER NotSecure
    Switch parameter to accomodate instances using the http protocol. Only use this if the instance is on http and not https.

    .PARAMETER Body
    Specifies the body object. The format will depend on what you have for content type. Usually, this is a string or a hashtable.

    .PARAMETER BinaryBody
    Specifies a byte array for the body. This is used for uploading files.

    .PARAMETER ContentType
    Specifies the content type of the body (only needed if a body is included)

    .PARAMETER Instance
    Specifies the name of the AutomateNOW instance. For example: s2.infinitedata.com

    .PARAMETER JustGiveMeJSON
    Switch parameter to return the results in a JSON string instead of a PSCustomObject

    .PARAMETER NotAPICommand
    Rarely used switch parameter that removes the '/api' portion of the API URL. Note: This parameter is slated for removal

    .PARAMETER NoHeaders
    Rarely used switch parameter that prevents the standard authorization bearer header from being included. This is normally used when requesting to download a file from the API.

    .PARAMETER IncludeAttachmentFilename
    Rarely used switch parameter that will include a 2nd object (string) with the usual response object. This is normally used when requesting to download a file from the API.

    .INPUTS
    None. You cannot pipe objects to Invoke-AutomateNOWAPI (yet).

    .OUTPUTS
    The corresponding ANOW Data Source Item type is returned (e.g. a local dictionary store item)

    .EXAMPLE
    Invoke-AutomateNOWAPI -command '/secUser/getUserInfo' -method GET

    .NOTES
    You must use Connect-AutomateNOW to establish the token by way of global variable.
    #>

    [CmdletBinding()]
    Param(
        [Parameter(Mandatory = $true)]
        [string]$Command,
        [Parameter(Mandatory = $true)]
        [ValidateSet('GET', 'POST')]
        [string]$Method,
        [Parameter(Mandatory = $false)]
        [hashtable]$Headers,
        [Parameter(Mandatory = $false)]
        [switch]$NotSecure = $false,
        [Parameter(Mandatory = $false)]
        [string]$Body,
        [Parameter(Mandatory = $false)]
        [byte[]]$BinaryBody,
        [Parameter(Mandatory = $false)]
        [string]$ContentType = 'application/json',
        [Parameter(Mandatory = $false)]
        [string]$Instance,
        [Parameter(Mandatory = $false)]
        [switch]$JustGiveMeJSON,
        [Parameter(Mandatory = $false)]
        [switch]$NotAPICommand = $false,
        [Parameter(Mandatory = $false)]
        [switch]$NoHeaders = $false,
        [Parameter(Mandatory = $false)]
        [switch]$IncludeAttachmentFilename = $false
    )
    If ($anow_session.header.values.count -eq 0 -or $anow_session.Instance.Length -eq 0) {
        Write-Warning -Message "Please use Connect-AutomateNOW to establish your access token."
        Break
    }
    ElseIf ($anow_session.header.Authorization -notmatch '^Bearer [a-zA-Z-_:,."0-9]{1,}$') {
        [string]$malformed_token = $anow_session.header.values
        Write-Warning -Message "Somehow the access token is not in the expected format. Please contact the author with this apparently malformed token: $malformed_token"
        Break
    }
    ElseIf ($command -notmatch '^/.{1,}') {
        Write-Warning -Message "Please prefix the command with a forward slash (for example: /secUser/getUserInfo)."
        Break
    }
    If ($Instance.Length -eq 0) {
        [string]$Instance = $anow_session.Instance
    }
    If ($Body.Length -gt 0 -and $BinaryBody.Count -gt 0) {
        Write-Warning -Message "You cannot specify a binary body and a text body. Please choose one or the other."
        Break
    }
    If ($Headers.keys.count -gt 0 -and $NoHeaders -eq $true) {
        Write-Warning -Message "You cannot specify -Headers and -NoHeaders. Please choose one or the other."
        Break
    }
    [hashtable]$parameters = @{}
    If ($NotSecure -eq $true) {
        [string]$protocol = 'http'
    }
    Else {
        [string]$protocol = 'https'
    }
    [int64]$ps_version_major = $PSVersionTable.PSVersion.Major
    $parameters.Add('UseBasicParsing', $true)
    If ($ps_version_major -gt 5) {
        If ($protocol -eq 'http') {
            $parameters.Add('SkipCertificateCheck', $true)
        }
    }
    If ($ps_version_major -lt 5) {
        Write-Warning -Message "Please use either Windows PowerShell 5.x or PowerShell Core. This module is not compatible with Windows PowerShell below version 5."
        Break
    }
    If ($NotAPICommand -ne $true) {
        [string]$api_url = ($protocol + '://' + $instance + '/automatenow/api' + $command)
    }
    Else {
        [string]$api_url = ($protocol + '://' + $instance + '/automatenow' + $command)
    }
    $parameters.Add('Uri', $api_url)
    If ($Headers.Keys.count -gt 0) {
        $Headers.Add('domain', $anow_session.header.domain)
        $Headers.Add('Authorization', $anow_session.header.Authorization)
        $parameters.Add('Headers', $Headers)
    }
    Else {
        If ($NoHeaders -ne $true) {
            $parameters.Add('Headers', $anow_session.header)
        }
    }
    $parameters.Add('Method', $Method)
    $parameters.Add('ContentType', $ContentType)
    If ($Body.Length -gt 0) {
        Write-Verbose -Message "Sending body: $Body"
        If ($Method -eq 'GET') {
            [string]$api_url = $api_url + '?' + $Body
        }
        Else {
            $parameters.Add('Body', $Body)
        }
    }
    ElseIf ($BinaryBody.Count -gt 0) {
        $parameters.Add('Body', $BinaryBody)
    }
    If ($anow_session.Proxy.Length -gt 0) {
        $parameters.Add('Proxy', $anow_session.Proxy)
        [int32]$ps_version_major = $PSVersionTable.PSVersion.Major
        If ($ps_version_major -eq 5) {
            # The below C# code provides the equivalent of the -SkipCertificateCheck parameter for Windows PowerShell 5.1 Invoke-WebRequest
            If (($null -eq ("TrustAllCertsPolicy" -as [type])) -and ($protocol -eq 'http')) {
                [string]$certificate_policy = @"
                using System.Net;
                using System.Security.Cryptography.X509Certificates;
                public class TrustAllCertsPolicy : ICertificatePolicy {
                    public bool CheckValidationResult(
                        ServicePoint srvPoint, X509Certificate certificate,
                        WebRequest request, int certificateProblem) {
                        return true;
                    }
                }
"@
                $Error.Clear()
                Try {
                    Add-Type -TypeDefinition $certificate_policy
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Add-Type failed to add the custom certificate policy due to [$Message]"
                    Break
                }
                $Error.Clear()
                Try {
                    [System.Net.ServicePointManager]::CertificatePolicy = New-Object -TypeName TrustAllCertsPolicy
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "New-Object failed to create a new 'TrustAllCertsPolicy' CertificatePolicy object due to [$Message]."
                    Break
                }
            }
            $parameters.Add('UseBasicParsing', $true)
        }
        ElseIf ( $ps_version_major -gt 5) {
            $parameters.Add('SkipCertificateCheck', $true)
        }
        Else {
            Write-Warning -Message "Please use either Windows PowerShell 5.1 or PowerShell Core."
            Break
        }
    }
    [string]$parameters_debug_display = $parameters | ConvertTo-Json
    Write-Debug -Message "Sending the following parameters to $api_url -> $parameters_debug_display."
    [string]$parameters_verbose_display = $parameters | Select-Object -ExcludeProperty $Headers | ConvertTo-Json
    Write-Verbose -Message "Sending the following parameters to $api_url -> $parameters_verbose_display."
    $ProgressPreference = 'SilentlyContinue'
    $Error.Clear()
    Try {
        [Microsoft.PowerShell.Commands.BasicHtmlWebResponseObject]$results = Invoke-WebRequest @parameters
    }
    Catch {
        [string]$Message = $_.Exception.Message
        If ($Message -match '(The underlying connection was closed|The SSL connection could not be established)') {
            Write-Warning -Message 'Please try again with the -NotSecure parameter if you are connecting to an insecure instance.'
            Break
        }
        ElseIf ($Message -match 'Response status code does not indicate success:') {
            $Error.Clear()
            Try {
                [int32]$return_code = $Message -split 'success: ' -split ' ' | Select-Object -Last 1 -Skip 1
            }
            Catch {
                [string]$Message2 = $_.Exception.Message
                Write-Warning -Message "Unable to extract the error code from [$Message] due to [$Message2]"
                Break
            }
        }
        ElseIf ($Message -match 'The remote server returned an error: ') {
            $Error.Clear()
            Try {
                [int32]$return_code = $Message -split '\(' -split '\)' | Select-Object -Skip 1 -First 1
            }
            Catch {
                [string]$Message2 = $_.Exception.Message
                Write-Warning -Message "Unable to extract the error code from [$Message] due to [$Message2]"
                Break
            }
        }
        ElseIf ($Message -match 'value of type "Microsoft.PowerShell.Commands.WebResponseObject" to type "Microsoft.PowerShell.Commands.BasicHtmlWebResponseObject"') {
            Write-Warning -Message "Detected a WebResponseObject was returned instead of the expected BasicHtmlWebResponseObject... Will try again for WebResponseObject."
            $Error.Clear()
            Try {
                [Microsoft.PowerShell.Commands.WebResponseObject]$results = Invoke-WebRequest @parameters
            }
            Catch {
                [string]$Message2 = $_.Exception.Message
                Write-Warning -Message "Invoke-WebRequest failed to failover to due WebResponseObject object due to [$Message2]"
                Break
            }
            [int32]$return_code = 0
            [string]$received_payload_type = (($results.content | Select-Object -First 1).GetType()).Name
            If ($received_payload_type -eq 'Byte') {
                [string]$converted_content = [System.Text.Encoding]::UTF8.GetString($results.content)
            }
        }
        Else {
            [string]$ReturnCodeWarning = "Invoke-WebRequest failed for unknown reasons under Invoke-AutomateNOWAPI due to [$Message]. This is not normal (at this point) to fail like this so you should check for possible performance problems on the ANOW instance or something else unexpected. Here are the parameters that were sent: $parameters_debug_display"
            Write-Warning -Message $ReturnCodeWarning
            Break
        }
        If ($return_code -gt 0) {
            [string]$ReturnCodeWarning = Switch ($return_code) {
                401 { "You received HTTP Code $return_code (Unauthorized). HAS YOUR TOKEN EXPIRED? ARE YOU ON THE CORRECT DOMAIN? :-)" }
                403 { "You received HTTP Code $return_code (Forbidden). DO YOU MAYBE NOT HAVE PERMISSION TO THIS? [$command]" }
                404 { "You received HTTP Code $return_code (Page Not Found). ARE YOU SURE THIS ENDPOINT REALLY EXISTS? [$command]" }
                Default { "You received HTTP Code $return_code instead of '200 OK'. Apparently, something is wrong..." }
            }
            Write-Warning -Message $ReturnCodeWarning
            Break
        }
    }
    $ProgressPreference = 'Continue'
    If ($converted_content.Length -eq 0) {
        [string]$content = $results.Content
    }
    Else {
        [string]$content = $converted_content
    }
    If ($IncludeAttachmentFilename -eq $true) {
        [string]$outgoing_filename = $results.headers.'Content-Disposition' -replace 'attachment; filename=' -replace '"'
    }
    If ($JustGiveMeJSON -eq $true) {
        If ($IncludeAttachmentFilename -ne $true) {
            Return $content
        }
        Else {
            Return $content, $outgoing_filename
        }
    }
    $Error.Clear()
    If ($BinaryBody.Count -eq 0) {
        Try {
            [PSCustomObject]$content_object = $content | ConvertFrom-JSON
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Verbose -Message "ConvertFrom-JSON failed to convert the returned results due to [$Message]. Let's try to deserialize as a backup option..."
            If ($ps_version_major -eq 5) {
                $Error.Clear()
                Try {
                    [int32]$system_web_extensions_type_present = [System.AppDomain]::CurrentDomain.GetAssemblies() | Where-Object { $_.ManifestModule.Name -eq 'System.Web.Extensions.dll' } | Measure-Object | Select-Object -ExpandProperty Count
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "The [System.AppDomain] class failed to invoke the due to CurrentDomain.GetAssemblies method due to [$Message]"
                    Break
                }
                If ($system_web_extensions_type_present -eq 0) {
                    $Error.Clear()
                    Try {
                        Add-Type -TypeDefinition System.Web.Extensions
                    }
                    Catch {
                        [string]$Message = $_.Exception.Message
                        Write-Warning -Message "Add-Type failed to add System.Web.Extensions due to [$Message]"
                        Break
                    }
                }
                $Error.Clear()
                Try {
                    [Web.Script.Serialization.JavaScriptSerializer]$serializer = [Web.Script.Serialization.JavaScriptSerializer]::new()
                    $serializer.MaxJsonLength = 2147483647 # this is the maximum value for int32
                    $serializer.RecursionLimit = 2147483647 # this is the maximum value for int32
                    [hashtable]$content_hashtable = $serializer.Deserialize($content, [hashtable])
                    [PSCustomObject]$content_object = $content_hashtable
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "Failed to deserialize a difficult payload due to [$Message]. Parameters used: $parameters_display"
                    Break
                }
                Write-Verbose -Message "Success! The deserialization in Windows PowerShell worked. We are able to continue..."
            }
            Else {
                $Error.Clear()
                Try {
                    [PSCustomObject]$content_object = $content | ConvertFrom-JSON -AsHashtable
                }
                Catch {
                    [string]$Message = $_.Exception.Message
                    Write-Warning -Message "ConvertFrom-JSON with the -AsHashTable parameter still failed to convert the returned results due to [$Message]. This is the end of the road. Please look into what happened."
                    Break
                }
                Write-Verbose -Message "Success! The deserialization in PowerShell Core worked. We are able to continue..."
            }
        }
    }
    Else {
        [string]$content = $content -split "`n" -match 'messageType' | Select-Object -First 1
        If ($content.Length -eq 0) {
            Write-Warning -Message "Somehow the returned content lacked a messageType after a binary payload was sent under Invoke-AutomateNOWAPI"
            Break
        }
        [string]$content = $content.Trim()
        [PSCustomObject]$content_object = $content | ConvertFrom-Json -Depth 100
        If ($content_object.response.status -ne 0) {
            [int32]$response_code = $content_object.response.status
            [string]$message = $content_object.response.data
            Write-Warning -Message "The ANOW API returned a response code [$response_code] due to [$message] in response to a sent binary payload."
            Break
        }
        [string]$MessageType = $content_object.messageType
        Write-Verbose -Message "The ANOW API acknowledged receipt of the binary payload with a response code of 0 and a message of [$MessageType]"
        Return 0
    }
    If ($IncludeAttachmentFilename -ne $true) {
        Return $content_object
    }
    Else {
        Return $content_object, $outgoing_filename
    }
}

#EndRegion

#Region = Utility Functions =

Function Compare-ObjectProperty {
    <#
    .SYNOPSIS
        Compares two objects property by property.
    .DESCRIPTION
        Compares two objects property by property. A simple Compare-Object only compares those properties with the same name in the two objects.
    .PARAMETER ReferenceObject
        The first object to compare
    .PARAMETER DifferenceObject
        The second object to compare
    .EXAMPLE
        $a = New-Object psobject -Prop ([ordered] @{ One = 1; Two = 2})
        $b = New-Object psobject -Prop ([ordered] @{ One = 1; Two = 2; Three = 3})

        Compare-Object $a $b

        # would return $null because it only compares the properties that have common names but

        Compare-ObjectProperty $a $b

        # would return below because it compares the two objects property by property

        PropertyName RefValue DiffValue
        ------------ -------- ---------
        Three 3
    .OUTPUTS
        [psobject]
    .LINK
        https://github.com/riedyw/PoshFunctions
    #>

    #region Parameters
    [CmdletBinding(ConfirmImpact = 'None')]
    [outputtype('psobject')]
    Param(
        [Parameter(Mandatory, HelpMessage = 'First object to compare', Position = 0)]
        [PSObject] $ReferenceObject,

        [Parameter(Mandatory, HelpMessage = 'Second object to compare', Position = 1)]
        [PSObject] $DifferenceObject
    )
    #endregion Parameters

    begin {
        Write-Verbose -Message "Starting [$($MyInvocation.Mycommand)]"
    }

    process {
        $objprops = $ReferenceObject | Get-Member -MemberType Property, NoteProperty | ForEach-Object Name
        $objprops += $DifferenceObject | Get-Member -MemberType Property, NoteProperty | ForEach-Object Name
        $objprops = $objprops | Sort-Object | Select-Object -Unique
        $diffs = @()
        foreach ($objprop in $objprops) {
            $diff = Compare-Object -ReferenceObject $ReferenceObject -DifferenceObject $DifferenceObject -Property $objprop
            if ($diff) {
                $diffprops = @{
                    PropertyName = $objprop
                    RefValue     = ($diff | Where-Object { $_.SideIndicator -eq '<=' } | ForEach-Object $($objprop))
                    DiffValue    = ($diff | Where-Object { $_.SideIndicator -eq '=>' } | ForEach-Object $($objprop))
                }
                $diffs += New-Object -TypeName PSObject -Property $diffprops
            }
        }
        if ($diffs) { return ($diffs | Select-Object -Property PropertyName, RefValue, DiffValue) }
    }

    end {
        Write-Verbose -Message "Ending [$($MyInvocation.Mycommand)]"
    }
}

Function ConvertTo-QueryString {
    <#
    Credit for this function: https://www.powershellgallery.com/packages/MSIdentityTools
    #>
    [CmdletBinding()]
    [OutputType([string])]
    param (
        [Parameter(Mandatory = $true)]
        $InputObject,
        [Parameter(Mandatory = $false)]
        [string[]] $IncludeProperties
    )
    process {
        $QueryString = New-Object System.Text.StringBuilder
        if ($InputObject -is [hashtable]) {
            foreach ($Item in $InputObject.GetEnumerator()) {
                if ($QueryString.Length -gt 0) { [void]$QueryString.Append('&') }
                [string]$ParameterName = $Item.Key -replace '[0-9]{1,}$'
                [void]$QueryString.AppendFormat('{0}={1}', $ParameterName, [System.Net.WebUtility]::UrlEncode($Item.Value))
            }
        }
        ElseIf ($InputObject -is [System.Collections.Specialized.OrderedDictionary]) {
            foreach ($Item in $InputObject.GetEnumerator()) {
                if ($QueryString.Length -gt 0) { [void]$QueryString.Append('&') }
                [string]$ParameterName = $Item.Key -replace '[0-9]{1,}$'
                If ($Item.value -is [boolean]) {
                    If ($Item.value -eq $true) {
                        [void]$QueryString.AppendFormat('{0}={1}', $ParameterName, [System.Net.WebUtility]::UrlEncode('true'))
                    }
                    Else {
                        [void]$QueryString.AppendFormat('{0}={1}', $ParameterName, [System.Net.WebUtility]::UrlEncode('false'))
                    }
                }
                ElseIf ($ParameterName -eq '_oldValues') {
                    [void]$QueryString.AppendFormat('{0}={1}', $ParameterName, $Item.value)
                }
                Else {
                    [void]$QueryString.AppendFormat('{0}={1}', $ParameterName, [System.Net.WebUtility]::UrlEncode($Item.value))
                }
            }
        }
        ElseIf ($InputObject.GetType().FullName.StartsWith('ANOW')) {
            foreach ($Item in $IncludeProperties) {
                if ($QueryString.Length -gt 0) { [void]$QueryString.Append('&') }
                [string]$ParameterName = $Item -replace '[0-9]{1,}$'
                If ($InputObject."$Item" -is [boolean]) {
                    If ($InputObject."$Item" -eq $true) {
                        [void]$QueryString.AppendFormat('{0}={1}', $ParameterName, [System.Net.WebUtility]::UrlEncode('true'))
                    }
                    Else {
                        [void]$QueryString.AppendFormat('{0}={1}', $ParameterName, [System.Net.WebUtility]::UrlEncode('false'))
                    }
                }
                ElseIf ($ParameterName -eq 'tags') {
                    [int32]$tag_count = $InputObject."$Item".Count
                    If ($tag_count -eq 0) {
                        Write-Warning -Message "Somehow there were no tags found while converting a parameter block to query string!"
                        Break
                    }
                    [int32]$current_tag = 1
                    ForEach ($tag_id in $InputObject."$Item") {
                        If ($current_tag -lt $tag_count) {
                            [void]$QueryString.AppendFormat('{0}={1}', $ParameterName, ([System.Net.WebUtility]::UrlEncode($tag_id) + '&'))
                        }
                        Else {
                            [void]$QueryString.AppendFormat('{0}={1}', $ParameterName, [System.Net.WebUtility]::UrlEncode($tag_id))
                        }
                        $current_tag++
                    }
                }
                ElseIf ($InputObject."$Item" -match '^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}.[0-9]{3}$') {
                    [void]$QueryString.AppendFormat('{0}={1}', $ParameterName, $InputObject."$Item")
                }
                Else {
                    [void]$QueryString.AppendFormat('{0}={1}', $ParameterName, [System.Net.WebUtility]::UrlEncode($InputObject."$Item"))
                }
            }
        }
        elseif ($InputObject -is [object] -and $InputObject -isnot [ValueType]) {
            foreach ($Item in ($InputObject | Get-Member -MemberType Property, NoteProperty)) {
                if ($QueryString.Length -gt 0) { [void]$QueryString.Append('&') }
                [string] $ParameterName = $Item.Name
                [void]$QueryString.AppendFormat('{0}={1}', $ParameterName, [System.Net.WebUtility]::UrlEncode($InputObject.($Item.Name)))
            }
        }
        else {
            ## Non-Terminating Error
            $Exception = New-Object ArgumentException -ArgumentList ('Cannot convert input of type {0} to query string.' -f $InputObject.GetType())
            Write-Error -Exception $Exception -Category ([System.Management.Automation.ErrorCategory]::ParserError) -CategoryActivity $MyInvocation.MyCommand -ErrorId 'ConvertQueryStringFailureTypeNotSupported' -TargetObject $InputObject
            continue
        }
        [string]$Result = $QueryString.ToString()
        #[string]$Result = $Result -creplace '\+', '%20' -creplace 'criteria[0-9]{1,}=', 'criteria=' -creplace '_sortBy[0-9]{1,}=', '_sortBy=' -creplace 'setWorkspaceTags[0-9]{1,}=', 'setWorkspaceTags=' -creplace 'tags[0-9]{1,}=', 'tags='
        [string]$Result = $Result -creplace '\+', '%20'
        Write-Output $Result
    }
}

Function New-AutomateNOWDefaultProcessingTitle {
    [OutputType([string])]
    [CmdletBinding()]
    Param(
        [string]$simpleId
    )
    $Error.Clear()
    Try {
        [ANOWTimeZone]$user_timezone_object = $anow_session.supported_timezones | Where-Object { $_.id -eq ($anow_session.user_timezone) } | Select-Object -First 1
    }
    Catch {
        [string]$Message = $_.Exception.Message
        Write-Warning -Message "Could not extract the current AutomateNOW timezone details for the logged in user due to [$Message]."
        Break
    }
    [int64]$current_offset = $user_timezone_object.rawOffset
    If ($user_timezone_object.inDaylightTime -eq $true) {
        [int64]$current_offset = ($current_offset + $user_timezone_object.dstsavings)
    }
    [datetime]$current_utc_time = (Get-Date).ToUniversalTime()
    [datetime]$current_offset_time = $current_utc_time.AddMilliseconds($current_offset)
    $current_server_time_display = Get-Date -Date $current_offset_time -format 'yyyy-MM-dd HH:mm:ss'
    [string]$title = ('Manual execution - ' + $simpleId + ' - ' + $current_server_time_display)
    Return $title
}

Function New-WebkitBoundaryString {
    [OutputType([string])]
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory = $false)]
        [switch]$Numerical,
        [Parameter(Mandatory = $false)]
        [int32]$Length = 16
    )
    If ($Numerical -eq $true) {
        [string]$webkit_boundary = (0..29 | ForEach-Object { [string](Get-Random -Minimum 0 -Maximum 10) }) -join ''
    }
    Else {
        [string]$webkit_boundary = (((65..90) + (97..122) + (48..57)) | Get-Random -Count $Length | ForEach-Object { [char]$_ } | Sort-Object { Get-Random }) -join ''
    }
    Return $webkit_boundary
}

Function Protect-AutomateNOWEncryptedString {
    <#
    .SYNOPSIS
    "Encrypts" and encodes a plain text string for use with certain object types within an instance of AutomateNOW!

    .DESCRIPTION
    "Encrypts" and encodes a plain text string for use with certain object types within an instance of AutomateNOW!

    .PARAMETER String
    A mandatory plain text string to "encrypt"

    .PARAMETER SecureString
    A mandatory secure string to "encrypt"

    .PARAMETER Key
    Optional 16-byte encryption key. The default will be used when this parameter is not specified.

    .INPUTS
    A single plain text string is accepted (including along the pipeline) or a secure string (not pipeline capable)

    .OUTPUTS
    The protected string is returned in plain text (base64 encoded) format

    .EXAMPLE
    Protect-AutomateNOWEncryptedString -String 'MySecretString'

    Return 'DxEIEAwFBQoMChMQBQoREAwFERATEAgKFgoQCg=='

    .NOTES

    #>
    [OutputType([string])]
    [CmdletBinding(DefaultParameterSetName = 'SecureString')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'String', ValueFromPipeline = $true)]
        [string]$String,
        [Parameter(Mandatory = $true, ParameterSetName = 'SecureString')]
        [SecureString]$SecureString,
        [Parameter(Mandatory = $false)]
        [byte[]]$Key = @(7, 22, 15, 11, 1, 24, 8, 13, 16, 10, 5, 17, 12, 19, 27, 9),
        [Parameter(Mandatory = $false)]
        [switch]$IncludePrefix
    )
    Begin {

    }
    Process {
        If ($_.Length -gt 0) {
            [string]$String = $_
        }
        If ($Key.Length -eq 0) {
            Write-Warning -Message "Somehow the encryption key is empty. Please check into this."
            Break
        }
        If ($null -ne $SecureString) {
            [string]$String = $SecureString | ConvertFrom-SecureString -AsPlainText
        }
        [byte[]]$passwd_array = [System.Text.Encoding]::UTF8.GetBytes($String)
        [byte[]]$encrytped_array = For ($i = 0; $i -lt ($passwd_array.Length); $i++) {
            [byte]$current_byte = $passwd_array[$i]
            [int32]$first = (-bnot $current_byte -shr 0) -band 0x0f
            [int32]$second = (-bnot $current_byte -shr 4) -band 0x0f
            $Key[$first]
            $Key[$second]
        }
        [string]$encrypted_string = [System.Convert]::ToBase64String($encrytped_array)
        If ($IncludePrefix -eq $true) {
            [string]$encrypted_string = ('ENCRYPTED::' + $encrypted_string)
        }
        Return $encrypted_string
    }
    End {

    }
}

Function Unprotect-AutomateNOWEncryptedString {
    <#
    .SYNOPSIS
    "Decrypts" and decodes the encrypted string within certain object types of an instance of AutomateNOW!

    .DESCRIPTION
    "Decrypts" and decodes the encrypted string within certain object types of an instance of AutomateNOW!

    .PARAMETER protected_string
    Mandatory valid base64 string that you retrieved from the AutomateNOW console while viewing the Endpoint objects. Do not include the 'ENCRYPTED::' portion of the string but if you do it will be removed for you automatically.

    .PARAMETER Key
    Optional 16-byte encryption key. The default will be used when this parameter is not specified.

    .INPUTS
    A single base64 encoded string is accepted.

    .OUTPUTS
    The unprotected string is returned in plain text.

    .EXAMPLE
    Unprotect-AutomateNOWEncryptedString -protected_string 'DREFCgsKCwoHChEFDQoFChMQBQobEw=='

    .NOTES

    #>
    [OutputType([string])]
    [CmdletBinding()]
    Param(
        [ValidateScript({ $_ -cmatch '^([ENCRYPTED::]{11}|)(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$' })]
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [string]$protected_string,
        [Parameter(Mandatory = $false)]
        [int32[]]$Key = @(7, 22, 15, 11, 1, 24, 8, 13, 16, 10, 5, 17, 12, 19, 27, 9)
    )
    Begin {

    }
    Process {
        Function Format-Byte {
            [OutputType([int32[]])]
            [CmdletBinding()]
            Param(
                [byte]$byte
            )
            [int32]$first = (-bnot $byte -shr 0) -band 0x0f
            [int32]$second = (-bnot $byte -shr 4) -band 0x0f
            Return @($first, $second)
        }
        Function Confirm-Byte {
            [OutputType([int32])]
            [CmdletBinding()]
            Param(
                [Parameter(Mandatory = $true)]
                [int32]$first_byte,
                [Parameter(Mandatory = $true)]
                [int32]$second_byte
            )
            For ($i = 0; $i -lt 256; $i++) {
                [int32[]]$attempted_bytes = Format-Byte -byte ([byte]$i)
                [int32]$attempted_byte_first = $attempted_bytes[0]
                [int32]$attempted_byte_second = $attempted_bytes[1]
                If (($attempted_byte_first -eq $first_byte) -and ($attempted_byte_second -eq $second_byte)) {
                    Return $i
                    Break
                }
            }
        }
        If ($_.Length -gt 0) {
            [string]$protected_string = $_
        }
        If ($protected_string -match '^ENCRYPTED::') {
            [string]$protected_string = $protected_string -replace 'ENCRYPTED::'
        }
        $Error.Clear()
        Try {
            [int32[]]$encrypted_byte_array = [System.Convert]::FromBase64String($protected_string)
        }
        Catch {
            [string]$Message = $_.Exception.Message
            Write-Warning -Message "Decoding the protected string [$protected_string] from base64 failed due to [$Message]"
            Break
        }
        [int32[]]$decoded_byte_array = For ($i = 0; $i -lt $encrypted_byte_array.Count; $i = $i + 2) {
            [int32]$first_byte = $Key.IndexOf($encrypted_byte_array[$i])
            [int32]$second_byte = $Key.IndexOf($encrypted_byte_array[$i + 1])
            [int32]$decoded_byte = Confirm-Byte -first_byte $first_byte -second_byte $second_byte
            $decoded_byte
        }
        [string]$unprotected_password = ([char[]]$decoded_byte_array -join '')
        Return $unprotected_password
    }
    End {

    }
}

#EndRegion

#Region = Lookup Tables =

Function Resolve-AutomateNOWTaskType2ServerNodeType {
    [OutputType([string[]])]
    [CmdletBinding(DefaultParameterSetName = 'TaskType')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'TaskType')]
        [ANOWProcessingTemplateItem_taskType]$TaskType,
        [Parameter(Mandatory = $true, ParameterSetName = 'NodeType')]
        [ANOWServerNode_serverNodeType]$ServerNodeType,
        [Parameter(Mandatory = $true, ParameterSetName = 'All')]
        [switch]$All
    )
    [System.Collections.ArrayList]$ANOWLookupTaskTypeToServerNodeType = [System.Collections.ArrayList]::new()
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AE_SHELL_SCRIPT' = 'LINUX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AE_SHELL_SCRIPT' = 'WINDOWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AE_SHELL_SCRIPT' = 'AIX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AMQP_SEND' = 'RABBIT_MQ'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AMQP_SEND' = 'QPID'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AMQP_SEND' = 'HORNETQ'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AMQP_SEND' = 'ZERO_MQ'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AMQP_SEND' = 'AMQP'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'ANSIBLE_PLAYBOOK' = 'ANSIBLE'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'ANSIBLE_PLAYBOOK_PATH' = 'ANSIBLE'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'APACHE_AIRFLOW_RUN_DAG' = 'APACHE_AIRFLOW'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'ARANGO_DB_INSERT' = 'ARANGO_DB'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AS400_BATCH_JOB' = 'AS400'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AS400_COMMAND_CALL' = 'AS400'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AS400_PROGRAM_CALL' = 'AS400'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AS400_RPA' = 'AS400'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AUTOMATE_NOW_TRIGGER_EVENT' = 'AUTOMATE_NOW'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AUTOMATION_ANYWHERE_DEPLOY_ROBOT' = 'AUTOMATION_ANYWHERE'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AUTOMATION_ANYWHERE_START_ROBOT' = 'AUTOMATION_ANYWHERE'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AUTOMATION_ANYWHERE_STOP_ROBOT' = 'AUTOMATION_ANYWHERE'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AUTOMATION_ANYWHERE_UNDEPLOY_ROBOT' = 'AUTOMATION_ANYWHERE'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AWS_BATCH_JOB' = 'AWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AWS_EC2_DELETE_VOLUME' = 'AWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AWS_EC2_START_INSTANCE' = 'AWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AWS_EC2_STOP_INSTANCE' = 'AWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AWS_EC2_TERMINATE_INSTANCE' = 'AWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AWS_EMR_ADD_STEPS' = 'AWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AWS_EMR_API_COMMAND' = 'AWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AWS_EMR_CANCEL_STEPS' = 'AWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AWS_EMR_GET' = 'AWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AWS_EMR_PUT' = 'AWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AWS_EMR_START_NOTEBOOK_EXECUTION' = 'AWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AWS_EMR_STOP_NOTEBOOK_EXECUTION' = 'AWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AWS_EMR_TERMINATE_JOB_FLOW' = 'AWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AWS_EMR_WORKFLOW' = 'AWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AWS_GLUE_CRAWLER' = 'AWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AWS_GLUE_JOB' = 'AWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AWS_GLUE_TRIGGER' = 'AWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AWS_GLUE_WORKFLOW' = 'AWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AWS_LAMBDA_CREATE_FUNCTION' = 'AWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AWS_LAMBDA_DELETE_FUNCTION' = 'AWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AWS_LAMBDA_INVOKE' = 'AWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AWS_S3_COPY_OBJECT' = 'AWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AWS_S3_DELETE_OBJECT' = 'AWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AWS_S3_MOVE_OBJECT' = 'AWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AWS_S3_RENAME_OBJECT' = 'AWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AWS_SAGE_MAKER_ADD_MODEL' = 'AWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AWS_SAGE_MAKER_API_COMMAND' = 'AWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AWS_SAGE_MAKER_DELETE_MODEL' = 'AWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AWS_SAGE_MAKER_PROCESSING' = 'AWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AWS_SAGE_MAKER_TRAINING' = 'AWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AWS_SAGE_MAKER_TRANSFORM' = 'AWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AWS_SAGE_MAKER_TUNING' = 'AWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AWS_START_STEP_FUNCTION_STATE_MACHINE' = 'AWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AZURE_BATCH_JOB' = 'AZURE'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AZURE_DATABRICKS_DELETE_CLUSTER' = 'AZURE_DATABRICKS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AZURE_DATABRICKS_JOB' = 'AZURE_DATABRICKS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AZURE_DATABRICKS_LIST_CLUSTERS' = 'AZURE_DATABRICKS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AZURE_DATABRICKS_START_CLUSTER' = 'AZURE_DATABRICKS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AZURE_DATABRICKS_TERMINATE_CLUSTER' = 'AZURE_DATABRICKS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AZURE_DATA_FACTORY_PIPELINE' = 'AZURE'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AZURE_DATA_FACTORY_TRIGGER' = 'AZURE'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AZURE_DATA_LAKE_JOB' = 'AZURE'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'AZURE_RUN_LOGIC_APP' = 'AZURE'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'BLUE_PRISM' = 'BLUE_PRISM'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'BLUE_PRISM_DEPLOY_ROBOT' = 'BLUE_PRISM'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'BLUE_PRISM_START_ROBOT' = 'BLUE_PRISM'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'BLUE_PRISM_STOP_ROBOT' = 'BLUE_PRISM'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'BLUE_PRISM_UNDEPLOY_ROBOT' = 'BLUE_PRISM'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'BMC_REMEDY_INCIDENT' = 'BMC_REMEDY'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'CASSANDRA_CQL_SCRIPT' = 'CASSANDRA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'CA_SERVICE_MANAGEMENT_INCIDENT' = 'CA_SERVICE_MANAGEMENT'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'COUCH_BASE_INSERT' = 'COUCH_BASE'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'COUCH_DB_INSERT' = 'COUCH_DB'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'CTRLM_ADD_CONDITION' = 'CTRL_M'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'CTRLM_CREATE_JOB' = 'CTRL_M'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'CTRLM_DELETE_CONDITION' = 'CTRL_M'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'CTRLM_ORDER_JOB' = 'CTRL_M'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'CTRLM_RESOURCE_TABLE_ADD' = 'CTRL_M'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'CTRLM_RESOURCE_TABLE_DELETE' = 'CTRL_M'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'CTRLM_RESOURCE_TABLE_UPDATE' = 'CTRL_M'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'DATASOURCE_DELETE_FILE' = 'INTERNAL'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'DATASOURCE_DOWNLOAD_FILE' = 'FILE_MANAGER'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'DATASOURCE_UPLOAD_FILE' = 'FILE_MANAGER'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'DBT_CORE_JOB' = 'DBT_CORE'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'DBT_JOB' = 'DBT'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'DYNAMO_DB_INSERT' = 'DYNAMO_DB'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'EMAIL_CONFIRMATION' = 'EMAIL'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'EMAIL_INPUT' = 'EMAIL'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'EMAIL_SEND' = 'EMAIL'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'FACEBOOK_POST' = 'FACEBOOK'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'FILE_CHECK' = 'FILE_MANAGER'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'FILE_TRANSFER' = 'FILE_MANAGER'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'FILE_WATCHER' = 'FILE_MANAGER'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'FLINK_JAR_DELETE' = 'FLINK'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'FLINK_JAR_UPLOAD' = 'FLINK'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'FLINK_RUN_JOB' = 'FLINK'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'GO' = 'LINUX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'GO' = 'WINDOWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'GO' = 'AIX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'GO' = 'HPUX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'GO' = 'SOLARIS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'GO' = 'OPENVMS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'GO' = 'MACOS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'GOOGLE_DATA_FLOW_JOB' = 'GOOGLE_DATA_FLOW'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'GROOVY' = 'LINUX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'GROOVY' = 'WINDOWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'GROOVY' = 'AIX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'GROOVY' = 'HPUX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'GROOVY' = 'SOLARIS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'GROOVY' = 'OPENVMS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'GROOVY' = 'MACOS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'HDFS_APPEND_FILE' = 'HDFS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'HDFS_CREATE_DIRECTORY' = 'HDFS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'HDFS_DELETE_DIRECTORY' = 'HDFS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'HDFS_DELETE_FILE' = 'HDFS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'HDFS_DOWNLOAD_FILE' = 'HDFS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'HDFS_RENAME' = 'HDFS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'HDFS_UPLOAD_FILE' = 'HDFS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'HP_OPEN_VIEW_SERVICE_MANAGER_INCIDENT' = 'HP_OPEN_VIEW_SERVICE_MANAGER'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'HTTP_REQUEST' = 'HTTP'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'IBM_CONTROL_DESK_INCIDENT' = 'IBM_CONTROL_DESK'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'IBM_DATASTAGE' = 'IBM_DATASTAGE'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'IBM_MQ_SEND' = 'IBM_MQ'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'INFORMATICA_CLOUD_TASKFLOW' = 'INFORMATICA_CLOUD'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'INFORMATICA_WORKFLOW' = 'INFORMATICA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'INFORMATICA_WS_WORKFLOW' = 'INFORMATICA_WS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'INSTAGRAM_POST' = 'INSTAGRAM'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'JAVA' = 'LINUX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'JAVA' = 'WINDOWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'JAVA' = 'AIX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'JAVA' = 'HPUX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'JAVA' = 'SOLARIS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'JAVA' = 'OPENVMS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'JAVA' = 'MACOS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'JAVASCRIPT' = 'LINUX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'JAVASCRIPT' = 'WINDOWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'JAVASCRIPT' = 'AIX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'JAVASCRIPT' = 'HPUX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'JAVASCRIPT' = 'SOLARIS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'JAVASCRIPT' = 'OPENVMS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'JAVASCRIPT' = 'MACOS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'JIRA_ADD_ISSUE' = 'JIRA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'JIRA_CLOSE_ISSUE' = 'JIRA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'JMS_SEND' = 'IBM_MQ'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'JMS_SEND' = 'RABBIT_MQ'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'JMS_SEND' = 'SQS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'JMS_SEND' = 'ACTIVE_MQ'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'JMS_SEND' = 'HORNETQ'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'JMS_SEND' = 'SOLACE'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'JMS_SEND' = 'JORAM_MQ'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'JMS_SEND' = 'ZERO_MQ'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'JMS_SEND' = 'PULSAR'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'JMS_SEND' = 'SQS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'KAFKA_SEND' = 'KAFKA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'KOTLIN' = 'LINUX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'KOTLIN' = 'WINDOWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'KOTLIN' = 'AIX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'KOTLIN' = 'HPUX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'KOTLIN' = 'SOLARIS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'KOTLIN' = 'OPENVMS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'KOTLIN' = 'MACOS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'LINKED_IN_POST' = 'LINKED_IN'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'MICROSOFT_POWER_BI_DATAFLOW_REFRESH' = 'MICROSOFT_POWER_BI'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'MICROSOFT_POWER_BI_DATASET_REFRESH' = 'MICROSOFT_POWER_BI'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'MONGO_DB_INSERT' = 'MONGO_DB'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'MQTT_SEND' = 'RABBIT_MQ'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'MQTT_SEND' = 'HORNETQ'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'MQTT_SEND' = 'ACTIVE_MQ'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'MQTT_SEND' = 'IBM_MQ'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'MS_SSIS' = 'MS_SSIS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'NEO4J_INSERT' = 'NEO4J'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'ODI_LOAD_PLAN' = 'ODI'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'ODI_SESSION' = 'ODI'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'OPENTEXT_DYNAMIC_JCL' = 'OPENTEXT'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'OPENTEXT_STORED_JCL' = 'OPENTEXT'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'ORACLE_EBS_EXECUTE_PROGRAM' = 'ORACLE_EBS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'ORACLE_EBS_EXECUTE_REQUEST_SET' = 'ORACLE_EBS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'ORACLE_EBS_PROGRAM' = 'ORACLE_EBS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'ORACLE_EBS_REQUEST_SET' = 'ORACLE_EBS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'ORACLE_SERVICE_CENTER_CASE' = 'ORACLE_SERVICE_CENTER'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'PEGA_DEPLOY_ROBOT' = 'PEGA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'PEGA_START_ROBOT' = 'PEGA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'PEGA_STOP_ROBOT' = 'PEGA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'PEGA_UNDEPLOY_ROBOT' = 'PEGA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'PEOPLESOFT_APPLICATION_ENGINE_TASK' = 'PEOPLESOFT'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'PEOPLESOFT_COBOL_SQL_TASK' = 'PEOPLESOFT'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'PEOPLESOFT_CRW_ONLINE_TASK' = 'PEOPLESOFT'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'PEOPLESOFT_CRYSTAL_REPORTS_TASK' = 'PEOPLESOFT'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'PEOPLESOFT_CUBE_BUILDER_TASK' = 'PEOPLESOFT'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'PEOPLESOFT_JOB_TASK' = 'PEOPLESOFT'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'PEOPLESOFT_NVISION_TASK' = 'PEOPLESOFT'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'PEOPLESOFT_SQR_PROCESS_TASK' = 'PEOPLESOFT'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'PEOPLESOFT_SQR_REPORT_TASK' = 'PEOPLESOFT'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'PEOPLESOFT_WINWORD_TASK' = 'PEOPLESOFT'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'PERL' = 'LINUX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'PERL' = 'WINDOWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'PERL' = 'AIX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'PERL' = 'HPUX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'PERL' = 'SOLARIS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'PERL' = 'OPENVMS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'PERL' = 'MACOS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'POWERSHELL' = 'WINDOWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'PYTHON' = 'LINUX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'PYTHON' = 'WINDOWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'PYTHON' = 'AIX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'PYTHON' = 'HPUX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'PYTHON' = 'SOLARIS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'PYTHON' = 'OPENVMS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'PYTHON' = 'MACOS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RABBIT_MQ_SEND' = 'RABBIT_MQ'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RAINCODE_DYNAMIC_JCL' = 'RAINCODE'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RAINCODE_STORED_JCL' = 'RAINCODE'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL' = 'ORACLE'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL' = 'TERADATA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL' = 'SINGLESTORE'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL' = 'SQL_SERVER'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL' = 'POSTGRESQL'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL' = 'MYSQL'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL' = 'DB2'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL' = 'NETEZZA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL' = 'AZURE_SQL_DATA_WAREHOUSE'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL' = 'AZURE_SQL_DATABASE'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL' = 'HIVE_QL'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL' = 'GOOGLE_BIG_QUERY'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL' = 'DASHDB'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL' = 'SNOWFLAKE'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL' = 'VERTICA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL' = 'PRESTO_DB'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL' = 'H2'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL' = 'SYBASE'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL' = 'INFORMIX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL' = 'SAP_HANA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL_STATEMENT' = 'ORACLE'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL_STATEMENT' = 'TERADATA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL_STATEMENT' = 'SINGLESTORE'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL_STATEMENT' = 'SQL_SERVER'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL_STATEMENT' = 'POSTGRESQL'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL_STATEMENT' = 'MYSQL'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL_STATEMENT' = 'DB2'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL_STATEMENT' = 'NETEZZA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL_STATEMENT' = 'AZURE_SQL_DATA_WAREHOUSE'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL_STATEMENT' = 'AZURE_SQL_DATABASE'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL_STATEMENT' = 'HIVE_QL'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL_STATEMENT' = 'GOOGLE_BIG_QUERY'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL_STATEMENT' = 'DASHDB'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL_STATEMENT' = 'SNOWFLAKE'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL_STATEMENT' = 'VERTICA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL_STATEMENT' = 'PRESTO_DB'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL_STATEMENT' = 'SAP_HANA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_SQL_STATEMENT' = 'INFORMIX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_STORED_PROCEDURE' = 'ORACLE'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_STORED_PROCEDURE' = 'TERADATA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_STORED_PROCEDURE' = 'SINGLESTORE'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_STORED_PROCEDURE' = 'SQL_SERVER'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_STORED_PROCEDURE' = 'POSTGRESQL'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_STORED_PROCEDURE' = 'MYSQL'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_STORED_PROCEDURE' = 'DB2'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_STORED_PROCEDURE' = 'NETEZZA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_STORED_PROCEDURE' = 'AZURE_SQL_DATA_WAREHOUSE'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_STORED_PROCEDURE' = 'AZURE_SQL_DATABASE'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_STORED_PROCEDURE' = 'GOOGLE_BIG_QUERY'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_STORED_PROCEDURE' = 'DASHDB'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_STORED_PROCEDURE' = 'SNOWFLAKE'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_STORED_PROCEDURE' = 'VERTICA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_STORED_PROCEDURE' = 'PRESTO_DB'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_STORED_PROCEDURE' = 'SAP_HANA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RDBMS_STORED_PROCEDURE' = 'INFORMIX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'REDDIT_POST' = 'REDDIT'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'REDIS_CLI' = 'REDIS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'REDIS_DELETE' = 'REDIS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'REDIS_GET' = 'REDIS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'REDIS_SET' = 'REDIS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'REST_WEB_SERVICE_CALL' = 'REST_WEB_SERVICE'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'ROBOT_FRAMEWORK_DEPLOY_ROBOT' = 'ROBOT_FRAMEWORK'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'ROBOT_FRAMEWORK_START_ROBOT' = 'ROBOT_FRAMEWORK'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'ROBOT_FRAMEWORK_STOP_ROBOT' = 'ROBOT_FRAMEWORK'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'ROBOT_FRAMEWORK_UNDEPLOY_ROBOT' = 'ROBOT_FRAMEWORK'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RUBY' = 'LINUX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RUBY' = 'WINDOWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RUBY' = 'AIX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RUBY' = 'HPUX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RUBY' = 'SOLARIS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RUBY' = 'OPENVMS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RUBY' = 'MACOS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RUST' = 'LINUX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RUST' = 'WINDOWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RUST' = 'AIX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RUST' = 'HPUX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RUST' = 'SOLARIS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RUST' = 'OPENVMS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'RUST' = 'MACOS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_4H_ARCHIVE' = 'SAP_S4_HANA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_4H_BW_PROCESS_CHAIN' = 'SAP_S4_HANA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_4H_CM_PROFILE_ACTIVATE' = 'SAP_S4_HANA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_4H_CM_PROFILE_DEACTIVATE' = 'SAP_S4_HANA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_4H_COPY_EXISTING_JOB' = 'SAP_S4_HANA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_4H_EXPORT_CALENDAR' = 'SAP_S4_HANA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_4H_EXPORT_JOB' = 'SAP_S4_HANA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_4H_FUNCTION_MODULE_CALL' = 'SAP_S4_HANA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_4H_GET_APPLICATION_LOG' = 'SAP_S4_HANA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_4H_JOB' = 'SAP_S4_HANA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_4H_JOB_INTERCEPTOR' = 'SAP_S4_HANA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_4H_MODIFY_INTERCEPTION_CRITERIA' = 'SAP_S4_HANA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_4H_MONITOR_EXISTING_JOB' = 'SAP_S4_HANA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_4H_RAISE_EVENT' = 'SAP_S4_HANA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_4H_READ_TABLE' = 'SAP_S4_HANA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_4H_RELEASE_EXISTING_JOB' = 'SAP_S4_HANA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_4H_START_SCHEDULED_JOB' = 'SAP_S4_HANA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_4H_SWITCH_OPERATION_MODE' = 'SAP_S4_HANA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_4H_VARIANT_COPY' = 'SAP_S4_HANA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_4H_VARIANT_CREATE' = 'SAP_S4_HANA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_4H_VARIANT_DELETE' = 'SAP_S4_HANA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_4H_VARIANT_UPDATE' = 'SAP_S4_HANA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_ARCHIVE' = 'SAP'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_BW_PROCESS_CHAIN' = 'SAP'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_CM_PROFILE_ACTIVATE' = 'SAP'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_CM_PROFILE_DEACTIVATE' = 'SAP'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_EXPORT_CALENDAR' = 'SAP'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_EXPORT_JOB' = 'SAP'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_FUNCTION_MODULE_CALL' = 'SAP'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_GET_APPLICATION_LOG' = 'SAP'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_IBP_JOB' = 'SAP_S4_HANA_CLOUD'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_MODIFY_INTERCEPTION_CRITERIA' = 'SAP'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_ODATA_API_CALL' = 'SAP_S4_HANA_CLOUD'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_R3_COPY_EXISTING_JOB' = 'SAP'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_R3_JOB' = 'SAP'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_R3_JOB_INTERCEPTOR' = 'SAP'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_R3_MONITOR_EXISTING_JOB' = 'SAP'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_R3_RAISE_EVENT' = 'SAP'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_R3_RELEASE_EXISTING_JOB' = 'SAP'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_R3_START_SCHEDULED_JOB' = 'SAP'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_R3_VARIANT_COPY' = 'SAP'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_R3_VARIANT_CREATE' = 'SAP'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_R3_VARIANT_DELETE' = 'SAP'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_R3_VARIANT_UPDATE' = 'SAP'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_READ_TABLE' = 'SAP'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_SOLUTION_MANAGER_TICKET' = 'SAP_SOLUTION_MANAGER'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAP_SWITCH_OPERATION_MODE' = 'SAP'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAS_4GL' = 'SAS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAS_DI' = 'SAS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAS_JOB' = 'SAS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SAS_VIYA_JOB' = 'SAS_VIYA'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SCALA' = 'LINUX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SCALA' = 'WINDOWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SCALA' = 'AIX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SCALA' = 'HPUX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SCALA' = 'SOLARIS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SCALA' = 'OPENVMS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SCALA' = 'MACOS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SERVICE_NOW_CLOSE_INCIDENT' = 'SERVICE_NOW'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SERVICE_NOW_CREATE_INCIDENT' = 'SERVICE_NOW'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SERVICE_NOW_RESOLVE_INCIDENT' = 'SERVICE_NOW'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SERVICE_NOW_UPDATE_INCIDENT' = 'SERVICE_NOW'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SH' = 'LINUX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SH' = 'WINDOWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SH' = 'AIX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SH' = 'HPUX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SH' = 'SOLARIS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SH' = 'OPENVMS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SH' = 'MACOS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SOAP_WEB_SERVICE_CALL' = 'SOAP_WEB_SERVICE'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SPARK_JAVA' = 'SPARK'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SPARK_PYTHON' = 'SPARK'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SPARK_R' = 'SPARK'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SPARK_RUN_JOB' = 'SPARK'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SPARK_SCALA' = 'SPARK'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SPARK_SQL' = 'SPARK'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'STOMP_SEND' = 'STOMP'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SWIFT' = 'MACOS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'SWIFT' = 'IOS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'TABLEAU_REFRESH_EXTRACT' = 'TABLEAU'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'TALEND_JOB' = 'TALEND'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'TEAMS_CHAT_MESSAGE' = 'TEAMS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'TELEGRAM_MESSAGE' = 'TELEGRAM'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'TIKTOK_POST' = 'TIKTOK'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'TITAN_INSERT' = 'TITAN'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'TUMBLR_POST' = 'TUMBLR'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'TWITTER_POST' = 'TWITTER'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'TYPESCRIPT' = 'LINUX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'TYPESCRIPT' = 'WINDOWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'TYPESCRIPT' = 'AIX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'TYPESCRIPT' = 'HPUX'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'TYPESCRIPT' = 'SOLARIS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'TYPESCRIPT' = 'OPENVMS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'TYPESCRIPT' = 'MACOS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'UI_PATH' = 'UI_PATH'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'UI_PATH_DEPLOY_ROBOT' = 'UI_PATH'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'UI_PATH_START_ROBOT' = 'UI_PATH'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'UI_PATH_STOP_ROBOT' = 'UI_PATH'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'UI_PATH_UNDEPLOY_ROBOT' = 'UI_PATH'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'VBSCRIPT' = 'WINDOWS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'WHATSAPP_MESSAGE' = 'WHATSAPP'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'WORK_FUSION_DEPLOY_ROBOT' = 'WORK_FUSION'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'WORK_FUSION_START_ROBOT' = 'WORK_FUSION'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'WORK_FUSION_STOP_ROBOT' = 'WORK_FUSION'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'WORK_FUSION_UNDEPLOY_ROBOT' = 'WORK_FUSION'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'XFTP_COMMAND' = 'FILE_MANAGER'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'XMPP_SEND' = 'XMPP'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'YOUTUBE_POST' = 'YOUTUBE'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'Z_OS_COMMAND' = 'Z_OS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'Z_OS_DYNAMIC_JCL' = 'Z_OS'; })
    [void]$ANOWLookupTaskTypeToServerNodeType.Add([hashtable]@{'Z_OS_STORED_JCL' = 'Z_OS'; })
    If ($TaskType.Length -gt 0) {
        [string[]]$TaskTypes = $ANOWLookupTaskTypeToServerNodeType | Where-Object { $_.keys -eq $TaskType } | Select-Object -ExpandProperty Values
        If ($TaskTypes.Count -gt 0) {
            Return $TaskTypes | Sort-Object
        }
        Else {
            Write-Warning -Message "There were no Task Types that match [$TaskType]"
        }
    }
    ElseIf ($ServerNodeType.Length -gt 0) {
        [string[]]$ServerNodeTypes = $ANOWLookupTaskTypeToServerNodeType | Where-Object { $_.values -eq $ServerNodeType } | Select-Object -ExpandProperty Keys
        If ($ServerNodeTypes.Count -gt 0) {
            Return $ServerNodeTypes | Sort-Object
        }
        Else {
            Write-Warning -Message "There were no Server Node Types that match [$ServerNodeType]"
        }
    }
    ElseIf ($All -eq $true) {
        Return $ANOWLookupTaskTypeToServerNodeType | Sort-Object
    }
    Else {
        Write-Warning -Message "Unable to resolve which output to return!"
        Break
    }
}

Function Resolve-AutomateNOWMonitorType2ServerNodeType {
    [OutputType([string[]])]
    [CmdletBinding(DefaultParameterSetName = 'MonitorType')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'MonitorType')]
        [ANOWProcessingTemplateItem_MonitorType]$MonitorType,
        [Parameter(Mandatory = $true, ParameterSetName = 'NodeType')]
        [ANOWServerNode_serverNodeType]$ServerNodeType,
        [Parameter(Mandatory = $true, ParameterSetName = 'All')]
        [switch]$All
    )
    [System.Collections.ArrayList]$ANOWLookupMonitorTypeToServerNodeType = [System.Collections.ArrayList]::new()
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'AWS_EMR_CONTAINER_MONITOR' = 'AWS'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'AWS_EMR_JOB_FLOW_MONITOR' = 'AWS'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'AWS_EMR_NOTEBOOK_MONITOR' = 'AWS'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'AWS_EMR_STEP_MONITOR' = 'AWS'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'AZURE_DATABRICKS_CLUSTER_MONITOR' = 'AZURE_DATABRICKS'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'EMAIL_MONITOR' = 'EMAIL'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'GROOVY_MONITOR' = 'LINUX'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'GROOVY_MONITOR' = 'WINDOWS'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'GROOVY_MONITOR' = 'AIX'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'GROOVY_MONITOR' = 'HPUX'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'GROOVY_MONITOR' = 'SOLARIS'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'GROOVY_MONITOR' = 'OPENVMS'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'HTTP_MONITOR' = 'HTTP'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'MQ_MONITOR' = 'JMS'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'PERL_MONITOR' = 'LINUX'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'PERL_MONITOR' = 'WINDOWS'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'PERL_MONITOR' = 'AIX'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'PERL_MONITOR' = 'HPUX'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'PERL_MONITOR' = 'SOLARIS'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'PERL_MONITOR' = 'OPENVMS'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'POWERSHELL_MONITOR' = 'WINDOWS'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'PYTHON_MONITOR' = 'LINUX'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'PYTHON_MONITOR' = 'WINDOWS'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'PYTHON_MONITOR' = 'AIX'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'PYTHON_MONITOR' = 'HPUX'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'PYTHON_MONITOR' = 'SOLARIS'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'PYTHON_MONITOR' = 'OPENVMS'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'RUBY_MONITOR' = 'LINUX'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'RUBY_MONITOR' = 'WINDOWS'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'RUBY_MONITOR' = 'AIX'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'RUBY_MONITOR' = 'HPUX'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'RUBY_MONITOR' = 'SOLARIS'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'RUBY_MONITOR' = 'OPENVMS'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'SAP_4H_INTERCEPTED_JOB_MONITOR' = 'SAP_S4_HANA'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'SAP_4H_JOB_MONITOR' = 'SAP_S4_HANA'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'SAP_IBP_JOB_MONITOR' = 'SAP_S4_HANA_CLOUD'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'SAP_IBP_PROCESS_FILTER_MONITOR' = 'SAP_S4_HANA_CLOUD'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'SAP_IBP_PROCESS_MONITOR' = 'SAP_S4_HANA_CLOUD'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'SAP_R3_INTERCEPTED_JOB_MONITOR' = 'SAP'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'SAP_R3_JOB_MONITOR' = 'SAP'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'SERVER_RESOURCE_MONITOR' = 'LINUX'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'SERVER_RESOURCE_MONITOR' = 'WINDOWS'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'SH_MONITOR' = 'LINUX'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'SH_MONITOR' = 'WINDOWS'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'SH_MONITOR' = 'AIX'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'SH_MONITOR' = 'HPUX'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'SH_MONITOR' = 'SOLARIS'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'SH_MONITOR' = 'OPENVMS'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'SYSTEM_MONITOR' = 'LINUX'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'SYSTEM_MONITOR' = 'WINDOWS'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'SYSTEM_MONITOR' = 'MACOS'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'SYSTEM_PROCESS_MONITOR' = 'LINUX'; })
    [void]$ANOWLookupMonitorTypeToServerNodeType.Add([hashtable]@{'SYSTEM_PROCESS_MONITOR' = 'WINDOWS'; })
    If ($MonitorType.Length -gt 0) {
        [string[]]$MonitorTypes = $ANOWLookupMonitorTypeToServerNodeType | Where-Object { $_.keys -eq $MonitorType } | Select-Object -ExpandProperty Values
        If ($MonitorTypes.Count -gt 0) {
            Return $MonitorTypes | Sort-Object
        }
        Else {
            Write-Warning -Message "There were no Monitor Types that match [$MonitorType]"
        }
    }
    ElseIf ($ServerNodeType.Length -gt 0) {
        [string[]]$ServerNodeTypes = $ANOWLookupMonitorTypeToServerNodeType | Where-Object { $_.values -eq $ServerNodeType } | Select-Object -ExpandProperty Keys
        If ($ServerNodeTypes.Count -gt 0) {
            Return $ServerNodeTypes | Sort-Object
        }
        Else {
            Write-Warning -Message "There were no Server Node Types that match [$ServerNodeType]"
        }
    }
    ElseIf ($All -eq $true) {
        Return $ANOWLookupMonitorTypeToServerNodeType | Sort-Object
    }
    Else {
        Write-Warning -Message "Unable to resolve which output to return!"
        Break
    }
}

Function Resolve-AutomateNOWSensorType2ServerNodeType {
    [OutputType([string[]])]
    [CmdletBinding(DefaultParameterSetName = 'SensorType')]
    Param(
        [Parameter(Mandatory = $true, ParameterSetName = 'SensorType')]
        [ANOWProcessingTemplateItem_SensorType]$SensorType,
        [Parameter(Mandatory = $true, ParameterSetName = 'NodeType')]
        [ANOWServerNode_serverNodeType]$ServerNodeType,
        [Parameter(Mandatory = $true, ParameterSetName = 'All')]
        [switch]$All
    )
    [System.Collections.ArrayList]$ANOWLookupSensorTypeToServerNodeType = [System.Collections.ArrayList]::new()
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'AMQP_SENSOR' = 'RABBIT_MQ'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'AMQP_SENSOR' = 'KAFKA'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'EMAIL_SENSOR' = 'EMAIL'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'FILE_SENSOR' = 'FILE_MANAGER'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'HTTP_SENSOR' = 'HTTP'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'IBM_MQ_SENSOR' = 'IBM_MQ'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'JIRA_ISSUE_SENSOR' = 'JIRA'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'JMS_SENSOR' = 'IBM_MQ'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'JMS_SENSOR' = 'RABBIT_MQ'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'JMS_SENSOR' = 'SQS'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'JMS_SENSOR' = 'ACTIVE_MQ'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'JMS_SENSOR' = 'HORNETQ'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'JMS_SENSOR' = 'SOLACE'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'JMS_SENSOR' = 'JORAM_MQ'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'JMS_SENSOR' = 'ZERO_MQ'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'JMS_SENSOR' = 'PULSAR'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'JMS_SENSOR' = 'SQS'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'KAFKA_SENSOR' = 'KAFKA'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'MQTT_SENSOR' = 'RABBIT_MQ'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'MQTT_SENSOR' = 'KAFKA'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'RABBIT_MQ_SENSOR' = 'RABBIT_MQ'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'SAP_4H_EVENT_SENSOR' = 'SAP_S4_HANA'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'SAP_4H_INTERCEPTED_JOB_SENSOR' = 'SAP_S4_HANA'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'SAP_IBP_PROCESS_SENSOR' = 'SAP_S4_HANA_CLOUD'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'SAP_R3_EVENT_SENSOR' = 'SAP'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'SAP_R3_INTERCEPTED_JOB_SENSOR' = 'SAP'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'SERVICE_NOW_INCIDENT_STATUS_SENSOR' = 'SERVICE_NOW'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'SQL_SENSOR' = 'ORACLE'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'SQL_SENSOR' = 'TERADATA'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'SQL_SENSOR' = 'SINGLESTORE'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'SQL_SENSOR' = 'SQL_SERVER'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'SQL_SENSOR' = 'POSTGRESQL'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'SQL_SENSOR' = 'MYSQL'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'SQL_SENSOR' = 'DB2'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'SQL_SENSOR' = 'NETEZZA'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'SQL_SENSOR' = 'AZURE_SQL_DATA_WAREHOUSE'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'SQL_SENSOR' = 'AZURE_SQL_DATABASE'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'SQL_SENSOR' = 'HIVE_QL'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'SQL_SENSOR' = 'GOOGLE_BIG_QUERY'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'SQL_SENSOR' = 'DASHDB'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'SQL_SENSOR' = 'SNOWFLAKE'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'SQL_SENSOR' = 'VERTICA'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'SQL_SENSOR' = 'PRESTO_DB'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'SQL_SENSOR' = 'H2'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'SQL_SENSOR' = 'SYBASE'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'SQL_SENSOR' = 'INFORMIX'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'SQL_SENSOR' = 'SAP_HANA'; })
    [void]$ANOWLookupSensorTypeToServerNodeType.Add([hashtable]@{'Z_OS_JES_JOB_SENSOR' = 'Z_OS'; })
    If ($SensorType.Length -gt 0) {
        [string[]]$SensorTypes = $ANOWLookupSensorTypeToServerNodeType | Where-Object { $_.keys -eq $SensorType } | Select-Object -ExpandProperty Values
        If ($SensorTypes.Count -gt 0) {
            Return $SensorTypes | Sort-Object
        }
        Else {
            Write-Warning -Message "There were no Sensor Types that match [$SensorType]"
        }
    }
    ElseIf ($ServerNodeType.Length -gt 0) {
        [string[]]$ServerNodeTypes = $ANOWLookupSensorTypeToServerNodeType | Where-Object { $_.values -eq $ServerNodeType } | Select-Object -ExpandProperty Keys
        If ($ServerNodeTypes.Count -gt 0) {
            Return $ServerNodeTypes | Sort-Object
        }
        Else {
            Write-Warning -Message "There were no Server Node Types that match [$ServerNodeType]"
        }
    }
    ElseIf ($All -eq $true) {
        Return $ANOWLookupSensorTypeToServerNodeType | Sort-Object
    }
    Else {
        Write-Warning -Message "Unable to resolve which output to return!"
        Break
    }
}

#EndRegion
